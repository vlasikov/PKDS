
_PKDS_TSTS06_STAND.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .app_info     00000400  08020000  0c020000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000b5f4  08020400  0c020400  00010400  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000800  10000000  10000000  00040000  2**0
                  ALLOC
  3 .ram_code     000009c0  10000800  0c02b9f4  00020800  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 PSRAM_DATA    00000000  100011c0  100011c0  000305f8  2**0
                  CONTENTS
  5 PSRAM_BSS     00000000  100011c0  100011c0  000305f8  2**0
                  CONTENTS
  6 .data         000005f8  20000000  0c02c3b4  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000b20  200005f8  0c02c9ac  000305f8  2**2
                  ALLOC
  8 .no_init      00000014  2000ffc0  2000ffc0  0003ffc0  2**2
                  ALLOC
  9 DSRAM2_DATA   00000000  30000000  30000000  000305f8  2**0
                  CONTENTS
 10 DSRAM2_BSS    00000000  30000000  30000000  000305f8  2**0
                  CONTENTS
 11 .debug_aranges 00001ee8  00000000  00000000  000305f8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_info   0003acbf  00000000  00000000  000324e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00007d5e  00000000  00000000  0006d19f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00014f65  00000000  00000000  00074efd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_frame  000075f8  00000000  00000000  00089e64  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    00011983  00000000  00000000  0009145c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loc    0000fca8  00000000  00000000  000a2ddf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_ranges 00001a60  00000000  00000000  000b2a87  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .build_attributes 00000e0d  00000000  00000000  000b44e7  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020400 <__Vectors>:
 8020400:	00 08 00 10 01 06 02 08 b1 06 02 08 b1 06 02 08     ................
 8020410:	b1 06 02 08 b1 06 02 08 b1 06 02 08 00 00 00 00     ................
	...
 802042c:	b1 06 02 08 b1 06 02 08 00 00 00 00 b1 06 02 08     ................
 802043c:	6d 90 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     m...............
 802044c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802045c:	b1 06 02 08 b1 06 02 08 00 00 00 00 00 00 00 00     ................
 802046c:	00 00 00 00 b1 06 02 08 00 00 00 00 31 20 02 08     ............1 ..
 802047c:	b1 06 02 08 e9 ad 02 08 b1 06 02 08 b1 06 02 08     ................
 802048c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802049c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204ac:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204bc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204cc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204dc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204ec:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204fc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802050c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802051c:	b1 06 02 08 79 ad 02 08 a1 ad 02 08 59 30 02 08     ....y.......Y0..
 802052c:	39 30 02 08 89 0b 00 10 b1 06 02 08 b1 06 02 08     90..............
 802053c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802054c:	b1 06 02 08 29 0d 00 10 f5 0d 00 10 b1 06 02 08     ....)...........
 802055c:	b1 06 02 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
 802056c:	00 00 00 00 ed 3d 02 08 79 ae 02 08 a1 af 02 08     .....=..y.......
 802057c:	11 3d 02 08 b1 06 02 08 6d 3d 02 08 1d 3c 02 08     .=......m=...<..
 802058c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802059c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205ac:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205bc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205cc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205dc:	00 00 00 00 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205ec:	b1 06 02 08 b1 06 02 08 00 00 00 00 b1 06 02 08     ................
 80205fc:	00 00 00 00                                         ....

08020600 <Reset_Handler>:
/* Reset Handler */
    .thumb_func
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler:
    ldr sp,=__initial_sp
 8020600:	f8df d08c 	ldr.w	sp, [pc, #140]	; 8020690 <__zero_table_end__>

#ifndef __SKIP_SYSTEM_INIT
    ldr  r0, =SystemInit
 8020604:	4823      	ldr	r0, [pc, #140]	; (8020694 <__zero_table_end__+0x4>)
    blx  r0
 8020606:	4780      	blx	r0
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r4, =__copy_table_start__
 8020608:	4c23      	ldr	r4, [pc, #140]	; (8020698 <__zero_table_end__+0x8>)
	ldr	r5, =__copy_table_end__
 802060a:	4d24      	ldr	r5, [pc, #144]	; (802069c <__zero_table_end__+0xc>)

.L_loop0:
	cmp	r4, r5
 802060c:	42ac      	cmp	r4, r5
	bge	.L_loop0_done
 802060e:	da09      	bge.n	8020624 <Reset_Handler+0x24>
	ldr	r1, [r4]
 8020610:	6821      	ldr	r1, [r4, #0]
	ldr	r2, [r4, #4]
 8020612:	6862      	ldr	r2, [r4, #4]
	ldr	r3, [r4, #8]
 8020614:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
	subs	r3, #4
 8020616:	3b04      	subs	r3, #4
	ittt	ge
 8020618:	bfa2      	ittt	ge
	ldrge	r0, [r1, r3]
 802061a:	58c8      	ldrge	r0, [r1, r3]
	strge	r0, [r2, r3]
 802061c:	50d0      	strge	r0, [r2, r3]
	bge	.L_loop0_0
 802061e:	e7fa      	bge.n	8020616 <Reset_Handler+0x16>

	adds	r4, #12
 8020620:	340c      	adds	r4, #12
	b	.L_loop0
 8020622:	e7f3      	b.n	802060c <Reset_Handler+0xc>
 *    offset 4: Size of this BSS section. Must be multiply of 4
 *
 *  Define __SKIP_BSS_CLEAR to disable zeroing uninitialzed data in startup.
 */    
#ifndef __SKIP_BSS_CLEAR
	ldr	r3, =__zero_table_start__
 8020624:	4b1e      	ldr	r3, [pc, #120]	; (80206a0 <__zero_table_end__+0x10>)
	ldr	r4, =__zero_table_end__
 8020626:	4c1f      	ldr	r4, [pc, #124]	; (80206a4 <__zero_table_end__+0x14>)

.L_loop2:
	cmp	r3, r4
 8020628:	42a3      	cmp	r3, r4
	bge	.L_loop2_done
 802062a:	da08      	bge.n	802063e <Reset_Handler+0x3e>
	ldr	r1, [r3]
 802062c:	6819      	ldr	r1, [r3, #0]
	ldr	r2, [r3, #4]
 802062e:	685a      	ldr	r2, [r3, #4]
	movs	r0, 0
 8020630:	2000      	movs	r0, #0

.L_loop2_0:
	subs	r2, #4
 8020632:	3a04      	subs	r2, #4
	itt	ge
 8020634:	bfa4      	itt	ge
	strge	r0, [r1, r2]
 8020636:	5088      	strge	r0, [r1, r2]
	bge	.L_loop2_0
 8020638:	e7fb      	bge.n	8020632 <Reset_Handler+0x32>

	adds	r3, #8
 802063a:	3308      	adds	r3, #8
	b	.L_loop2
 802063c:	e7f4      	b.n	8020628 <Reset_Handler+0x28>
.L_loop2_done:    
#endif /* __SKIP_BSS_CLEAR */
   
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
 802063e:	481a      	ldr	r0, [pc, #104]	; (80206a8 <__zero_table_end__+0x18>)
    blx  r0
 8020640:	4780      	blx	r0
#endif

    ldr  r0, =main
 8020642:	481a      	ldr	r0, [pc, #104]	; (80206ac <__zero_table_end__+0x1c>)
    blx  r0
 8020644:	4780      	blx	r0
	...

08020648 <__copy_table_start__>:
 8020648:	0c02c3b4 	.word	0x0c02c3b4
 802064c:	20000000 	.word	0x20000000
 8020650:	000005f8 	.word	0x000005f8
 8020654:	0c02c9ac 	.word	0x0c02c9ac
 8020658:	30000000 	.word	0x30000000
 802065c:	00000000 	.word	0x00000000
 8020660:	0c02c3b4 	.word	0x0c02c3b4
 8020664:	100011c0 	.word	0x100011c0
 8020668:	00000000 	.word	0x00000000
 802066c:	0c02b9f4 	.word	0x0c02b9f4
 8020670:	10000800 	.word	0x10000800
 8020674:	000009c0 	.word	0x000009c0

08020678 <__copy_table_end__>:
 8020678:	200005f8 	.word	0x200005f8
 802067c:	00000b1c 	.word	0x00000b1c
 8020680:	30000000 	.word	0x30000000
 8020684:	00000000 	.word	0x00000000
 8020688:	100011c0 	.word	0x100011c0
 802068c:	00000000 	.word	0x00000000

08020690 <__zero_table_end__>:
    ldr sp,=__initial_sp
 8020690:	10000800 	.word	0x10000800
    ldr  r0, =SystemInit
 8020694:	080206b5 	.word	0x080206b5
	ldr	r4, =__copy_table_start__
 8020698:	08020648 	.word	0x08020648
	ldr	r5, =__copy_table_end__
 802069c:	08020678 	.word	0x08020678
	ldr	r3, =__zero_table_start__
 80206a0:	08020678 	.word	0x08020678
	ldr	r4, =__zero_table_end__
 80206a4:	08020690 	.word	0x08020690
    ldr  r0, =__libc_init_array
 80206a8:	0802b0cd 	.word	0x0802b0cd
    ldr  r0, =main
 80206ac:	0802b035 	.word	0x0802b035

080206b0 <BusFault_Handler>:
	.align	1
    .thumb_func
    .weak Default_Handler
    .type Default_Handler, %function
Default_Handler:
    b .
 80206b0:	e7fe      	b.n	80206b0 <BusFault_Handler>
	...

080206b4 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 80206b4:	b598      	push	{r3, r4, r7, lr}
 80206b6:	af00      	add	r7, sp, #0
  memcpy(g_chipid, CHIPID_LOC, 16);
 80206b8:	4a06      	ldr	r2, [pc, #24]	; (80206d4 <SystemInit+0x20>)
 80206ba:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80206be:	4614      	mov	r4, r2
 80206c0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80206c2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  SystemCoreSetup();
 80206c6:	f009 fb29 	bl	8029d1c <SystemCoreSetup>
  SystemCoreClockSetup(); 
 80206ca:	f009 fb95 	bl	8029df8 <SystemCoreClockSetup>
}
 80206ce:	bf00      	nop
 80206d0:	bd98      	pop	{r3, r4, r7, pc}
 80206d2:	bf00      	nop
 80206d4:	2000ffc4 	.word	0x2000ffc4

080206d8 <SystemCoreClockUpdate>:

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 80206d8:	b580      	push	{r7, lr}
 80206da:	b084      	sub	sp, #16
 80206dc:	af00      	add	r7, sp, #0
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80206de:	4b2f      	ldr	r3, [pc, #188]	; (802079c <SystemCoreClockUpdate+0xc4>)
 80206e0:	68db      	ldr	r3, [r3, #12]
 80206e2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80206e6:	2b00      	cmp	r3, #0
 80206e8:	d03e      	beq.n	8020768 <SystemCoreClockUpdate+0x90>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 80206ea:	4b2d      	ldr	r3, [pc, #180]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 80206ec:	68db      	ldr	r3, [r3, #12]
 80206ee:	f003 0301 	and.w	r3, r3, #1
 80206f2:	2b00      	cmp	r3, #0
 80206f4:	d002      	beq.n	80206fc <SystemCoreClockUpdate+0x24>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 80206f6:	4b2b      	ldr	r3, [pc, #172]	; (80207a4 <SystemCoreClockUpdate+0xcc>)
 80206f8:	60fb      	str	r3, [r7, #12]
 80206fa:	e002      	b.n	8020702 <SystemCoreClockUpdate+0x2a>
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 80206fc:	f009 fb72 	bl	8029de4 <OSCHP_GetFrequency>
 8020700:	60f8      	str	r0, [r7, #12]
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 8020702:	4b27      	ldr	r3, [pc, #156]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 8020704:	681b      	ldr	r3, [r3, #0]
 8020706:	f003 0304 	and.w	r3, r3, #4
 802070a:	2b00      	cmp	r3, #0
 802070c:	d020      	beq.n	8020750 <SystemCoreClockUpdate+0x78>
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 802070e:	4b24      	ldr	r3, [pc, #144]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 8020710:	689b      	ldr	r3, [r3, #8]
 8020712:	0e1b      	lsrs	r3, r3, #24
 8020714:	f003 030f 	and.w	r3, r3, #15
 8020718:	3301      	adds	r3, #1
 802071a:	607b      	str	r3, [r7, #4]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 802071c:	4b20      	ldr	r3, [pc, #128]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 802071e:	689b      	ldr	r3, [r3, #8]
 8020720:	0a1b      	lsrs	r3, r3, #8
 8020722:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020726:	3301      	adds	r3, #1
 8020728:	603b      	str	r3, [r7, #0]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 802072a:	4b1d      	ldr	r3, [pc, #116]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 802072c:	689b      	ldr	r3, [r3, #8]
 802072e:	0c1b      	lsrs	r3, r3, #16
 8020730:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020734:	3301      	adds	r3, #1
 8020736:	60bb      	str	r3, [r7, #8]

      temp = (temp / (pdiv * kdiv)) * ndiv;
 8020738:	687b      	ldr	r3, [r7, #4]
 802073a:	68ba      	ldr	r2, [r7, #8]
 802073c:	fb02 f303 	mul.w	r3, r2, r3
 8020740:	68fa      	ldr	r2, [r7, #12]
 8020742:	fbb2 f2f3 	udiv	r2, r2, r3
 8020746:	683b      	ldr	r3, [r7, #0]
 8020748:	fb02 f303 	mul.w	r3, r2, r3
 802074c:	60fb      	str	r3, [r7, #12]
 802074e:	e00d      	b.n	802076c <SystemCoreClockUpdate+0x94>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 8020750:	4b13      	ldr	r3, [pc, #76]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 8020752:	689b      	ldr	r3, [r3, #8]
 8020754:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020758:	3301      	adds	r3, #1
 802075a:	60bb      	str	r3, [r7, #8]
      
      temp = (temp / kdiv);
 802075c:	68fa      	ldr	r2, [r7, #12]
 802075e:	68bb      	ldr	r3, [r7, #8]
 8020760:	fbb2 f3f3 	udiv	r3, r2, r3
 8020764:	60fb      	str	r3, [r7, #12]
 8020766:	e001      	b.n	802076c <SystemCoreClockUpdate+0x94>
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 8020768:	4b0e      	ldr	r3, [pc, #56]	; (80207a4 <SystemCoreClockUpdate+0xcc>)
 802076a:	60fb      	str	r3, [r7, #12]
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 802076c:	4b0b      	ldr	r3, [pc, #44]	; (802079c <SystemCoreClockUpdate+0xc4>)
 802076e:	68db      	ldr	r3, [r3, #12]
 8020770:	b2db      	uxtb	r3, r3
 8020772:	3301      	adds	r3, #1
 8020774:	68fa      	ldr	r2, [r7, #12]
 8020776:	fbb2 f3f3 	udiv	r3, r2, r3
 802077a:	60fb      	str	r3, [r7, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 802077c:	4b07      	ldr	r3, [pc, #28]	; (802079c <SystemCoreClockUpdate+0xc4>)
 802077e:	691b      	ldr	r3, [r3, #16]
 8020780:	f003 0301 	and.w	r3, r3, #1
 8020784:	3301      	adds	r3, #1
 8020786:	68fa      	ldr	r2, [r7, #12]
 8020788:	fbb2 f3f3 	udiv	r3, r2, r3
 802078c:	60fb      	str	r3, [r7, #12]

  SystemCoreClock = temp;
 802078e:	4a06      	ldr	r2, [pc, #24]	; (80207a8 <SystemCoreClockUpdate+0xd0>)
 8020790:	68fb      	ldr	r3, [r7, #12]
 8020792:	6013      	str	r3, [r2, #0]
}
 8020794:	bf00      	nop
 8020796:	3710      	adds	r7, #16
 8020798:	46bd      	mov	sp, r7
 802079a:	bd80      	pop	{r7, pc}
 802079c:	50004600 	.word	0x50004600
 80207a0:	50004710 	.word	0x50004710
 80207a4:	016e3600 	.word	0x016e3600
 80207a8:	2000ffc0 	.word	0x2000ffc0

080207ac <XMC_VADC_GROUP_QueueTriggerConversion>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
 80207ac:	b480      	push	{r7}
 80207ae:	b083      	sub	sp, #12
 80207b0:	af00      	add	r7, sp, #0
 80207b2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_TREV_Pos);
 80207b4:	687b      	ldr	r3, [r7, #4]
 80207b6:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80207ba:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 80207be:	687b      	ldr	r3, [r7, #4]
 80207c0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 80207c4:	bf00      	nop
 80207c6:	370c      	adds	r7, #12
 80207c8:	46bd      	mov	sp, r7
 80207ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207ce:	4770      	bx	lr

080207d0 <XMC_VADC_GROUP_QueueInsertChannel>:
 * \par<b>Related APIs:</b><br>
 *  XMC_VADC_GROUP_QueueRemoveChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
    const XMC_VADC_QUEUE_ENTRY_t entry)
{
 80207d0:	b480      	push	{r7}
 80207d2:	b083      	sub	sp, #12
 80207d4:	af00      	add	r7, sp, #0
 80207d6:	6078      	str	r0, [r7, #4]
 80207d8:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 80207da:	683a      	ldr	r2, [r7, #0]
 80207dc:	687b      	ldr	r3, [r7, #4]
 80207de:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 80207e2:	bf00      	nop
 80207e4:	370c      	adds	r7, #12
 80207e6:	46bd      	mov	sp, r7
 80207e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207ec:	4770      	bx	lr

080207ee <XMC_VADC_GROUP_ResultInit>:
 * XMC_VADC_GROUP_AddResultToFifo()<BR> XMC_VADC_GROUP_EnableResultEvent()<br> XMC_VADC_GROUP_DisableResultEvent()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t res_reg_num,
    const XMC_VADC_RESULT_CONFIG_t *config)
{
 80207ee:	b480      	push	{r7}
 80207f0:	b085      	sub	sp, #20
 80207f2:	af00      	add	r7, sp, #0
 80207f4:	60f8      	str	r0, [r7, #12]
 80207f6:	60b9      	str	r1, [r7, #8]
 80207f8:	607a      	str	r2, [r7, #4]
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 80207fa:	687b      	ldr	r3, [r7, #4]
 80207fc:	6819      	ldr	r1, [r3, #0]
 80207fe:	68fb      	ldr	r3, [r7, #12]
 8020800:	68ba      	ldr	r2, [r7, #8]
 8020802:	32a0      	adds	r2, #160	; 0xa0
 8020804:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

}
 8020808:	bf00      	nop
 802080a:	3714      	adds	r7, #20
 802080c:	46bd      	mov	sp, r7
 802080e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020812:	4770      	bx	lr

08020814 <XMC_VADC_GROUP_GetResult>:
 * \par<b>Related APIs:</b><br>
 * XMC_VADC_GROUP_GetDetailedResult().
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t XMC_VADC_GROUP_GetResult(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t res_reg)
{
 8020814:	b480      	push	{r7}
 8020816:	b083      	sub	sp, #12
 8020818:	af00      	add	r7, sp, #0
 802081a:	6078      	str	r0, [r7, #4]
 802081c:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))

  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 802081e:	687b      	ldr	r3, [r7, #4]
 8020820:	683a      	ldr	r2, [r7, #0]
 8020822:	32c0      	adds	r2, #192	; 0xc0
 8020824:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8020828:	b29b      	uxth	r3, r3
}
 802082a:	4618      	mov	r0, r3
 802082c:	370c      	adds	r7, #12
 802082e:	46bd      	mov	sp, r7
 8020830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020834:	4770      	bx	lr

08020836 <VADC_GetResult>:
 *
 * \par<b>Description:</b><br>
 * Returns the VADC conversion result by reading result register from selected group number.
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t VADC_GetResult(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg)
{
 8020836:	b580      	push	{r7, lr}
 8020838:	b084      	sub	sp, #16
 802083a:	af00      	add	r7, sp, #0
 802083c:	6078      	str	r0, [r7, #4]
 802083e:	6039      	str	r1, [r7, #0]
  XMC_VADC_RESULT_SIZE_t result;
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8020840:	6839      	ldr	r1, [r7, #0]
 8020842:	6878      	ldr	r0, [r7, #4]
 8020844:	f7ff ffe6 	bl	8020814 <XMC_VADC_GROUP_GetResult>
 8020848:	4603      	mov	r3, r0
 802084a:	81fb      	strh	r3, [r7, #14]
  return(result);
 802084c:	89fb      	ldrh	r3, [r7, #14]
}
 802084e:	4618      	mov	r0, r3
 8020850:	3710      	adds	r7, #16
 8020852:	46bd      	mov	sp, r7
 8020854:	bd80      	pop	{r7, pc}
	...

08020858 <Motor0_BLDC_SCALAR_Current_Measurment_Init>:
/*********************************************************************************************************************/
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)


void Motor0_BLDC_SCALAR_Current_Measurment_Init(void)
{
 8020858:	b580      	push	{r7, lr}
 802085a:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_OFFSET_DAC == 1U)
  volatile uint32_t delay;       /* DAC settlement delay counter */
  uint32_t dac_settlement_dealy = BLDC_SCALAR_DAC_SETTLEMENT_DELAY;  /* required DAC settlement delay */
#endif
  /* Initialize VADC channel */
  XMC_VADC_GROUP_ChannelInit(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM,
 802085c:	4a0d      	ldr	r2, [pc, #52]	; (8020894 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x3c>)
 802085e:	2105      	movs	r1, #5
 8020860:	480d      	ldr	r0, [pc, #52]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020862:	f008 f933 	bl	8028acc <XMC_VADC_GROUP_ChannelInit>
      &Motor0_BLDC_SCALAR_VADC_IDCLink_CH_handle);

  /* Initialize VADC result */
  XMC_VADC_GROUP_ResultInit(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM,
 8020866:	4a0d      	ldr	r2, [pc, #52]	; (802089c <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x44>)
 8020868:	2105      	movs	r1, #5
 802086a:	480b      	ldr	r0, [pc, #44]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802086c:	f7ff ffbf 	bl	80207ee <XMC_VADC_GROUP_ResultInit>
      &Motor0_BLDC_SCALAR_VADC_IDCLink_Res_handle);

  /* Request the LLD to insert the channel in queue.*/
  XMC_VADC_GROUP_QueueInsertChannel(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, Motor0_BLDC_SCALAR_VADC_IDCLink_queue_entry);
 8020870:	4b0b      	ldr	r3, [pc, #44]	; (80208a0 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x48>)
 8020872:	6819      	ldr	r1, [r3, #0]
 8020874:	4808      	ldr	r0, [pc, #32]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020876:	f7ff ffab 	bl	80207d0 <XMC_VADC_GROUP_QueueInsertChannel>
  /*Initialize DAC data register for generating amplifier bias voltage of 1.65V*/
  XMC_DAC_CH_Write((XMC_DAC_t  *)(void *)DAC,DAC_CHANNEL_0,BLDC_SCALAR_DAC_VOLTAGE_COUNT);
#endif
  #if((MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U) && (BLDC_SCALAR_IDC_DIRECT_CURRENT == MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE))
  /* If over current protection is enabled then configure group boundaries accordingly and enable interrupt */
   XMC_VADC_GROUP_SetBoundaries(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_OVER_CURRENT_VADC_BOUND0_T,
 802087a:	f641 7205 	movw	r2, #7941	; 0x1f05
 802087e:	2100      	movs	r1, #0
 8020880:	4805      	ldr	r0, [pc, #20]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020882:	f008 f82b 	bl	80288dc <XMC_VADC_GROUP_SetBoundaries>
       MOTOR0_BLDC_SCALAR_OVER_CURRENT_VADC_BOUND1_T);
  /* Bind the channel event to shared service request line */
  XMC_VADC_GROUP_ChannelSetEventInterruptNode(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM,
 8020886:	2204      	movs	r2, #4
 8020888:	2105      	movs	r1, #5
 802088a:	4803      	ldr	r0, [pc, #12]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802088c:	f008 f984 	bl	8028b98 <XMC_VADC_GROUP_ChannelSetEventInterruptNode>
      MOTOR0_BLDC_SCALAR_VADC_CHEVT_SR);
  #endif
}
 8020890:	bf00      	nop
 8020892:	bd80      	pop	{r7, pc}
 8020894:	20000080 	.word	0x20000080
 8020898:	40005000 	.word	0x40005000
 802089c:	200005f8 	.word	0x200005f8
 80208a0:	2000007c 	.word	0x2000007c

080208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>:

#if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U))
#if (MOTOR0_BLDC_SCALAR_ENABLE_AMPLIFIER_OFFSET_CALIBRATION == 1U)

void Motor0_BLDC_SCALAR_AmpBiasVoltCalibration(void)
{
 80208a4:	b580      	push	{r7, lr}
 80208a6:	b086      	sub	sp, #24
 80208a8:	af00      	add	r7, sp, #0
  uint32_t amp_offset = 0U;      /* current amplifier offset value */
 80208aa:	2300      	movs	r3, #0
 80208ac:	617b      	str	r3, [r7, #20]
  uint32_t count;                /* for loop count */
  volatile uint32_t delay;       /* ADC conversion delay counter */
  uint32_t vadc_conversion_time_dealy = BLDC_SCALAR_VADC_CONVERSION_DELAY;  /* ADC conversion delay */
 80208ae:	230f      	movs	r3, #15
 80208b0:	60fb      	str	r3, [r7, #12]
  Motor0_BLDC_SCALAR_CurrentMeasurement.avg_dc_amplifier_offset = (int32_t) temp_ampoffset;
#endif  /* end of MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT */

  /* Direct DC link current */
#if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  amp_offset = 0U;
 80208b2:	2300      	movs	r3, #0
 80208b4:	617b      	str	r3, [r7, #20]
  /* SW trigger for direct DC link current channel and measure the amplifier bias voltage */
  /* Calibration is done with average of 16 measurements */
  for (count = 0U; count < BLDC_SCALAR_ADCCAL_COUNT; count++)
 80208b6:	2300      	movs	r3, #0
 80208b8:	613b      	str	r3, [r7, #16]
 80208ba:	e019      	b.n	80208f0 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x4c>
  {
    XMC_VADC_GROUP_QueueTriggerConversion(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP);
 80208bc:	4813      	ldr	r0, [pc, #76]	; (802090c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x68>)
 80208be:	f7ff ff75 	bl	80207ac <XMC_VADC_GROUP_QueueTriggerConversion>
    /* VADC queue measurements conversion time delay */
    for (delay = 0U; delay < vadc_conversion_time_dealy; delay++)
 80208c2:	2300      	movs	r3, #0
 80208c4:	607b      	str	r3, [r7, #4]
 80208c6:	e002      	b.n	80208ce <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x2a>
 80208c8:	687b      	ldr	r3, [r7, #4]
 80208ca:	3301      	adds	r3, #1
 80208cc:	607b      	str	r3, [r7, #4]
 80208ce:	687b      	ldr	r3, [r7, #4]
 80208d0:	68fa      	ldr	r2, [r7, #12]
 80208d2:	429a      	cmp	r2, r3
 80208d4:	d8f8      	bhi.n	80208c8 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x24>
    {

    }
    temp_ampoffset = (uint32_t) (VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM));
 80208d6:	2105      	movs	r1, #5
 80208d8:	480c      	ldr	r0, [pc, #48]	; (802090c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x68>)
 80208da:	f7ff ffac 	bl	8020836 <VADC_GetResult>
 80208de:	4603      	mov	r3, r0
 80208e0:	60bb      	str	r3, [r7, #8]
    amp_offset = amp_offset + temp_ampoffset;
 80208e2:	697a      	ldr	r2, [r7, #20]
 80208e4:	68bb      	ldr	r3, [r7, #8]
 80208e6:	4413      	add	r3, r2
 80208e8:	617b      	str	r3, [r7, #20]
  for (count = 0U; count < BLDC_SCALAR_ADCCAL_COUNT; count++)
 80208ea:	693b      	ldr	r3, [r7, #16]
 80208ec:	3301      	adds	r3, #1
 80208ee:	613b      	str	r3, [r7, #16]
 80208f0:	693b      	ldr	r3, [r7, #16]
 80208f2:	2b0f      	cmp	r3, #15
 80208f4:	d9e2      	bls.n	80208bc <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x18>
  }
  temp_ampoffset = ((uint32_t)amp_offset >> (uint32_t)BLDC_SCALAR_ADCCAL_SHIFT_4);
 80208f6:	697b      	ldr	r3, [r7, #20]
 80208f8:	091b      	lsrs	r3, r3, #4
 80208fa:	60bb      	str	r3, [r7, #8]
  Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset = (int32_t) temp_ampoffset;
 80208fc:	68bb      	ldr	r3, [r7, #8]
 80208fe:	4a04      	ldr	r2, [pc, #16]	; (8020910 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x6c>)
 8020900:	6013      	str	r3, [r2, #0]
#endif /* end of MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT */


}
 8020902:	bf00      	nop
 8020904:	3718      	adds	r7, #24
 8020906:	46bd      	mov	sp, r7
 8020908:	bd80      	pop	{r7, pc}
 802090a:	bf00      	nop
 802090c:	40005000 	.word	0x40005000
 8020910:	20000124 	.word	0x20000124

08020914 <XMC_SCU_SetCcuTriggerLow>:
 * the timer using this API.<BR>
 * \par<b>Related APIs:</b><BR>
 * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerHigh()\n\n\n
 */
__STATIC_INLINE void XMC_SCU_SetCcuTriggerLow(const uint32_t trigger)
{
 8020914:	b480      	push	{r7}
 8020916:	b083      	sub	sp, #12
 8020918:	af00      	add	r7, sp, #0
 802091a:	6078      	str	r0, [r7, #4]
  SCU_GENERAL->CCUCON &= (uint32_t)~trigger;
 802091c:	4b06      	ldr	r3, [pc, #24]	; (8020938 <XMC_SCU_SetCcuTriggerLow+0x24>)
 802091e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8020920:	687b      	ldr	r3, [r7, #4]
 8020922:	43db      	mvns	r3, r3
 8020924:	4904      	ldr	r1, [pc, #16]	; (8020938 <XMC_SCU_SetCcuTriggerLow+0x24>)
 8020926:	4013      	ands	r3, r2
 8020928:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 802092a:	bf00      	nop
 802092c:	370c      	adds	r7, #12
 802092e:	46bd      	mov	sp, r7
 8020930:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020934:	4770      	bx	lr
 8020936:	bf00      	nop
 8020938:	50004000 	.word	0x50004000

0802093c <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 802093c:	b480      	push	{r7}
 802093e:	b083      	sub	sp, #12
 8020940:	af00      	add	r7, sp, #0
 8020942:	6078      	str	r0, [r7, #4]
 8020944:	460b      	mov	r3, r1
 8020946:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8020948:	78fb      	ldrb	r3, [r7, #3]
 802094a:	2201      	movs	r2, #1
 802094c:	409a      	lsls	r2, r3
 802094e:	687b      	ldr	r3, [r7, #4]
 8020950:	605a      	str	r2, [r3, #4]
}
 8020952:	bf00      	nop
 8020954:	370c      	adds	r7, #12
 8020956:	46bd      	mov	sp, r7
 8020958:	f85d 7b04 	ldr.w	r7, [sp], #4
 802095c:	4770      	bx	lr

0802095e <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 802095e:	b480      	push	{r7}
 8020960:	b083      	sub	sp, #12
 8020962:	af00      	add	r7, sp, #0
 8020964:	6078      	str	r0, [r7, #4]
 8020966:	460b      	mov	r3, r1
 8020968:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802096a:	78fb      	ldrb	r3, [r7, #3]
 802096c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8020970:	409a      	lsls	r2, r3
 8020972:	687b      	ldr	r3, [r7, #4]
 8020974:	605a      	str	r2, [r3, #4]
}
 8020976:	bf00      	nop
 8020978:	370c      	adds	r7, #12
 802097a:	46bd      	mov	sp, r7
 802097c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020980:	4770      	bx	lr

08020982 <Motor0_BLDC_SCALAR_CCU8_PWM_Stop>:
 *
 * \par<b>Description:</b><br>
 * Set CCUCON trigger signal to low to stop all slices.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_PWM_Stop(void)
{
 8020982:	b580      	push	{r7, lr}
 8020984:	af00      	add	r7, sp, #0
  /* Pull CCUCON signal to low */
  XMC_SCU_SetCcuTriggerLow((uint32_t)MOTOR0_BLDC_SCALAR_CCU8_SYNC_START);
 8020986:	f44f 7080 	mov.w	r0, #256	; 0x100
 802098a:	f7ff ffc3 	bl	8020914 <XMC_SCU_SetCcuTriggerLow>
}
 802098e:	bf00      	nop
 8020990:	bd80      	pop	{r7, pc}

08020992 <Motor0_BLDC_SCALAR_CCU8_EnableDeadTime>:
 *
 * \par<b>Description:</b><br>
 * Enable the dead time for compare channel and ST path.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(XMC_CCU8_SLICE_t * phase_ptr, const uint8_t channel_mask)
{
 8020992:	b480      	push	{r7}
 8020994:	b083      	sub	sp, #12
 8020996:	af00      	add	r7, sp, #0
 8020998:	6078      	str	r0, [r7, #4]
 802099a:	460b      	mov	r3, r1
 802099c:	70fb      	strb	r3, [r7, #3]
  phase_ptr->DTC |= (uint32_t)channel_mask;
 802099e:	687b      	ldr	r3, [r7, #4]
 80209a0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80209a2:	78fb      	ldrb	r3, [r7, #3]
 80209a4:	431a      	orrs	r2, r3
 80209a6:	687b      	ldr	r3, [r7, #4]
 80209a8:	64da      	str	r2, [r3, #76]	; 0x4c

}
 80209aa:	bf00      	nop
 80209ac:	370c      	adds	r7, #12
 80209ae:	46bd      	mov	sp, r7
 80209b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209b4:	4770      	bx	lr

080209b6 <Motor0_BLDC_SCALAR_CCU8_DisableDeadTime>:
 *
 * \par<b>Description:</b><br>
 * Disable the dead time for compare channel and ST path.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(XMC_CCU8_SLICE_t * phase_ptr, const uint8_t channel_mask)
{
 80209b6:	b480      	push	{r7}
 80209b8:	b083      	sub	sp, #12
 80209ba:	af00      	add	r7, sp, #0
 80209bc:	6078      	str	r0, [r7, #4]
 80209be:	460b      	mov	r3, r1
 80209c0:	70fb      	strb	r3, [r7, #3]
  phase_ptr->DTC &= ~(uint32_t)channel_mask;
 80209c2:	687b      	ldr	r3, [r7, #4]
 80209c4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80209c6:	78fb      	ldrb	r3, [r7, #3]
 80209c8:	43db      	mvns	r3, r3
 80209ca:	401a      	ands	r2, r3
 80209cc:	687b      	ldr	r3, [r7, #4]
 80209ce:	64da      	str	r2, [r3, #76]	; 0x4c
}
 80209d0:	bf00      	nop
 80209d2:	370c      	adds	r7, #12
 80209d4:	46bd      	mov	sp, r7
 80209d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209da:	4770      	bx	lr

080209dc <Motor0_BLDC_SCALAR_PWM_BC_Init>:
 * -Trap pin and
 * -Inverter pin as per user configurations.
 * Initialize the variable ph_cmpval[1] with (period value + 1), Used for 0% duty cycle
 */
void Motor0_BLDC_SCALAR_PWM_BC_Init(void)
{
 80209dc:	b580      	push	{r7, lr}
 80209de:	af00      	add	r7, sp, #0
  /*initialize PWM timer slices*/
  Motor0_BLDC_SCALAR_CCU8_PWM_Init();
 80209e0:	f000 faac 	bl	8020f3c <Motor0_BLDC_SCALAR_CCU8_PWM_Init>
  /*initialize PWM output pins*/
  Motor0_BLDC_SCALAR_GPIO_PWM_Init();
 80209e4:	f000 fae0 	bl	8020fa8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init>
  /*initialize Trap pin*/
  Motor0_BLDC_SCALAR_GPIO_Trap_Init();
#endif
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*initialize Inverter pin*/
  Motor0_BLDC_SCALAR_GPIO_Inverter_Init();
 80209e8:	f000 fb28 	bl	802103c <Motor0_BLDC_SCALAR_GPIO_Inverter_Init>
#endif

  /*configure variable ph_cmpval[1] with 0% duty*/
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[1] = Motor0_BLDC_SCALAR_CCU8_PWM_Config.period + (uint16_t)1;
 80209ec:	4b03      	ldr	r3, [pc, #12]	; (80209fc <Motor0_BLDC_SCALAR_PWM_BC_Init+0x20>)
 80209ee:	8a5b      	ldrh	r3, [r3, #18]
 80209f0:	3301      	adds	r3, #1
 80209f2:	b29a      	uxth	r2, r3
 80209f4:	4b02      	ldr	r3, [pc, #8]	; (8020a00 <Motor0_BLDC_SCALAR_PWM_BC_Init+0x24>)
 80209f6:	841a      	strh	r2, [r3, #32]

}
 80209f8:	bf00      	nop
 80209fa:	bd80      	pop	{r7, pc}
 80209fc:	20000068 	.word	0x20000068
 8020a00:	200000d0 	.word	0x200000d0

08020a04 <Motor0_BLDC_SCALAR_PWM_BC_Stop>:
/*
 * This function reset the inverter pin output level and
 * stop the CCU8 slices.
 */
void  Motor0_BLDC_SCALAR_PWM_BC_Stop(void)
{
 8020a04:	b580      	push	{r7, lr}
 8020a06:	af00      	add	r7, sp, #0
  /*Disable Inverter*/
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  Motor0_BLDC_SCALAR_PWM_BC_InverterDisable();
 8020a08:	f000 f81c 	bl	8020a44 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>
#endif
  /* Stop pwm timers*/
  Motor0_BLDC_SCALAR_CCU8_PWM_Stop();
 8020a0c:	f7ff ffb9 	bl	8020982 <Motor0_BLDC_SCALAR_CCU8_PWM_Stop>
}
 8020a10:	bf00      	nop
 8020a12:	bd80      	pop	{r7, pc}

08020a14 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable>:
/*
 * This function set the inverter pin output level low and high
 * Based on inverter_pin configuration.
 */
void Motor0_BLDC_SCALAR_PWM_BC_InverterEnable(void)
{
 8020a14:	b580      	push	{r7, lr}
 8020a16:	af00      	add	r7, sp, #0
  if (PWM_BC_IPIN_HIGH == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a18:	4b08      	ldr	r3, [pc, #32]	; (8020a3c <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x28>)
 8020a1a:	7b5b      	ldrb	r3, [r3, #13]
 8020a1c:	2b01      	cmp	r3, #1
 8020a1e:	d103      	bne.n	8020a28 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x14>
  {
    XMC_GPIO_SetOutputHigh(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a20:	210b      	movs	r1, #11
 8020a22:	4807      	ldr	r0, [pc, #28]	; (8020a40 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x2c>)
 8020a24:	f7ff ff8a 	bl	802093c <XMC_GPIO_SetOutputHigh>
  }
  if (PWM_BC_IPIN_LOW == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a28:	4b04      	ldr	r3, [pc, #16]	; (8020a3c <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x28>)
 8020a2a:	7b5b      	ldrb	r3, [r3, #13]
 8020a2c:	2b02      	cmp	r3, #2
 8020a2e:	d103      	bne.n	8020a38 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x24>
  {
    XMC_GPIO_SetOutputLow(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a30:	210b      	movs	r1, #11
 8020a32:	4803      	ldr	r0, [pc, #12]	; (8020a40 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x2c>)
 8020a34:	f7ff ff93 	bl	802095e <XMC_GPIO_SetOutputLow>
  }
}
 8020a38:	bf00      	nop
 8020a3a:	bd80      	pop	{r7, pc}
 8020a3c:	200000d0 	.word	0x200000d0
 8020a40:	48028200 	.word	0x48028200

08020a44 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>:
/*
 * This function set the inverter pin output level low
 * if inverter_pin is high and vice versa.
 */
void Motor0_BLDC_SCALAR_PWM_BC_InverterDisable(void)
{
 8020a44:	b580      	push	{r7, lr}
 8020a46:	af00      	add	r7, sp, #0
  if (PWM_BC_IPIN_HIGH == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a48:	4b08      	ldr	r3, [pc, #32]	; (8020a6c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x28>)
 8020a4a:	7b5b      	ldrb	r3, [r3, #13]
 8020a4c:	2b01      	cmp	r3, #1
 8020a4e:	d103      	bne.n	8020a58 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x14>
  {
    XMC_GPIO_SetOutputLow(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a50:	210b      	movs	r1, #11
 8020a52:	4807      	ldr	r0, [pc, #28]	; (8020a70 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x2c>)
 8020a54:	f7ff ff83 	bl	802095e <XMC_GPIO_SetOutputLow>
  }
  if (PWM_BC_IPIN_LOW == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a58:	4b04      	ldr	r3, [pc, #16]	; (8020a6c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x28>)
 8020a5a:	7b5b      	ldrb	r3, [r3, #13]
 8020a5c:	2b02      	cmp	r3, #2
 8020a5e:	d103      	bne.n	8020a68 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x24>
  {
    XMC_GPIO_SetOutputHigh(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a60:	210b      	movs	r1, #11
 8020a62:	4803      	ldr	r0, [pc, #12]	; (8020a70 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x2c>)
 8020a64:	f7ff ff6a 	bl	802093c <XMC_GPIO_SetOutputHigh>
  }
}
 8020a68:	bf00      	nop
 8020a6a:	bd80      	pop	{r7, pc}
 8020a6c:	200000d0 	.word	0x200000d0
 8020a70:	48028200 	.word	0x48028200

08020a74 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8020a74:	b480      	push	{r7}
 8020a76:	b083      	sub	sp, #12
 8020a78:	af00      	add	r7, sp, #0
 8020a7a:	4603      	mov	r3, r0
 8020a7c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8020a7e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8020a82:	2b00      	cmp	r3, #0
 8020a84:	db0c      	blt.n	8020aa0 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8020a86:	79fb      	ldrb	r3, [r7, #7]
 8020a88:	f003 021f 	and.w	r2, r3, #31
 8020a8c:	4907      	ldr	r1, [pc, #28]	; (8020aac <__NVIC_ClearPendingIRQ+0x38>)
 8020a8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8020a92:	095b      	lsrs	r3, r3, #5
 8020a94:	2001      	movs	r0, #1
 8020a96:	fa00 f202 	lsl.w	r2, r0, r2
 8020a9a:	3360      	adds	r3, #96	; 0x60
 8020a9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8020aa0:	bf00      	nop
 8020aa2:	370c      	adds	r7, #12
 8020aa4:	46bd      	mov	sp, r7
 8020aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020aaa:	4770      	bx	lr
 8020aac:	e000e100 	.word	0xe000e100

08020ab0 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020ab0:	b480      	push	{r7}
 8020ab2:	b083      	sub	sp, #12
 8020ab4:	af00      	add	r7, sp, #0
 8020ab6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8020ab8:	687b      	ldr	r3, [r7, #4]
 8020aba:	2201      	movs	r2, #1
 8020abc:	60da      	str	r2, [r3, #12]
}
 8020abe:	bf00      	nop
 8020ac0:	370c      	adds	r7, #12
 8020ac2:	46bd      	mov	sp, r7
 8020ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ac8:	4770      	bx	lr

08020aca <XMC_CCU4_SLICE_StopTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020aca:	b480      	push	{r7}
 8020acc:	b083      	sub	sp, #12
 8020ace:	af00      	add	r7, sp, #0
 8020ad0:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8020ad2:	687b      	ldr	r3, [r7, #4]
 8020ad4:	2201      	movs	r2, #1
 8020ad6:	611a      	str	r2, [r3, #16]
}
 8020ad8:	bf00      	nop
 8020ada:	370c      	adds	r7, #12
 8020adc:	46bd      	mov	sp, r7
 8020ade:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ae2:	4770      	bx	lr

08020ae4 <XMC_CCU4_SLICE_ClearTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020ae4:	b480      	push	{r7}
 8020ae6:	b083      	sub	sp, #12
 8020ae8:	af00      	add	r7, sp, #0
 8020aea:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8020aec:	687b      	ldr	r3, [r7, #4]
 8020aee:	2202      	movs	r2, #2
 8020af0:	611a      	str	r2, [r3, #16]
}
 8020af2:	bf00      	nop
 8020af4:	370c      	adds	r7, #12
 8020af6:	46bd      	mov	sp, r7
 8020af8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020afc:	4770      	bx	lr

08020afe <XMC_POSIF_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_Stop(),XMC_POSIF_IsRunning() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_Start(XMC_POSIF_t *const peripheral)
{
 8020afe:	b480      	push	{r7}
 8020b00:	b083      	sub	sp, #12
 8020b02:	af00      	add	r7, sp, #0
 8020b04:	6078      	str	r0, [r7, #4]
  peripheral->PRUNS = (uint32_t)POSIF_PRUNS_SRB_Msk;
 8020b06:	687b      	ldr	r3, [r7, #4]
 8020b08:	2201      	movs	r2, #1
 8020b0a:	609a      	str	r2, [r3, #8]
}
 8020b0c:	bf00      	nop
 8020b0e:	370c      	adds	r7, #12
 8020b10:	46bd      	mov	sp, r7
 8020b12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b16:	4770      	bx	lr

08020b18 <XMC_POSIF_Stop>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_Start(),XMC_POSIF_IsRunning() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_Stop(XMC_POSIF_t *const peripheral)
{
 8020b18:	b480      	push	{r7}
 8020b1a:	b083      	sub	sp, #12
 8020b1c:	af00      	add	r7, sp, #0
 8020b1e:	6078      	str	r0, [r7, #4]
  peripheral->PRUNC = (uint32_t)(POSIF_PRUNC_CRB_Msk | POSIF_PRUNC_CSM_Msk);
 8020b20:	687b      	ldr	r3, [r7, #4]
 8020b22:	2203      	movs	r2, #3
 8020b24:	60da      	str	r2, [r3, #12]
}
 8020b26:	bf00      	nop
 8020b28:	370c      	adds	r7, #12
 8020b2a:	46bd      	mov	sp, r7
 8020b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b30:	4770      	bx	lr

08020b32 <XMC_GPIO_GetInput>:
 * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 *
 */

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8020b32:	b480      	push	{r7}
 8020b34:	b083      	sub	sp, #12
 8020b36:	af00      	add	r7, sp, #0
 8020b38:	6078      	str	r0, [r7, #4]
 8020b3a:	460b      	mov	r3, r1
 8020b3c:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
 8020b3e:	687b      	ldr	r3, [r7, #4]
 8020b40:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020b42:	78fb      	ldrb	r3, [r7, #3]
 8020b44:	fa22 f303 	lsr.w	r3, r2, r3
 8020b48:	f003 0301 	and.w	r3, r3, #1
}
 8020b4c:	4618      	mov	r0, r3
 8020b4e:	370c      	adds	r7, #12
 8020b50:	46bd      	mov	sp, r7
 8020b52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b56:	4770      	bx	lr

08020b58 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
 *
 * \par<b>Description:</b><br>
 * Resets variables related to speed calculation.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter(void)
{
 8020b58:	b480      	push	{r7}
 8020b5a:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 8020b5c:	4b12      	ldr	r3, [pc, #72]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b5e:	2200      	movs	r2, #0
 8020b60:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 8020b64:	4b10      	ldr	r3, [pc, #64]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b66:	2200      	movs	r2, #0
 8020b68:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 8020b6a:	4b0f      	ldr	r3, [pc, #60]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b6c:	2200      	movs	r2, #0
 8020b6e:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 8020b70:	4b0d      	ldr	r3, [pc, #52]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b72:	2200      	movs	r2, #0
 8020b74:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 8020b76:	4b0c      	ldr	r3, [pc, #48]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b78:	2200      	movs	r2, #0
 8020b7a:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 8020b7c:	4b0a      	ldr	r3, [pc, #40]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b7e:	2200      	movs	r2, #0
 8020b80:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 8020b82:	4b09      	ldr	r3, [pc, #36]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b84:	2200      	movs	r2, #0
 8020b86:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 8020b88:	4b07      	ldr	r3, [pc, #28]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b8a:	2200      	movs	r2, #0
 8020b8c:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 8020b8e:	4b06      	ldr	r3, [pc, #24]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b90:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020b92:	4a05      	ldr	r2, [pc, #20]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b94:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 8020b96:	4b04      	ldr	r3, [pc, #16]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b98:	2200      	movs	r2, #0
 8020b9a:	621a      	str	r2, [r3, #32]
}
 8020b9c:	bf00      	nop
 8020b9e:	46bd      	mov	sp, r7
 8020ba0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ba4:	4770      	bx	lr
 8020ba6:	bf00      	nop
 8020ba8:	200000f8 	.word	0x200000f8

08020bac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init>:
/*
 * Initialize POSIF and CCU4 peripherals
 * Initialize hall sensor input pins.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init()
{
 8020bac:	b580      	push	{r7, lr}
 8020bae:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_POSIF_3Hall_Init();
 8020bb0:	f000 fb10 	bl	80211d4 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init>
  Motor0_BLDC_SCALAR_CCU4_3Hall_Init();
 8020bb4:	f000 f8c4 	bl	8020d40 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init>
  Motor0_BLDC_SCALAR_GPIO_3Hall_Init();
 8020bb8:	f000 fa28 	bl	802100c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init>
}
 8020bbc:	bf00      	nop
 8020bbe:	bd80      	pop	{r7, pc}

08020bc0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>:

/*
 * Start POSIF and CCU4 timer.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start()
{
 8020bc0:	b580      	push	{r7, lr}
 8020bc2:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8020bc4:	f7ff ffc8 	bl	8020b58 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>

  /*
   * Set RUN bit of the POSIF and
   * CC41 First slice will be started on external start trigger
   */
  XMC_POSIF_Start(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8020bc8:	4806      	ldr	r0, [pc, #24]	; (8020be4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x24>)
 8020bca:	f7ff ff98 	bl	8020afe <XMC_POSIF_Start>

  XMC_CCU4_SLICE_ClearTimer(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE);
 8020bce:	4806      	ldr	r0, [pc, #24]	; (8020be8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x28>)
 8020bd0:	f7ff ff88 	bl	8020ae4 <XMC_CCU4_SLICE_ClearTimer>
  XMC_CCU4_SLICE_ClearTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bd4:	4805      	ldr	r0, [pc, #20]	; (8020bec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x2c>)
 8020bd6:	f7ff ff85 	bl	8020ae4 <XMC_CCU4_SLICE_ClearTimer>

  XMC_CCU4_SLICE_StartTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bda:	4804      	ldr	r0, [pc, #16]	; (8020bec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x2c>)
 8020bdc:	f7ff ff68 	bl	8020ab0 <XMC_CCU4_SLICE_StartTimer>

}
 8020be0:	bf00      	nop
 8020be2:	bd80      	pop	{r7, pc}
 8020be4:	40028000 	.word	0x40028000
 8020be8:	4000c100 	.word	0x4000c100
 8020bec:	4000c200 	.word	0x4000c200

08020bf0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop>:

/*
 * Stop POSIF and CCU4 timer.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop()
{
 8020bf0:	b580      	push	{r7, lr}
 8020bf2:	af00      	add	r7, sp, #0
  XMC_POSIF_Stop(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8020bf4:	4806      	ldr	r0, [pc, #24]	; (8020c10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x20>)
 8020bf6:	f7ff ff8f 	bl	8020b18 <XMC_POSIF_Stop>
  NVIC_ClearPendingIRQ(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE);
 8020bfa:	2044      	movs	r0, #68	; 0x44
 8020bfc:	f7ff ff3a 	bl	8020a74 <__NVIC_ClearPendingIRQ>
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE);
 8020c00:	4804      	ldr	r0, [pc, #16]	; (8020c14 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x24>)
 8020c02:	f7ff ff62 	bl	8020aca <XMC_CCU4_SLICE_StopTimer>
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020c06:	4804      	ldr	r0, [pc, #16]	; (8020c18 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x28>)
 8020c08:	f7ff ff5f 	bl	8020aca <XMC_CCU4_SLICE_StopTimer>
}
 8020c0c:	bf00      	nop
 8020c0e:	bd80      	pop	{r7, pc}
 8020c10:	40028000 	.word	0x40028000
 8020c14:	4000c100 	.word	0x4000c100
 8020c18:	4000c200 	.word	0x4000c200

08020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>:
 * This function will return the current state of the POSIF input pins to
 * which hall sensors are connected. This information is required before
 * starting the motor to know the start position of the motor.
 */
uint32_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition(void)
{
 8020c1c:	b580      	push	{r7, lr}
 8020c1e:	b084      	sub	sp, #16
 8020c20:	af00      	add	r7, sp, #0
  uint32_t hallposition;
  uint32_t hall[3] = { 0U };
 8020c22:	463b      	mov	r3, r7
 8020c24:	2200      	movs	r2, #0
 8020c26:	601a      	str	r2, [r3, #0]
 8020c28:	605a      	str	r2, [r3, #4]
 8020c2a:	609a      	str	r2, [r3, #8]

  /*Read the input pins.*/
  hall[0] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_1);
 8020c2c:	2103      	movs	r1, #3
 8020c2e:	4811      	ldr	r0, [pc, #68]	; (8020c74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c30:	f7ff ff7f 	bl	8020b32 <XMC_GPIO_GetInput>
 8020c34:	4603      	mov	r3, r0
 8020c36:	603b      	str	r3, [r7, #0]
  hall[1] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_2);
 8020c38:	2102      	movs	r1, #2
 8020c3a:	480e      	ldr	r0, [pc, #56]	; (8020c74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c3c:	f7ff ff79 	bl	8020b32 <XMC_GPIO_GetInput>
 8020c40:	4603      	mov	r3, r0
 8020c42:	607b      	str	r3, [r7, #4]
  hallposition = (uint32_t)(hall[0] | ((uint32_t) hall[1] << 1U));
 8020c44:	683a      	ldr	r2, [r7, #0]
 8020c46:	687b      	ldr	r3, [r7, #4]
 8020c48:	005b      	lsls	r3, r3, #1
 8020c4a:	4313      	orrs	r3, r2
 8020c4c:	60fb      	str	r3, [r7, #12]

  hall[2] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_3);
 8020c4e:	2101      	movs	r1, #1
 8020c50:	4808      	ldr	r0, [pc, #32]	; (8020c74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c52:	f7ff ff6e 	bl	8020b32 <XMC_GPIO_GetInput>
 8020c56:	4603      	mov	r3, r0
 8020c58:	60bb      	str	r3, [r7, #8]
  hallposition |= ((uint32_t)(hall[2] << BLDC_SCALAR_SPEED_POS_HALL_2_POS));
 8020c5a:	68bb      	ldr	r3, [r7, #8]
 8020c5c:	009b      	lsls	r3, r3, #2
 8020c5e:	68fa      	ldr	r2, [r7, #12]
 8020c60:	4313      	orrs	r3, r2
 8020c62:	60fb      	str	r3, [r7, #12]


  return ((uint32_t)(hallposition & BLDC_SCALAR_SPEED_POS_HALL_MASK));
 8020c64:	68fb      	ldr	r3, [r7, #12]
 8020c66:	f003 0307 	and.w	r3, r3, #7
}
 8020c6a:	4618      	mov	r0, r3
 8020c6c:	3710      	adds	r7, #16
 8020c6e:	46bd      	mov	sp, r7
 8020c70:	bd80      	pop	{r7, pc}
 8020c72:	bf00      	nop
 8020c74:	48028100 	.word	0x48028100

08020c78 <XMC_CCU4_EnableClock>:
{
 8020c78:	b480      	push	{r7}
 8020c7a:	b083      	sub	sp, #12
 8020c7c:	af00      	add	r7, sp, #0
 8020c7e:	6078      	str	r0, [r7, #4]
 8020c80:	460b      	mov	r3, r1
 8020c82:	70fb      	strb	r3, [r7, #3]
  module->GIDLC = ((uint32_t) 1) << slice_number;
 8020c84:	78fb      	ldrb	r3, [r7, #3]
 8020c86:	2201      	movs	r2, #1
 8020c88:	409a      	lsls	r2, r3
 8020c8a:	687b      	ldr	r3, [r7, #4]
 8020c8c:	60da      	str	r2, [r3, #12]
}
 8020c8e:	bf00      	nop
 8020c90:	370c      	adds	r7, #12
 8020c92:	46bd      	mov	sp, r7
 8020c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020c98:	4770      	bx	lr

08020c9a <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
 8020c9a:	b480      	push	{r7}
 8020c9c:	b083      	sub	sp, #12
 8020c9e:	af00      	add	r7, sp, #0
 8020ca0:	6078      	str	r0, [r7, #4]
 8020ca2:	460b      	mov	r3, r1
 8020ca4:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8020ca6:	887a      	ldrh	r2, [r7, #2]
 8020ca8:	687b      	ldr	r3, [r7, #4]
 8020caa:	635a      	str	r2, [r3, #52]	; 0x34
}
 8020cac:	bf00      	nop
 8020cae:	370c      	adds	r7, #12
 8020cb0:	46bd      	mov	sp, r7
 8020cb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cb6:	4770      	bx	lr

08020cb8 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
 8020cb8:	b480      	push	{r7}
 8020cba:	b083      	sub	sp, #12
 8020cbc:	af00      	add	r7, sp, #0
 8020cbe:	6078      	str	r0, [r7, #4]
 8020cc0:	460b      	mov	r3, r1
 8020cc2:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8020cc4:	887a      	ldrh	r2, [r7, #2]
 8020cc6:	687b      	ldr	r3, [r7, #4]
 8020cc8:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8020cca:	bf00      	nop
 8020ccc:	370c      	adds	r7, #12
 8020cce:	46bd      	mov	sp, r7
 8020cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cd4:	4770      	bx	lr

08020cd6 <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 8020cd6:	b480      	push	{r7}
 8020cd8:	b083      	sub	sp, #12
 8020cda:	af00      	add	r7, sp, #0
 8020cdc:	6078      	str	r0, [r7, #4]
 8020cde:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8020ce0:	687b      	ldr	r3, [r7, #4]
 8020ce2:	683a      	ldr	r2, [r7, #0]
 8020ce4:	611a      	str	r2, [r3, #16]
}
 8020ce6:	bf00      	nop
 8020ce8:	370c      	adds	r7, #12
 8020cea:	46bd      	mov	sp, r7
 8020cec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cf0:	4770      	bx	lr

08020cf2 <XMC_CCU4_SLICE_EnableFloatingPrescaler>:
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue()<BR> XMC_CCU4_SLICE_DisableFloatingPrescaler()<BR>
 *  XMC_CCU4_SLICE_SetPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableFloatingPrescaler(XMC_CCU4_SLICE_t *const slice)
{
 8020cf2:	b480      	push	{r7}
 8020cf4:	b083      	sub	sp, #12
 8020cf6:	af00      	add	r7, sp, #0
 8020cf8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableFloatingPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TC |= (uint32_t) CCU4_CC4_TC_FPE_Msk;
 8020cfa:	687b      	ldr	r3, [r7, #4]
 8020cfc:	695b      	ldr	r3, [r3, #20]
 8020cfe:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8020d02:	687b      	ldr	r3, [r7, #4]
 8020d04:	615a      	str	r2, [r3, #20]
}
 8020d06:	bf00      	nop
 8020d08:	370c      	adds	r7, #12
 8020d0a:	46bd      	mov	sp, r7
 8020d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020d10:	4770      	bx	lr

08020d12 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 8020d12:	b480      	push	{r7}
 8020d14:	b083      	sub	sp, #12
 8020d16:	af00      	add	r7, sp, #0
 8020d18:	6078      	str	r0, [r7, #4]
 8020d1a:	460b      	mov	r3, r1
 8020d1c:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8020d1e:	687b      	ldr	r3, [r7, #4]
 8020d20:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8020d24:	78fb      	ldrb	r3, [r7, #3]
 8020d26:	2101      	movs	r1, #1
 8020d28:	fa01 f303 	lsl.w	r3, r1, r3
 8020d2c:	431a      	orrs	r2, r3
 8020d2e:	687b      	ldr	r3, [r7, #4]
 8020d30:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8020d34:	bf00      	nop
 8020d36:	370c      	adds	r7, #12
 8020d38:	46bd      	mov	sp, r7
 8020d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020d3e:	4770      	bx	lr

08020d40 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init>:
 *
 * \par<b>Description:</b><br>
 * CCU4 slices initialization for 3 hall feedback configuration.
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_Init(void)
{
 8020d40:	b580      	push	{r7, lr}
 8020d42:	af00      	add	r7, sp, #0
  /* Enable CCU4 module */
  XMC_CCU4_Init(MOTOR0_BLDC_SCALAR_CCU4_MODULE,XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
 8020d44:	2100      	movs	r1, #0
 8020d46:	4804      	ldr	r0, [pc, #16]	; (8020d58 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init+0x18>)
 8020d48:	f006 fd5a 	bl	8027800 <XMC_CCU4_Init>
#if (MOTOR0_BLDC_SCALAR_ENABLE_FAST_SYNCH_CCU4 == 1U)
  /* Enable CCU4 Fast Sync module */
  XMC_CCU4_Init(MOTOR0_BLDC_SCALAR_CCU4_MODULE_FAST_SYNC,XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
#endif
  /*Phase delay slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init();
 8020d4c:	f000 f806 	bl	8020d5c <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init>
  /*Speed capture slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init();
 8020d50:	f000 f83e 	bl	8020dd0 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init>
#if(1U == MOTOR0_BLDC_SCALAR_ENABLE_FAST_SYNCH_CCU4)
  /*Fast sync slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_MCMSync_Init();
#endif
}
 8020d54:	bf00      	nop
 8020d56:	bd80      	pop	{r7, pc}
 8020d58:	4000c000 	.word	0x4000c000

08020d5c <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init>:
 *
 * \par<b>Description:</b><br>
 * Initializes phase delay CCU4 slice for MCM pattern update .
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init(void)
{
 8020d5c:	b580      	push	{r7, lr}
 8020d5e:	af00      	add	r7, sp, #0
  /*Phase delay slice compare timer initiation*/
  XMC_CCU4_SLICE_CompareInit(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d60:	4916      	ldr	r1, [pc, #88]	; (8020dbc <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x60>)
 8020d62:	4817      	ldr	r0, [pc, #92]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d64:	f006 fd87 	bl	8027876 <XMC_CCU4_SLICE_CompareInit>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_PhaseDelay_CompareConfig);

  /*Phase delay blanking time configuration*/
  XMC_CCU4_SLICE_SetTimerCompareMatch(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d68:	4b16      	ldr	r3, [pc, #88]	; (8020dc4 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x68>)
 8020d6a:	881b      	ldrh	r3, [r3, #0]
 8020d6c:	4619      	mov	r1, r3
 8020d6e:	4814      	ldr	r0, [pc, #80]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d70:	f7ff ffa2 	bl	8020cb8 <XMC_CCU4_SLICE_SetTimerCompareMatch>
      Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Config.blanking_time);

  /*Phase delay slice period value(phase delay timing) configuration*/
  XMC_CCU4_SLICE_SetTimerPeriodMatch(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d74:	4b13      	ldr	r3, [pc, #76]	; (8020dc4 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x68>)
 8020d76:	885b      	ldrh	r3, [r3, #2]
 8020d78:	4619      	mov	r1, r3
 8020d7a:	4811      	ldr	r0, [pc, #68]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d7c:	f7ff ff8d 	bl	8020c9a <XMC_CCU4_SLICE_SetTimerPeriodMatch>
      Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Config.phase_delay);

  /*enable shadow transfer for compare and period value*/
  XMC_CCU4_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU4_MODULE,MOTOR0_BLDC_SCALAR_CCU4_DELAY_SHADOWTRANSFER);
 8020d80:	2101      	movs	r1, #1
 8020d82:	4811      	ldr	r0, [pc, #68]	; (8020dc8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x6c>)
 8020d84:	f7ff ffa7 	bl	8020cd6 <XMC_CCU4_EnableShadowTransfer>

  /*Configure Event 0 signal for phase delay slice*/
  XMC_CCU4_SLICE_ConfigureEvent(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020d88:	4a10      	ldr	r2, [pc, #64]	; (8020dcc <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x70>)
 8020d8a:	2101      	movs	r1, #1
 8020d8c:	480c      	ldr	r0, [pc, #48]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d8e:	f006 ffa5 	bl	8027cdc <XMC_CCU4_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_PhaseDelay_StartEventconfig);

  /*Configure Event 0 signal as start signal for phase delay slice*/
  XMC_CCU4_SLICE_StartConfig(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020d92:	2201      	movs	r2, #1
 8020d94:	2101      	movs	r1, #1
 8020d96:	480a      	ldr	r0, [pc, #40]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d98:	f006 fdcb 	bl	8027932 <XMC_CCU4_SLICE_StartConfig>
      XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR);

  /* Clear IDLE mode.*/
  XMC_CCU4_EnableClock(MOTOR0_BLDC_SCALAR_CCU4_MODULE, MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE_NUM);
 8020d9c:	2100      	movs	r1, #0
 8020d9e:	480a      	ldr	r0, [pc, #40]	; (8020dc8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x6c>)
 8020da0:	f7ff ff6a 	bl	8020c78 <XMC_CCU4_EnableClock>

  /*bind interrupt node for period match of phase delay*/
  XMC_CCU4_SLICE_SetInterruptNode(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8020da4:	2200      	movs	r2, #0
 8020da6:	2100      	movs	r1, #0
 8020da8:	4805      	ldr	r0, [pc, #20]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020daa:	f007 f831 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_CCU4_PHASE_DELAY_PM_SR);

  /*Enable period match interrupt of slice 0*/
  XMC_CCU4_SLICE_EnableEvent(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8020dae:	2100      	movs	r1, #0
 8020db0:	4803      	ldr	r0, [pc, #12]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020db2:	f7ff ffae 	bl	8020d12 <XMC_CCU4_SLICE_EnableEvent>
}
 8020db6:	bf00      	nop
 8020db8:	bd80      	pop	{r7, pc}
 8020dba:	bf00      	nop
 8020dbc:	20000040 	.word	0x20000040
 8020dc0:	4000c100 	.word	0x4000c100
 8020dc4:	2000004c 	.word	0x2000004c
 8020dc8:	4000c000 	.word	0x4000c000
 8020dcc:	20000048 	.word	0x20000048

08020dd0 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init>:
 *
 * \par<b>Description:</b><br>
 * Initializes capture CCU4 slice for motor speed calculations from HALL events.
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init(void)
{
 8020dd0:	b580      	push	{r7, lr}
 8020dd2:	af00      	add	r7, sp, #0
  /*capture slice initiation*/
  XMC_CCU4_SLICE_CaptureInit(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, &Motor0_BLDC_SCALAR_CCU4_3HALL_CaptureConfig);
 8020dd4:	490c      	ldr	r1, [pc, #48]	; (8020e08 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x38>)
 8020dd6:	480d      	ldr	r0, [pc, #52]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020dd8:	f006 fd84 	bl	80278e4 <XMC_CCU4_SLICE_CaptureInit>

  /*Set prescaler value*/
  XMC_CCU4_SLICE_SetPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, MOTOR0_BLDC_SCALAR_CCU4_PRESCALER);
 8020ddc:	2105      	movs	r1, #5
 8020dde:	480b      	ldr	r0, [pc, #44]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020de0:	f006 fff8 	bl	8027dd4 <XMC_CCU4_SLICE_SetPrescaler>
  /* enable floating prescaler for capture slice*/
  XMC_CCU4_SLICE_EnableFloatingPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020de4:	4809      	ldr	r0, [pc, #36]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020de6:	f7ff ff84 	bl	8020cf2 <XMC_CCU4_SLICE_EnableFloatingPrescaler>

  /* configure Event 0 signal as capture event*/
  XMC_CCU4_SLICE_ConfigureEvent(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020dea:	4a09      	ldr	r2, [pc, #36]	; (8020e10 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x40>)
 8020dec:	2101      	movs	r1, #1
 8020dee:	4807      	ldr	r0, [pc, #28]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020df0:	f006 ff74 	bl	8027cdc <XMC_CCU4_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_Capture_ExtCaptureEventConfig);

  /* configure channel for speed capture*/
  XMC_CCU4_SLICE_Capture1Config(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, XMC_CCU4_SLICE_EVENT_0);
 8020df4:	2101      	movs	r1, #1
 8020df6:	4805      	ldr	r0, [pc, #20]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020df8:	f006 fe86 	bl	8027b08 <XMC_CCU4_SLICE_Capture1Config>

  /* Clear IDLE mode.*/
  XMC_CCU4_EnableClock(MOTOR0_BLDC_SCALAR_CCU4_MODULE, MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE_NUM);
 8020dfc:	2101      	movs	r1, #1
 8020dfe:	4805      	ldr	r0, [pc, #20]	; (8020e14 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x44>)
 8020e00:	f7ff ff3a 	bl	8020c78 <XMC_CCU4_EnableClock>

}
 8020e04:	bf00      	nop
 8020e06:	bd80      	pop	{r7, pc}
 8020e08:	20000050 	.word	0x20000050
 8020e0c:	4000c200 	.word	0x4000c200
 8020e10:	20000058 	.word	0x20000058
 8020e14:	4000c000 	.word	0x4000c000

08020e18 <XMC_CCU8_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU8_DisableClock()<BR>  XMC_CCU8_EnableMultipleClocks()<BR>  XMC_CCU8_StartPrescaler()<BR>  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
 8020e18:	b480      	push	{r7}
 8020e1a:	b083      	sub	sp, #12
 8020e1c:	af00      	add	r7, sp, #0
 8020e1e:	6078      	str	r0, [r7, #4]
 8020e20:	460b      	mov	r3, r1
 8020e22:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1 << slice_number);
 8020e24:	78fb      	ldrb	r3, [r7, #3]
 8020e26:	2201      	movs	r2, #1
 8020e28:	409a      	lsls	r2, r3
 8020e2a:	687b      	ldr	r3, [r7, #4]
 8020e2c:	60da      	str	r2, [r3, #12]
}
 8020e2e:	bf00      	nop
 8020e30:	370c      	adds	r7, #12
 8020e32:	46bd      	mov	sp, r7
 8020e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e38:	4770      	bx	lr

08020e3a <XMC_CCU8_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 8020e3a:	b480      	push	{r7}
 8020e3c:	b083      	sub	sp, #12
 8020e3e:	af00      	add	r7, sp, #0
 8020e40:	6078      	str	r0, [r7, #4]
 8020e42:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8020e44:	687b      	ldr	r3, [r7, #4]
 8020e46:	683a      	ldr	r2, [r7, #0]
 8020e48:	611a      	str	r2, [r3, #16]
}
 8020e4a:	bf00      	nop
 8020e4c:	370c      	adds	r7, #12
 8020e4e:	46bd      	mov	sp, r7
 8020e50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e54:	4770      	bx	lr

08020e56 <XMC_CCU8_SLICE_EnableEvent>:
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU8_SLICE_SetInterruptNode()<BR>  XMC_CCU8_SLICE_EnableMultipleEvents()<BR>  XMC_CCU8_SLICE_DisableEvent()<BR>
 *  XMC_CCU8_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
 8020e56:	b480      	push	{r7}
 8020e58:	b083      	sub	sp, #12
 8020e5a:	af00      	add	r7, sp, #0
 8020e5c:	6078      	str	r0, [r7, #4]
 8020e5e:	460b      	mov	r3, r1
 8020e60:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8020e62:	687b      	ldr	r3, [r7, #4]
 8020e64:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8020e68:	78fb      	ldrb	r3, [r7, #3]
 8020e6a:	2101      	movs	r1, #1
 8020e6c:	fa01 f303 	lsl.w	r3, r1, r3
 8020e70:	431a      	orrs	r2, r3
 8020e72:	687b      	ldr	r3, [r7, #4]
 8020e74:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8020e78:	bf00      	nop
 8020e7a:	370c      	adds	r7, #12
 8020e7c:	46bd      	mov	sp, r7
 8020e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e82:	4770      	bx	lr

08020e84 <BLDC_SCALAR_CCU8_Event_Init>:
 *
 * \par<b>Description:</b><br>
 * Initialize CCU8 slice for enable event and SR binding to the node.
 */
static void BLDC_SCALAR_CCU8_Event_Init(XMC_CCU8_SLICE_t* slice_ptr, XMC_CCU8_SLICE_IRQ_ID_t irq_id, XMC_CCU8_SLICE_SR_ID_t sr_id)
{
 8020e84:	b580      	push	{r7, lr}
 8020e86:	b082      	sub	sp, #8
 8020e88:	af00      	add	r7, sp, #0
 8020e8a:	6078      	str	r0, [r7, #4]
 8020e8c:	460b      	mov	r3, r1
 8020e8e:	70fb      	strb	r3, [r7, #3]
 8020e90:	4613      	mov	r3, r2
 8020e92:	70bb      	strb	r3, [r7, #2]
  /*Bind slice event SR(service request) to interrupt node*/
  XMC_CCU8_SLICE_SetInterruptNode(slice_ptr,irq_id,sr_id);
 8020e94:	78ba      	ldrb	r2, [r7, #2]
 8020e96:	78fb      	ldrb	r3, [r7, #3]
 8020e98:	4619      	mov	r1, r3
 8020e9a:	6878      	ldr	r0, [r7, #4]
 8020e9c:	f007 f9a6 	bl	80281ec <XMC_CCU8_SLICE_SetInterruptNode>

  /* Enable slice event */
  XMC_CCU8_SLICE_EnableEvent(slice_ptr,irq_id);
 8020ea0:	78fb      	ldrb	r3, [r7, #3]
 8020ea2:	4619      	mov	r1, r3
 8020ea4:	6878      	ldr	r0, [r7, #4]
 8020ea6:	f7ff ffd6 	bl	8020e56 <XMC_CCU8_SLICE_EnableEvent>
}
 8020eaa:	bf00      	nop
 8020eac:	3708      	adds	r7, #8
 8020eae:	46bd      	mov	sp, r7
 8020eb0:	bd80      	pop	{r7, pc}
	...

08020eb4 <Motor0_BLDC_SCALAR_CCU8_Slice_Init>:
 * Initialize CCU8 slice.
 */


static void Motor0_BLDC_SCALAR_CCU8_Slice_Init(uint32_t count)
{
 8020eb4:	b580      	push	{r7, lr}
 8020eb6:	b084      	sub	sp, #16
 8020eb8:	af00      	add	r7, sp, #0
 8020eba:	6078      	str	r0, [r7, #4]
  XMC_CCU8_SLICE_t* const slice_ptr = Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count];
 8020ebc:	4a19      	ldr	r2, [pc, #100]	; (8020f24 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ebe:	687b      	ldr	r3, [r7, #4]
 8020ec0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8020ec4:	60fb      	str	r3, [r7, #12]

  /*Enable clock for slice*/
  XMC_CCU8_EnableClock(MOTOR0_BLDC_SCALAR_CCU8_MODULE,Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_number[count]);
 8020ec6:	4a17      	ldr	r2, [pc, #92]	; (8020f24 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ec8:	687b      	ldr	r3, [r7, #4]
 8020eca:	4413      	add	r3, r2
 8020ecc:	330c      	adds	r3, #12
 8020ece:	781b      	ldrb	r3, [r3, #0]
 8020ed0:	4619      	mov	r1, r3
 8020ed2:	4815      	ldr	r0, [pc, #84]	; (8020f28 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x74>)
 8020ed4:	f7ff ffa0 	bl	8020e18 <XMC_CCU8_EnableClock>

  /* CCU8 Slice configuration */
  XMC_CCU8_SLICE_CompareInit(slice_ptr, &Motor0_BLDC_SCALAR_CCU8CompareConf);
 8020ed8:	4914      	ldr	r1, [pc, #80]	; (8020f2c <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x78>)
 8020eda:	68f8      	ldr	r0, [r7, #12]
 8020edc:	f007 f861 	bl	8027fa2 <XMC_CCU8_SLICE_CompareInit>
  /* Update CCU8 slice period registers */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(slice_ptr,Motor0_BLDC_SCALAR_CCU8_PWM_Config.period);
 8020ee0:	4b10      	ldr	r3, [pc, #64]	; (8020f24 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ee2:	8a5b      	ldrh	r3, [r3, #18]
 8020ee4:	4619      	mov	r1, r3
 8020ee6:	68f8      	ldr	r0, [r7, #12]
 8020ee8:	f007 f959 	bl	802819e <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /*
   * Mapped slice to EVENT-0 (sync start event)
   * External Start Function triggered by Event-0 rising edge
   * Clears the timer and sets run bit.
   */
  XMC_CCU8_SLICE_ConfigureEvent(slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_0,
 8020eec:	4a10      	ldr	r2, [pc, #64]	; (8020f30 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x7c>)
 8020eee:	2101      	movs	r1, #1
 8020ef0:	68f8      	ldr	r0, [r7, #12]
 8020ef2:	f007 f8ea 	bl	80280ca <XMC_CCU8_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU8ExtStartEventConf);
  XMC_CCU8_SLICE_StartConfig(slice_ptr,XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
 8020ef6:	2201      	movs	r2, #1
 8020ef8:	2101      	movs	r1, #1
 8020efa:	68f8      	ldr	r0, [r7, #12]
 8020efc:	f007 f88b 	bl	8028016 <XMC_CCU8_SLICE_StartConfig>
  /*
   * Mapped slice to EVENT-1 (sync stop event)
   * External Stop Function triggered by Event-1 falling edge
   * Clears the timer and run bit
   */
  XMC_CCU8_SLICE_ConfigureEvent(slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_1,
 8020f00:	4a0c      	ldr	r2, [pc, #48]	; (8020f34 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x80>)
 8020f02:	2102      	movs	r1, #2
 8020f04:	68f8      	ldr	r0, [r7, #12]
 8020f06:	f007 f8e0 	bl	80280ca <XMC_CCU8_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU8ExtStopEventConf);
  XMC_CCU8_SLICE_StopConfig(slice_ptr,XMC_CCU8_SLICE_EVENT_1,  XMC_CCU8_SLICE_END_MODE_TIMER_STOP_CLEAR);
 8020f0a:	2202      	movs	r2, #2
 8020f0c:	2102      	movs	r1, #2
 8020f0e:	68f8      	ldr	r0, [r7, #12]
 8020f10:	f007 f8af 	bl	8028072 <XMC_CCU8_SLICE_StopConfig>
      &Motor0_BLDC_SCALAR_CCU8TrapEventConf);
  slice_ptr->CMC |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
  #endif

  /* Configure the dead time value */
  XMC_CCU8_SLICE_DeadTimeInit(slice_ptr,&Motor0_BLDC_SCALAR_CCU8_DeadTimeConfig);
 8020f14:	4908      	ldr	r1, [pc, #32]	; (8020f38 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x84>)
 8020f16:	68f8      	ldr	r0, [r7, #12]
 8020f18:	f007 f9d2 	bl	80282c0 <XMC_CCU8_SLICE_DeadTimeInit>
}
 8020f1c:	bf00      	nop
 8020f1e:	3710      	adds	r7, #16
 8020f20:	46bd      	mov	sp, r7
 8020f22:	bd80      	pop	{r7, pc}
 8020f24:	20000068 	.word	0x20000068
 8020f28:	40020000 	.word	0x40020000
 8020f2c:	0802b178 	.word	0x0802b178
 8020f30:	0802b170 	.word	0x0802b170
 8020f34:	0802b174 	.word	0x0802b174
 8020f38:	2000005c 	.word	0x2000005c

08020f3c <Motor0_BLDC_SCALAR_CCU8_PWM_Init>:
 *
 * \par<b>Description:</b><br>
 * Initialize CCU8 slice for all 3 phases PWM generation.
 */
void Motor0_BLDC_SCALAR_CCU8_PWM_Init(void)
{
 8020f3c:	b580      	push	{r7, lr}
 8020f3e:	b082      	sub	sp, #8
 8020f40:	af00      	add	r7, sp, #0
  /*
   * Enable CCU8 module
   * Start the pre-scaler
   * Configure multi channel Shadow transfer request
   */
  XMC_CCU8_Init(MOTOR0_BLDC_SCALAR_CCU8_MODULE,XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
 8020f42:	2100      	movs	r1, #0
 8020f44:	4816      	ldr	r0, [pc, #88]	; (8020fa0 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x64>)
 8020f46:	f007 f80d 	bl	8027f64 <XMC_CCU8_Init>

  /*Initialize CCU8 Phase-U, V and W Slice*/
  for (count = 0U; count < CCU8_MAXPHASE_COUNT;count++)
 8020f4a:	2300      	movs	r3, #0
 8020f4c:	607b      	str	r3, [r7, #4]
 8020f4e:	e005      	b.n	8020f5c <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x20>
  {
    Motor0_BLDC_SCALAR_CCU8_Slice_Init(count);
 8020f50:	6878      	ldr	r0, [r7, #4]
 8020f52:	f7ff ffaf 	bl	8020eb4 <Motor0_BLDC_SCALAR_CCU8_Slice_Init>
  for (count = 0U; count < CCU8_MAXPHASE_COUNT;count++)
 8020f56:	687b      	ldr	r3, [r7, #4]
 8020f58:	3301      	adds	r3, #1
 8020f5a:	607b      	str	r3, [r7, #4]
 8020f5c:	687b      	ldr	r3, [r7, #4]
 8020f5e:	2b02      	cmp	r3, #2
 8020f60:	d9f6      	bls.n	8020f50 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x14>

  /*
   * Initialize Phase-U one match event and Bind Phase-U one match event SR(service request)
   * to interrupt node for control loop execution.
   */
  BLDC_SCALAR_CCU8_Event_Init(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[0U],
 8020f62:	4b10      	ldr	r3, [pc, #64]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f64:	681b      	ldr	r3, [r3, #0]
 8020f66:	2200      	movs	r2, #0
 8020f68:	2101      	movs	r1, #1
 8020f6a:	4618      	mov	r0, r3
 8020f6c:	f7ff ff8a 	bl	8020e84 <BLDC_SCALAR_CCU8_Event_Init>
  /*
   * DC link current measurement trigger
   * phase-V compare match 2 down event
   */
  /* Initialize phase-V compare match 2 down event and bind SR to interrupt node for ADC trigger */
  BLDC_SCALAR_CCU8_Event_Init(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[1U],
 8020f70:	4b0c      	ldr	r3, [pc, #48]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f72:	685b      	ldr	r3, [r3, #4]
 8020f74:	2202      	movs	r2, #2
 8020f76:	2105      	movs	r1, #5
 8020f78:	4618      	mov	r0, r3
 8020f7a:	f7ff ff83 	bl	8020e84 <BLDC_SCALAR_CCU8_Event_Init>
   (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2, (XMC_CCU8_SLICE_SR_ID_t)MOTOR0_BLDC_SCALAR_CCU8_COMPMATCH_SR);

  XMC_CCU8_SLICE_SetTimerCompareMatch(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[1U], XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 8020f7e:	4b09      	ldr	r3, [pc, #36]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f80:	685b      	ldr	r3, [r3, #4]
 8020f82:	4a08      	ldr	r2, [pc, #32]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f84:	8a12      	ldrh	r2, [r2, #16]
 8020f86:	2101      	movs	r1, #1
 8020f88:	4618      	mov	r0, r3
 8020f8a:	f007 f917 	bl	80281bc <XMC_CCU8_SLICE_SetTimerCompareMatch>
      Motor0_BLDC_SCALAR_CCU8_PWM_Config.current_trigger);

  /*Enable CCU8 shadow transfer*/
  XMC_CCU8_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU8_MODULE, MOTOR0_BLDC_SCALAR_CCU8_SHADOW_TRANSFER);
 8020f8e:	f240 1111 	movw	r1, #273	; 0x111
 8020f92:	4803      	ldr	r0, [pc, #12]	; (8020fa0 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x64>)
 8020f94:	f7ff ff51 	bl	8020e3a <XMC_CCU8_EnableShadowTransfer>
}
 8020f98:	bf00      	nop
 8020f9a:	3708      	adds	r7, #8
 8020f9c:	46bd      	mov	sp, r7
 8020f9e:	bd80      	pop	{r7, pc}
 8020fa0:	40020000 	.word	0x40020000
 8020fa4:	20000068 	.word	0x20000068

08020fa8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as output pins of CCU8 slices for PWM generation.
 */
void Motor0_BLDC_SCALAR_GPIO_PWM_Init(void)
{
 8020fa8:	b580      	push	{r7, lr}
 8020faa:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_U_HS, &Motor0_BLDC_SCALAR_GPIO_PhU_High_Config);
 8020fac:	4a0f      	ldr	r2, [pc, #60]	; (8020fec <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x44>)
 8020fae:	2109      	movs	r1, #9
 8020fb0:	480f      	ldr	r0, [pc, #60]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fb2:	f005 fb2b 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_U_LS, &Motor0_BLDC_SCALAR_GPIO_PhU_Low_Config);
 8020fb6:	4a0f      	ldr	r2, [pc, #60]	; (8020ff4 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x4c>)
 8020fb8:	210e      	movs	r1, #14
 8020fba:	480f      	ldr	r0, [pc, #60]	; (8020ff8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x50>)
 8020fbc:	f005 fb26 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_V_HS, &Motor0_BLDC_SCALAR_GPIO_PhV_High_Config);
 8020fc0:	4a0e      	ldr	r2, [pc, #56]	; (8020ffc <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x54>)
 8020fc2:	210a      	movs	r1, #10
 8020fc4:	480a      	ldr	r0, [pc, #40]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fc6:	f005 fb21 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_V_LS, &Motor0_BLDC_SCALAR_GPIO_PhV_Low_Config);
 8020fca:	4a0d      	ldr	r2, [pc, #52]	; (8021000 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x58>)
 8020fcc:	210f      	movs	r1, #15
 8020fce:	480a      	ldr	r0, [pc, #40]	; (8020ff8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x50>)
 8020fd0:	f005 fb1c 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_W_HS, &Motor0_BLDC_SCALAR_GPIO_PhW_High_Config);
 8020fd4:	4a0b      	ldr	r2, [pc, #44]	; (8021004 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x5c>)
 8020fd6:	210b      	movs	r1, #11
 8020fd8:	4805      	ldr	r0, [pc, #20]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fda:	f005 fb17 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_W_LS, &Motor0_BLDC_SCALAR_GPIO_PhW_Low_Config);
 8020fde:	4a0a      	ldr	r2, [pc, #40]	; (8021008 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x60>)
 8020fe0:	2108      	movs	r1, #8
 8020fe2:	4803      	ldr	r0, [pc, #12]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fe4:	f005 fb12 	bl	802660c <XMC_GPIO_Init>
}
 8020fe8:	bf00      	nop
 8020fea:	bd80      	pop	{r7, pc}
 8020fec:	0802b188 	.word	0x0802b188
 8020ff0:	48028500 	.word	0x48028500
 8020ff4:	0802b194 	.word	0x0802b194
 8020ff8:	48028200 	.word	0x48028200
 8020ffc:	0802b1a0 	.word	0x0802b1a0
 8021000:	0802b1ac 	.word	0x0802b1ac
 8021004:	0802b1b8 	.word	0x0802b1b8
 8021008:	0802b1c4 	.word	0x0802b1c4

0802100c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as input pins to the POSIF to sense HALL feedback.
 */
void Motor0_BLDC_SCALAR_GPIO_3Hall_Init(void)
{
 802100c:	b580      	push	{r7, lr}
 802100e:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_1, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 8021010:	4a08      	ldr	r2, [pc, #32]	; (8021034 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 8021012:	2103      	movs	r1, #3
 8021014:	4808      	ldr	r0, [pc, #32]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8021016:	f005 faf9 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_2, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 802101a:	4a06      	ldr	r2, [pc, #24]	; (8021034 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 802101c:	2102      	movs	r1, #2
 802101e:	4806      	ldr	r0, [pc, #24]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8021020:	f005 faf4 	bl	802660c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_3, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 8021024:	4a03      	ldr	r2, [pc, #12]	; (8021034 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 8021026:	2101      	movs	r1, #1
 8021028:	4803      	ldr	r0, [pc, #12]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 802102a:	f005 faef 	bl	802660c <XMC_GPIO_Init>
}
 802102e:	bf00      	nop
 8021030:	bd80      	pop	{r7, pc}
 8021032:	bf00      	nop
 8021034:	0802b1d0 	.word	0x0802b1d0
 8021038:	48028100 	.word	0x48028100

0802103c <Motor0_BLDC_SCALAR_GPIO_Inverter_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as general purpose output pin for inverter enable.
 */
void Motor0_BLDC_SCALAR_GPIO_Inverter_Init(void)
{
 802103c:	b580      	push	{r7, lr}
 802103e:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE, &Motor0_BLDC_SCALAR_GPIO_Inverter_Config);
 8021040:	4a03      	ldr	r2, [pc, #12]	; (8021050 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init+0x14>)
 8021042:	210b      	movs	r1, #11
 8021044:	4803      	ldr	r0, [pc, #12]	; (8021054 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init+0x18>)
 8021046:	f005 fae1 	bl	802660c <XMC_GPIO_Init>
}
 802104a:	bf00      	nop
 802104c:	bd80      	pop	{r7, pc}
 802104e:	bf00      	nop
 8021050:	0802b1dc 	.word	0x0802b1dc
 8021054:	48028200 	.word	0x48028200

08021058 <__NVIC_GetPriorityGrouping>:
{
 8021058:	b480      	push	{r7}
 802105a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802105c:	4b04      	ldr	r3, [pc, #16]	; (8021070 <__NVIC_GetPriorityGrouping+0x18>)
 802105e:	68db      	ldr	r3, [r3, #12]
 8021060:	0a1b      	lsrs	r3, r3, #8
 8021062:	f003 0307 	and.w	r3, r3, #7
}
 8021066:	4618      	mov	r0, r3
 8021068:	46bd      	mov	sp, r7
 802106a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802106e:	4770      	bx	lr
 8021070:	e000ed00 	.word	0xe000ed00

08021074 <__NVIC_EnableIRQ>:
{
 8021074:	b480      	push	{r7}
 8021076:	b083      	sub	sp, #12
 8021078:	af00      	add	r7, sp, #0
 802107a:	4603      	mov	r3, r0
 802107c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802107e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8021082:	2b00      	cmp	r3, #0
 8021084:	db0b      	blt.n	802109e <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8021086:	79fb      	ldrb	r3, [r7, #7]
 8021088:	f003 021f 	and.w	r2, r3, #31
 802108c:	4907      	ldr	r1, [pc, #28]	; (80210ac <__NVIC_EnableIRQ+0x38>)
 802108e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8021092:	095b      	lsrs	r3, r3, #5
 8021094:	2001      	movs	r0, #1
 8021096:	fa00 f202 	lsl.w	r2, r0, r2
 802109a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 802109e:	bf00      	nop
 80210a0:	370c      	adds	r7, #12
 80210a2:	46bd      	mov	sp, r7
 80210a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210a8:	4770      	bx	lr
 80210aa:	bf00      	nop
 80210ac:	e000e100 	.word	0xe000e100

080210b0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80210b0:	b480      	push	{r7}
 80210b2:	b083      	sub	sp, #12
 80210b4:	af00      	add	r7, sp, #0
 80210b6:	4603      	mov	r3, r0
 80210b8:	6039      	str	r1, [r7, #0]
 80210ba:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80210bc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80210c0:	2b00      	cmp	r3, #0
 80210c2:	db0a      	blt.n	80210da <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80210c4:	683b      	ldr	r3, [r7, #0]
 80210c6:	b2da      	uxtb	r2, r3
 80210c8:	490c      	ldr	r1, [pc, #48]	; (80210fc <__NVIC_SetPriority+0x4c>)
 80210ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80210ce:	0092      	lsls	r2, r2, #2
 80210d0:	b2d2      	uxtb	r2, r2
 80210d2:	440b      	add	r3, r1
 80210d4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80210d8:	e00a      	b.n	80210f0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80210da:	683b      	ldr	r3, [r7, #0]
 80210dc:	b2da      	uxtb	r2, r3
 80210de:	4908      	ldr	r1, [pc, #32]	; (8021100 <__NVIC_SetPriority+0x50>)
 80210e0:	79fb      	ldrb	r3, [r7, #7]
 80210e2:	f003 030f 	and.w	r3, r3, #15
 80210e6:	3b04      	subs	r3, #4
 80210e8:	0092      	lsls	r2, r2, #2
 80210ea:	b2d2      	uxtb	r2, r2
 80210ec:	440b      	add	r3, r1
 80210ee:	761a      	strb	r2, [r3, #24]
}
 80210f0:	bf00      	nop
 80210f2:	370c      	adds	r7, #12
 80210f4:	46bd      	mov	sp, r7
 80210f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210fa:	4770      	bx	lr
 80210fc:	e000e100 	.word	0xe000e100
 8021100:	e000ed00 	.word	0xe000ed00

08021104 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8021104:	b480      	push	{r7}
 8021106:	b089      	sub	sp, #36	; 0x24
 8021108:	af00      	add	r7, sp, #0
 802110a:	60f8      	str	r0, [r7, #12]
 802110c:	60b9      	str	r1, [r7, #8]
 802110e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8021110:	68fb      	ldr	r3, [r7, #12]
 8021112:	f003 0307 	and.w	r3, r3, #7
 8021116:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8021118:	69fb      	ldr	r3, [r7, #28]
 802111a:	f1c3 0307 	rsb	r3, r3, #7
 802111e:	2b06      	cmp	r3, #6
 8021120:	bf28      	it	cs
 8021122:	2306      	movcs	r3, #6
 8021124:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8021126:	69fb      	ldr	r3, [r7, #28]
 8021128:	3306      	adds	r3, #6
 802112a:	2b06      	cmp	r3, #6
 802112c:	d902      	bls.n	8021134 <NVIC_EncodePriority+0x30>
 802112e:	69fb      	ldr	r3, [r7, #28]
 8021130:	3b01      	subs	r3, #1
 8021132:	e000      	b.n	8021136 <NVIC_EncodePriority+0x32>
 8021134:	2300      	movs	r3, #0
 8021136:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8021138:	f04f 32ff 	mov.w	r2, #4294967295
 802113c:	69bb      	ldr	r3, [r7, #24]
 802113e:	fa02 f303 	lsl.w	r3, r2, r3
 8021142:	43da      	mvns	r2, r3
 8021144:	68bb      	ldr	r3, [r7, #8]
 8021146:	401a      	ands	r2, r3
 8021148:	697b      	ldr	r3, [r7, #20]
 802114a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802114c:	f04f 31ff 	mov.w	r1, #4294967295
 8021150:	697b      	ldr	r3, [r7, #20]
 8021152:	fa01 f303 	lsl.w	r3, r1, r3
 8021156:	43d9      	mvns	r1, r3
 8021158:	687b      	ldr	r3, [r7, #4]
 802115a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802115c:	4313      	orrs	r3, r2
         );
}
 802115e:	4618      	mov	r0, r3
 8021160:	3724      	adds	r7, #36	; 0x24
 8021162:	46bd      	mov	sp, r7
 8021164:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021168:	4770      	bx	lr

0802116a <BLDC_SCALAR_NVIC_NodeInit>:
 *
 * \par<b>Description:</b><br>
 * Sets the priority of an interrupt and enables the interrupt.
 */
void BLDC_SCALAR_NVIC_NodeInit(IRQn_Type node_id, uint32_t priority, uint32_t sub_priority)
{
 802116a:	b580      	push	{r7, lr}
 802116c:	b084      	sub	sp, #16
 802116e:	af00      	add	r7, sp, #0
 8021170:	4603      	mov	r3, r0
 8021172:	60b9      	str	r1, [r7, #8]
 8021174:	607a      	str	r2, [r7, #4]
 8021176:	73fb      	strb	r3, [r7, #15]
  /*set the priority and sub priority*/
  #if (UC_FAMILY == XMC1)
  NVIC_SetPriority(node_id,priority);
  #else
  NVIC_SetPriority(node_id, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), priority,sub_priority));
 8021178:	f7ff ff6e 	bl	8021058 <__NVIC_GetPriorityGrouping>
 802117c:	4603      	mov	r3, r0
 802117e:	687a      	ldr	r2, [r7, #4]
 8021180:	68b9      	ldr	r1, [r7, #8]
 8021182:	4618      	mov	r0, r3
 8021184:	f7ff ffbe 	bl	8021104 <NVIC_EncodePriority>
 8021188:	4602      	mov	r2, r0
 802118a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802118e:	4611      	mov	r1, r2
 8021190:	4618      	mov	r0, r3
 8021192:	f7ff ff8d 	bl	80210b0 <__NVIC_SetPriority>
  #endif
  /*Enable the IRQ*/
  NVIC_EnableIRQ(node_id);
 8021196:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802119a:	4618      	mov	r0, r3
 802119c:	f7ff ff6a 	bl	8021074 <__NVIC_EnableIRQ>
}
 80211a0:	bf00      	nop
 80211a2:	3710      	adds	r7, #16
 80211a4:	46bd      	mov	sp, r7
 80211a6:	bd80      	pop	{r7, pc}

080211a8 <XMC_POSIF_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_DisableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_EnableEvent(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 80211a8:	b480      	push	{r7}
 80211aa:	b083      	sub	sp, #12
 80211ac:	af00      	add	r7, sp, #0
 80211ae:	6078      	str	r0, [r7, #4]
 80211b0:	460b      	mov	r3, r1
 80211b2:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE |= (uint32_t)1 << (uint8_t)event;
 80211b4:	687b      	ldr	r3, [r7, #4]
 80211b6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80211b8:	78fb      	ldrb	r3, [r7, #3]
 80211ba:	2101      	movs	r1, #1
 80211bc:	fa01 f303 	lsl.w	r3, r1, r3
 80211c0:	431a      	orrs	r2, r3
 80211c2:	687b      	ldr	r3, [r7, #4]
 80211c4:	675a      	str	r2, [r3, #116]	; 0x74
}
 80211c6:	bf00      	nop
 80211c8:	370c      	adds	r7, #12
 80211ca:	46bd      	mov	sp, r7
 80211cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80211d0:	4770      	bx	lr
	...

080211d4 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init>:
 * - Correct hall event,
 * - Wrong hall event,
 * - Multi-channel pattern shadow transfer event
 */
void Motor0_BLDC_SCALAR_POSIF_3Hall_Init()
{
 80211d4:	b580      	push	{r7, lr}
 80211d6:	af00      	add	r7, sp, #0
  XMC_POSIF_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_GLOBAL_Config);
 80211d8:	4914      	ldr	r1, [pc, #80]	; (802122c <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x58>)
 80211da:	4815      	ldr	r0, [pc, #84]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211dc:	f007 f92c 	bl	8028438 <XMC_POSIF_Init>
  XMC_POSIF_MCM_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_MCM_Config);
 80211e0:	4914      	ldr	r1, [pc, #80]	; (8021234 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x60>)
 80211e2:	4813      	ldr	r0, [pc, #76]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211e4:	f007 f95a 	bl	802849c <XMC_POSIF_MCM_Init>
  XMC_POSIF_HSC_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_HALL_Config);
 80211e8:	4913      	ldr	r1, [pc, #76]	; (8021238 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x64>)
 80211ea:	4811      	ldr	r0, [pc, #68]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211ec:	f007 f937 	bl	802845e <XMC_POSIF_HSC_Init>

  /*Bind interrupt node*/
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_CHE,
 80211f0:	2200      	movs	r2, #0
 80211f2:	2100      	movs	r1, #0
 80211f4:	480e      	ldr	r0, [pc, #56]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211f6:	f007 f970 	bl	80284da <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_HALL_SR);
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_WHE,
 80211fa:	2200      	movs	r2, #0
 80211fc:	2101      	movs	r1, #1
 80211fe:	480c      	ldr	r0, [pc, #48]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021200:	f007 f96b 	bl	80284da <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_HALL_SR);
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_MCP_SHADOW_TRANSFER,
 8021204:	2201      	movs	r2, #1
 8021206:	2104      	movs	r1, #4
 8021208:	4809      	ldr	r0, [pc, #36]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 802120a:	f007 f966 	bl	80284da <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_MCP_SR);

  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_CHE);
 802120e:	2100      	movs	r1, #0
 8021210:	4807      	ldr	r0, [pc, #28]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021212:	f7ff ffc9 	bl	80211a8 <XMC_POSIF_EnableEvent>
  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_WHE);
 8021216:	2101      	movs	r1, #1
 8021218:	4805      	ldr	r0, [pc, #20]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 802121a:	f7ff ffc5 	bl	80211a8 <XMC_POSIF_EnableEvent>
  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_MCP_SHADOW_TRANSFER);
 802121e:	2104      	movs	r1, #4
 8021220:	4803      	ldr	r0, [pc, #12]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021222:	f7ff ffc1 	bl	80211a8 <XMC_POSIF_EnableEvent>
}
 8021226:	bf00      	nop
 8021228:	bd80      	pop	{r7, pc}
 802122a:	bf00      	nop
 802122c:	0802b1ec 	.word	0x0802b1ec
 8021230:	40028000 	.word	0x40028000
 8021234:	0802b1f0 	.word	0x0802b1f0
 8021238:	0802b1e8 	.word	0x0802b1e8

0802123c <XMC_VADC_GROUP_QueueSetGatingMode>:
{
 802123c:	b480      	push	{r7}
 802123e:	b083      	sub	sp, #12
 8021240:	af00      	add	r7, sp, #0
 8021242:	6078      	str	r0, [r7, #4]
 8021244:	460b      	mov	r3, r1
 8021246:	70fb      	strb	r3, [r7, #3]
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8021248:	687b      	ldr	r3, [r7, #4]
 802124a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 802124e:	f023 0203 	bic.w	r2, r3, #3
 8021252:	687b      	ldr	r3, [r7, #4]
 8021254:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 8021258:	687b      	ldr	r3, [r7, #4]
 802125a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 802125e:	78fb      	ldrb	r3, [r7, #3]
 8021260:	431a      	orrs	r2, r3
 8021262:	687b      	ldr	r3, [r7, #4]
 8021264:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 8021268:	bf00      	nop
 802126a:	370c      	adds	r7, #12
 802126c:	46bd      	mov	sp, r7
 802126e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021272:	4770      	bx	lr

08021274 <XMC_VADC_GROUP_QueueFlushEntries>:
{
 8021274:	b480      	push	{r7}
 8021276:	b083      	sub	sp, #12
 8021278:	af00      	add	r7, sp, #0
 802127a:	6078      	str	r0, [r7, #4]
  group_ptr->QMR0 |= (uint32_t)VADC_G_QMR0_FLUSH_Msk;
 802127c:	687b      	ldr	r3, [r7, #4]
 802127e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021282:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8021286:	687b      	ldr	r3, [r7, #4]
 8021288:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  while ( !((group_ptr->QSR0) & (uint32_t)VADC_G_QSR0_EMPTY_Msk))
 802128c:	bf00      	nop
 802128e:	687b      	ldr	r3, [r7, #4]
 8021290:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8021294:	f003 0320 	and.w	r3, r3, #32
 8021298:	2b00      	cmp	r3, #0
 802129a:	d0f8      	beq.n	802128e <XMC_VADC_GROUP_QueueFlushEntries+0x1a>
}
 802129c:	bf00      	nop
 802129e:	bf00      	nop
 80212a0:	370c      	adds	r7, #12
 80212a2:	46bd      	mov	sp, r7
 80212a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80212a8:	4770      	bx	lr
	...

080212ac <Motor0_BLDC_SCALAR_VADC_Init>:
 * \par<b>Description:</b><br>
 * Initializes VADC peripheral and power on the required VADC Group and Queues.
 * Only required converters will be turned on to optimize power consumption.
 */
void Motor0_BLDC_SCALAR_VADC_Init(void)
{
 80212ac:	b580      	push	{r7, lr}
 80212ae:	af00      	add	r7, sp, #0
  /* Initialize an instance of VADC Global hardware */
  XMC_VADC_GLOBAL_Init(VADC, &Motor0_BLDC_SCALAR_VADC_GLOBAL_config);
 80212b0:	490e      	ldr	r1, [pc, #56]	; (80212ec <Motor0_BLDC_SCALAR_VADC_Init+0x40>)
 80212b2:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 80212b6:	f007 f9bb 	bl	8028630 <XMC_VADC_GLOBAL_Init>
  /* Switch on the converter of the Group[2]*/
  XMC_VADC_GROUP_SetPowerMode(VADC_G2,XMC_VADC_GROUP_POWERMODE_NORMAL);
  #endif
  #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U)
  /* Switch on the converter of the Group[3]*/
  XMC_VADC_GROUP_SetPowerMode(VADC_G3,XMC_VADC_GROUP_POWERMODE_NORMAL);
 80212ba:	2103      	movs	r1, #3
 80212bc:	480c      	ldr	r0, [pc, #48]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212be:	f007 faf1 	bl	80288a4 <XMC_VADC_GROUP_SetPowerMode>
  XMC_VADC_GROUP_QueueFlushEntries(VADC_G2);
  #endif  /* end of #if(VADC_ENABLE_GROUP_QUEUE_2 == 1U) */

  #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U)
  /* Program the input classes for Group[3] */
  XMC_VADC_GROUP_InputClassInit(VADC_G3,Motor0_BLDC_SCALAR_VADC_GROUP_class0,XMC_VADC_GROUP_CONV_STD,0U);
 80212c2:	490c      	ldr	r1, [pc, #48]	; (80212f4 <Motor0_BLDC_SCALAR_VADC_Init+0x48>)
 80212c4:	2300      	movs	r3, #0
 80212c6:	2200      	movs	r2, #0
 80212c8:	6809      	ldr	r1, [r1, #0]
 80212ca:	4809      	ldr	r0, [pc, #36]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212cc:	f007 fa8d 	bl	80287ea <XMC_VADC_GROUP_InputClassInit>
  /* Initialize the Queue3 */
  XMC_VADC_GROUP_QueueInit(VADC_G3,&Motor0_BLDC_SCALAR_VADC_QUEUE_3_cfg);
 80212d0:	4909      	ldr	r1, [pc, #36]	; (80212f8 <Motor0_BLDC_SCALAR_VADC_Init+0x4c>)
 80212d2:	4807      	ldr	r0, [pc, #28]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212d4:	f007 fbac 	bl	8028a30 <XMC_VADC_GROUP_QueueInit>
  /* Configure the gating mode for queue3 */
  XMC_VADC_GROUP_QueueSetGatingMode(VADC_G3, (XMC_VADC_GATEMODE_t)MOTOR0_BLDC_SCALAR_VADC_QUEUE_3_GATING);
 80212d8:	2101      	movs	r1, #1
 80212da:	4805      	ldr	r0, [pc, #20]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212dc:	f7ff ffae 	bl	802123c <XMC_VADC_GROUP_QueueSetGatingMode>
  /* Flush any entries that are currently in the queue3 buffer */
  XMC_VADC_GROUP_QueueFlushEntries(VADC_G3);
 80212e0:	4803      	ldr	r0, [pc, #12]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212e2:	f7ff ffc7 	bl	8021274 <XMC_VADC_GROUP_QueueFlushEntries>
  #endif  /* end of #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U) */
}
 80212e6:	bf00      	nop
 80212e8:	bd80      	pop	{r7, pc}
 80212ea:	bf00      	nop
 80212ec:	0802b1f4 	.word	0x0802b1f4
 80212f0:	40005000 	.word	0x40005000
 80212f4:	0802b20c 	.word	0x0802b20c
 80212f8:	0802b210 	.word	0x0802b210

080212fc <XMC_CCU8_EnableShadowTransfer>:
{
 80212fc:	b480      	push	{r7}
 80212fe:	b083      	sub	sp, #12
 8021300:	af00      	add	r7, sp, #0
 8021302:	6078      	str	r0, [r7, #4]
 8021304:	6039      	str	r1, [r7, #0]
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8021306:	687b      	ldr	r3, [r7, #4]
 8021308:	683a      	ldr	r2, [r7, #0]
 802130a:	611a      	str	r2, [r3, #16]
}
 802130c:	bf00      	nop
 802130e:	370c      	adds	r7, #12
 8021310:	46bd      	mov	sp, r7
 8021312:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021316:	4770      	bx	lr

08021318 <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021318:	b480      	push	{r7}
 802131a:	b083      	sub	sp, #12
 802131c:	af00      	add	r7, sp, #0
 802131e:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021320:	687b      	ldr	r3, [r7, #4]
 8021322:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021326:	b2db      	uxtb	r3, r3
 8021328:	115b      	asrs	r3, r3, #5
 802132a:	b2db      	uxtb	r3, r3
 802132c:	f003 0307 	and.w	r3, r3, #7
 8021330:	b2db      	uxtb	r3, r3
}
 8021332:	4618      	mov	r0, r3
 8021334:	370c      	adds	r7, #12
 8021336:	46bd      	mov	sp, r7
 8021338:	f85d 7b04 	ldr.w	r7, [sp], #4
 802133c:	4770      	bx	lr

0802133e <XMC_VADC_GROUP_GetResult>:
{
 802133e:	b480      	push	{r7}
 8021340:	b083      	sub	sp, #12
 8021342:	af00      	add	r7, sp, #0
 8021344:	6078      	str	r0, [r7, #4]
 8021346:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8021348:	687b      	ldr	r3, [r7, #4]
 802134a:	683a      	ldr	r2, [r7, #0]
 802134c:	32c0      	adds	r2, #192	; 0xc0
 802134e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8021352:	b29b      	uxth	r3, r3
}
 8021354:	4618      	mov	r0, r3
 8021356:	370c      	adds	r7, #12
 8021358:	46bd      	mov	sp, r7
 802135a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802135e:	4770      	bx	lr

08021360 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate>:
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate
(
  uint16_t dutycycle
)
{
 8021360:	b580      	push	{r7, lr}
 8021362:	b084      	sub	sp, #16
 8021364:	af00      	add	r7, sp, #0
 8021366:	4603      	mov	r3, r0
 8021368:	80fb      	strh	r3, [r7, #6]
  uint16_t duty = (dutycycle * Motor0_BLDC_SCALAR_PWM_BC.amplitude_scale) >> BLDC_SCALAR_PWM_BC_SHIFT_14;
 802136a:	88fb      	ldrh	r3, [r7, #6]
 802136c:	4a1a      	ldr	r2, [pc, #104]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802136e:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 8021370:	fb02 f303 	mul.w	r3, r2, r3
 8021374:	139b      	asrs	r3, r3, #14
 8021376:	81fb      	strh	r3, [r7, #14]
  /* Update compare value for inverted switch*/
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[3] = Motor0_BLDC_SCALAR_PWM_BC.ccu8_handle_ptr->period - duty;
 8021378:	4b17      	ldr	r3, [pc, #92]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802137a:	681b      	ldr	r3, [r3, #0]
 802137c:	8a5a      	ldrh	r2, [r3, #18]
 802137e:	89fb      	ldrh	r3, [r7, #14]
 8021380:	1ad3      	subs	r3, r2, r3
 8021382:	b29a      	uxth	r2, r3
 8021384:	4b14      	ldr	r3, [pc, #80]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021386:	849a      	strh	r2, [r3, #36]	; 0x24
  /* Update compare value for direct switch */
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[2] = duty;
 8021388:	4a13      	ldr	r2, [pc, #76]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802138a:	89fb      	ldrh	r3, [r7, #14]
 802138c:	8453      	strh	r3, [r2, #34]	; 0x22

  /*Load the duty cycle to the channel compare shadow register*/
  (MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[0U]];
 802138e:	4b12      	ldr	r3, [pc, #72]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021390:	7b9b      	ldrb	r3, [r3, #14]
 8021392:	4a11      	ldr	r2, [pc, #68]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021394:	330c      	adds	r3, #12
 8021396:	005b      	lsls	r3, r3, #1
 8021398:	4413      	add	r3, r2
 802139a:	88da      	ldrh	r2, [r3, #6]
 802139c:	4b0f      	ldr	r3, [pc, #60]	; (80213dc <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x7c>)
 802139e:	63da      	str	r2, [r3, #60]	; 0x3c
  (MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[1U]];
 80213a0:	4b0d      	ldr	r3, [pc, #52]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213a2:	7bdb      	ldrb	r3, [r3, #15]
 80213a4:	4a0c      	ldr	r2, [pc, #48]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213a6:	330c      	adds	r3, #12
 80213a8:	005b      	lsls	r3, r3, #1
 80213aa:	4413      	add	r3, r2
 80213ac:	88da      	ldrh	r2, [r3, #6]
 80213ae:	4b0c      	ldr	r3, [pc, #48]	; (80213e0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x80>)
 80213b0:	63da      	str	r2, [r3, #60]	; 0x3c
  (MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[2U]];
 80213b2:	4b09      	ldr	r3, [pc, #36]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213b4:	7c1b      	ldrb	r3, [r3, #16]
 80213b6:	4a08      	ldr	r2, [pc, #32]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213b8:	330c      	adds	r3, #12
 80213ba:	005b      	lsls	r3, r3, #1
 80213bc:	4413      	add	r3, r2
 80213be:	88da      	ldrh	r2, [r3, #6]
 80213c0:	4b08      	ldr	r3, [pc, #32]	; (80213e4 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x84>)
 80213c2:	63da      	str	r2, [r3, #60]	; 0x3c

  /*Enable the shadow transfer*/
  XMC_CCU8_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU8_MODULE, MOTOR0_BLDC_SCALAR_CCU8_SHADOW_TRANSFER);
 80213c4:	f240 1111 	movw	r1, #273	; 0x111
 80213c8:	4807      	ldr	r0, [pc, #28]	; (80213e8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x88>)
 80213ca:	f7ff ff97 	bl	80212fc <XMC_CCU8_EnableShadowTransfer>
}
 80213ce:	bf00      	nop
 80213d0:	3710      	adds	r7, #16
 80213d2:	46bd      	mov	sp, r7
 80213d4:	bd80      	pop	{r7, pc}
 80213d6:	bf00      	nop
 80213d8:	200000d0 	.word	0x200000d0
 80213dc:	40020300 	.word	0x40020300
 80213e0:	40020200 	.word	0x40020200
 80213e4:	40020100 	.word	0x40020100
 80213e8:	40020000 	.word	0x40020000

080213ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
 *
 * \par<b>Description:</b><br>
 * Resets variables related to speed calculation.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter(void)
{
 80213ec:	b480      	push	{r7}
 80213ee:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 80213f0:	4b12      	ldr	r3, [pc, #72]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213f2:	2200      	movs	r2, #0
 80213f4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 80213f8:	4b10      	ldr	r3, [pc, #64]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213fa:	2200      	movs	r2, #0
 80213fc:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 80213fe:	4b0f      	ldr	r3, [pc, #60]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021400:	2200      	movs	r2, #0
 8021402:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 8021404:	4b0d      	ldr	r3, [pc, #52]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021406:	2200      	movs	r2, #0
 8021408:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 802140a:	4b0c      	ldr	r3, [pc, #48]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802140c:	2200      	movs	r2, #0
 802140e:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 8021410:	4b0a      	ldr	r3, [pc, #40]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021412:	2200      	movs	r2, #0
 8021414:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 8021416:	4b09      	ldr	r3, [pc, #36]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021418:	2200      	movs	r2, #0
 802141a:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 802141c:	4b07      	ldr	r3, [pc, #28]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802141e:	2200      	movs	r2, #0
 8021420:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 8021422:	4b06      	ldr	r3, [pc, #24]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021424:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021426:	4a05      	ldr	r2, [pc, #20]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021428:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 802142a:	4b04      	ldr	r3, [pc, #16]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802142c:	2200      	movs	r2, #0
 802142e:	621a      	str	r2, [r3, #32]
}
 8021430:	bf00      	nop
 8021432:	46bd      	mov	sp, r7
 8021434:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021438:	4770      	bx	lr
 802143a:	bf00      	nop
 802143c:	200000f8 	.word	0x200000f8

08021440 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
 *
 * \par<b>Description</b><br>
 * Returns last sampled hall sensor pattern of \a peripheral.\n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern(void)
{
 8021440:	b580      	push	{r7, lr}
 8021442:	b082      	sub	sp, #8
 8021444:	af00      	add	r7, sp, #0
  uint8_t hall_pattern;
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021446:	4805      	ldr	r0, [pc, #20]	; (802145c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 8021448:	f7ff ff66 	bl	8021318 <XMC_POSIF_HSC_GetLastSampledPattern>
 802144c:	4603      	mov	r3, r0
 802144e:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 8021450:	79fb      	ldrb	r3, [r7, #7]
}
 8021452:	4618      	mov	r0, r3
 8021454:	3708      	adds	r7, #8
 8021456:	46bd      	mov	sp, r7
 8021458:	bd80      	pop	{r7, pc}
 802145a:	bf00      	nop
 802145c:	40028000 	.word	0x40028000

08021460 <VADC_GetResult>:
 *
 * \par<b>Description:</b><br>
 * Returns the VADC conversion result by reading result register from selected group number.
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t VADC_GetResult(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg)
{
 8021460:	b580      	push	{r7, lr}
 8021462:	b084      	sub	sp, #16
 8021464:	af00      	add	r7, sp, #0
 8021466:	6078      	str	r0, [r7, #4]
 8021468:	6039      	str	r1, [r7, #0]
  XMC_VADC_RESULT_SIZE_t result;
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 802146a:	6839      	ldr	r1, [r7, #0]
 802146c:	6878      	ldr	r0, [r7, #4]
 802146e:	f7ff ff66 	bl	802133e <XMC_VADC_GROUP_GetResult>
 8021472:	4603      	mov	r3, r0
 8021474:	81fb      	strh	r3, [r7, #14]
  return(result);
 8021476:	89fb      	ldrh	r3, [r7, #14]
}
 8021478:	4618      	mov	r0, r3
 802147a:	3710      	adds	r7, #16
 802147c:	46bd      	mov	sp, r7
 802147e:	bd80      	pop	{r7, pc}

08021480 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>:
 *
 * \par<b>Description:</b><br>
 * Limits the input value based on higher_limit and lower_limit
 */
__STATIC_INLINE int32_t Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(int32_t input_val, int32_t higher_limit, int32_t lower_limit)
{
 8021480:	b480      	push	{r7}
 8021482:	b087      	sub	sp, #28
 8021484:	af00      	add	r7, sp, #0
 8021486:	60f8      	str	r0, [r7, #12]
 8021488:	60b9      	str	r1, [r7, #8]
 802148a:	607a      	str	r2, [r7, #4]
  int32_t return_val;
  if ( input_val > higher_limit )
 802148c:	68fa      	ldr	r2, [r7, #12]
 802148e:	68bb      	ldr	r3, [r7, #8]
 8021490:	429a      	cmp	r2, r3
 8021492:	dd02      	ble.n	802149a <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x1a>
  {
    return_val = higher_limit;
 8021494:	68bb      	ldr	r3, [r7, #8]
 8021496:	617b      	str	r3, [r7, #20]
 8021498:	e008      	b.n	80214ac <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  }
  else if ( input_val < lower_limit )
 802149a:	68fa      	ldr	r2, [r7, #12]
 802149c:	687b      	ldr	r3, [r7, #4]
 802149e:	429a      	cmp	r2, r3
 80214a0:	da02      	bge.n	80214a8 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x28>
  {
    return_val = lower_limit;
 80214a2:	687b      	ldr	r3, [r7, #4]
 80214a4:	617b      	str	r3, [r7, #20]
 80214a6:	e001      	b.n	80214ac <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  }
  else
  {
    return_val = input_val;
 80214a8:	68fb      	ldr	r3, [r7, #12]
 80214aa:	617b      	str	r3, [r7, #20]
  }
  return return_val;
 80214ac:	697b      	ldr	r3, [r7, #20]
}
 80214ae:	4618      	mov	r0, r3
 80214b0:	371c      	adds	r7, #28
 80214b2:	46bd      	mov	sp, r7
 80214b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80214b8:	4770      	bx	lr

080214ba <Motor0_BLDC_SCALAR_PT1_Filter>:
  * Yn[3,2,1,0] =Yn-1[3,2,1,0] +Z1*(Xn -Yn-1[3,2]) \n
  * Where Z1 is time constant.
  */

__STATIC_INLINE void Motor0_BLDC_SCALAR_PT1_Filter(BLDC_SCALAR_PT1_FILTER_t *handle_ptr, int32_t actual_val)
{
 80214ba:	b590      	push	{r4, r7, lr}
 80214bc:	b083      	sub	sp, #12
 80214be:	af00      	add	r7, sp, #0
 80214c0:	6078      	str	r0, [r7, #4]
 80214c2:	6039      	str	r1, [r7, #0]
  register int32_t temp_buff;

  /* yn+1 = yn + z1*(x - yn) */
  temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16)));
 80214c4:	687b      	ldr	r3, [r7, #4]
 80214c6:	691a      	ldr	r2, [r3, #16]
 80214c8:	687b      	ldr	r3, [r7, #4]
 80214ca:	681b      	ldr	r3, [r3, #0]
 80214cc:	6879      	ldr	r1, [r7, #4]
 80214ce:	6909      	ldr	r1, [r1, #16]
 80214d0:	1409      	asrs	r1, r1, #16
 80214d2:	6838      	ldr	r0, [r7, #0]
 80214d4:	1a41      	subs	r1, r0, r1
 80214d6:	fb01 f303 	mul.w	r3, r1, r3
 80214da:	18d4      	adds	r4, r2, r3
  /* Checking the buffer limits in the range of Ymin to Ymax */
  handle_ptr->pt1_buf = Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(temp_buff, handle_ptr->y_max, handle_ptr->y_min);
 80214dc:	687b      	ldr	r3, [r7, #4]
 80214de:	6899      	ldr	r1, [r3, #8]
 80214e0:	687b      	ldr	r3, [r7, #4]
 80214e2:	68db      	ldr	r3, [r3, #12]
 80214e4:	461a      	mov	r2, r3
 80214e6:	4620      	mov	r0, r4
 80214e8:	f7ff ffca 	bl	8021480 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>
 80214ec:	4602      	mov	r2, r0
 80214ee:	687b      	ldr	r3, [r7, #4]
 80214f0:	611a      	str	r2, [r3, #16]
  handle_ptr->pt1_out_val = (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16);
 80214f2:	687b      	ldr	r3, [r7, #4]
 80214f4:	691b      	ldr	r3, [r3, #16]
 80214f6:	141a      	asrs	r2, r3, #16
 80214f8:	687b      	ldr	r3, [r7, #4]
 80214fa:	615a      	str	r2, [r3, #20]
}
 80214fc:	bf00      	nop
 80214fe:	370c      	adds	r7, #12
 8021500:	46bd      	mov	sp, r7
 8021502:	bd90      	pop	{r4, r7, pc}

08021504 <Motor0_BLDC_SCALAR_GetCurrentValue>:
 * without PT1 filter:                                    <b>0.78 uSec </b>\n
 * with PT1 filter:                                       <b>1.46 uSec </b>\n
 * with filter and with demagnetization blanking enabled: <b>1.6 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetCurrentValue(int32_t *dclink_current)
{
 8021504:	b580      	push	{r7, lr}
 8021506:	b084      	sub	sp, #16
 8021508:	af00      	add	r7, sp, #0
 802150a:	6078      	str	r0, [r7, #4]
  int32_t current_value;
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 802150c:	2105      	movs	r1, #5
 802150e:	4821      	ldr	r0, [pc, #132]	; (8021594 <Motor0_BLDC_SCALAR_GetCurrentValue+0x90>)
 8021510:	f7ff ffa6 	bl	8021460 <VADC_GetResult>
 8021514:	4603      	mov	r3, r0
 8021516:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 8021518:	4b1f      	ldr	r3, [pc, #124]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802151a:	681b      	ldr	r3, [r3, #0]
 802151c:	68fa      	ldr	r2, [r7, #12]
 802151e:	1ad3      	subs	r3, r2, r3
 8021520:	4a1d      	ldr	r2, [pc, #116]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021522:	6892      	ldr	r2, [r2, #8]
 8021524:	fb02 f303 	mul.w	r3, r2, r3
 8021528:	139b      	asrs	r3, r3, #14
 802152a:	60fb      	str	r3, [r7, #12]

  #if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_LINK_CURRENT_FILTER == 1U)
  /* PT1 filter   */
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_DirectCurrent,(int32_t)current_value);
 802152c:	68f9      	ldr	r1, [r7, #12]
 802152e:	481b      	ldr	r0, [pc, #108]	; (802159c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021530:	f7ff ffc3 	bl	80214ba <Motor0_BLDC_SCALAR_PT1_Filter>
  current_value = ((Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_out_val));
 8021534:	4b19      	ldr	r3, [pc, #100]	; (802159c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021536:	695b      	ldr	r3, [r3, #20]
 8021538:	60fb      	str	r3, [r7, #12]
  /*
   * Skip the direct DC link current measurement at commutation point based on de-magnetization count
   * This is required only if the SW filter is disabled
   */
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable == 1U)
 802153a:	4b17      	ldr	r3, [pc, #92]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802153c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8021540:	2b01      	cmp	r3, #1
 8021542:	d11c      	bne.n	802157e <Motor0_BLDC_SCALAR_GetCurrentValue+0x7a>
  {
    Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter++;
 8021544:	4b14      	ldr	r3, [pc, #80]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021546:	69db      	ldr	r3, [r3, #28]
 8021548:	3301      	adds	r3, #1
 802154a:	4a13      	ldr	r2, [pc, #76]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802154c:	61d3      	str	r3, [r2, #28]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 802154e:	4b12      	ldr	r3, [pc, #72]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021550:	69da      	ldr	r2, [r3, #28]
        Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_count)
 8021552:	4b11      	ldr	r3, [pc, #68]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021554:	699b      	ldr	r3, [r3, #24]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021556:	429a      	cmp	r2, r3
 8021558:	d90c      	bls.n	8021574 <Motor0_BLDC_SCALAR_GetCurrentValue+0x70>
    {
      /* De-magnetization blanking time over. Read current and reset the De-magnetization counter */
     *dclink_current = current_value;
 802155a:	687b      	ldr	r3, [r7, #4]
 802155c:	68fa      	ldr	r2, [r7, #12]
 802155e:	601a      	str	r2, [r3, #0]
     Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current = current_value;
 8021560:	4a0d      	ldr	r2, [pc, #52]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021562:	68fb      	ldr	r3, [r7, #12]
 8021564:	6113      	str	r3, [r2, #16]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 8021566:	4b0c      	ldr	r3, [pc, #48]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021568:	2200      	movs	r2, #0
 802156a:	61da      	str	r2, [r3, #28]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 0U;
 802156c:	4b0a      	ldr	r3, [pc, #40]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802156e:	2200      	movs	r2, #0
 8021570:	f883 2020 	strb.w	r2, [r3, #32]
    }
    *dclink_current = Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current;
 8021574:	4b08      	ldr	r3, [pc, #32]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021576:	691a      	ldr	r2, [r3, #16]
 8021578:	687b      	ldr	r3, [r7, #4]
 802157a:	601a      	str	r2, [r3, #0]
    *dclink_current = current_value;
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  }
#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
}
 802157c:	e005      	b.n	802158a <Motor0_BLDC_SCALAR_GetCurrentValue+0x86>
    *dclink_current = current_value;
 802157e:	687b      	ldr	r3, [r7, #4]
 8021580:	68fa      	ldr	r2, [r7, #12]
 8021582:	601a      	str	r2, [r3, #0]
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
 8021584:	4a04      	ldr	r2, [pc, #16]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021586:	68fb      	ldr	r3, [r7, #12]
 8021588:	6113      	str	r3, [r2, #16]
}
 802158a:	bf00      	nop
 802158c:	3710      	adds	r7, #16
 802158e:	46bd      	mov	sp, r7
 8021590:	bd80      	pop	{r7, pc}
 8021592:	bf00      	nop
 8021594:	40005000 	.word	0x40005000
 8021598:	20000124 	.word	0x20000124
 802159c:	200000a4 	.word	0x200000a4

080215a0 <Motor0_BLDC_SCALAR_GetAverageCurrentValue>:
 * without PT1 filter: <b>0.588 uSec </b> \n
 * with PT1 filter: <b>1.380 uSec </b>\n
 * with filter and with MOTOR0_BLDC_SCALAR_VADC_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK enabled: <b>1.508 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetAverageCurrentValue(int32_t *dclink_average_current)
{
 80215a0:	b580      	push	{r7, lr}
 80215a2:	b084      	sub	sp, #16
 80215a4:	af00      	add	r7, sp, #0
 80215a6:	6078      	str	r0, [r7, #4]
  /* Average current pin */
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_AVERAGE_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_AVERAGE_RES_REG_NUM);
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.avg_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
#else
  /* Average current calculated from DC link current pin */
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 80215a8:	2105      	movs	r1, #5
 80215aa:	480f      	ldr	r0, [pc, #60]	; (80215e8 <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x48>)
 80215ac:	f7ff ff58 	bl	8021460 <VADC_GetResult>
 80215b0:	4603      	mov	r3, r0
 80215b2:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 80215b4:	4b0d      	ldr	r3, [pc, #52]	; (80215ec <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215b6:	681b      	ldr	r3, [r3, #0]
 80215b8:	68fa      	ldr	r2, [r7, #12]
 80215ba:	1ad3      	subs	r3, r2, r3
 80215bc:	4a0b      	ldr	r2, [pc, #44]	; (80215ec <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215be:	6892      	ldr	r2, [r2, #8]
 80215c0:	fb02 f303 	mul.w	r3, r2, r3
 80215c4:	139b      	asrs	r3, r3, #14
 80215c6:	60fb      	str	r3, [r7, #12]
  current_value = (current_value * ((int32_t)*Motor0_BLDC_SCALAR_CurrentMeasurement.amplitude)) >> BLDC_SCALAR_SHIFT_14;
 80215c8:	4b08      	ldr	r3, [pc, #32]	; (80215ec <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215ca:	695b      	ldr	r3, [r3, #20]
 80215cc:	681b      	ldr	r3, [r3, #0]
 80215ce:	461a      	mov	r2, r3
 80215d0:	68fb      	ldr	r3, [r7, #12]
 80215d2:	fb02 f303 	mul.w	r3, r2, r3
 80215d6:	139b      	asrs	r3, r3, #14
 80215d8:	60fb      	str	r3, [r7, #12]
#if (MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U)
  /* PT1 filter is used to remove high frequency noise of average DC link current */
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_AverageCurrent,(int32_t)current_value);
  *dclink_average_current = ((Motor0_BLDC_SCALAR_PT1_AverageCurrent.pt1_out_val));
#else
  *dclink_average_current = current_value;
 80215da:	687b      	ldr	r3, [r7, #4]
 80215dc:	68fa      	ldr	r2, [r7, #12]
 80215de:	601a      	str	r2, [r3, #0]
#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U) */
}
 80215e0:	bf00      	nop
 80215e2:	3710      	adds	r7, #16
 80215e4:	46bd      	mov	sp, r7
 80215e6:	bd80      	pop	{r7, pc}
 80215e8:	40005000 	.word	0x40005000
 80215ec:	20000124 	.word	0x20000124

080215f0 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT>:
 *
 * \par<b>Description:</b><br>
 * Limits the input value based on higher_limit and lower_limit
 */
__STATIC_INLINE int32_t Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT(int32_t input_val, int32_t higher_limit, int32_t lower_limit)
{
 80215f0:	b480      	push	{r7}
 80215f2:	b087      	sub	sp, #28
 80215f4:	af00      	add	r7, sp, #0
 80215f6:	60f8      	str	r0, [r7, #12]
 80215f8:	60b9      	str	r1, [r7, #8]
 80215fa:	607a      	str	r2, [r7, #4]
  int32_t return_val;
  if ( input_val > higher_limit )
 80215fc:	68fa      	ldr	r2, [r7, #12]
 80215fe:	68bb      	ldr	r3, [r7, #8]
 8021600:	429a      	cmp	r2, r3
 8021602:	dd02      	ble.n	802160a <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x1a>
  {
    return_val = higher_limit;
 8021604:	68bb      	ldr	r3, [r7, #8]
 8021606:	617b      	str	r3, [r7, #20]
 8021608:	e008      	b.n	802161c <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x2c>
  }
  else if ( input_val < lower_limit )
 802160a:	68fa      	ldr	r2, [r7, #12]
 802160c:	687b      	ldr	r3, [r7, #4]
 802160e:	429a      	cmp	r2, r3
 8021610:	da02      	bge.n	8021618 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x28>
  {
    return_val = lower_limit;
 8021612:	687b      	ldr	r3, [r7, #4]
 8021614:	617b      	str	r3, [r7, #20]
 8021616:	e001      	b.n	802161c <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x2c>
  }
  else
  {
    return_val = input_val;
 8021618:	68fb      	ldr	r3, [r7, #12]
 802161a:	617b      	str	r3, [r7, #20]
  }
  return return_val;
 802161c:	697b      	ldr	r3, [r7, #20]
}
 802161e:	4618      	mov	r0, r3
 8021620:	371c      	adds	r7, #28
 8021622:	46bd      	mov	sp, r7
 8021624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021628:	4770      	bx	lr

0802162a <Motor0_BLDC_SCALAR_PI_SAT_STATE>:
 *
 * \par<b>Description:</b><br>
 * Checks if PI saturation flag is set
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_PI_SAT_STATE(int32_t input1, int32_t input2)
{
 802162a:	b480      	push	{r7}
 802162c:	b085      	sub	sp, #20
 802162e:	af00      	add	r7, sp, #0
 8021630:	6078      	str	r0, [r7, #4]
 8021632:	6039      	str	r1, [r7, #0]
  uint8_t return_val;
  if (input1 == input2)
 8021634:	687a      	ldr	r2, [r7, #4]
 8021636:	683b      	ldr	r3, [r7, #0]
 8021638:	429a      	cmp	r2, r3
 802163a:	d102      	bne.n	8021642 <Motor0_BLDC_SCALAR_PI_SAT_STATE+0x18>
  {
    return_val = 1U;
 802163c:	2301      	movs	r3, #1
 802163e:	73fb      	strb	r3, [r7, #15]
 8021640:	e001      	b.n	8021646 <Motor0_BLDC_SCALAR_PI_SAT_STATE+0x1c>
  }
  else
  {
    return_val = 0U;
 8021642:	2300      	movs	r3, #0
 8021644:	73fb      	strb	r3, [r7, #15]
  }
  return (return_val);
 8021646:	7bfb      	ldrb	r3, [r7, #15]
}
 8021648:	4618      	mov	r0, r3
 802164a:	3714      	adds	r7, #20
 802164c:	46bd      	mov	sp, r7
 802164e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021652:	4770      	bx	lr

08021654 <Motor0_BLDC_SCALAR_PI_Controller>:
__STATIC_INLINE void Motor0_BLDC_SCALAR_PI_Controller
(
    BLDC_SCALAR_PI_CONTROLLER_t *handle_ptr,
    int32_t error_val
)
{
 8021654:	b590      	push	{r4, r7, lr}
 8021656:	b083      	sub	sp, #12
 8021658:	af00      	add	r7, sp, #0
 802165a:	6078      	str	r0, [r7, #4]
 802165c:	6039      	str	r1, [r7, #0]
  register int32_t u_k;
  register int32_t error = error_val;
 802165e:	683c      	ldr	r4, [r7, #0]

  handle_ptr->ik = (int32_t)(error * (int32_t)handle_ptr->ki * (int32_t)handle_ptr->sat_state) + handle_ptr->ik;              /*Integral output I[k] = I[k-1] + Ki * error[k] */
 8021660:	687b      	ldr	r3, [r7, #4]
 8021662:	8a5b      	ldrh	r3, [r3, #18]
 8021664:	fb04 f303 	mul.w	r3, r4, r3
 8021668:	687a      	ldr	r2, [r7, #4]
 802166a:	7d52      	ldrb	r2, [r2, #21]
 802166c:	fb03 f202 	mul.w	r2, r3, r2
 8021670:	687b      	ldr	r3, [r7, #4]
 8021672:	685b      	ldr	r3, [r3, #4]
 8021674:	441a      	add	r2, r3
 8021676:	687b      	ldr	r3, [r7, #4]
 8021678:	605a      	str	r2, [r3, #4]
  u_k = (( error * (int32_t)handle_ptr->kp) + handle_ptr->ik) >> handle_ptr->scale_kpki;         /*PI output U[k] = Kp * error[k] + I[k]. */
 802167a:	687b      	ldr	r3, [r7, #4]
 802167c:	8a1b      	ldrh	r3, [r3, #16]
 802167e:	fb03 f204 	mul.w	r2, r3, r4
 8021682:	687b      	ldr	r3, [r7, #4]
 8021684:	685b      	ldr	r3, [r3, #4]
 8021686:	4413      	add	r3, r2
 8021688:	687a      	ldr	r2, [r7, #4]
 802168a:	7d12      	ldrb	r2, [r2, #20]
 802168c:	fa43 f402 	asr.w	r4, r3, r2
  handle_ptr->uk = Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT(u_k, handle_ptr->uk_limit_max, handle_ptr->uk_limit_min);  /* Check U[k] output limit. Vq = handle_ptr->Uk. */
 8021690:	687b      	ldr	r3, [r7, #4]
 8021692:	68d9      	ldr	r1, [r3, #12]
 8021694:	687b      	ldr	r3, [r7, #4]
 8021696:	689b      	ldr	r3, [r3, #8]
 8021698:	461a      	mov	r2, r3
 802169a:	4620      	mov	r0, r4
 802169c:	f7ff ffa8 	bl	80215f0 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT>
 80216a0:	4602      	mov	r2, r0
 80216a2:	687b      	ldr	r3, [r7, #4]
 80216a4:	601a      	str	r2, [r3, #0]
  handle_ptr->sat_state = (uint8_t)Motor0_BLDC_SCALAR_PI_SAT_STATE(u_k, handle_ptr->uk);                                   /* Update saturation flag */
 80216a6:	687b      	ldr	r3, [r7, #4]
 80216a8:	681b      	ldr	r3, [r3, #0]
 80216aa:	4619      	mov	r1, r3
 80216ac:	4620      	mov	r0, r4
 80216ae:	f7ff ffbc 	bl	802162a <Motor0_BLDC_SCALAR_PI_SAT_STATE>
 80216b2:	4603      	mov	r3, r0
 80216b4:	461a      	mov	r2, r3
 80216b6:	687b      	ldr	r3, [r7, #4]
 80216b8:	755a      	strb	r2, [r3, #21]
}
 80216ba:	bf00      	nop
 80216bc:	370c      	adds	r7, #12
 80216be:	46bd      	mov	sp, r7
 80216c0:	bd90      	pop	{r4, r7, pc}
	...

080216c4 <Motor0_BLDC_SCALAR_SpeedControlScheme>:
 *
 * \par<b>Execution Time:</b><br>
 * <b>1.820 uSec </b>using O3 optimization level
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SpeedControlScheme(int32_t *output)
{
 80216c4:	b580      	push	{r7, lr}
 80216c6:	b084      	sub	sp, #16
 80216c8:	af00      	add	r7, sp, #0
 80216ca:	6078      	str	r0, [r7, #4]
  int32_t error;
  Motor0_BLDC_SCALAR_SpeedControl.fdbk_speed = Motor0_BLDC_SCALAR.motor_speed;
 80216cc:	4b0c      	ldr	r3, [pc, #48]	; (8021700 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x3c>)
 80216ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80216d0:	4a0c      	ldr	r2, [pc, #48]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216d2:	60d3      	str	r3, [r2, #12]
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR_Ramp.set_value;
 80216d4:	4b0c      	ldr	r3, [pc, #48]	; (8021708 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x44>)
 80216d6:	681b      	ldr	r3, [r3, #0]
 80216d8:	4a0a      	ldr	r2, [pc, #40]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216da:	6093      	str	r3, [r2, #8]
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR.analogip_val;
#else
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
#endif

  error = (int32_t)(Motor0_BLDC_SCALAR_SpeedControl.ref_speed) - (int32_t)(Motor0_BLDC_SCALAR_SpeedControl.fdbk_speed);
 80216dc:	4b09      	ldr	r3, [pc, #36]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216de:	689a      	ldr	r2, [r3, #8]
 80216e0:	4b08      	ldr	r3, [pc, #32]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216e2:	68db      	ldr	r3, [r3, #12]
 80216e4:	1ad3      	subs	r3, r2, r3
 80216e6:	60fb      	str	r3, [r7, #12]

  /*Speed Control based on PI technique*/
  Motor0_BLDC_SCALAR_PI_Controller(&Motor0_BLDC_SCALAR_SpeedControl_PI,(int32_t)error);
 80216e8:	68f9      	ldr	r1, [r7, #12]
 80216ea:	4808      	ldr	r0, [pc, #32]	; (802170c <Motor0_BLDC_SCALAR_SpeedControlScheme+0x48>)
 80216ec:	f7ff ffb2 	bl	8021654 <Motor0_BLDC_SCALAR_PI_Controller>

  *output = Motor0_BLDC_SCALAR_SpeedControl_PI.uk;
 80216f0:	4b06      	ldr	r3, [pc, #24]	; (802170c <Motor0_BLDC_SCALAR_SpeedControlScheme+0x48>)
 80216f2:	681a      	ldr	r2, [r3, #0]
 80216f4:	687b      	ldr	r3, [r7, #4]
 80216f6:	601a      	str	r2, [r3, #0]
}
 80216f8:	bf00      	nop
 80216fa:	3710      	adds	r7, #16
 80216fc:	46bd      	mov	sp, r7
 80216fe:	bd80      	pop	{r7, pc}
 8021700:	2000018c 	.word	0x2000018c
 8021704:	20000148 	.word	0x20000148
 8021708:	200000bc 	.word	0x200000bc
 802170c:	2000008c 	.word	0x2000008c

08021710 <Motor0_BLDC_SCALAR_DirectionControl>:
 * using O3 optimization level \n
 * without bi-direction control: <b>0.120 uSec</b> \n
 * with bi-direction control (normal operation): <b>0.820 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_DirectionControl(int32_t output, uint32_t *amplitude)
{
 8021710:	b580      	push	{r7, lr}
 8021712:	b084      	sub	sp, #16
 8021714:	af00      	add	r7, sp, #0
 8021716:	6078      	str	r0, [r7, #4]
 8021718:	6039      	str	r1, [r7, #0]

  /*
   * Change the direction when control scheme output is of reverse polarity of the set motor direction
   * Get the absolute value of the amplitude
   */
  if (output < 0)
 802171a:	687b      	ldr	r3, [r7, #4]
 802171c:	2b00      	cmp	r3, #0
 802171e:	da13      	bge.n	8021748 <Motor0_BLDC_SCALAR_DirectionControl+0x38>
  {
    output = -1 * output;
 8021720:	687b      	ldr	r3, [r7, #4]
 8021722:	425b      	negs	r3, r3
 8021724:	607b      	str	r3, [r7, #4]

    if (Motor0_BLDC_SCALAR.motor_set_direction == BLDC_SCALAR_POSITIVE_DIR)
 8021726:	4b25      	ldr	r3, [pc, #148]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021728:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802172a:	2b01      	cmp	r3, #1
 802172c:	d11f      	bne.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 802172e:	4b23      	ldr	r3, [pc, #140]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021730:	f04f 32ff 	mov.w	r2, #4294967295
 8021734:	679a      	str	r2, [r3, #120]	; 0x78
      index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021736:	f7ff fe83 	bl	8021440 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 802173a:	4603      	mov	r3, r0
 802173c:	73fb      	strb	r3, [r7, #15]
      Motor0_BLDC_SCALAR_PatternInitiator(index);
 802173e:	7bfb      	ldrb	r3, [r7, #15]
 8021740:	4618      	mov	r0, r3
 8021742:	f009 fd09 	bl	802b158 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
 8021746:	e012      	b.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    }
  }
  else if (output > 0)
 8021748:	687b      	ldr	r3, [r7, #4]
 802174a:	2b00      	cmp	r3, #0
 802174c:	dd0f      	ble.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
  {
    if (Motor0_BLDC_SCALAR.motor_set_direction == BLDC_SCALAR_NEGATIVE_DIR)
 802174e:	4b1b      	ldr	r3, [pc, #108]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021750:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021752:	f1b3 3fff 	cmp.w	r3, #4294967295
 8021756:	d10a      	bne.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 8021758:	4b18      	ldr	r3, [pc, #96]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 802175a:	2201      	movs	r2, #1
 802175c:	679a      	str	r2, [r3, #120]	; 0x78
      index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 802175e:	f7ff fe6f 	bl	8021440 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021762:	4603      	mov	r3, r0
 8021764:	73fb      	strb	r3, [r7, #15]
      Motor0_BLDC_SCALAR_PatternInitiator(index);
 8021766:	7bfb      	ldrb	r3, [r7, #15]
 8021768:	4618      	mov	r0, r3
 802176a:	f009 fcf5 	bl	802b158 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
  }
  else
  {

  }
  *amplitude = (uint32_t)output;
 802176e:	687a      	ldr	r2, [r7, #4]
 8021770:	683b      	ldr	r3, [r7, #0]
 8021772:	601a      	str	r2, [r3, #0]
  /* zero speed handling in speed control with bi-directional control */
  #if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U)
    speed = Motor0_BLDC_SCALAR.analogip_val;
  #else
    speed = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 8021774:	4b12      	ldr	r3, [pc, #72]	; (80217c0 <Motor0_BLDC_SCALAR_DirectionControl+0xb0>)
 8021776:	685b      	ldr	r3, [r3, #4]
 8021778:	60bb      	str	r3, [r7, #8]
  #endif
  if (speed == 0)
 802177a:	68bb      	ldr	r3, [r7, #8]
 802177c:	2b00      	cmp	r3, #0
 802177e:	d119      	bne.n	80217b4 <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
  {
    /* Limiting speed to 0 when motor speed with in the range of 2% */
    if ((Motor0_BLDC_SCALAR.motor_speed < Motor0_BLDC_SCALAR.min_speed) && (Motor0_BLDC_SCALAR.motor_speed > -Motor0_BLDC_SCALAR.min_speed))
 8021780:	4b0e      	ldr	r3, [pc, #56]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021782:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8021784:	4b0d      	ldr	r3, [pc, #52]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021786:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 802178a:	429a      	cmp	r2, r3
 802178c:	da12      	bge.n	80217b4 <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
 802178e:	4b0b      	ldr	r3, [pc, #44]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021790:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8021792:	4b0a      	ldr	r3, [pc, #40]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021794:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8021798:	425b      	negs	r3, r3
 802179a:	429a      	cmp	r2, r3
 802179c:	dd0a      	ble.n	80217b4 <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
    {
      Motor0_BLDC_SCALAR.motor_speed = 0;
 802179e:	4b07      	ldr	r3, [pc, #28]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 80217a0:	2200      	movs	r2, #0
 80217a2:	66da      	str	r2, [r3, #108]	; 0x6c
      Motor0_BLDC_SCALAR.motor_current = 0;
 80217a4:	4b05      	ldr	r3, [pc, #20]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 80217a6:	2200      	movs	r2, #0
 80217a8:	671a      	str	r2, [r3, #112]	; 0x70
      Motor0_BLDC_SCALAR_SpeedControl_PI.ik = 0;
 80217aa:	4b06      	ldr	r3, [pc, #24]	; (80217c4 <Motor0_BLDC_SCALAR_DirectionControl+0xb4>)
 80217ac:	2200      	movs	r2, #0
 80217ae:	605a      	str	r2, [r3, #4]

      /* Reset speed calculation related variables */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 80217b0:	f7ff fe1c 	bl	80213ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>
  {
    output = 0;
  }
  *amplitude = (uint32_t) output;
#endif
}
 80217b4:	bf00      	nop
 80217b6:	3710      	adds	r7, #16
 80217b8:	46bd      	mov	sp, r7
 80217ba:	bd80      	pop	{r7, pc}
 80217bc:	2000018c 	.word	0x2000018c
 80217c0:	20000148 	.word	0x20000148
 80217c4:	2000008c 	.word	0x2000008c

080217c8 <XMC_CCU4_StartPrescaler>:
{
 80217c8:	b480      	push	{r7}
 80217ca:	b083      	sub	sp, #12
 80217cc:	af00      	add	r7, sp, #0
 80217ce:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 80217d0:	687b      	ldr	r3, [r7, #4]
 80217d2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217d6:	60da      	str	r2, [r3, #12]
}
 80217d8:	bf00      	nop
 80217da:	370c      	adds	r7, #12
 80217dc:	46bd      	mov	sp, r7
 80217de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217e2:	4770      	bx	lr

080217e4 <XMC_CCU4_StopPrescaler>:
{
 80217e4:	b480      	push	{r7}
 80217e6:	b083      	sub	sp, #12
 80217e8:	af00      	add	r7, sp, #0
 80217ea:	6078      	str	r0, [r7, #4]
  module->GIDLS = (uint32_t) CCU4_GIDLS_CPRB_Msk;
 80217ec:	687b      	ldr	r3, [r7, #4]
 80217ee:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217f2:	609a      	str	r2, [r3, #8]
}
 80217f4:	bf00      	nop
 80217f6:	370c      	adds	r7, #12
 80217f8:	46bd      	mov	sp, r7
 80217fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217fe:	4770      	bx	lr

08021800 <XMC_CCU4_SLICE_StartTimer>:
{
 8021800:	b480      	push	{r7}
 8021802:	b083      	sub	sp, #12
 8021804:	af00      	add	r7, sp, #0
 8021806:	6078      	str	r0, [r7, #4]
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8021808:	687b      	ldr	r3, [r7, #4]
 802180a:	2201      	movs	r2, #1
 802180c:	60da      	str	r2, [r3, #12]
}
 802180e:	bf00      	nop
 8021810:	370c      	adds	r7, #12
 8021812:	46bd      	mov	sp, r7
 8021814:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021818:	4770      	bx	lr

0802181a <XMC_CCU4_SLICE_StopTimer>:
{
 802181a:	b480      	push	{r7}
 802181c:	b083      	sub	sp, #12
 802181e:	af00      	add	r7, sp, #0
 8021820:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8021822:	687b      	ldr	r3, [r7, #4]
 8021824:	2201      	movs	r2, #1
 8021826:	611a      	str	r2, [r3, #16]
}
 8021828:	bf00      	nop
 802182a:	370c      	adds	r7, #12
 802182c:	46bd      	mov	sp, r7
 802182e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021832:	4770      	bx	lr

08021834 <XMC_CCU4_SLICE_GetTimerValue>:
{
 8021834:	b480      	push	{r7}
 8021836:	b083      	sub	sp, #12
 8021838:	af00      	add	r7, sp, #0
 802183a:	6078      	str	r0, [r7, #4]
  return ((uint16_t)slice->TIMER);
 802183c:	687b      	ldr	r3, [r7, #4]
 802183e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8021840:	b29b      	uxth	r3, r3
}
 8021842:	4618      	mov	r0, r3
 8021844:	370c      	adds	r7, #12
 8021846:	46bd      	mov	sp, r7
 8021848:	f85d 7b04 	ldr.w	r7, [sp], #4
 802184c:	4770      	bx	lr

0802184e <XMC_CCU4_SLICE_SetTimerValue>:
{
 802184e:	b480      	push	{r7}
 8021850:	b083      	sub	sp, #12
 8021852:	af00      	add	r7, sp, #0
 8021854:	6078      	str	r0, [r7, #4]
 8021856:	460b      	mov	r3, r1
 8021858:	807b      	strh	r3, [r7, #2]
  slice->TIMER = (uint32_t) timer_val;
 802185a:	887a      	ldrh	r2, [r7, #2]
 802185c:	687b      	ldr	r3, [r7, #4]
 802185e:	671a      	str	r2, [r3, #112]	; 0x70
}
 8021860:	bf00      	nop
 8021862:	370c      	adds	r7, #12
 8021864:	46bd      	mov	sp, r7
 8021866:	f85d 7b04 	ldr.w	r7, [sp], #4
 802186a:	4770      	bx	lr

0802186c <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 802186c:	b480      	push	{r7}
 802186e:	b083      	sub	sp, #12
 8021870:	af00      	add	r7, sp, #0
 8021872:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021874:	687b      	ldr	r3, [r7, #4]
 8021876:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 802187a:	b2db      	uxtb	r3, r3
 802187c:	115b      	asrs	r3, r3, #5
 802187e:	b2db      	uxtb	r3, r3
 8021880:	f003 0307 	and.w	r3, r3, #7
 8021884:	b2db      	uxtb	r3, r3
}
 8021886:	4618      	mov	r0, r3
 8021888:	370c      	adds	r7, #12
 802188a:	46bd      	mov	sp, r7
 802188c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021890:	4770      	bx	lr

08021892 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8021892:	b480      	push	{r7}
 8021894:	b083      	sub	sp, #12
 8021896:	af00      	add	r7, sp, #0
 8021898:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 802189a:	687b      	ldr	r3, [r7, #4]
 802189c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802189e:	08db      	lsrs	r3, r3, #3
 80218a0:	b2db      	uxtb	r3, r3
 80218a2:	f003 0307 	and.w	r3, r3, #7
 80218a6:	b2db      	uxtb	r3, r3
}
 80218a8:	4618      	mov	r0, r3
 80218aa:	370c      	adds	r7, #12
 80218ac:	46bd      	mov	sp, r7
 80218ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218b2:	4770      	bx	lr

080218b4 <XMC_POSIF_HSC_SetHallPatterns>:
{
 80218b4:	b480      	push	{r7}
 80218b6:	b083      	sub	sp, #12
 80218b8:	af00      	add	r7, sp, #0
 80218ba:	6078      	str	r0, [r7, #4]
 80218bc:	460b      	mov	r3, r1
 80218be:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 80218c0:	78fb      	ldrb	r3, [r7, #3]
 80218c2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 80218c6:	687b      	ldr	r3, [r7, #4]
 80218c8:	635a      	str	r2, [r3, #52]	; 0x34
}
 80218ca:	bf00      	nop
 80218cc:	370c      	adds	r7, #12
 80218ce:	46bd      	mov	sp, r7
 80218d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218d4:	4770      	bx	lr

080218d6 <XMC_POSIF_HSC_UpdateHallPattern>:
{
 80218d6:	b480      	push	{r7}
 80218d8:	b083      	sub	sp, #12
 80218da:	af00      	add	r7, sp, #0
 80218dc:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 80218de:	687b      	ldr	r3, [r7, #4]
 80218e0:	2202      	movs	r2, #2
 80218e2:	649a      	str	r2, [r3, #72]	; 0x48
}
 80218e4:	bf00      	nop
 80218e6:	370c      	adds	r7, #12
 80218e8:	46bd      	mov	sp, r7
 80218ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218ee:	4770      	bx	lr

080218f0 <XMC_POSIF_ClearEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_SetEvent() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_ClearEvent(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 80218f0:	b480      	push	{r7}
 80218f2:	b083      	sub	sp, #12
 80218f4:	af00      	add	r7, sp, #0
 80218f6:	6078      	str	r0, [r7, #4]
 80218f8:	460b      	mov	r3, r1
 80218fa:	70fb      	strb	r3, [r7, #3]
  peripheral->RPFLG = (uint32_t)1 << (uint8_t)event;
 80218fc:	78fb      	ldrb	r3, [r7, #3]
 80218fe:	2201      	movs	r2, #1
 8021900:	409a      	lsls	r2, r3
 8021902:	687b      	ldr	r3, [r7, #4]
 8021904:	67da      	str	r2, [r3, #124]	; 0x7c
}
 8021906:	bf00      	nop
 8021908:	370c      	adds	r7, #12
 802190a:	46bd      	mov	sp, r7
 802190c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021910:	4770      	bx	lr

08021912 <XMC_POSIF_GetEventStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_SetEvent(),XMC_POSIF_ClearEvent() \n\n\n
 */
__STATIC_INLINE uint8_t XMC_POSIF_GetEventStatus(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 8021912:	b480      	push	{r7}
 8021914:	b083      	sub	sp, #12
 8021916:	af00      	add	r7, sp, #0
 8021918:	6078      	str	r0, [r7, #4]
 802191a:	460b      	mov	r3, r1
 802191c:	70fb      	strb	r3, [r7, #3]
  return ((uint8_t)((peripheral->PFLG >> (uint8_t)event) & 1U));
 802191e:	687b      	ldr	r3, [r7, #4]
 8021920:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8021922:	78fb      	ldrb	r3, [r7, #3]
 8021924:	fa22 f303 	lsr.w	r3, r2, r3
 8021928:	b2db      	uxtb	r3, r3
 802192a:	f003 0301 	and.w	r3, r3, #1
 802192e:	b2db      	uxtb	r3, r3
}
 8021930:	4618      	mov	r0, r3
 8021932:	370c      	adds	r7, #12
 8021934:	46bd      	mov	sp, r7
 8021936:	f85d 7b04 	ldr.w	r7, [sp], #4
 802193a:	4770      	bx	lr

0802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 802193c:	b580      	push	{r7, lr}
 802193e:	b082      	sub	sp, #8
 8021940:	af00      	add	r7, sp, #0
 8021942:	4603      	mov	r3, r0
 8021944:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021946:	79fb      	ldrb	r3, [r7, #7]
 8021948:	4619      	mov	r1, r3
 802194a:	4803      	ldr	r0, [pc, #12]	; (8021958 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 802194c:	f7ff ffb2 	bl	80218b4 <XMC_POSIF_HSC_SetHallPatterns>
}
 8021950:	bf00      	nop
 8021952:	3708      	adds	r7, #8
 8021954:	46bd      	mov	sp, r7
 8021956:	bd80      	pop	{r7, pc}
 8021958:	40028000 	.word	0x40028000

0802195c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
{
 802195c:	b580      	push	{r7, lr}
 802195e:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021960:	4802      	ldr	r0, [pc, #8]	; (802196c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 8021962:	f7ff ffb8 	bl	80218d6 <XMC_POSIF_HSC_UpdateHallPattern>
}
 8021966:	bf00      	nop
 8021968:	bd80      	pop	{r7, pc}
 802196a:	bf00      	nop
 802196c:	40028000 	.word	0x40028000

08021970 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8021970:	b580      	push	{r7, lr}
 8021972:	b082      	sub	sp, #8
 8021974:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021976:	4805      	ldr	r0, [pc, #20]	; (802198c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8021978:	f7ff ff8b 	bl	8021892 <XMC_POSIF_HSC_GetExpectedPattern>
 802197c:	4603      	mov	r3, r0
 802197e:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8021980:	79fb      	ldrb	r3, [r7, #7]
}
 8021982:	4618      	mov	r0, r3
 8021984:	3708      	adds	r7, #8
 8021986:	46bd      	mov	sp, r7
 8021988:	bd80      	pop	{r7, pc}
 802198a:	bf00      	nop
 802198c:	40028000 	.word	0x40028000

08021990 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>:
{
 8021990:	b580      	push	{r7, lr}
 8021992:	b082      	sub	sp, #8
 8021994:	af00      	add	r7, sp, #0
  period = XMC_CCU4_SLICE_GetCaptureRegisterValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, BLDC_SCALAR_HALL_CAPTURE_REGITSER);
 8021996:	2103      	movs	r1, #3
 8021998:	4804      	ldr	r0, [pc, #16]	; (80219ac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime+0x1c>)
 802199a:	f006 fa09 	bl	8027db0 <XMC_CCU4_SLICE_GetCaptureRegisterValue>
 802199e:	6078      	str	r0, [r7, #4]
  return(period);
 80219a0:	687b      	ldr	r3, [r7, #4]
}
 80219a2:	4618      	mov	r0, r3
 80219a4:	3708      	adds	r7, #8
 80219a6:	46bd      	mov	sp, r7
 80219a8:	bd80      	pop	{r7, pc}
 80219aa:	bf00      	nop
 80219ac:	4000c200 	.word	0x4000c200

080219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
{
 80219b0:	b580      	push	{r7, lr}
 80219b2:	b082      	sub	sp, #8
 80219b4:	af00      	add	r7, sp, #0
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 80219b6:	4805      	ldr	r0, [pc, #20]	; (80219cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 80219b8:	f7ff ff58 	bl	802186c <XMC_POSIF_HSC_GetLastSampledPattern>
 80219bc:	4603      	mov	r3, r0
 80219be:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 80219c0:	79fb      	ldrb	r3, [r7, #7]
}
 80219c2:	4618      	mov	r0, r3
 80219c4:	3708      	adds	r7, #8
 80219c6:	46bd      	mov	sp, r7
 80219c8:	bd80      	pop	{r7, pc}
 80219ca:	bf00      	nop
 80219cc:	40028000 	.word	0x40028000

080219d0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler>:
 *
 * \par<b>Description</b><br>
 * Reset the capture timer prescaler value.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler(void)
{
 80219d0:	b580      	push	{r7, lr}
 80219d2:	af00      	add	r7, sp, #0
  /*
   * Stop timer and prescalar.
   * initialize timer and prescalar value and restert the timer
   */
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219d4:	480a      	ldr	r0, [pc, #40]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219d6:	f7ff ff20 	bl	802181a <XMC_CCU4_SLICE_StopTimer>
  XMC_CCU4_StopPrescaler(MOTOR0_BLDC_SCALAR_CCU4_MODULE);
 80219da:	480a      	ldr	r0, [pc, #40]	; (8021a04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x34>)
 80219dc:	f7ff ff02 	bl	80217e4 <XMC_CCU4_StopPrescaler>
  XMC_CCU4_SLICE_SetTimerValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, 0U);
 80219e0:	2100      	movs	r1, #0
 80219e2:	4807      	ldr	r0, [pc, #28]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219e4:	f7ff ff33 	bl	802184e <XMC_CCU4_SLICE_SetTimerValue>
  XMC_CCU4_SLICE_SetPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, MOTOR0_BLDC_SCALAR_CCU4_PRESCALER);
 80219e8:	2105      	movs	r1, #5
 80219ea:	4805      	ldr	r0, [pc, #20]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219ec:	f006 f9f2 	bl	8027dd4 <XMC_CCU4_SLICE_SetPrescaler>
  XMC_CCU4_StartPrescaler(MOTOR0_BLDC_SCALAR_CCU4_MODULE);
 80219f0:	4804      	ldr	r0, [pc, #16]	; (8021a04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x34>)
 80219f2:	f7ff fee9 	bl	80217c8 <XMC_CCU4_StartPrescaler>
  XMC_CCU4_SLICE_StartTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219f6:	4802      	ldr	r0, [pc, #8]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219f8:	f7ff ff02 	bl	8021800 <XMC_CCU4_SLICE_StartTimer>
}
 80219fc:	bf00      	nop
 80219fe:	bd80      	pop	{r7, pc}
 8021a00:	4000c200 	.word	0x4000c200
 8021a04:	4000c000 	.word	0x4000c000

08021a08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal>:
 *
 * \par<b>Description</b><br>
 * Return Hall event capture timer current value\n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal(void)
{
 8021a08:	b580      	push	{r7, lr}
 8021a0a:	b082      	sub	sp, #8
 8021a0c:	af00      	add	r7, sp, #0
  uint16_t period;
  period = XMC_CCU4_SLICE_GetTimerValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8021a0e:	4805      	ldr	r0, [pc, #20]	; (8021a24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal+0x1c>)
 8021a10:	f7ff ff10 	bl	8021834 <XMC_CCU4_SLICE_GetTimerValue>
 8021a14:	4603      	mov	r3, r0
 8021a16:	80fb      	strh	r3, [r7, #6]
  return(period);
 8021a18:	88fb      	ldrh	r3, [r7, #6]
}
 8021a1a:	4618      	mov	r0, r3
 8021a1c:	3708      	adds	r7, #8
 8021a1e:	46bd      	mov	sp, r7
 8021a20:	bd80      	pop	{r7, pc}
 8021a22:	bf00      	nop
 8021a24:	4000c200 	.word	0x4000c200

08021a28 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus>:
 *
 * \par<b>Description</b><br>
 * Returns event status of peripheral. \n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus(const XMC_POSIF_IRQ_EVENT_t event)
{
 8021a28:	b580      	push	{r7, lr}
 8021a2a:	b082      	sub	sp, #8
 8021a2c:	af00      	add	r7, sp, #0
 8021a2e:	4603      	mov	r3, r0
 8021a30:	71fb      	strb	r3, [r7, #7]
  return XMC_POSIF_GetEventStatus(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8021a32:	79fb      	ldrb	r3, [r7, #7]
 8021a34:	4619      	mov	r1, r3
 8021a36:	4804      	ldr	r0, [pc, #16]	; (8021a48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus+0x20>)
 8021a38:	f7ff ff6b 	bl	8021912 <XMC_POSIF_GetEventStatus>
 8021a3c:	4603      	mov	r3, r0
}
 8021a3e:	4618      	mov	r0, r3
 8021a40:	3708      	adds	r7, #8
 8021a42:	46bd      	mov	sp, r7
 8021a44:	bd80      	pop	{r7, pc}
 8021a46:	bf00      	nop
 8021a48:	40028000 	.word	0x40028000

08021a4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>:
 *
 * \par<b>Description</b><br>
 * Clears event by acknowledgment of peripheral. \n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 8021a4c:	b580      	push	{r7, lr}
 8021a4e:	b082      	sub	sp, #8
 8021a50:	af00      	add	r7, sp, #0
 8021a52:	4603      	mov	r3, r0
 8021a54:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_ClearEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8021a56:	79fb      	ldrb	r3, [r7, #7]
 8021a58:	4619      	mov	r1, r3
 8021a5a:	4803      	ldr	r0, [pc, #12]	; (8021a68 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent+0x1c>)
 8021a5c:	f7ff ff48 	bl	80218f0 <XMC_POSIF_ClearEvent>
}
 8021a60:	bf00      	nop
 8021a62:	3708      	adds	r7, #8
 8021a64:	46bd      	mov	sp, r7
 8021a66:	bd80      	pop	{r7, pc}
 8021a68:	40028000 	.word	0x40028000

08021a6c <Motor0_BLDC_SCALAR_WrongHallEvent>:
 * Restart capture timer and calculate the speed.
 *
 * if hall failure, stop the motor and change the state to ERROR.
 */
static void Motor0_BLDC_SCALAR_WrongHallEvent(void)
{
 8021a6c:	b580      	push	{r7, lr}
 8021a6e:	b088      	sub	sp, #32
 8021a70:	af00      	add	r7, sp, #0
  uint8_t sampled_pat;      /* Sampled hall pattern */
  uint8_t reverse_pat;      /* Expected reverse direction pattern based on last sample pattern */
  uint8_t correct_pat;      /* Expected correct direction pattern based on last sample pattern */

  /* 0: positive direction, 8: negative direction to access the pattern table */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
 8021a72:	4b59      	ldr	r3, [pc, #356]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021a74:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021a76:	b2db      	uxtb	r3, r3
 8021a78:	f003 0308 	and.w	r3, r3, #8
 8021a7c:	77fb      	strb	r3, [r7, #31]
  int32_t temp_dir  = (-Motor0_BLDC_SCALAR.motor_set_direction);
 8021a7e:	4b56      	ldr	r3, [pc, #344]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021a80:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021a82:	425b      	negs	r3, r3
 8021a84:	61bb      	str	r3, [r7, #24]
  uint8_t rev_direction = ((uint8_t)(temp_dir) & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX);    /* reverse direction */
 8021a86:	69bb      	ldr	r3, [r7, #24]
 8021a88:	b2db      	uxtb	r3, r3
 8021a8a:	f003 0308 	and.w	r3, r3, #8
 8021a8e:	75fb      	strb	r3, [r7, #23]
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
  uint8_t pos;           /* array index variable */
#endif
  uint32_t speed = 0U;     /* electrical speed in RPM */
 8021a90:	2300      	movs	r3, #0
 8021a92:	607b      	str	r3, [r7, #4]
  uint32_t capval;         /* Calculated time between two hall events */

#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  /* To blank the direct DC link current measurement at the commutation point */
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 1U;
 8021a94:	4b51      	ldr	r3, [pc, #324]	; (8021bdc <Motor0_BLDC_SCALAR_WrongHallEvent+0x170>)
 8021a96:	2201      	movs	r2, #1
 8021a98:	f883 2020 	strb.w	r2, [r3, #32]
#if (MOTOR0_BLDC_SCALAR_ENABLE_STALL_DETECTION == 1U)
  /* Reset the stall detection count as hall event is detected for timeout*/
  Motor0_BLDC_SCALAR.stall_detection_counter = 0U;
#endif
  /*Get the sampled hall pattern*/
  sampled_pat = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021a9c:	f7ff ff88 	bl	80219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021aa0:	4603      	mov	r3, r0
 8021aa2:	75bb      	strb	r3, [r7, #22]
  reverse_pat = (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + rev_direction] >> BLDC_SCALAR_HALL_PATTERN_POS);
 8021aa4:	4b4e      	ldr	r3, [pc, #312]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021aa6:	7c5b      	ldrb	r3, [r3, #17]
 8021aa8:	461a      	mov	r2, r3
 8021aaa:	7dfb      	ldrb	r3, [r7, #23]
 8021aac:	4413      	add	r3, r2
 8021aae:	4a4c      	ldr	r2, [pc, #304]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021ab0:	5cd3      	ldrb	r3, [r2, r3]
 8021ab2:	08db      	lsrs	r3, r3, #3
 8021ab4:	757b      	strb	r3, [r7, #21]
  correct_pat = (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + direction] >> BLDC_SCALAR_HALL_PATTERN_POS);
 8021ab6:	4b4a      	ldr	r3, [pc, #296]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021ab8:	7c5b      	ldrb	r3, [r3, #17]
 8021aba:	461a      	mov	r2, r3
 8021abc:	7ffb      	ldrb	r3, [r7, #31]
 8021abe:	4413      	add	r3, r2
 8021ac0:	4a47      	ldr	r2, [pc, #284]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021ac2:	5cd3      	ldrb	r3, [r2, r3]
 8021ac4:	08db      	lsrs	r3, r3, #3
 8021ac6:	753b      	strb	r3, [r7, #20]

  /* Check if the pattern matches the correct or reverse hall pattern */
  if (( reverse_pat == sampled_pat) || ( correct_pat == sampled_pat))
 8021ac8:	7d7a      	ldrb	r2, [r7, #21]
 8021aca:	7dbb      	ldrb	r3, [r7, #22]
 8021acc:	429a      	cmp	r2, r3
 8021ace:	d003      	beq.n	8021ad8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x6c>
 8021ad0:	7d3a      	ldrb	r2, [r7, #20]
 8021ad2:	7dbb      	ldrb	r3, [r7, #22]
 8021ad4:	429a      	cmp	r2, r3
 8021ad6:	d16b      	bne.n	8021bb0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x144>
  {
    /* Reverse hall event detected */

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
    /* BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION  - to get the direction of freely running motor */
    if ((Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U) &&
 8021ad8:	4b42      	ldr	r3, [pc, #264]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021ada:	781b      	ldrb	r3, [r3, #0]
 8021adc:	2b00      	cmp	r3, #0
 8021ade:	d12a      	bne.n	8021b36 <Motor0_BLDC_SCALAR_WrongHallEvent+0xca>
          (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION))
 8021ae0:	4b3d      	ldr	r3, [pc, #244]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ae2:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8021ae6:	b2db      	uxtb	r3, r3
    if ((Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U) &&
 8021ae8:	2b02      	cmp	r3, #2
 8021aea:	d124      	bne.n	8021b36 <Motor0_BLDC_SCALAR_WrongHallEvent+0xca>
    {
      /* Find the direction of rotation if motor is already running */
      Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = (int32_t) (Motor0_BLDC_SCALAR.motor_set_direction * -1);
 8021aec:	4b3a      	ldr	r3, [pc, #232]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021aee:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021af0:	425b      	negs	r3, r3
 8021af2:	4a3c      	ldr	r2, [pc, #240]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021af4:	60d3      	str	r3, [r2, #12]
      direction = (uint8_t) Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 8021af6:	4b3b      	ldr	r3, [pc, #236]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021af8:	68db      	ldr	r3, [r3, #12]
 8021afa:	b2db      	uxtb	r3, r3
 8021afc:	f003 0308 	and.w	r3, r3, #8
 8021b00:	77fb      	strb	r3, [r7, #31]
      Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired = 1U;
 8021b02:	4b38      	ldr	r3, [pc, #224]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021b04:	2201      	movs	r2, #1
 8021b06:	741a      	strb	r2, [r3, #16]

      /* Update the hall pattern in shadow register and perform immediate transfer */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[((uint8_t) sampled_pat + (uint32_t) direction)]));
 8021b08:	7dba      	ldrb	r2, [r7, #22]
 8021b0a:	7ffb      	ldrb	r3, [r7, #31]
 8021b0c:	4413      	add	r3, r2
 8021b0e:	4a34      	ldr	r2, [pc, #208]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021b10:	5cd3      	ldrb	r3, [r2, r3]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021b12:	4618      	mov	r0, r3
 8021b14:	f7ff ff12 	bl	802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
 8021b18:	f7ff ff20 	bl	802195c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>
      pos =  Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 8021b1c:	f7ff ff28 	bl	8021970 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 8021b20:	4603      	mov	r3, r0
 8021b22:	74fb      	strb	r3, [r7, #19]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
 8021b24:	7cfa      	ldrb	r2, [r7, #19]
 8021b26:	7ffb      	ldrb	r3, [r7, #31]
 8021b28:	4413      	add	r3, r2
 8021b2a:	4a2d      	ldr	r2, [pc, #180]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021b2c:	5cd3      	ldrb	r3, [r2, r3]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021b2e:	4618      	mov	r0, r3
 8021b30:	f7ff ff04 	bl	802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
 8021b34:	e035      	b.n	8021ba2 <Motor0_BLDC_SCALAR_WrongHallEvent+0x136>
    /* Apply hall pattern and multi-channel pattern for intended direction */
    else
    {
#endif
      /* Update actual motor direction */
      Motor0_BLDC_SCALAR.actual_motor_direction = (-Motor0_BLDC_SCALAR.motor_set_direction);
 8021b36:	4b28      	ldr	r3, [pc, #160]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b38:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021b3a:	425b      	negs	r3, r3
 8021b3c:	4a26      	ldr	r2, [pc, #152]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b3e:	67d3      	str	r3, [r2, #124]	; 0x7c

      Motor0_BLDC_SCALAR_PatternInitiator(sampled_pat);
 8021b40:	7dbb      	ldrb	r3, [r7, #22]
 8021b42:	4618      	mov	r0, r3
 8021b44:	f009 fb08 	bl	802b158 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>

      /* Restart the capture slice which is used for speed calculation */
      timer = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal();
 8021b48:	f7ff ff5e 	bl	8021a08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal>
 8021b4c:	4603      	mov	r3, r0
 8021b4e:	823b      	strh	r3, [r7, #16]
      curr_psc = ((uint32_t)((uint32_t)MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE->FPC & (uint32_t)CCU4_CC4_FPC_PVAL_Msk) >> (uint32_t)CCU4_CC4_FPC_PVAL_Pos);
 8021b50:	4b25      	ldr	r3, [pc, #148]	; (8021be8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x17c>)
 8021b52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021b54:	0a1b      	lsrs	r3, r3, #8
 8021b56:	f003 030f 	and.w	r3, r3, #15
 8021b5a:	60fb      	str	r3, [r7, #12]

      /* Stop timer and prescaler and restart with reset values*/
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler();
 8021b5c:	f7ff ff38 	bl	80219d0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler>

      /* speed calculation */
      capval = BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021b60:	68fb      	ldr	r3, [r7, #12]
 8021b62:	3b05      	subs	r3, #5
 8021b64:	4a21      	ldr	r2, [pc, #132]	; (8021bec <Motor0_BLDC_SCALAR_WrongHallEvent+0x180>)
 8021b66:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
               (((uint32_t)1 << (uint32_t)(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * timer);
 8021b6a:	8a39      	ldrh	r1, [r7, #16]
 8021b6c:	68fb      	ldr	r3, [r7, #12]
 8021b6e:	3b05      	subs	r3, #5
 8021b70:	fa01 f303 	lsl.w	r3, r1, r3
      capval = BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021b74:	4413      	add	r3, r2
 8021b76:	60bb      	str	r3, [r7, #8]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = capval;
 8021b78:	4a1d      	ldr	r2, [pc, #116]	; (8021bf0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x184>)
 8021b7a:	68bb      	ldr	r3, [r7, #8]
 8021b7c:	6193      	str	r3, [r2, #24]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation(capval, &speed);
 8021b7e:	1d3b      	adds	r3, r7, #4
 8021b80:	4619      	mov	r1, r3
 8021b82:	68b8      	ldr	r0, [r7, #8]
 8021b84:	f009 faf0 	bl	802b168 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer>
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b88:	4b13      	ldr	r3, [pc, #76]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b8a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021b8c:	687a      	ldr	r2, [r7, #4]
 8021b8e:	fb02 f303 	mul.w	r3, r2, r3
                                       (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8021b92:	4a11      	ldr	r2, [pc, #68]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b94:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b98:	fb02 f303 	mul.w	r3, r2, r3
                                       (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8021b9c:	129b      	asrs	r3, r3, #10
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b9e:	4a0e      	ldr	r2, [pc, #56]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ba0:	66d3      	str	r3, [r2, #108]	; 0x6c
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
    }
#endif
    Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021ba2:	f7ff ff05 	bl	80219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021ba6:	4603      	mov	r3, r0
 8021ba8:	461a      	mov	r2, r3
 8021baa:	4b0d      	ldr	r3, [pc, #52]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021bac:	745a      	strb	r2, [r3, #17]
 8021bae:	e00b      	b.n	8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x15c>

  /* Hall failure - sampled hall pattern does not match with either direction pattern */
  else
  {
    /* wrong hall event */
    Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_WRONGHALL;
 8021bb0:	4b09      	ldr	r3, [pc, #36]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021bb2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8021bb4:	f043 0308 	orr.w	r3, r3, #8
 8021bb8:	4a07      	ldr	r2, [pc, #28]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021bba:	6693      	str	r3, [r2, #104]	; 0x68
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 8021bbc:	4b06      	ldr	r3, [pc, #24]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021bbe:	2208      	movs	r2, #8
 8021bc0:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    Motor0_BLDC_SCALAR_MotorStop();
 8021bc4:	f000 fee8 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
  }
  /* clear wrong hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(XMC_POSIF_IRQ_EVENT_WHE);
 8021bc8:	2001      	movs	r0, #1
 8021bca:	f7ff ff3f 	bl	8021a4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>
}
 8021bce:	bf00      	nop
 8021bd0:	3720      	adds	r7, #32
 8021bd2:	46bd      	mov	sp, r7
 8021bd4:	bd80      	pop	{r7, pc}
 8021bd6:	bf00      	nop
 8021bd8:	2000018c 	.word	0x2000018c
 8021bdc:	20000124 	.word	0x20000124
 8021be0:	20000158 	.word	0x20000158
 8021be4:	2000016c 	.word	0x2000016c
 8021be8:	4000c200 	.word	0x4000c200
 8021bec:	20000000 	.word	0x20000000
 8021bf0:	200000f8 	.word	0x200000f8

08021bf4 <Motor0_BLDC_SCALAR_CorrectHallEvent>:
/*
 * Find the direction of the motor in free running condition.
 * This event is disabled once control is switched to closed loop.
 */
static void Motor0_BLDC_SCALAR_CorrectHallEvent(void)
{
 8021bf4:	b580      	push	{r7, lr}
 8021bf6:	b086      	sub	sp, #24
 8021bf8:	af00      	add	r7, sp, #0
  /* 0: positive direction, 8: negative direction to access the pattern table */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
 8021bfa:	4b34      	ldr	r3, [pc, #208]	; (8021ccc <Motor0_BLDC_SCALAR_CorrectHallEvent+0xd8>)
 8021bfc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021bfe:	b2db      	uxtb	r3, r3
 8021c00:	f003 0308 	and.w	r3, r3, #8
 8021c04:	75fb      	strb	r3, [r7, #23]
  uint8_t pos;          /* Array index variable */
  uint32_t capture_reg;   /* capture register value */
  uint32_t curr_psc;      /* Prescaler value */

  /* Speed is calculated based on last two hall events */
  Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter++;
 8021c06:	4b32      	ldr	r3, [pc, #200]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c08:	695b      	ldr	r3, [r3, #20]
 8021c0a:	3301      	adds	r3, #1
 8021c0c:	4a30      	ldr	r2, [pc, #192]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c0e:	6153      	str	r3, [r2, #20]
  Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter = 0U;
 8021c10:	4b2f      	ldr	r3, [pc, #188]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c12:	2200      	movs	r2, #0
 8021c14:	609a      	str	r2, [r3, #8]
   * if correct hall event is the first event after the state machine has started,
   * identified direction is the intended direction.
   * If wrong hall event is the first event after the state machine has started,
   * identified direction is the reverse direction.
   */
  if ((Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter == 1U) && (Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired == 0U))
 8021c16:	4b2e      	ldr	r3, [pc, #184]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c18:	695b      	ldr	r3, [r3, #20]
 8021c1a:	2b01      	cmp	r3, #1
 8021c1c:	d10a      	bne.n	8021c34 <Motor0_BLDC_SCALAR_CorrectHallEvent+0x40>
 8021c1e:	4b2c      	ldr	r3, [pc, #176]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c20:	7c1b      	ldrb	r3, [r3, #16]
 8021c22:	2b00      	cmp	r3, #0
 8021c24:	d106      	bne.n	8021c34 <Motor0_BLDC_SCALAR_CorrectHallEvent+0x40>
  {
    Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = (int32_t) Motor0_BLDC_SCALAR.motor_set_direction;
 8021c26:	4b29      	ldr	r3, [pc, #164]	; (8021ccc <Motor0_BLDC_SCALAR_CorrectHallEvent+0xd8>)
 8021c28:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021c2a:	4a29      	ldr	r2, [pc, #164]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c2c:	60d3      	str	r3, [r2, #12]
    Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired = 1U;
 8021c2e:	4b28      	ldr	r3, [pc, #160]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c30:	2201      	movs	r2, #1
 8021c32:	741a      	strb	r2, [r3, #16]
  }

  direction = (uint8_t) Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 8021c34:	4b26      	ldr	r3, [pc, #152]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c36:	68db      	ldr	r3, [r3, #12]
 8021c38:	b2db      	uxtb	r3, r3
 8021c3a:	f003 0308 	and.w	r3, r3, #8
 8021c3e:	75fb      	strb	r3, [r7, #23]

  /* Read the captured value */
  capture_reg = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime();
 8021c40:	f7ff fea6 	bl	8021990 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>
 8021c44:	6138      	str	r0, [r7, #16]
  if ((Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter > 1U) && (Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U))
 8021c46:	4b22      	ldr	r3, [pc, #136]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c48:	695b      	ldr	r3, [r3, #20]
 8021c4a:	2b01      	cmp	r3, #1
 8021c4c:	d925      	bls.n	8021c9a <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
 8021c4e:	4b20      	ldr	r3, [pc, #128]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c50:	781b      	ldrb	r3, [r3, #0]
 8021c52:	2b00      	cmp	r3, #0
 8021c54:	d121      	bne.n	8021c9a <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
  {
    capture_reg = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime();
 8021c56:	f7ff fe9b 	bl	8021990 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>
 8021c5a:	6138      	str	r0, [r7, #16]

    capval = (capture_reg & (uint32_t) BLDC_SCALAR_HALL_CAPTURE_MASK);
 8021c5c:	693b      	ldr	r3, [r7, #16]
 8021c5e:	b29b      	uxth	r3, r3
 8021c60:	60fb      	str	r3, [r7, #12]
    curr_psc = (capture_reg & BLDC_SCALAR_HALL_CAPTURE_PRESCALAR_MASK) >> BLDC_SCALAR_HALL_CAPTURE_PRESCALAR_POS;
 8021c62:	693b      	ldr	r3, [r7, #16]
 8021c64:	0c1b      	lsrs	r3, r3, #16
 8021c66:	f003 030f 	and.w	r3, r3, #15
 8021c6a:	60bb      	str	r3, [r7, #8]
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval += BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)]
 8021c6c:	4b18      	ldr	r3, [pc, #96]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c6e:	685a      	ldr	r2, [r3, #4]
 8021c70:	68bb      	ldr	r3, [r7, #8]
 8021c72:	3b05      	subs	r3, #5
 8021c74:	4917      	ldr	r1, [pc, #92]	; (8021cd4 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe0>)
 8021c76:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                                   + (((uint32_t)1 << (uint32_t)(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * capval);
 8021c7a:	68bb      	ldr	r3, [r7, #8]
 8021c7c:	3b05      	subs	r3, #5
 8021c7e:	68f8      	ldr	r0, [r7, #12]
 8021c80:	fa00 f303 	lsl.w	r3, r0, r3
 8021c84:	440b      	add	r3, r1
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval += BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)]
 8021c86:	4413      	add	r3, r2
 8021c88:	4a11      	ldr	r2, [pc, #68]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c8a:	6053      	str	r3, [r2, #4]

    /*
     * STATE_IDENTIFICATION state execution needs three correct hall events. First
     * event is ignored and speed is calculated based on last two events
     */
    if (Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter == BLDC_SCALAR_HALL_CAPTURE_COUNTER)
 8021c8c:	4b10      	ldr	r3, [pc, #64]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c8e:	695b      	ldr	r3, [r3, #20]
 8021c90:	2b03      	cmp	r3, #3
 8021c92:	d102      	bne.n	8021c9a <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
    {
      Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done = 1U;
 8021c94:	4b0e      	ldr	r3, [pc, #56]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c96:	2201      	movs	r2, #1
 8021c98:	701a      	strb	r2, [r3, #0]
    }
  }
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021c9a:	f7ff fe89 	bl	80219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021c9e:	4603      	mov	r3, r0
 8021ca0:	461a      	mov	r2, r3
 8021ca2:	4b0d      	ldr	r3, [pc, #52]	; (8021cd8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe4>)
 8021ca4:	745a      	strb	r2, [r3, #17]
  pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 8021ca6:	f7ff fe63 	bl	8021970 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 8021caa:	4603      	mov	r3, r0
 8021cac:	71fb      	strb	r3, [r7, #7]

  /* next hall pattern in hall shadow register*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
 8021cae:	79fa      	ldrb	r2, [r7, #7]
 8021cb0:	7dfb      	ldrb	r3, [r7, #23]
 8021cb2:	4413      	add	r3, r2
 8021cb4:	4a08      	ldr	r2, [pc, #32]	; (8021cd8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe4>)
 8021cb6:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021cb8:	4618      	mov	r0, r3
 8021cba:	f7ff fe3f 	bl	802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>

  /* clear correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8021cbe:	2000      	movs	r0, #0
 8021cc0:	f7ff fec4 	bl	8021a4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>
}
 8021cc4:	bf00      	nop
 8021cc6:	3718      	adds	r7, #24
 8021cc8:	46bd      	mov	sp, r7
 8021cca:	bd80      	pop	{r7, pc}
 8021ccc:	2000018c 	.word	0x2000018c
 8021cd0:	2000016c 	.word	0x2000016c
 8021cd4:	20000000 	.word	0x20000000
 8021cd8:	20000158 	.word	0x20000158

08021cdc <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021cdc:	b480      	push	{r7}
 8021cde:	b083      	sub	sp, #12
 8021ce0:	af00      	add	r7, sp, #0
 8021ce2:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021ce4:	687b      	ldr	r3, [r7, #4]
 8021ce6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021cea:	b2db      	uxtb	r3, r3
 8021cec:	115b      	asrs	r3, r3, #5
 8021cee:	b2db      	uxtb	r3, r3
 8021cf0:	f003 0307 	and.w	r3, r3, #7
 8021cf4:	b2db      	uxtb	r3, r3
}
 8021cf6:	4618      	mov	r0, r3
 8021cf8:	370c      	adds	r7, #12
 8021cfa:	46bd      	mov	sp, r7
 8021cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d00:	4770      	bx	lr

08021d02 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8021d02:	b480      	push	{r7}
 8021d04:	b083      	sub	sp, #12
 8021d06:	af00      	add	r7, sp, #0
 8021d08:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8021d0a:	687b      	ldr	r3, [r7, #4]
 8021d0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021d0e:	08db      	lsrs	r3, r3, #3
 8021d10:	b2db      	uxtb	r3, r3
 8021d12:	f003 0307 	and.w	r3, r3, #7
 8021d16:	b2db      	uxtb	r3, r3
}
 8021d18:	4618      	mov	r0, r3
 8021d1a:	370c      	adds	r7, #12
 8021d1c:	46bd      	mov	sp, r7
 8021d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d22:	4770      	bx	lr

08021d24 <XMC_POSIF_HSC_SetHallPatterns>:
{
 8021d24:	b480      	push	{r7}
 8021d26:	b083      	sub	sp, #12
 8021d28:	af00      	add	r7, sp, #0
 8021d2a:	6078      	str	r0, [r7, #4]
 8021d2c:	460b      	mov	r3, r1
 8021d2e:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8021d30:	78fb      	ldrb	r3, [r7, #3]
 8021d32:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8021d36:	687b      	ldr	r3, [r7, #4]
 8021d38:	635a      	str	r2, [r3, #52]	; 0x34
}
 8021d3a:	bf00      	nop
 8021d3c:	370c      	adds	r7, #12
 8021d3e:	46bd      	mov	sp, r7
 8021d40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d44:	4770      	bx	lr

08021d46 <XMC_POSIF_MCM_SetMultiChannelPattern>:
{
 8021d46:	b480      	push	{r7}
 8021d48:	b083      	sub	sp, #12
 8021d4a:	af00      	add	r7, sp, #0
 8021d4c:	6078      	str	r0, [r7, #4]
 8021d4e:	460b      	mov	r3, r1
 8021d50:	807b      	strh	r3, [r7, #2]
  peripheral->MCSM = pattern;
 8021d52:	887a      	ldrh	r2, [r7, #2]
 8021d54:	687b      	ldr	r3, [r7, #4]
 8021d56:	645a      	str	r2, [r3, #68]	; 0x44
}
 8021d58:	bf00      	nop
 8021d5a:	370c      	adds	r7, #12
 8021d5c:	46bd      	mov	sp, r7
 8021d5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d62:	4770      	bx	lr

08021d64 <XMC_POSIF_MCM_GetMultiChannelPattern>:
{
 8021d64:	b480      	push	{r7}
 8021d66:	b083      	sub	sp, #12
 8021d68:	af00      	add	r7, sp, #0
 8021d6a:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCM & (uint32_t)POSIF_MCM_MCMP_Msk));
 8021d6c:	687b      	ldr	r3, [r7, #4]
 8021d6e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8021d70:	b29b      	uxth	r3, r3
}
 8021d72:	4618      	mov	r0, r3
 8021d74:	370c      	adds	r7, #12
 8021d76:	46bd      	mov	sp, r7
 8021d78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d7c:	4770      	bx	lr

08021d7e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>:
{
 8021d7e:	b480      	push	{r7}
 8021d80:	b083      	sub	sp, #12
 8021d82:	af00      	add	r7, sp, #0
 8021d84:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCSM & (uint32_t)POSIF_MCSM_MCMPS_Msk));
 8021d86:	687b      	ldr	r3, [r7, #4]
 8021d88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8021d8a:	b29b      	uxth	r3, r3
}
 8021d8c:	4618      	mov	r0, r3
 8021d8e:	370c      	adds	r7, #12
 8021d90:	46bd      	mov	sp, r7
 8021d92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d96:	4770      	bx	lr

08021d98 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue>:
{
 8021d98:	b580      	push	{r7, lr}
 8021d9a:	b086      	sub	sp, #24
 8021d9c:	af00      	add	r7, sp, #0
 8021d9e:	6078      	str	r0, [r7, #4]
  BLDC_SCALAR_SPEED_POS_HALL_STATUS_t status = BLDC_SCALAR_SPEED_POS_HALL_STATUS_FAILURE;  /* return status */
 8021da0:	2301      	movs	r3, #1
 8021da2:	75fb      	strb	r3, [r7, #23]
  temp_capval = (uint32_t)XMC_CCU4_SLICE_GetCaptureRegisterValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, BLDC_SCALAR_HALL_CAPTURE_REGITSER);
 8021da4:	2103      	movs	r1, #3
 8021da6:	4816      	ldr	r0, [pc, #88]	; (8021e00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x68>)
 8021da8:	f006 f802 	bl	8027db0 <XMC_CCU4_SLICE_GetCaptureRegisterValue>
 8021dac:	6138      	str	r0, [r7, #16]
  if (((temp_capval & (uint32_t)CCU4_CC4_CV_FFL_Msk) >> CCU4_CC4_CV_FFL_Pos) == 1U)
 8021dae:	693b      	ldr	r3, [r7, #16]
 8021db0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8021db4:	2b00      	cmp	r3, #0
 8021db6:	d01b      	beq.n	8021df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x58>
    curr_psc = ((temp_capval & (uint32_t)CCU4_CC4_CV_FPCV_Msk) >> (uint32_t)CCU4_CC4_CV_FPCV_Pos);
 8021db8:	693b      	ldr	r3, [r7, #16]
 8021dba:	0c1b      	lsrs	r3, r3, #16
 8021dbc:	f003 030f 	and.w	r3, r3, #15
 8021dc0:	60fb      	str	r3, [r7, #12]
    temp_capval = temp_capval & BLDC_SCALAR_SPEED_POS_HALL_CAP_COMP_VAL;
 8021dc2:	693b      	ldr	r3, [r7, #16]
 8021dc4:	b29b      	uxth	r3, r3
 8021dc6:	613b      	str	r3, [r7, #16]
        (uint32_t)(BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021dc8:	68fb      	ldr	r3, [r7, #12]
 8021dca:	3b05      	subs	r3, #5
 8021dcc:	4a0d      	ldr	r2, [pc, #52]	; (8021e04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x6c>)
 8021dce:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
        (((uint32_t)1 << (curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * (uint32_t)temp_capval));
 8021dd2:	68fb      	ldr	r3, [r7, #12]
 8021dd4:	3b05      	subs	r3, #5
 8021dd6:	6939      	ldr	r1, [r7, #16]
 8021dd8:	fa01 f303 	lsl.w	r3, r1, r3
        (uint32_t)(BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021ddc:	4413      	add	r3, r2
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval =
 8021dde:	4a0a      	ldr	r2, [pc, #40]	; (8021e08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x70>)
 8021de0:	6193      	str	r3, [r2, #24]
    *capval = (uint32_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval;
 8021de2:	4b09      	ldr	r3, [pc, #36]	; (8021e08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x70>)
 8021de4:	699a      	ldr	r2, [r3, #24]
 8021de6:	687b      	ldr	r3, [r7, #4]
 8021de8:	601a      	str	r2, [r3, #0]
    status = BLDC_SCALAR_SPEED_POS_HALL_STATUS_SUCCESS;
 8021dea:	2300      	movs	r3, #0
 8021dec:	75fb      	strb	r3, [r7, #23]
 8021dee:	e002      	b.n	8021df6 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x5e>
    *capval = 0U;
 8021df0:	687b      	ldr	r3, [r7, #4]
 8021df2:	2200      	movs	r2, #0
 8021df4:	601a      	str	r2, [r3, #0]
  return (status);
 8021df6:	7dfb      	ldrb	r3, [r7, #23]
}
 8021df8:	4618      	mov	r0, r3
 8021dfa:	3718      	adds	r7, #24
 8021dfc:	46bd      	mov	sp, r7
 8021dfe:	bd80      	pop	{r7, pc}
 8021e00:	4000c200 	.word	0x4000c200
 8021e04:	20000000 	.word	0x20000000
 8021e08:	200000f8 	.word	0x200000f8

08021e0c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern>:
{
 8021e0c:	b580      	push	{r7, lr}
 8021e0e:	b082      	sub	sp, #8
 8021e10:	af00      	add	r7, sp, #0
 8021e12:	4603      	mov	r3, r0
 8021e14:	80fb      	strh	r3, [r7, #6]
  XMC_POSIF_MCM_SetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021e16:	88fb      	ldrh	r3, [r7, #6]
 8021e18:	4619      	mov	r1, r3
 8021e1a:	4803      	ldr	r0, [pc, #12]	; (8021e28 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern+0x1c>)
 8021e1c:	f7ff ff93 	bl	8021d46 <XMC_POSIF_MCM_SetMultiChannelPattern>
}
 8021e20:	bf00      	nop
 8021e22:	3708      	adds	r7, #8
 8021e24:	46bd      	mov	sp, r7
 8021e26:	bd80      	pop	{r7, pc}
 8021e28:	40028000 	.word	0x40028000

08021e2c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern>:
{
 8021e2c:	b580      	push	{r7, lr}
 8021e2e:	b082      	sub	sp, #8
 8021e30:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_MCM_GetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e32:	4805      	ldr	r0, [pc, #20]	; (8021e48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern+0x1c>)
 8021e34:	f7ff ff96 	bl	8021d64 <XMC_POSIF_MCM_GetMultiChannelPattern>
 8021e38:	4603      	mov	r3, r0
 8021e3a:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8021e3c:	88fb      	ldrh	r3, [r7, #6]
}
 8021e3e:	4618      	mov	r0, r3
 8021e40:	3708      	adds	r7, #8
 8021e42:	46bd      	mov	sp, r7
 8021e44:	bd80      	pop	{r7, pc}
 8021e46:	bf00      	nop
 8021e48:	40028000 	.word	0x40028000

08021e4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern>:
{
 8021e4c:	b580      	push	{r7, lr}
 8021e4e:	b082      	sub	sp, #8
 8021e50:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_MCM_GetShadowMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e52:	4805      	ldr	r0, [pc, #20]	; (8021e68 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern+0x1c>)
 8021e54:	f7ff ff93 	bl	8021d7e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>
 8021e58:	4603      	mov	r3, r0
 8021e5a:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8021e5c:	88fb      	ldrh	r3, [r7, #6]
}
 8021e5e:	4618      	mov	r0, r3
 8021e60:	3708      	adds	r7, #8
 8021e62:	46bd      	mov	sp, r7
 8021e64:	bd80      	pop	{r7, pc}
 8021e66:	bf00      	nop
 8021e68:	40028000 	.word	0x40028000

08021e6c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8021e6c:	b580      	push	{r7, lr}
 8021e6e:	b082      	sub	sp, #8
 8021e70:	af00      	add	r7, sp, #0
 8021e72:	4603      	mov	r3, r0
 8021e74:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021e76:	79fb      	ldrb	r3, [r7, #7]
 8021e78:	4619      	mov	r1, r3
 8021e7a:	4803      	ldr	r0, [pc, #12]	; (8021e88 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8021e7c:	f7ff ff52 	bl	8021d24 <XMC_POSIF_HSC_SetHallPatterns>
}
 8021e80:	bf00      	nop
 8021e82:	3708      	adds	r7, #8
 8021e84:	46bd      	mov	sp, r7
 8021e86:	bd80      	pop	{r7, pc}
 8021e88:	40028000 	.word	0x40028000

08021e8c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8021e8c:	b580      	push	{r7, lr}
 8021e8e:	b082      	sub	sp, #8
 8021e90:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e92:	4805      	ldr	r0, [pc, #20]	; (8021ea8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8021e94:	f7ff ff35 	bl	8021d02 <XMC_POSIF_HSC_GetExpectedPattern>
 8021e98:	4603      	mov	r3, r0
 8021e9a:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8021e9c:	79fb      	ldrb	r3, [r7, #7]
}
 8021e9e:	4618      	mov	r0, r3
 8021ea0:	3708      	adds	r7, #8
 8021ea2:	46bd      	mov	sp, r7
 8021ea4:	bd80      	pop	{r7, pc}
 8021ea6:	bf00      	nop
 8021ea8:	40028000 	.word	0x40028000

08021eac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
{
 8021eac:	b580      	push	{r7, lr}
 8021eae:	b082      	sub	sp, #8
 8021eb0:	af00      	add	r7, sp, #0
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021eb2:	4805      	ldr	r0, [pc, #20]	; (8021ec8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 8021eb4:	f7ff ff12 	bl	8021cdc <XMC_POSIF_HSC_GetLastSampledPattern>
 8021eb8:	4603      	mov	r3, r0
 8021eba:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 8021ebc:	79fb      	ldrb	r3, [r7, #7]
}
 8021ebe:	4618      	mov	r0, r3
 8021ec0:	3708      	adds	r7, #8
 8021ec2:	46bd      	mov	sp, r7
 8021ec4:	bd80      	pop	{r7, pc}
 8021ec6:	bf00      	nop
 8021ec8:	40028000 	.word	0x40028000

08021ecc <XMC_VADC_GROUP_GetResult>:
{
 8021ecc:	b480      	push	{r7}
 8021ece:	b083      	sub	sp, #12
 8021ed0:	af00      	add	r7, sp, #0
 8021ed2:	6078      	str	r0, [r7, #4]
 8021ed4:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8021ed6:	687b      	ldr	r3, [r7, #4]
 8021ed8:	683a      	ldr	r2, [r7, #0]
 8021eda:	32c0      	adds	r2, #192	; 0xc0
 8021edc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8021ee0:	b29b      	uxth	r3, r3
}
 8021ee2:	4618      	mov	r0, r3
 8021ee4:	370c      	adds	r7, #12
 8021ee6:	46bd      	mov	sp, r7
 8021ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021eec:	4770      	bx	lr

08021eee <VADC_GetResult>:
{
 8021eee:	b580      	push	{r7, lr}
 8021ef0:	b084      	sub	sp, #16
 8021ef2:	af00      	add	r7, sp, #0
 8021ef4:	6078      	str	r0, [r7, #4]
 8021ef6:	6039      	str	r1, [r7, #0]
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8021ef8:	6839      	ldr	r1, [r7, #0]
 8021efa:	6878      	ldr	r0, [r7, #4]
 8021efc:	f7ff ffe6 	bl	8021ecc <XMC_VADC_GROUP_GetResult>
 8021f00:	4603      	mov	r3, r0
 8021f02:	81fb      	strh	r3, [r7, #14]
  return(result);
 8021f04:	89fb      	ldrh	r3, [r7, #14]
}
 8021f06:	4618      	mov	r0, r3
 8021f08:	3710      	adds	r7, #16
 8021f0a:	46bd      	mov	sp, r7
 8021f0c:	bd80      	pop	{r7, pc}

08021f0e <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>:
{
 8021f0e:	b480      	push	{r7}
 8021f10:	b087      	sub	sp, #28
 8021f12:	af00      	add	r7, sp, #0
 8021f14:	60f8      	str	r0, [r7, #12]
 8021f16:	60b9      	str	r1, [r7, #8]
 8021f18:	607a      	str	r2, [r7, #4]
  if ( input_val > higher_limit )
 8021f1a:	68fa      	ldr	r2, [r7, #12]
 8021f1c:	68bb      	ldr	r3, [r7, #8]
 8021f1e:	429a      	cmp	r2, r3
 8021f20:	dd02      	ble.n	8021f28 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x1a>
    return_val = higher_limit;
 8021f22:	68bb      	ldr	r3, [r7, #8]
 8021f24:	617b      	str	r3, [r7, #20]
 8021f26:	e008      	b.n	8021f3a <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  else if ( input_val < lower_limit )
 8021f28:	68fa      	ldr	r2, [r7, #12]
 8021f2a:	687b      	ldr	r3, [r7, #4]
 8021f2c:	429a      	cmp	r2, r3
 8021f2e:	da02      	bge.n	8021f36 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x28>
    return_val = lower_limit;
 8021f30:	687b      	ldr	r3, [r7, #4]
 8021f32:	617b      	str	r3, [r7, #20]
 8021f34:	e001      	b.n	8021f3a <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
    return_val = input_val;
 8021f36:	68fb      	ldr	r3, [r7, #12]
 8021f38:	617b      	str	r3, [r7, #20]
  return return_val;
 8021f3a:	697b      	ldr	r3, [r7, #20]
}
 8021f3c:	4618      	mov	r0, r3
 8021f3e:	371c      	adds	r7, #28
 8021f40:	46bd      	mov	sp, r7
 8021f42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f46:	4770      	bx	lr

08021f48 <Motor0_BLDC_SCALAR_PT1_Filter>:
{
 8021f48:	b590      	push	{r4, r7, lr}
 8021f4a:	b083      	sub	sp, #12
 8021f4c:	af00      	add	r7, sp, #0
 8021f4e:	6078      	str	r0, [r7, #4]
 8021f50:	6039      	str	r1, [r7, #0]
  temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16)));
 8021f52:	687b      	ldr	r3, [r7, #4]
 8021f54:	691a      	ldr	r2, [r3, #16]
 8021f56:	687b      	ldr	r3, [r7, #4]
 8021f58:	681b      	ldr	r3, [r3, #0]
 8021f5a:	6879      	ldr	r1, [r7, #4]
 8021f5c:	6909      	ldr	r1, [r1, #16]
 8021f5e:	1409      	asrs	r1, r1, #16
 8021f60:	6838      	ldr	r0, [r7, #0]
 8021f62:	1a41      	subs	r1, r0, r1
 8021f64:	fb01 f303 	mul.w	r3, r1, r3
 8021f68:	18d4      	adds	r4, r2, r3
  handle_ptr->pt1_buf = Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(temp_buff, handle_ptr->y_max, handle_ptr->y_min);
 8021f6a:	687b      	ldr	r3, [r7, #4]
 8021f6c:	6899      	ldr	r1, [r3, #8]
 8021f6e:	687b      	ldr	r3, [r7, #4]
 8021f70:	68db      	ldr	r3, [r3, #12]
 8021f72:	461a      	mov	r2, r3
 8021f74:	4620      	mov	r0, r4
 8021f76:	f7ff ffca 	bl	8021f0e <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>
 8021f7a:	4602      	mov	r2, r0
 8021f7c:	687b      	ldr	r3, [r7, #4]
 8021f7e:	611a      	str	r2, [r3, #16]
  handle_ptr->pt1_out_val = (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16);
 8021f80:	687b      	ldr	r3, [r7, #4]
 8021f82:	691b      	ldr	r3, [r3, #16]
 8021f84:	141a      	asrs	r2, r3, #16
 8021f86:	687b      	ldr	r3, [r7, #4]
 8021f88:	615a      	str	r2, [r3, #20]
}
 8021f8a:	bf00      	nop
 8021f8c:	370c      	adds	r7, #12
 8021f8e:	46bd      	mov	sp, r7
 8021f90:	bd90      	pop	{r4, r7, pc}
	...

08021f94 <Motor0_BLDC_SCALAR_GetCurrentValue>:
{
 8021f94:	b580      	push	{r7, lr}
 8021f96:	b084      	sub	sp, #16
 8021f98:	af00      	add	r7, sp, #0
 8021f9a:	6078      	str	r0, [r7, #4]
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 8021f9c:	2105      	movs	r1, #5
 8021f9e:	4821      	ldr	r0, [pc, #132]	; (8022024 <Motor0_BLDC_SCALAR_GetCurrentValue+0x90>)
 8021fa0:	f7ff ffa5 	bl	8021eee <VADC_GetResult>
 8021fa4:	4603      	mov	r3, r0
 8021fa6:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 8021fa8:	4b1f      	ldr	r3, [pc, #124]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021faa:	681b      	ldr	r3, [r3, #0]
 8021fac:	68fa      	ldr	r2, [r7, #12]
 8021fae:	1ad3      	subs	r3, r2, r3
 8021fb0:	4a1d      	ldr	r2, [pc, #116]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fb2:	6892      	ldr	r2, [r2, #8]
 8021fb4:	fb02 f303 	mul.w	r3, r2, r3
 8021fb8:	139b      	asrs	r3, r3, #14
 8021fba:	60fb      	str	r3, [r7, #12]
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_DirectCurrent,(int32_t)current_value);
 8021fbc:	68f9      	ldr	r1, [r7, #12]
 8021fbe:	481b      	ldr	r0, [pc, #108]	; (802202c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021fc0:	f7ff ffc2 	bl	8021f48 <Motor0_BLDC_SCALAR_PT1_Filter>
  current_value = ((Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_out_val));
 8021fc4:	4b19      	ldr	r3, [pc, #100]	; (802202c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021fc6:	695b      	ldr	r3, [r3, #20]
 8021fc8:	60fb      	str	r3, [r7, #12]
  if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable == 1U)
 8021fca:	4b17      	ldr	r3, [pc, #92]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fcc:	f893 3020 	ldrb.w	r3, [r3, #32]
 8021fd0:	2b01      	cmp	r3, #1
 8021fd2:	d11c      	bne.n	802200e <Motor0_BLDC_SCALAR_GetCurrentValue+0x7a>
    Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter++;
 8021fd4:	4b14      	ldr	r3, [pc, #80]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fd6:	69db      	ldr	r3, [r3, #28]
 8021fd8:	3301      	adds	r3, #1
 8021fda:	4a13      	ldr	r2, [pc, #76]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fdc:	61d3      	str	r3, [r2, #28]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021fde:	4b12      	ldr	r3, [pc, #72]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fe0:	69da      	ldr	r2, [r3, #28]
        Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_count)
 8021fe2:	4b11      	ldr	r3, [pc, #68]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fe4:	699b      	ldr	r3, [r3, #24]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021fe6:	429a      	cmp	r2, r3
 8021fe8:	d90c      	bls.n	8022004 <Motor0_BLDC_SCALAR_GetCurrentValue+0x70>
     *dclink_current = current_value;
 8021fea:	687b      	ldr	r3, [r7, #4]
 8021fec:	68fa      	ldr	r2, [r7, #12]
 8021fee:	601a      	str	r2, [r3, #0]
     Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current = current_value;
 8021ff0:	4a0d      	ldr	r2, [pc, #52]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ff2:	68fb      	ldr	r3, [r7, #12]
 8021ff4:	6113      	str	r3, [r2, #16]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 8021ff6:	4b0c      	ldr	r3, [pc, #48]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ff8:	2200      	movs	r2, #0
 8021ffa:	61da      	str	r2, [r3, #28]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 0U;
 8021ffc:	4b0a      	ldr	r3, [pc, #40]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ffe:	2200      	movs	r2, #0
 8022000:	f883 2020 	strb.w	r2, [r3, #32]
    *dclink_current = Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current;
 8022004:	4b08      	ldr	r3, [pc, #32]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8022006:	691a      	ldr	r2, [r3, #16]
 8022008:	687b      	ldr	r3, [r7, #4]
 802200a:	601a      	str	r2, [r3, #0]
}
 802200c:	e005      	b.n	802201a <Motor0_BLDC_SCALAR_GetCurrentValue+0x86>
    *dclink_current = current_value;
 802200e:	687b      	ldr	r3, [r7, #4]
 8022010:	68fa      	ldr	r2, [r7, #12]
 8022012:	601a      	str	r2, [r3, #0]
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
 8022014:	4a04      	ldr	r2, [pc, #16]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8022016:	68fb      	ldr	r3, [r7, #12]
 8022018:	6113      	str	r3, [r2, #16]
}
 802201a:	bf00      	nop
 802201c:	3710      	adds	r7, #16
 802201e:	46bd      	mov	sp, r7
 8022020:	bd80      	pop	{r7, pc}
 8022022:	bf00      	nop
 8022024:	40005000 	.word	0x40005000
 8022028:	20000124 	.word	0x20000124
 802202c:	200000a4 	.word	0x200000a4

08022030 <VADC0_C0_0_IRQHandler>:
 * Current protection - Global boundary \n
 * Voltage protection - Group specific boundary \n
 */
#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
void Motor0_BLDC_SCALAR_Protection_ISR(void)
{
 8022030:	b580      	push	{r7, lr}
 8022032:	b082      	sub	sp, #8
 8022034:	af00      	add	r7, sp, #0
  int32_t current;   /* ADC value of the current in Q14 */
  /*******************************Current Protection ****************************************************/
  /* Direct DC link current measurement is used for over-current protection */
#if ((MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE == BLDC_SCALAR_IDC_DIRECT_CURRENT) && (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U))
  /* Check whether the interrupt is due to current limit overshoot */
  if ((((MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP->CEFLAG) >> MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM) & 0x1U) == 0x1U)
 8022036:	4b21      	ldr	r3, [pc, #132]	; (80220bc <VADC0_C0_0_IRQHandler+0x8c>)
 8022038:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 802203c:	095b      	lsrs	r3, r3, #5
 802203e:	f003 0301 	and.w	r3, r3, #1
 8022042:	2b01      	cmp	r3, #1
 8022044:	d135      	bne.n	80220b2 <VADC0_C0_0_IRQHandler+0x82>
  {
    /* Read the current value for short-circuit protection */
    Motor0_BLDC_SCALAR_GetCurrentValue(&current);
 8022046:	1d3b      	adds	r3, r7, #4
 8022048:	4618      	mov	r0, r3
 802204a:	f7ff ffa3 	bl	8021f94 <Motor0_BLDC_SCALAR_GetCurrentValue>
    if ((current > Motor0_BLDC_SCALAR_CurrentMeasurement.short_circuit_current) ||
 802204e:	4b1c      	ldr	r3, [pc, #112]	; (80220c0 <VADC0_C0_0_IRQHandler+0x90>)
 8022050:	68da      	ldr	r2, [r3, #12]
 8022052:	687b      	ldr	r3, [r7, #4]
 8022054:	429a      	cmp	r2, r3
 8022056:	db04      	blt.n	8022062 <VADC0_C0_0_IRQHandler+0x32>
        (current > BLDC_SCALAR_VADC_MAX_CURRENT_LIMIT))
 8022058:	687b      	ldr	r3, [r7, #4]
    if ((current > Motor0_BLDC_SCALAR_CurrentMeasurement.short_circuit_current) ||
 802205a:	f643 72d8 	movw	r2, #16344	; 0x3fd8
 802205e:	4293      	cmp	r3, r2
 8022060:	dd0c      	ble.n	802207c <VADC0_C0_0_IRQHandler+0x4c>
    {
      /* Stop the motor immediately if current is greater than configured short circuit current */
      Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_SHORTCIRCUIT;
 8022062:	4b18      	ldr	r3, [pc, #96]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022064:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8022066:	f043 0304 	orr.w	r3, r3, #4
 802206a:	4a16      	ldr	r2, [pc, #88]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802206c:	6693      	str	r3, [r2, #104]	; 0x68
      Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 802206e:	4b15      	ldr	r3, [pc, #84]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022070:	2208      	movs	r2, #8
 8022072:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      Motor0_BLDC_SCALAR_MotorStop();
 8022076:	f000 fc8f 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
      }
    }
  }
#endif /* end of #if (MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE == BLDC_SCALAR_IDC_AVG_CURRENT)*/
#endif
}
 802207a:	e01a      	b.n	80220b2 <VADC0_C0_0_IRQHandler+0x82>
      Motor0_BLDC_SCALAR.overcurrent_counter += 2U;
 802207c:	4b11      	ldr	r3, [pc, #68]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802207e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8022082:	3302      	adds	r3, #2
 8022084:	4a0f      	ldr	r2, [pc, #60]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022086:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
      if (Motor0_BLDC_SCALAR.overcurrent_counter > Motor0_BLDC_SCALAR.overcurrent_count)
 802208a:	4b0e      	ldr	r3, [pc, #56]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802208c:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8022090:	4b0c      	ldr	r3, [pc, #48]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022092:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8022096:	429a      	cmp	r2, r3
 8022098:	d90b      	bls.n	80220b2 <VADC0_C0_0_IRQHandler+0x82>
        Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_OVERCURRENT;
 802209a:	4b0a      	ldr	r3, [pc, #40]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802209c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 802209e:	f043 0302 	orr.w	r3, r3, #2
 80220a2:	4a08      	ldr	r2, [pc, #32]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 80220a4:	6693      	str	r3, [r2, #104]	; 0x68
        Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 80220a6:	4b07      	ldr	r3, [pc, #28]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 80220a8:	2208      	movs	r2, #8
 80220aa:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
        Motor0_BLDC_SCALAR_MotorStop();
 80220ae:	f000 fc73 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
}
 80220b2:	bf00      	nop
 80220b4:	3708      	adds	r7, #8
 80220b6:	46bd      	mov	sp, r7
 80220b8:	bd80      	pop	{r7, pc}
 80220ba:	bf00      	nop
 80220bc:	40005000 	.word	0x40005000
 80220c0:	20000124 	.word	0x20000124
 80220c4:	2000018c 	.word	0x2000018c

080220c8 <__NVIC_ClearPendingIRQ>:
{
 80220c8:	b480      	push	{r7}
 80220ca:	b083      	sub	sp, #12
 80220cc:	af00      	add	r7, sp, #0
 80220ce:	4603      	mov	r3, r0
 80220d0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80220d2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80220d6:	2b00      	cmp	r3, #0
 80220d8:	db0c      	blt.n	80220f4 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80220da:	79fb      	ldrb	r3, [r7, #7]
 80220dc:	f003 021f 	and.w	r2, r3, #31
 80220e0:	4907      	ldr	r1, [pc, #28]	; (8022100 <__NVIC_ClearPendingIRQ+0x38>)
 80220e2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80220e6:	095b      	lsrs	r3, r3, #5
 80220e8:	2001      	movs	r0, #1
 80220ea:	fa00 f202 	lsl.w	r2, r0, r2
 80220ee:	3360      	adds	r3, #96	; 0x60
 80220f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80220f4:	bf00      	nop
 80220f6:	370c      	adds	r7, #12
 80220f8:	46bd      	mov	sp, r7
 80220fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80220fe:	4770      	bx	lr
 8022100:	e000e100 	.word	0xe000e100

08022104 <XMC_SCU_SetCcuTriggerHigh>:
{
 8022104:	b480      	push	{r7}
 8022106:	b083      	sub	sp, #12
 8022108:	af00      	add	r7, sp, #0
 802210a:	6078      	str	r0, [r7, #4]
  SCU_GENERAL->CCUCON |= (uint32_t)trigger;
 802210c:	4b05      	ldr	r3, [pc, #20]	; (8022124 <XMC_SCU_SetCcuTriggerHigh+0x20>)
 802210e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8022110:	4904      	ldr	r1, [pc, #16]	; (8022124 <XMC_SCU_SetCcuTriggerHigh+0x20>)
 8022112:	687b      	ldr	r3, [r7, #4]
 8022114:	4313      	orrs	r3, r2
 8022116:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 8022118:	bf00      	nop
 802211a:	370c      	adds	r7, #12
 802211c:	46bd      	mov	sp, r7
 802211e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022122:	4770      	bx	lr
 8022124:	50004000 	.word	0x50004000

08022128 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8022128:	b480      	push	{r7}
 802212a:	b083      	sub	sp, #12
 802212c:	af00      	add	r7, sp, #0
 802212e:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8022130:	687b      	ldr	r3, [r7, #4]
 8022132:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022134:	08db      	lsrs	r3, r3, #3
 8022136:	b2db      	uxtb	r3, r3
 8022138:	f003 0307 	and.w	r3, r3, #7
 802213c:	b2db      	uxtb	r3, r3
}
 802213e:	4618      	mov	r0, r3
 8022140:	370c      	adds	r7, #12
 8022142:	46bd      	mov	sp, r7
 8022144:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022148:	4770      	bx	lr

0802214a <XMC_POSIF_HSC_SetHallPatterns>:
{
 802214a:	b480      	push	{r7}
 802214c:	b083      	sub	sp, #12
 802214e:	af00      	add	r7, sp, #0
 8022150:	6078      	str	r0, [r7, #4]
 8022152:	460b      	mov	r3, r1
 8022154:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8022156:	78fb      	ldrb	r3, [r7, #3]
 8022158:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 802215c:	687b      	ldr	r3, [r7, #4]
 802215e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8022160:	bf00      	nop
 8022162:	370c      	adds	r7, #12
 8022164:	46bd      	mov	sp, r7
 8022166:	f85d 7b04 	ldr.w	r7, [sp], #4
 802216a:	4770      	bx	lr

0802216c <XMC_POSIF_HSC_UpdateHallPattern>:
{
 802216c:	b480      	push	{r7}
 802216e:	b083      	sub	sp, #12
 8022170:	af00      	add	r7, sp, #0
 8022172:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 8022174:	687b      	ldr	r3, [r7, #4]
 8022176:	2202      	movs	r2, #2
 8022178:	649a      	str	r2, [r3, #72]	; 0x48
}
 802217a:	bf00      	nop
 802217c:	370c      	adds	r7, #12
 802217e:	46bd      	mov	sp, r7
 8022180:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022184:	4770      	bx	lr

08022186 <XMC_POSIF_DisableEvent>:
{
 8022186:	b480      	push	{r7}
 8022188:	b083      	sub	sp, #12
 802218a:	af00      	add	r7, sp, #0
 802218c:	6078      	str	r0, [r7, #4]
 802218e:	460b      	mov	r3, r1
 8022190:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE &= ~((uint32_t)1 << (uint8_t)event);
 8022192:	687b      	ldr	r3, [r7, #4]
 8022194:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8022196:	78fb      	ldrb	r3, [r7, #3]
 8022198:	2101      	movs	r1, #1
 802219a:	fa01 f303 	lsl.w	r3, r1, r3
 802219e:	43db      	mvns	r3, r3
 80221a0:	401a      	ands	r2, r3
 80221a2:	687b      	ldr	r3, [r7, #4]
 80221a4:	675a      	str	r2, [r3, #116]	; 0x74
}
 80221a6:	bf00      	nop
 80221a8:	370c      	adds	r7, #12
 80221aa:	46bd      	mov	sp, r7
 80221ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80221b0:	4770      	bx	lr

080221b2 <Motor0_BLDC_SCALAR_CCU8_PWM_Start>:
 *
 * \par<b>Description:</b><br>
 * Set CCUCON trigger signal to high to start all slices synchronously.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_PWM_Start(void)
{
 80221b2:	b580      	push	{r7, lr}
 80221b4:	af00      	add	r7, sp, #0
  XMC_SCU_SetCcuTriggerHigh((uint32_t)MOTOR0_BLDC_SCALAR_CCU8_SYNC_START);
 80221b6:	f44f 7080 	mov.w	r0, #256	; 0x100
 80221ba:	f7ff ffa3 	bl	8022104 <XMC_SCU_SetCcuTriggerHigh>
}
 80221be:	bf00      	nop
 80221c0:	bd80      	pop	{r7, pc}
	...

080221c4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
{
 80221c4:	b480      	push	{r7}
 80221c6:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 80221c8:	4b12      	ldr	r3, [pc, #72]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221ca:	2200      	movs	r2, #0
 80221cc:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 80221d0:	4b10      	ldr	r3, [pc, #64]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221d2:	2200      	movs	r2, #0
 80221d4:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 80221d6:	4b0f      	ldr	r3, [pc, #60]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221d8:	2200      	movs	r2, #0
 80221da:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 80221dc:	4b0d      	ldr	r3, [pc, #52]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221de:	2200      	movs	r2, #0
 80221e0:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 80221e2:	4b0c      	ldr	r3, [pc, #48]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221e4:	2200      	movs	r2, #0
 80221e6:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 80221e8:	4b0a      	ldr	r3, [pc, #40]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221ea:	2200      	movs	r2, #0
 80221ec:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 80221ee:	4b09      	ldr	r3, [pc, #36]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221f0:	2200      	movs	r2, #0
 80221f2:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 80221f4:	4b07      	ldr	r3, [pc, #28]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221f6:	2200      	movs	r2, #0
 80221f8:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 80221fa:	4b06      	ldr	r3, [pc, #24]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80221fe:	4a05      	ldr	r2, [pc, #20]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8022200:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 8022202:	4b04      	ldr	r3, [pc, #16]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8022204:	2200      	movs	r2, #0
 8022206:	621a      	str	r2, [r3, #32]
}
 8022208:	bf00      	nop
 802220a:	46bd      	mov	sp, r7
 802220c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022210:	4770      	bx	lr
 8022212:	bf00      	nop
 8022214:	200000f8 	.word	0x200000f8

08022218 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8022218:	b580      	push	{r7, lr}
 802221a:	b082      	sub	sp, #8
 802221c:	af00      	add	r7, sp, #0
 802221e:	4603      	mov	r3, r0
 8022220:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8022222:	79fb      	ldrb	r3, [r7, #7]
 8022224:	4619      	mov	r1, r3
 8022226:	4803      	ldr	r0, [pc, #12]	; (8022234 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8022228:	f7ff ff8f 	bl	802214a <XMC_POSIF_HSC_SetHallPatterns>
}
 802222c:	bf00      	nop
 802222e:	3708      	adds	r7, #8
 8022230:	46bd      	mov	sp, r7
 8022232:	bd80      	pop	{r7, pc}
 8022234:	40028000 	.word	0x40028000

08022238 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
{
 8022238:	b580      	push	{r7, lr}
 802223a:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802223c:	4802      	ldr	r0, [pc, #8]	; (8022248 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 802223e:	f7ff ff95 	bl	802216c <XMC_POSIF_HSC_UpdateHallPattern>
}
 8022242:	bf00      	nop
 8022244:	bd80      	pop	{r7, pc}
 8022246:	bf00      	nop
 8022248:	40028000 	.word	0x40028000

0802224c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 802224c:	b580      	push	{r7, lr}
 802224e:	b082      	sub	sp, #8
 8022250:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022252:	4805      	ldr	r0, [pc, #20]	; (8022268 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8022254:	f7ff ff68 	bl	8022128 <XMC_POSIF_HSC_GetExpectedPattern>
 8022258:	4603      	mov	r3, r0
 802225a:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 802225c:	79fb      	ldrb	r3, [r7, #7]
}
 802225e:	4618      	mov	r0, r3
 8022260:	3708      	adds	r7, #8
 8022262:	46bd      	mov	sp, r7
 8022264:	bd80      	pop	{r7, pc}
 8022266:	bf00      	nop
 8022268:	40028000 	.word	0x40028000

0802226c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>:
 *
 * \par<b>Description</b><br>
 * Disables event generation of peripheral.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 802226c:	b580      	push	{r7, lr}
 802226e:	b082      	sub	sp, #8
 8022270:	af00      	add	r7, sp, #0
 8022272:	4603      	mov	r3, r0
 8022274:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_DisableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8022276:	79fb      	ldrb	r3, [r7, #7]
 8022278:	4619      	mov	r1, r3
 802227a:	4803      	ldr	r0, [pc, #12]	; (8022288 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent+0x1c>)
 802227c:	f7ff ff83 	bl	8022186 <XMC_POSIF_DisableEvent>
}
 8022280:	bf00      	nop
 8022282:	3708      	adds	r7, #8
 8022284:	46bd      	mov	sp, r7
 8022286:	bd80      	pop	{r7, pc}
 8022288:	40028000 	.word	0x40028000

0802228c <Motor0_BLDC_SCALAR_MSM_START_Func>:
 * Initialize Motor control variables
 * Enable inverter
 * Enable interrupt for ctrap and protection
 */
static void Motor0_BLDC_SCALAR_MSM_START_Func(void)
{
 802228c:	b580      	push	{r7, lr}
 802228e:	af00      	add	r7, sp, #0
  /*Initialize all run time parameters*/
  Motor0_BLDC_SCALAR_MotorParamInit();
 8022290:	f000 fa7a 	bl	8022788 <Motor0_BLDC_SCALAR_MotorParamInit>
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*Enable inverter*/
  Motor0_BLDC_SCALAR_PWM_BC_InverterEnable();
 8022294:	f7fe fbbe 	bl	8020a14 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable>
  /* ISR Init for trap */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_CTRAP_NODE, MOTOR0_BLDC_SCALAR_TRAP_NVIC_PRIO,MOTOR0_BLDC_SCALAR_TRAP_NVIC_SUBPRIO);
#endif
#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  /* ISR Init for VADC channel event handler*/
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NODE, MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NVIC_PRIO,MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NVIC_SUBPRIO);
 8022298:	2200      	movs	r2, #0
 802229a:	213c      	movs	r1, #60	; 0x3c
 802229c:	200e      	movs	r0, #14
 802229e:	f7fe ff64 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
#endif

  Motor0_BLDC_SCALAR_MSM_START_Exit_Func();
 80222a2:	f000 f802 	bl	80222aa <Motor0_BLDC_SCALAR_MSM_START_Exit_Func>
}
 80222a6:	bf00      	nop
 80222a8:	bd80      	pop	{r7, pc}

080222aa <Motor0_BLDC_SCALAR_MSM_START_Exit_Func>:
 * BOOTSTRAP: if catch free running motor feature is disabled and bootstrap feature is enabled
 * HALL_LEARNING: if catch free running motor feature is disabled and bootstrap feature is disabled, and hall learning feature is enabled
 * NORMAL_OPERATION: if catch free running motor, bootstrap and hall learning features are disabled
 */
static void Motor0_BLDC_SCALAR_MSM_START_Exit_Func(void)
{
 80222aa:	b580      	push	{r7, lr}
 80222ac:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
  Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func();
 80222ae:	f000 f881 	bl	80223b4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func>
    Motor0_BLDC_SCALAR_MSM_HALL_LEARNING_Entry_Func();
  #else
    Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
  #endif
#endif  /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U) */
}
 80222b2:	bf00      	nop
 80222b4:	bd80      	pop	{r7, pc}
	...

080222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>:
 * Start the CCU8 for PWM
 * Disable correct hall event
 * Enable wrong hall event, multi-channel pattern shadow transfer event and CCU8 one match event
 */
static void Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func(void)
{
 80222b8:	b580      	push	{r7, lr}
 80222ba:	af00      	add	r7, sp, #0
  /* Disable correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 80222bc:	2000      	movs	r0, #0
 80222be:	f7ff ffd5 	bl	802226c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t) Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 80222c2:	f7fe fcab 	bl	8020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 80222c6:	4603      	mov	r3, r0
 80222c8:	b2da      	uxtb	r2, r3
 80222ca:	4b1a      	ldr	r3, [pc, #104]	; (8022334 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x7c>)
 80222cc:	745a      	strb	r2, [r3, #17]
  Motor0_BLDC_SCALAR_PatternInitiator(Motor0_BLDC_SCALAR_Hall.prev_hall_pos);
 80222ce:	4b19      	ldr	r3, [pc, #100]	; (8022334 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x7c>)
 80222d0:	7c5b      	ldrb	r3, [r3, #17]
 80222d2:	4618      	mov	r0, r3
 80222d4:	f008 ff40 	bl	802b158 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
  NVIC_ClearPendingIRQ(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE);
 80222d8:	2044      	movs	r0, #68	; 0x44
 80222da:	f7ff fef5 	bl	80220c8 <__NVIC_ClearPendingIRQ>

  /* POSIF is in running mode in MOTOR_STATE_IDENTIFICATION state */
  if (Motor0_BLDC_SCALAR.msm_state != BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION)
 80222de:	4b16      	ldr	r3, [pc, #88]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 80222e0:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 80222e4:	b2db      	uxtb	r3, r3
 80222e6:	2b02      	cmp	r3, #2
 80222e8:	d006      	beq.n	80222f8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x40>
  {
    /* Start POSIF */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start();
 80222ea:	f7fe fc69 	bl	8020bc0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>

    /* ISR Init for wrong hall event*/
    BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE,MOTOR0_BLDC_SCALAR_HALL_NVIC_PRIO,MOTOR0_BLDC_SCALAR_HALL_NVIC_SUBPRIO);
 80222ee:	2200      	movs	r2, #0
 80222f0:	213d      	movs	r1, #61	; 0x3d
 80222f2:	2044      	movs	r0, #68	; 0x44
 80222f4:	f7fe ff39 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
  }

  /* ISR Init for pattern update handler */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NODE, MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NVIC_PRIO, MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NVIC_SUBPRIO);
 80222f8:	2200      	movs	r2, #0
 80222fa:	213d      	movs	r1, #61	; 0x3d
 80222fc:	2045      	movs	r0, #69	; 0x45
 80222fe:	f7fe ff34 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
  /* ISR Init for control loop */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_CTRL_LOOP_NODE, MOTOR0_BLDC_SCALAR_CTRL_LOOP_NVIC_PRIO,MOTOR0_BLDC_SCALAR_CTRL_LOOP_NVIC_SUBPRIO);
 8022302:	2200      	movs	r2, #0
 8022304:	213e      	movs	r1, #62	; 0x3e
 8022306:	203c      	movs	r0, #60	; 0x3c
 8022308:	f7fe ff2f 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>

  if ((Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_START) || (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION))
 802230c:	4b0a      	ldr	r3, [pc, #40]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 802230e:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8022312:	b2db      	uxtb	r3, r3
 8022314:	2b01      	cmp	r3, #1
 8022316:	d005      	beq.n	8022324 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x6c>
 8022318:	4b07      	ldr	r3, [pc, #28]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 802231a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 802231e:	b2db      	uxtb	r3, r3
 8022320:	2b02      	cmp	r3, #2
 8022322:	d101      	bne.n	8022328 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x70>
  {
    /* Start CCU8 */
    Motor0_BLDC_SCALAR_CCU8_PWM_Start();
 8022324:	f7ff ff45 	bl	80221b2 <Motor0_BLDC_SCALAR_CCU8_PWM_Start>
  }
  Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_NORMAL_OPERATION;
 8022328:	4b03      	ldr	r3, [pc, #12]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 802232a:	2207      	movs	r2, #7
 802232c:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 8022330:	bf00      	nop
 8022332:	bd80      	pop	{r7, pc}
 8022334:	20000158 	.word	0x20000158
 8022338:	2000018c 	.word	0x2000018c

0802233c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func>:
 * Ramp
 * Stall detection
 * zero duty condition handling
 */
static void Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func(void)
{
 802233c:	b580      	push	{r7, lr}
 802233e:	b082      	sub	sp, #8
 8022340:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_AnalogIpMeasurement();
#endif

  /************************** Ramp start**************************/
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  Motor0_BLDC_SCALAR.set_val = Motor0_BLDC_SCALAR_Ramp.set_value;
 8022342:	4b18      	ldr	r3, [pc, #96]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022344:	681b      	ldr	r3, [r3, #0]
 8022346:	4a18      	ldr	r2, [pc, #96]	; (80223a8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 8022348:	6013      	str	r3, [r2, #0]
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR.analogip_val;
#else  /* potentiometer disabled */
  #if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  /* Speed control */
    Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 802234a:	4b18      	ldr	r3, [pc, #96]	; (80223ac <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x70>)
 802234c:	685b      	ldr	r3, [r3, #4]
 802234e:	4a15      	ldr	r2, [pc, #84]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022350:	6053      	str	r3, [r2, #4]
    Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR_VoltageControl.user_voltage_set;
  #endif

#endif /* end of #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U) */

  setval_diff =  ((Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value) *
 8022352:	4b14      	ldr	r3, [pc, #80]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022354:	685a      	ldr	r2, [r3, #4]
 8022356:	4b13      	ldr	r3, [pc, #76]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022358:	681b      	ldr	r3, [r3, #0]
 802235a:	1ad3      	subs	r3, r2, r3
                 Motor0_BLDC_SCALAR.motor_set_direction;
 802235c:	4a12      	ldr	r2, [pc, #72]	; (80223a8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 802235e:	6f92      	ldr	r2, [r2, #120]	; 0x78
  setval_diff =  ((Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value) *
 8022360:	fb02 f303 	mul.w	r3, r2, r3
 8022364:	607b      	str	r3, [r7, #4]

  /* Find whether ramp up or down is required based on set value */
  if (setval_diff < 0)
 8022366:	687b      	ldr	r3, [r7, #4]
 8022368:	2b00      	cmp	r3, #0
 802236a:	da04      	bge.n	8022376 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x3a>
  {
    Motor0_BLDC_SCALAR_Ramp.ramp_rate = Motor0_BLDC_SCALAR_Ramp.ramp_down_rate;
 802236c:	4b0d      	ldr	r3, [pc, #52]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802236e:	691b      	ldr	r3, [r3, #16]
 8022370:	4a0c      	ldr	r2, [pc, #48]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022372:	6093      	str	r3, [r2, #8]
 8022374:	e003      	b.n	802237e <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x42>
  }
  else
  {
    Motor0_BLDC_SCALAR_Ramp.ramp_rate = Motor0_BLDC_SCALAR_Ramp.ramp_up_rate;
 8022376:	4b0b      	ldr	r3, [pc, #44]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022378:	68db      	ldr	r3, [r3, #12]
 802237a:	4a0a      	ldr	r2, [pc, #40]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802237c:	6093      	str	r3, [r2, #8]
  {
    Motor0_BLDC_SCALAR_Ramp_Linear();
  }
  #else /* #if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_VDC_LINK_MEASUREMENT == 1U) */

  Motor0_BLDC_SCALAR_Ramp_Linear();
 802237e:	f008 fee7 	bl	802b150 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer>
    {
      Motor0_BLDC_SCALAR.stall_check = 1U;
    }
#endif
    /* zero speed handling */
    curr_psc = (uint32_t)((uint32_t)MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE->FPC >> BLDC_SCALAR_HALL_CAPVAL_POS);
 8022382:	4b0b      	ldr	r3, [pc, #44]	; (80223b0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x74>)
 8022384:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022386:	0a1b      	lsrs	r3, r3, #8
 8022388:	603b      	str	r3, [r7, #0]
    /* reset the speed calculation related variables when prescaler is greater 11 */
    if (curr_psc > BLDC_SCALAR_PRESCALER_CMP_VALUE)
 802238a:	683b      	ldr	r3, [r7, #0]
 802238c:	2b0b      	cmp	r3, #11
 802238e:	d904      	bls.n	802239a <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x5e>
    {
      /* Reset speed calculation related variables */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8022390:	f7ff ff18 	bl	80221c4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>
      Motor0_BLDC_SCALAR.motor_speed = 0;
 8022394:	4b04      	ldr	r3, [pc, #16]	; (80223a8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 8022396:	2200      	movs	r2, #0
 8022398:	66da      	str	r2, [r3, #108]	; 0x6c
  {
    Motor0_BLDC_SCALAR_MSM_IDLE_Entry_Func();
  }
#endif

}
 802239a:	bf00      	nop
 802239c:	3708      	adds	r7, #8
 802239e:	46bd      	mov	sp, r7
 80223a0:	bd80      	pop	{r7, pc}
 80223a2:	bf00      	nop
 80223a4:	200000bc 	.word	0x200000bc
 80223a8:	2000018c 	.word	0x2000018c
 80223ac:	20000148 	.word	0x20000148
 80223b0:	4000c200 	.word	0x4000c200

080223b4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func>:
 * Enable correct and wrong hall event
 */

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
static void Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func(void)
{
 80223b4:	b580      	push	{r7, lr}
 80223b6:	b082      	sub	sp, #8
 80223b8:	af00      	add	r7, sp, #0
  uint8_t pattern_index;       /* hall pattern index */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 80223ba:	4b1b      	ldr	r3, [pc, #108]	; (8022428 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 80223bc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80223be:	b2db      	uxtb	r3, r3
 80223c0:	f003 0308 	and.w	r3, r3, #8
 80223c4:	71fb      	strb	r3, [r7, #7]

  Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = Motor0_BLDC_SCALAR.motor_set_direction;
 80223c6:	4b18      	ldr	r3, [pc, #96]	; (8022428 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 80223c8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80223ca:	4a18      	ldr	r2, [pc, #96]	; (802242c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x78>)
 80223cc:	60d3      	str	r3, [r2, #12]

  /* Load initial hall pattern and start the POSIF */
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t) Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 80223ce:	f7fe fc25 	bl	8020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 80223d2:	4603      	mov	r3, r0
 80223d4:	b2da      	uxtb	r2, r3
 80223d6:	4b16      	ldr	r3, [pc, #88]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223d8:	745a      	strb	r2, [r3, #17]

  /* Update the hall pattern in shadow register and perform immediate transfer */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + (uint32_t) direction]));
 80223da:	4b15      	ldr	r3, [pc, #84]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223dc:	7c5b      	ldrb	r3, [r3, #17]
 80223de:	461a      	mov	r2, r3
 80223e0:	79fb      	ldrb	r3, [r7, #7]
 80223e2:	4413      	add	r3, r2
 80223e4:	4a12      	ldr	r2, [pc, #72]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223e6:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 80223e8:	4618      	mov	r0, r3
 80223ea:	f7ff ff15 	bl	8022218 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
 80223ee:	f7ff ff23 	bl	8022238 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>
  /*Get Expected Pattern*/
  pattern_index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 80223f2:	f7ff ff2b 	bl	802224c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 80223f6:	4603      	mov	r3, r0
 80223f8:	71bb      	strb	r3, [r7, #6]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pattern_index + (uint32_t) direction]));
 80223fa:	79ba      	ldrb	r2, [r7, #6]
 80223fc:	79fb      	ldrb	r3, [r7, #7]
 80223fe:	4413      	add	r3, r2
 8022400:	4a0b      	ldr	r2, [pc, #44]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 8022402:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8022404:	4618      	mov	r0, r3
 8022406:	f7ff ff07 	bl	8022218 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>

  /* Start POSIF */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start();
 802240a:	f7fe fbd9 	bl	8020bc0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>
  /* ISR Init for wrong hall event and correct hall event handler*/
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE, MOTOR0_BLDC_SCALAR_HALL_NVIC_PRIO,MOTOR0_BLDC_SCALAR_HALL_NVIC_SUBPRIO);
 802240e:	2200      	movs	r2, #0
 8022410:	213d      	movs	r1, #61	; 0x3d
 8022412:	2044      	movs	r0, #68	; 0x44
 8022414:	f7fe fea9 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
  /*Change Motor Control State to motor state identification */
  Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION;
 8022418:	4b03      	ldr	r3, [pc, #12]	; (8022428 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 802241a:	2202      	movs	r2, #2
 802241c:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 8022420:	bf00      	nop
 8022422:	3708      	adds	r7, #8
 8022424:	46bd      	mov	sp, r7
 8022426:	bd80      	pop	{r7, pc}
 8022428:	2000018c 	.word	0x2000018c
 802242c:	2000016c 	.word	0x2000016c
 8022430:	20000158 	.word	0x20000158

08022434 <Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func>:
/*
 * STATE_IDENTIFICATION state:
 * Wait for detection timeout or state identification flag to be set; whichever is earlier
 */
static void Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func(void)
{
 8022434:	b580      	push	{r7, lr}
 8022436:	af00      	add	r7, sp, #0
  if (BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED == Motor0_BLDC_SCALAR_State_Identification())
 8022438:	f000 f958 	bl	80226ec <Motor0_BLDC_SCALAR_State_Identification>
 802243c:	4603      	mov	r3, r0
 802243e:	2b01      	cmp	r3, #1
 8022440:	d101      	bne.n	8022446 <Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func+0x12>
  {
    Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func();
 8022442:	f000 f803 	bl	802244c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func>
  }
}
 8022446:	bf00      	nop
 8022448:	bd80      	pop	{r7, pc}
	...

0802244c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func>:
 *            if motor is running in reverse direction with speed less than threshold speed and bootstrap is enabled
 * HALL_LEARNING: if motor is freely running in the intended direction with speed less than threshold speed and bootstrap is disabled and hall learning is enabled OR
 *            if motor is running in reverse direction with speed less than threshold speed and bootstrap is disabled and hall learning is enabled
 */
static void Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func(void)
{
 802244c:	b580      	push	{r7, lr}
 802244e:	af00      	add	r7, sp, #0
  /* Disable correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8022450:	2000      	movs	r0, #0
 8022452:	f7ff ff0b 	bl	802226c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>

  /* Motor is freely running in the intended direction */
  if (Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction == Motor0_BLDC_SCALAR.motor_set_direction)
 8022456:	4b20      	ldr	r3, [pc, #128]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022458:	68da      	ldr	r2, [r3, #12]
 802245a:	4b20      	ldr	r3, [pc, #128]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802245c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802245e:	429a      	cmp	r2, r3
 8022460:	d118      	bne.n	8022494 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x48>
        Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
    #endif
    }
#else
    /* if speed is greater than threshold speed, go to closed loop operation */
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022462:	4b1e      	ldr	r3, [pc, #120]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022464:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022466:	4b1c      	ldr	r3, [pc, #112]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022468:	699b      	ldr	r3, [r3, #24]
 802246a:	429a      	cmp	r2, r3
 802246c:	dc06      	bgt.n	802247c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x30>
        (Motor0_BLDC_SCALAR.motor_speed < -Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed))
 802246e:	4b1b      	ldr	r3, [pc, #108]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022470:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022472:	4b19      	ldr	r3, [pc, #100]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022474:	699b      	ldr	r3, [r3, #24]
 8022476:	425b      	negs	r3, r3
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022478:	429a      	cmp	r2, r3
 802247a:	da06      	bge.n	802248a <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x3e>
    {
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) && (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U))
      Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR.motor_speed;
 802247c:	4b17      	ldr	r3, [pc, #92]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802247e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8022480:	4a17      	ldr	r2, [pc, #92]	; (80224e0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x94>)
 8022482:	6013      	str	r3, [r2, #0]
#endif
      /* Normal operation */
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 8022484:	f7ff ff18 	bl	80222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
 8022488:	e023      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
    else
    {
      /*Current amplifier bias voltage calibration*/
    #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U))
    #if (MOTOR0_BLDC_SCALAR_ENABLE_AMPLIFIER_OFFSET_CALIBRATION == 1U)
      Motor0_BLDC_SCALAR_AmpBiasVoltCalibration();
 802248a:	f7fe fa0b 	bl	80208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>
      if (BLDC_SCALAR_HALL_LEARNING_FLAG_DISABLED == Motor0_BLDC_SCALAR_Hall.hall_learning_flag)
      {
        Motor0_BLDC_SCALAR_MSM_HALL_LEARNING_Entry_Func();
      }
    #else
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 802248e:	f7ff ff13 	bl	80222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
    #else
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
    #endif
    }
  }
}
 8022492:	e01e      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022494:	4b11      	ldr	r3, [pc, #68]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022496:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022498:	4b0f      	ldr	r3, [pc, #60]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 802249a:	699b      	ldr	r3, [r3, #24]
 802249c:	429a      	cmp	r2, r3
 802249e:	dc06      	bgt.n	80224ae <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x62>
        (Motor0_BLDC_SCALAR.motor_speed < -Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed))
 80224a0:	4b0e      	ldr	r3, [pc, #56]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224a2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80224a4:	4b0c      	ldr	r3, [pc, #48]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 80224a6:	699b      	ldr	r3, [r3, #24]
 80224a8:	425b      	negs	r3, r3
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 80224aa:	429a      	cmp	r2, r3
 80224ac:	da0c      	bge.n	80224c8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x7c>
      Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 80224ae:	4b0b      	ldr	r3, [pc, #44]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224b0:	2208      	movs	r2, #8
 80224b2:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_MOTOR_FREE_RUNNING;
 80224b6:	4b09      	ldr	r3, [pc, #36]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80224ba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80224be:	4a07      	ldr	r2, [pc, #28]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224c0:	6693      	str	r3, [r2, #104]	; 0x68
      Motor0_BLDC_SCALAR_MotorStop();
 80224c2:	f000 fa69 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
 80224c6:	e004      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
      Motor0_BLDC_SCALAR_AmpBiasVoltCalibration();
 80224c8:	f7fe f9ec 	bl	80208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 80224cc:	f7ff fef4 	bl	80222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
}
 80224d0:	e7ff      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
 80224d2:	bf00      	nop
 80224d4:	bd80      	pop	{r7, pc}
 80224d6:	bf00      	nop
 80224d8:	2000016c 	.word	0x2000016c
 80224dc:	2000018c 	.word	0x2000018c
 80224e0:	200000bc 	.word	0x200000bc

080224e4 <Motor0_BLDC_SCALAR_MSM_ERROR_Func>:
/*
 * ERROR state:
 * Change the state to STOP when all the errors are cleared
 */
static void Motor0_BLDC_SCALAR_MSM_ERROR_Func(void)
{
 80224e4:	b480      	push	{r7}
 80224e6:	af00      	add	r7, sp, #0
/* Change the state to STOP when all the errors are cleared */
  if (Motor0_BLDC_SCALAR.error_status == 0U)
 80224e8:	4b06      	ldr	r3, [pc, #24]	; (8022504 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x20>)
 80224ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80224ec:	2b00      	cmp	r3, #0
 80224ee:	d103      	bne.n	80224f8 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x14>
  {
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
 80224f0:	4b04      	ldr	r3, [pc, #16]	; (8022504 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x20>)
 80224f2:	2200      	movs	r2, #0
 80224f4:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  }
}
 80224f8:	bf00      	nop
 80224fa:	46bd      	mov	sp, r7
 80224fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022500:	4770      	bx	lr
 8022502:	bf00      	nop
 8022504:	2000018c 	.word	0x2000018c

08022508 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8022508:	b480      	push	{r7}
 802250a:	b083      	sub	sp, #12
 802250c:	af00      	add	r7, sp, #0
 802250e:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8022510:	687b      	ldr	r3, [r7, #4]
 8022512:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022514:	08db      	lsrs	r3, r3, #3
 8022516:	b2db      	uxtb	r3, r3
 8022518:	f003 0307 	and.w	r3, r3, #7
 802251c:	b2db      	uxtb	r3, r3
}
 802251e:	4618      	mov	r0, r3
 8022520:	370c      	adds	r7, #12
 8022522:	46bd      	mov	sp, r7
 8022524:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022528:	4770      	bx	lr

0802252a <XMC_POSIF_HSC_SetHallPatterns>:
{
 802252a:	b480      	push	{r7}
 802252c:	b083      	sub	sp, #12
 802252e:	af00      	add	r7, sp, #0
 8022530:	6078      	str	r0, [r7, #4]
 8022532:	460b      	mov	r3, r1
 8022534:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8022536:	78fb      	ldrb	r3, [r7, #3]
 8022538:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 802253c:	687b      	ldr	r3, [r7, #4]
 802253e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8022540:	bf00      	nop
 8022542:	370c      	adds	r7, #12
 8022544:	46bd      	mov	sp, r7
 8022546:	f85d 7b04 	ldr.w	r7, [sp], #4
 802254a:	4770      	bx	lr

0802254c <XMC_POSIF_HSC_UpdateHallPattern>:
{
 802254c:	b480      	push	{r7}
 802254e:	b083      	sub	sp, #12
 8022550:	af00      	add	r7, sp, #0
 8022552:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 8022554:	687b      	ldr	r3, [r7, #4]
 8022556:	2202      	movs	r2, #2
 8022558:	649a      	str	r2, [r3, #72]	; 0x48
}
 802255a:	bf00      	nop
 802255c:	370c      	adds	r7, #12
 802255e:	46bd      	mov	sp, r7
 8022560:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022564:	4770      	bx	lr

08022566 <XMC_POSIF_MCM_SetMultiChannelPattern>:
{
 8022566:	b480      	push	{r7}
 8022568:	b083      	sub	sp, #12
 802256a:	af00      	add	r7, sp, #0
 802256c:	6078      	str	r0, [r7, #4]
 802256e:	460b      	mov	r3, r1
 8022570:	807b      	strh	r3, [r7, #2]
  peripheral->MCSM = pattern;
 8022572:	887a      	ldrh	r2, [r7, #2]
 8022574:	687b      	ldr	r3, [r7, #4]
 8022576:	645a      	str	r2, [r3, #68]	; 0x44
}
 8022578:	bf00      	nop
 802257a:	370c      	adds	r7, #12
 802257c:	46bd      	mov	sp, r7
 802257e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022582:	4770      	bx	lr

08022584 <XMC_POSIF_MCM_GetMultiChannelPattern>:
{
 8022584:	b480      	push	{r7}
 8022586:	b083      	sub	sp, #12
 8022588:	af00      	add	r7, sp, #0
 802258a:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCM & (uint32_t)POSIF_MCM_MCMP_Msk));
 802258c:	687b      	ldr	r3, [r7, #4]
 802258e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022590:	b29b      	uxth	r3, r3
}
 8022592:	4618      	mov	r0, r3
 8022594:	370c      	adds	r7, #12
 8022596:	46bd      	mov	sp, r7
 8022598:	f85d 7b04 	ldr.w	r7, [sp], #4
 802259c:	4770      	bx	lr

0802259e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>:
{
 802259e:	b480      	push	{r7}
 80225a0:	b083      	sub	sp, #12
 80225a2:	af00      	add	r7, sp, #0
 80225a4:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCSM & (uint32_t)POSIF_MCSM_MCMPS_Msk));
 80225a6:	687b      	ldr	r3, [r7, #4]
 80225a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80225aa:	b29b      	uxth	r3, r3
}
 80225ac:	4618      	mov	r0, r3
 80225ae:	370c      	adds	r7, #12
 80225b0:	46bd      	mov	sp, r7
 80225b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225b6:	4770      	bx	lr

080225b8 <XMC_POSIF_MCM_UpdateMultiChannelPattern>:
{
 80225b8:	b480      	push	{r7}
 80225ba:	b083      	sub	sp, #12
 80225bc:	af00      	add	r7, sp, #0
 80225be:	6078      	str	r0, [r7, #4]
  peripheral->MCMS |= (uint32_t)POSIF_MCMS_STMR_Msk;
 80225c0:	687b      	ldr	r3, [r7, #4]
 80225c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80225c4:	f043 0204 	orr.w	r2, r3, #4
 80225c8:	687b      	ldr	r3, [r7, #4]
 80225ca:	649a      	str	r2, [r3, #72]	; 0x48
}
 80225cc:	bf00      	nop
 80225ce:	370c      	adds	r7, #12
 80225d0:	46bd      	mov	sp, r7
 80225d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225d6:	4770      	bx	lr

080225d8 <XMC_POSIF_DisableEvent>:
{
 80225d8:	b480      	push	{r7}
 80225da:	b083      	sub	sp, #12
 80225dc:	af00      	add	r7, sp, #0
 80225de:	6078      	str	r0, [r7, #4]
 80225e0:	460b      	mov	r3, r1
 80225e2:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE &= ~((uint32_t)1 << (uint8_t)event);
 80225e4:	687b      	ldr	r3, [r7, #4]
 80225e6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80225e8:	78fb      	ldrb	r3, [r7, #3]
 80225ea:	2101      	movs	r1, #1
 80225ec:	fa01 f303 	lsl.w	r3, r1, r3
 80225f0:	43db      	mvns	r3, r3
 80225f2:	401a      	ands	r2, r3
 80225f4:	687b      	ldr	r3, [r7, #4]
 80225f6:	675a      	str	r2, [r3, #116]	; 0x74
}
 80225f8:	bf00      	nop
 80225fa:	370c      	adds	r7, #12
 80225fc:	46bd      	mov	sp, r7
 80225fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022602:	4770      	bx	lr

08022604 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Configures \a MCSM register with Multi-Channel Pattern.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(uint16_t pattern)
{
 8022604:	b580      	push	{r7, lr}
 8022606:	b082      	sub	sp, #8
 8022608:	af00      	add	r7, sp, #0
 802260a:	4603      	mov	r3, r0
 802260c:	80fb      	strh	r3, [r7, #6]

  XMC_POSIF_MCM_SetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 802260e:	88fb      	ldrh	r3, [r7, #6]
 8022610:	4619      	mov	r1, r3
 8022612:	4803      	ldr	r0, [pc, #12]	; (8022620 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern+0x1c>)
 8022614:	f7ff ffa7 	bl	8022566 <XMC_POSIF_MCM_SetMultiChannelPattern>

}
 8022618:	bf00      	nop
 802261a:	3708      	adds	r7, #8
 802261c:	46bd      	mov	sp, r7
 802261e:	bd80      	pop	{r7, pc}
 8022620:	40028000 	.word	0x40028000

08022624 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Performs shadow transfer of the Multi-Channel Pattern register by configuring.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern(void)
{
 8022624:	b580      	push	{r7, lr}
 8022626:	af00      	add	r7, sp, #0
  XMC_POSIF_MCM_UpdateMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022628:	4802      	ldr	r0, [pc, #8]	; (8022634 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern+0x10>)
 802262a:	f7ff ffc5 	bl	80225b8 <XMC_POSIF_MCM_UpdateMultiChannelPattern>
}
 802262e:	bf00      	nop
 8022630:	bd80      	pop	{r7, pc}
 8022632:	bf00      	nop
 8022634:	40028000 	.word	0x40028000

08022638 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Returns configured multi channel pattern of \a peripheral. \n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern(void)
{
 8022638:	b580      	push	{r7, lr}
 802263a:	b082      	sub	sp, #8
 802263c:	af00      	add	r7, sp, #0
  uint16_t pattern;
  pattern = XMC_POSIF_MCM_GetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802263e:	4805      	ldr	r0, [pc, #20]	; (8022654 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern+0x1c>)
 8022640:	f7ff ffa0 	bl	8022584 <XMC_POSIF_MCM_GetMultiChannelPattern>
 8022644:	4603      	mov	r3, r0
 8022646:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8022648:	88fb      	ldrh	r3, [r7, #6]
}
 802264a:	4618      	mov	r0, r3
 802264c:	3708      	adds	r7, #8
 802264e:	46bd      	mov	sp, r7
 8022650:	bd80      	pop	{r7, pc}
 8022652:	bf00      	nop
 8022654:	40028000 	.word	0x40028000

08022658 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Returns configured multi channel pattern in shadow register of \a peripheral. \n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern(void)
{
 8022658:	b580      	push	{r7, lr}
 802265a:	b082      	sub	sp, #8
 802265c:	af00      	add	r7, sp, #0
  uint16_t pattern;
  pattern = XMC_POSIF_MCM_GetShadowMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802265e:	4805      	ldr	r0, [pc, #20]	; (8022674 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern+0x1c>)
 8022660:	f7ff ff9d 	bl	802259e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>
 8022664:	4603      	mov	r3, r0
 8022666:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8022668:	88fb      	ldrh	r3, [r7, #6]
}
 802266a:	4618      	mov	r0, r3
 802266c:	3708      	adds	r7, #8
 802266e:	46bd      	mov	sp, r7
 8022670:	bd80      	pop	{r7, pc}
 8022672:	bf00      	nop
 8022674:	40028000 	.word	0x40028000

08022678 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
 *
 * \par<b>Description</b><br>
 * Configures current and expected hall pattern of \a peripheral. \n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(uint8_t pattern)
{
 8022678:	b580      	push	{r7, lr}
 802267a:	b082      	sub	sp, #8
 802267c:	af00      	add	r7, sp, #0
 802267e:	4603      	mov	r3, r0
 8022680:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8022682:	79fb      	ldrb	r3, [r7, #7]
 8022684:	4619      	mov	r1, r3
 8022686:	4803      	ldr	r0, [pc, #12]	; (8022694 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8022688:	f7ff ff4f 	bl	802252a <XMC_POSIF_HSC_SetHallPatterns>
}
 802268c:	bf00      	nop
 802268e:	3708      	adds	r7, #8
 8022690:	46bd      	mov	sp, r7
 8022692:	bd80      	pop	{r7, pc}
 8022694:	40028000 	.word	0x40028000

08022698 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
 * \par<b>Description</b><br>
 * The transfer of hall sensor pattern shadow registers content to the hall sensor pattern register happens
 * on hardware trigger.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern(void)
{
 8022698:	b580      	push	{r7, lr}
 802269a:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802269c:	4802      	ldr	r0, [pc, #8]	; (80226a8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 802269e:	f7ff ff55 	bl	802254c <XMC_POSIF_HSC_UpdateHallPattern>
}
 80226a2:	bf00      	nop
 80226a4:	bd80      	pop	{r7, pc}
 80226a6:	bf00      	nop
 80226a8:	40028000 	.word	0x40028000

080226ac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
 *
 * \par<b>Description</b><br>
 * Retrieves the expected hall sensor pattern from \a HALP register's \a HEP bit field of \a peripheral.\n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern(void)
{
 80226ac:	b580      	push	{r7, lr}
 80226ae:	b082      	sub	sp, #8
 80226b0:	af00      	add	r7, sp, #0
  uint8_t pattern;
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 80226b2:	4805      	ldr	r0, [pc, #20]	; (80226c8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 80226b4:	f7ff ff28 	bl	8022508 <XMC_POSIF_HSC_GetExpectedPattern>
 80226b8:	4603      	mov	r3, r0
 80226ba:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 80226bc:	79fb      	ldrb	r3, [r7, #7]
}
 80226be:	4618      	mov	r0, r3
 80226c0:	3708      	adds	r7, #8
 80226c2:	46bd      	mov	sp, r7
 80226c4:	bd80      	pop	{r7, pc}
 80226c6:	bf00      	nop
 80226c8:	40028000 	.word	0x40028000

080226cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>:
 *
 * \par<b>Description</b><br>
 * Disables event generation of peripheral.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 80226cc:	b580      	push	{r7, lr}
 80226ce:	b082      	sub	sp, #8
 80226d0:	af00      	add	r7, sp, #0
 80226d2:	4603      	mov	r3, r0
 80226d4:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_DisableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 80226d6:	79fb      	ldrb	r3, [r7, #7]
 80226d8:	4619      	mov	r1, r3
 80226da:	4803      	ldr	r0, [pc, #12]	; (80226e8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent+0x1c>)
 80226dc:	f7ff ff7c 	bl	80225d8 <XMC_POSIF_DisableEvent>
}
 80226e0:	bf00      	nop
 80226e2:	3708      	adds	r7, #8
 80226e4:	46bd      	mov	sp, r7
 80226e6:	bd80      	pop	{r7, pc}
 80226e8:	40028000 	.word	0x40028000

080226ec <Motor0_BLDC_SCALAR_State_Identification>:
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval, mcmshadow);
}

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
BLDC_SCALAR_STATE_IDENTIFICATION_t Motor0_BLDC_SCALAR_State_Identification(void)
{
 80226ec:	b580      	push	{r7, lr}
 80226ee:	b082      	sub	sp, #8
 80226f0:	af00      	add	r7, sp, #0
  BLDC_SCALAR_STATE_IDENTIFICATION_t status = BLDC_SCALAR_STATE_IDENTIFICATION_PROGRESS;
 80226f2:	2300      	movs	r3, #0
 80226f4:	71fb      	strb	r3, [r7, #7]
  uint32_t speed;
  /* 3 hall events are detected */
  if (Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 1U)
 80226f6:	4b21      	ldr	r3, [pc, #132]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 80226f8:	781b      	ldrb	r3, [r3, #0]
 80226fa:	2b01      	cmp	r3, #1
 80226fc:	d125      	bne.n	802274a <Motor0_BLDC_SCALAR_State_Identification+0x5e>
  {
    /* Calculate the speed and change the status */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 80226fe:	2000      	movs	r0, #0
 8022700:	f7ff ffe4 	bl	80226cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval = (Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval >> 1U) * BLDC_SCALAR_HALL_EVENTS_PER_CYCLE;
 8022704:	4b1d      	ldr	r3, [pc, #116]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022706:	685b      	ldr	r3, [r3, #4]
 8022708:	085a      	lsrs	r2, r3, #1
 802270a:	4613      	mov	r3, r2
 802270c:	005b      	lsls	r3, r3, #1
 802270e:	4413      	add	r3, r2
 8022710:	005b      	lsls	r3, r3, #1
 8022712:	461a      	mov	r2, r3
 8022714:	4b19      	ldr	r3, [pc, #100]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022716:	605a      	str	r2, [r3, #4]
    speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant / (Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval));
 8022718:	4b19      	ldr	r3, [pc, #100]	; (8022780 <Motor0_BLDC_SCALAR_State_Identification+0x94>)
 802271a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802271c:	4b17      	ldr	r3, [pc, #92]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802271e:	685b      	ldr	r3, [r3, #4]
 8022720:	fbb2 f3f3 	udiv	r3, r2, r3
 8022724:	603b      	str	r3, [r7, #0]
    speed = ((speed * Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8022726:	4b17      	ldr	r3, [pc, #92]	; (8022784 <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022728:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 802272c:	683a      	ldr	r2, [r7, #0]
 802272e:	fb02 f303 	mul.w	r3, r2, r3
 8022732:	0a9b      	lsrs	r3, r3, #10
 8022734:	603b      	str	r3, [r7, #0]
    Motor0_BLDC_SCALAR.motor_speed = (int32_t)((int32_t)speed * Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction);
 8022736:	4b11      	ldr	r3, [pc, #68]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022738:	68db      	ldr	r3, [r3, #12]
 802273a:	683a      	ldr	r2, [r7, #0]
 802273c:	fb02 f303 	mul.w	r3, r2, r3
 8022740:	4a10      	ldr	r2, [pc, #64]	; (8022784 <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022742:	66d3      	str	r3, [r2, #108]	; 0x6c
    status = BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED;
 8022744:	2301      	movs	r3, #1
 8022746:	71fb      	strb	r3, [r7, #7]
 8022748:	e012      	b.n	8022770 <Motor0_BLDC_SCALAR_State_Identification+0x84>
  }
  else
  {
    /* Wait for timeout */
    Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter++;
 802274a:	4b0c      	ldr	r3, [pc, #48]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802274c:	689b      	ldr	r3, [r3, #8]
 802274e:	3301      	adds	r3, #1
 8022750:	4a0a      	ldr	r2, [pc, #40]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022752:	6093      	str	r3, [r2, #8]
    if (Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter >= Motor0_BLDC_SCALAR_HALL_CatchFree.cf_detection_timeout)
 8022754:	4b09      	ldr	r3, [pc, #36]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022756:	689a      	ldr	r2, [r3, #8]
 8022758:	4b08      	ldr	r3, [pc, #32]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802275a:	69db      	ldr	r3, [r3, #28]
 802275c:	429a      	cmp	r2, r3
 802275e:	d307      	bcc.n	8022770 <Motor0_BLDC_SCALAR_State_Identification+0x84>
    {
      Motor0_BLDC_SCALAR.motor_speed = 0;
 8022760:	4b08      	ldr	r3, [pc, #32]	; (8022784 <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022762:	2200      	movs	r2, #0
 8022764:	66da      	str	r2, [r3, #108]	; 0x6c
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8022766:	2000      	movs	r0, #0
 8022768:	f7ff ffb0 	bl	80226cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
      status = BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED;
 802276c:	2301      	movs	r3, #1
 802276e:	71fb      	strb	r3, [r7, #7]
    }
  }
  return status;
 8022770:	79fb      	ldrb	r3, [r7, #7]
}
 8022772:	4618      	mov	r0, r3
 8022774:	3708      	adds	r7, #8
 8022776:	46bd      	mov	sp, r7
 8022778:	bd80      	pop	{r7, pc}
 802277a:	bf00      	nop
 802277c:	2000016c 	.word	0x2000016c
 8022780:	200000f8 	.word	0x200000f8
 8022784:	2000018c 	.word	0x2000018c

08022788 <Motor0_BLDC_SCALAR_MotorParamInit>:
 **********************************************************************************************************************/


/* Reset and Initialize of the motor control parameters */
void Motor0_BLDC_SCALAR_MotorParamInit(void)
{
 8022788:	b480      	push	{r7}
 802278a:	b083      	sub	sp, #12
 802278c:	af00      	add	r7, sp, #0
#endif
#if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U) && (MOTOR0_BLDC_SCALAR_ENABLE_BIDIRECTIONAL_CTRL == 1U))
  volatile uint32_t adc_conversion_delay;  /* wait for the conversion delay */
#endif
  /* Reset runtime control parameters */
  Motor0_BLDC_SCALAR.amplitude               = 0U;
 802278e:	4b2b      	ldr	r3, [pc, #172]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022790:	2200      	movs	r2, #0
 8022792:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  Motor0_BLDC_SCALAR.motor_speed             = 0;
 8022796:	4b29      	ldr	r3, [pc, #164]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022798:	2200      	movs	r2, #0
 802279a:	66da      	str	r2, [r3, #108]	; 0x6c
  Motor0_BLDC_SCALAR.motor_current           = 0;
 802279c:	4b27      	ldr	r3, [pc, #156]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 802279e:	2200      	movs	r2, #0
 80227a0:	671a      	str	r2, [r3, #112]	; 0x70
  Motor0_BLDC_SCALAR.motor_average_current   = 0;
 80227a2:	4b26      	ldr	r3, [pc, #152]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227a4:	2200      	movs	r2, #0
 80227a6:	675a      	str	r2, [r3, #116]	; 0x74
  Motor0_BLDC_SCALAR.dclink_voltage          = 0U;
 80227a8:	4b24      	ldr	r3, [pc, #144]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227aa:	2200      	movs	r2, #0
 80227ac:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  Motor0_BLDC_SCALAR.overcurrent_counter         = 0U;
 80227b0:	4b22      	ldr	r3, [pc, #136]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227b2:	2200      	movs	r2, #0
 80227b4:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#if (MOTOR0_BLDC_SCALAR_ENABLE_UNDER_OVER_VOLTAGE == 1U)
  Motor0_BLDC_SCALAR.over_under_voltage_counter  = 0U;
#endif
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING ==1U)
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 80227b8:	4b21      	ldr	r3, [pc, #132]	; (8022840 <Motor0_BLDC_SCALAR_MotorParamInit+0xb8>)
 80227ba:	2200      	movs	r2, #0
 80227bc:	61da      	str	r2, [r3, #28]
#endif /* if(MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
#if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_LINK_CURRENT_FILTER == 1U)
  Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_buf = 0;          /* Reset PT1 buffer */
 80227be:	4b21      	ldr	r3, [pc, #132]	; (8022844 <Motor0_BLDC_SCALAR_MotorParamInit+0xbc>)
 80227c0:	2200      	movs	r2, #0
 80227c2:	611a      	str	r2, [r3, #16]
#endif /* if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U) */
#endif

#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  start_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 80227c4:	4b20      	ldr	r3, [pc, #128]	; (8022848 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227c6:	681b      	ldr	r3, [r3, #0]
 80227c8:	607b      	str	r3, [r7, #4]
  end_value = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 80227ca:	4b1f      	ldr	r3, [pc, #124]	; (8022848 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227cc:	685b      	ldr	r3, [r3, #4]
 80227ce:	603b      	str	r3, [r7, #0]
    Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
  }
#else
  /* Initialize the rotation direction */
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  if (start_value == (int32_t)0)
 80227d0:	687b      	ldr	r3, [r7, #4]
 80227d2:	2b00      	cmp	r3, #0
 80227d4:	d10b      	bne.n	80227ee <Motor0_BLDC_SCALAR_MotorParamInit+0x66>
  {
    if (end_value >= (int32_t)0)
 80227d6:	683b      	ldr	r3, [r7, #0]
 80227d8:	2b00      	cmp	r3, #0
 80227da:	db03      	blt.n	80227e4 <Motor0_BLDC_SCALAR_MotorParamInit+0x5c>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 80227dc:	4b17      	ldr	r3, [pc, #92]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227de:	2201      	movs	r2, #1
 80227e0:	679a      	str	r2, [r3, #120]	; 0x78
 80227e2:	e00f      	b.n	8022804 <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
    else
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 80227e4:	4b15      	ldr	r3, [pc, #84]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227e6:	f04f 32ff 	mov.w	r2, #4294967295
 80227ea:	679a      	str	r2, [r3, #120]	; 0x78
 80227ec:	e00a      	b.n	8022804 <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
  }
  else
  {
    if (start_value > (int32_t)0)
 80227ee:	687b      	ldr	r3, [r7, #4]
 80227f0:	2b00      	cmp	r3, #0
 80227f2:	dd03      	ble.n	80227fc <Motor0_BLDC_SCALAR_MotorParamInit+0x74>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 80227f4:	4b11      	ldr	r3, [pc, #68]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227f6:	2201      	movs	r2, #1
 80227f8:	679a      	str	r2, [r3, #120]	; 0x78
 80227fa:	e003      	b.n	8022804 <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
    else
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 80227fc:	4b0f      	ldr	r3, [pc, #60]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227fe:	f04f 32ff 	mov.w	r2, #4294967295
 8022802:	679a      	str	r2, [r3, #120]	; 0x78
  {
    Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
  }
#endif
#endif
  Motor0_BLDC_SCALAR.actual_motor_direction = (Motor0_BLDC_SCALAR.motor_set_direction);
 8022804:	4b0d      	ldr	r3, [pc, #52]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022806:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8022808:	4a0c      	ldr	r2, [pc, #48]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 802280a:	67d3      	str	r3, [r2, #124]	; 0x7c
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)

  /* Start the ramp from start value if analog input is disabled */
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 802280c:	4b0e      	ldr	r3, [pc, #56]	; (8022848 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 802280e:	681b      	ldr	r3, [r3, #0]
 8022810:	4a0e      	ldr	r2, [pc, #56]	; (802284c <Motor0_BLDC_SCALAR_MotorParamInit+0xc4>)
 8022812:	6013      	str	r3, [r2, #0]

#endif /* if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U) */

  /* Reset the PI integral buffer */
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_SpeedControl_PI.ik = 0;
 8022814:	4b0e      	ldr	r3, [pc, #56]	; (8022850 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 8022816:	2200      	movs	r2, #0
 8022818:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SpeedControl_PI.uk = 0;
 802281a:	4b0d      	ldr	r3, [pc, #52]	; (8022850 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 802281c:	2200      	movs	r2, #0
 802281e:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SpeedControl_PI.sat_state = 1U;
 8022820:	4b0b      	ldr	r3, [pc, #44]	; (8022850 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 8022822:	2201      	movs	r2, #1
 8022824:	755a      	strb	r2, [r3, #21]
  Motor0_BLDC_SCALAR.speedcontrol_rate_counter = 0U;
 8022826:	4b05      	ldr	r3, [pc, #20]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022828:	2200      	movs	r2, #0
 802282a:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_CURRENT_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_CurrentControl_PI.ik = 0;
  Motor0_BLDC_SCALAR_CurrentControl_PI.sat_state = 1U;
#endif

}
 802282e:	bf00      	nop
 8022830:	370c      	adds	r7, #12
 8022832:	46bd      	mov	sp, r7
 8022834:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022838:	4770      	bx	lr
 802283a:	bf00      	nop
 802283c:	2000018c 	.word	0x2000018c
 8022840:	20000124 	.word	0x20000124
 8022844:	200000a4 	.word	0x200000a4
 8022848:	20000148 	.word	0x20000148
 802284c:	200000bc 	.word	0x200000bc
 8022850:	2000008c 	.word	0x2000008c

08022854 <Motor0_BLDC_SCALAR_MotorVarInit>:
/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/* One time initialization of the BLDC_SCALAR data structure variables based on configuration */
static void Motor0_BLDC_SCALAR_MotorVarInit(void)
{
 8022854:	b480      	push	{r7}
 8022856:	b083      	sub	sp, #12
 8022858:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)

  /* Start the ramp from start value if analog input is disabled */
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 802285a:	4b31      	ldr	r3, [pc, #196]	; (8022920 <Motor0_BLDC_SCALAR_MotorVarInit+0xcc>)
 802285c:	681b      	ldr	r3, [r3, #0]
 802285e:	4a31      	ldr	r2, [pc, #196]	; (8022924 <Motor0_BLDC_SCALAR_MotorVarInit+0xd0>)
 8022860:	6013      	str	r3, [r2, #0]

#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U) */

/******************start: mc_pattern table*****************************/
  /* multi-channel pattern generation for high side sync modulation */
  for (mcm_index = 0U; mcm_index <= BLDC_SCALAR_MCM_PATTERN_TABLE_SIZE; mcm_index++)
 8022862:	2300      	movs	r3, #0
 8022864:	71fb      	strb	r3, [r7, #7]
 8022866:	e050      	b.n	802290a <Motor0_BLDC_SCALAR_MotorVarInit+0xb6>
  {
    if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM))) ==
 8022868:	79fb      	ldrb	r3, [r7, #7]
 802286a:	4a2f      	ldr	r2, [pc, #188]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 802286c:	3310      	adds	r3, #16
 802286e:	005b      	lsls	r3, r3, #1
 8022870:	4413      	add	r3, r2
 8022872:	889b      	ldrh	r3, [r3, #4]
 8022874:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8022878:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802287c:	d10f      	bne.n	802289e <Motor0_BLDC_SCALAR_MotorVarInit+0x4a>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM))));
 802287e:	79fb      	ldrb	r3, [r7, #7]
 8022880:	4a29      	ldr	r2, [pc, #164]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 8022882:	3310      	adds	r3, #16
 8022884:	005b      	lsls	r3, r3, #1
 8022886:	4413      	add	r3, r2
 8022888:	889a      	ldrh	r2, [r3, #4]
 802288a:	79fb      	ldrb	r3, [r7, #7]
 802288c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8022890:	b291      	uxth	r1, r2
 8022892:	4a25      	ldr	r2, [pc, #148]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 8022894:	005b      	lsls	r3, r3, #1
 8022896:	4413      	add	r3, r2
 8022898:	460a      	mov	r2, r1
 802289a:	809a      	strh	r2, [r3, #4]
 802289c:	e032      	b.n	8022904 <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
    }
    else if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM))) ==
 802289e:	79fb      	ldrb	r3, [r7, #7]
 80228a0:	4a21      	ldr	r2, [pc, #132]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228a2:	3310      	adds	r3, #16
 80228a4:	005b      	lsls	r3, r3, #1
 80228a6:	4413      	add	r3, r2
 80228a8:	889b      	ldrh	r3, [r3, #4]
 80228aa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80228ae:	2b10      	cmp	r3, #16
 80228b0:	d10f      	bne.n	80228d2 <Motor0_BLDC_SCALAR_MotorVarInit+0x7e>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM))));
 80228b2:	79fb      	ldrb	r3, [r7, #7]
 80228b4:	4a1c      	ldr	r2, [pc, #112]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228b6:	3310      	adds	r3, #16
 80228b8:	005b      	lsls	r3, r3, #1
 80228ba:	4413      	add	r3, r2
 80228bc:	889a      	ldrh	r2, [r3, #4]
 80228be:	79fb      	ldrb	r3, [r7, #7]
 80228c0:	f042 0220 	orr.w	r2, r2, #32
 80228c4:	b291      	uxth	r1, r2
 80228c6:	4a18      	ldr	r2, [pc, #96]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228c8:	005b      	lsls	r3, r3, #1
 80228ca:	4413      	add	r3, r2
 80228cc:	460a      	mov	r2, r1
 80228ce:	809a      	strh	r2, [r3, #4]
 80228d0:	e018      	b.n	8022904 <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
    }
    else if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM))) ==
 80228d2:	79fb      	ldrb	r3, [r7, #7]
 80228d4:	4a14      	ldr	r2, [pc, #80]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228d6:	3310      	adds	r3, #16
 80228d8:	005b      	lsls	r3, r3, #1
 80228da:	4413      	add	r3, r2
 80228dc:	889b      	ldrh	r3, [r3, #4]
 80228de:	f003 030f 	and.w	r3, r3, #15
 80228e2:	2b01      	cmp	r3, #1
 80228e4:	d10e      	bne.n	8022904 <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM))));
 80228e6:	79fb      	ldrb	r3, [r7, #7]
 80228e8:	4a0f      	ldr	r2, [pc, #60]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228ea:	3310      	adds	r3, #16
 80228ec:	005b      	lsls	r3, r3, #1
 80228ee:	4413      	add	r3, r2
 80228f0:	889a      	ldrh	r2, [r3, #4]
 80228f2:	79fb      	ldrb	r3, [r7, #7]
 80228f4:	f042 0202 	orr.w	r2, r2, #2
 80228f8:	b291      	uxth	r1, r2
 80228fa:	4a0b      	ldr	r2, [pc, #44]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228fc:	005b      	lsls	r3, r3, #1
 80228fe:	4413      	add	r3, r2
 8022900:	460a      	mov	r2, r1
 8022902:	809a      	strh	r2, [r3, #4]
  for (mcm_index = 0U; mcm_index <= BLDC_SCALAR_MCM_PATTERN_TABLE_SIZE; mcm_index++)
 8022904:	79fb      	ldrb	r3, [r7, #7]
 8022906:	3301      	adds	r3, #1
 8022908:	71fb      	strb	r3, [r7, #7]
 802290a:	79fb      	ldrb	r3, [r7, #7]
 802290c:	2b0f      	cmp	r3, #15
 802290e:	d9ab      	bls.n	8022868 <Motor0_BLDC_SCALAR_MotorVarInit+0x14>

    }
  }
  /******************end: mc_pattern table*****************************/

}
 8022910:	bf00      	nop
 8022912:	bf00      	nop
 8022914:	370c      	adds	r7, #12
 8022916:	46bd      	mov	sp, r7
 8022918:	f85d 7b04 	ldr.w	r7, [sp], #4
 802291c:	4770      	bx	lr
 802291e:	bf00      	nop
 8022920:	20000148 	.word	0x20000148
 8022924:	200000bc 	.word	0x200000bc
 8022928:	2000018c 	.word	0x2000018c

0802292c <Motor0_BLDC_SCALAR_MeasurementInit>:


static void Motor0_BLDC_SCALAR_MeasurementInit(void)
{
 802292c:	b580      	push	{r7, lr}
 802292e:	af00      	add	r7, sp, #0
  /* Initialize VADC peripheral */
  Motor0_BLDC_SCALAR_VADC_Init();
 8022930:	f7fe fcbc 	bl	80212ac <Motor0_BLDC_SCALAR_VADC_Init>

  /* Channel,Result register and Queue entry configuration for configured channels */
  /* Calling sequence of below functions will decide the Queue entries sequence in corresponding Queues. */
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Current_Measurment_Init();
 8022934:	f7fd ff90 	bl	8020858 <Motor0_BLDC_SCALAR_Current_Measurment_Init>
  #endif

  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_USER_DEF4_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Volt_Userdef4_Init();
  #endif
}
 8022938:	bf00      	nop
 802293a:	bd80      	pop	{r7, pc}

0802293c <Motor0_BLDC_SCALAR_Init>:


/* Initialize the required peripherals, modules and interrupts */
void Motor0_BLDC_SCALAR_Init(void)
{
 802293c:	b580      	push	{r7, lr}
 802293e:	b082      	sub	sp, #8
 8022940:	af00      	add	r7, sp, #0
  volatile uint32_t delay_counter;

  /* Initialization settling period */
  for (delay_counter = 0U; delay_counter < (uint32_t)BLDC_SCALAR_SETTLING_TIME; delay_counter++)
 8022942:	2300      	movs	r3, #0
 8022944:	607b      	str	r3, [r7, #4]
 8022946:	e002      	b.n	802294e <Motor0_BLDC_SCALAR_Init+0x12>
 8022948:	687b      	ldr	r3, [r7, #4]
 802294a:	3301      	adds	r3, #1
 802294c:	607b      	str	r3, [r7, #4]
 802294e:	687b      	ldr	r3, [r7, #4]
 8022950:	4a07      	ldr	r2, [pc, #28]	; (8022970 <Motor0_BLDC_SCALAR_Init+0x34>)
 8022952:	4293      	cmp	r3, r2
 8022954:	d9f8      	bls.n	8022948 <Motor0_BLDC_SCALAR_Init+0xc>
  {

  }

  /* Initializes block commutation module along with the peripherals - CCU8, GPIO */
  Motor0_BLDC_SCALAR_PWM_BC_Init();
 8022956:	f7fe f841 	bl	80209dc <Motor0_BLDC_SCALAR_PWM_BC_Init>

  /* Initializes hall feedback module along with the peripherals - POSIF, CCU4, GPIO */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init();
 802295a:	f7fe f927 	bl	8020bac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init>

  /* Initializes measurement module along with the peripherals - VADC, GPIO */
  Motor0_BLDC_SCALAR_MeasurementInit();
 802295e:	f7ff ffe5 	bl	802292c <Motor0_BLDC_SCALAR_MeasurementInit>

  /* Initializes BLDC_SCALAR data structure elements based on the user configurations */
  Motor0_BLDC_SCALAR_MotorVarInit();
 8022962:	f7ff ff77 	bl	8022854 <Motor0_BLDC_SCALAR_MotorVarInit>

  /* Initializes systick - this will start the statemachine interrupt */
  //BLDC_SCALAR_SYSTICK_TIMER_Init();

}
 8022966:	bf00      	nop
 8022968:	3708      	adds	r7, #8
 802296a:	46bd      	mov	sp, r7
 802296c:	bd80      	pop	{r7, pc}
 802296e:	bf00      	nop
 8022970:	0007fffe 	.word	0x0007fffe

08022974 <Motor0_BLDC_SCALAR_MotorStart>:

void Motor0_BLDC_SCALAR_MotorStart(void)
{
 8022974:	b580      	push	{r7, lr}
 8022976:	af00      	add	r7, sp, #0
  /*
   * Motor State machine should be in STOP state to start the motor.
  * In case of any error, motor start function won't be started
  * until clear all the errors.
  */
  if (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_STOP)
 8022978:	4b06      	ldr	r3, [pc, #24]	; (8022994 <Motor0_BLDC_SCALAR_MotorStart+0x20>)
 802297a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 802297e:	b2db      	uxtb	r3, r3
 8022980:	2b00      	cmp	r3, #0
 8022982:	d105      	bne.n	8022990 <Motor0_BLDC_SCALAR_MotorStart+0x1c>
  {
     Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_START;
 8022984:	4b03      	ldr	r3, [pc, #12]	; (8022994 <Motor0_BLDC_SCALAR_MotorStart+0x20>)
 8022986:	2201      	movs	r2, #1
 8022988:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
     Motor0_BLDC_SCALAR_MSM();
 802298c:	f008 fbe8 	bl	802b160 <__Motor0_BLDC_SCALAR_MSM_veneer>
  }
}
 8022990:	bf00      	nop
 8022992:	bd80      	pop	{r7, pc}
 8022994:	2000018c 	.word	0x2000018c

08022998 <Motor0_BLDC_SCALAR_MotorStop>:

void Motor0_BLDC_SCALAR_MotorStop(void)
{
 8022998:	b580      	push	{r7, lr}
 802299a:	af00      	add	r7, sp, #0
  /*stop pwm bc*/
  Motor0_BLDC_SCALAR_PWM_BC_Stop();
 802299c:	f7fe f832 	bl	8020a04 <Motor0_BLDC_SCALAR_PWM_BC_Stop>

  /*stop posif*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop();
 80229a0:	f7fe f926 	bl	8020bf0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop>

#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*disable inverter*/
  Motor0_BLDC_SCALAR_PWM_BC_InverterDisable();
 80229a4:	f7fe f84e 	bl	8020a44 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>
#endif

  Motor0_BLDC_SCALAR.motor_speed = 0;
 80229a8:	4b0c      	ldr	r3, [pc, #48]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229aa:	2200      	movs	r2, #0
 80229ac:	66da      	str	r2, [r3, #108]	; 0x6c
  Motor0_BLDC_SCALAR.motor_current = 0;
 80229ae:	4b0b      	ldr	r3, [pc, #44]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229b0:	2200      	movs	r2, #0
 80229b2:	671a      	str	r2, [r3, #112]	; 0x70
  Motor0_BLDC_SCALAR.motor_average_current = 0;
 80229b4:	4b09      	ldr	r3, [pc, #36]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229b6:	2200      	movs	r2, #0
 80229b8:	675a      	str	r2, [r3, #116]	; 0x74

  if (Motor0_BLDC_SCALAR.error_status != 0U)
 80229ba:	4b08      	ldr	r3, [pc, #32]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229bc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80229be:	2b00      	cmp	r3, #0
 80229c0:	d006      	beq.n	80229d0 <Motor0_BLDC_SCALAR_MotorStop+0x38>
  {
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 80229c2:	4b06      	ldr	r3, [pc, #24]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229c4:	2208      	movs	r2, #8
 80229c6:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    /*Change motor control state machine to error*/
    Motor0_BLDC_SCALAR_MSM();
 80229ca:	f008 fbc9 	bl	802b160 <__Motor0_BLDC_SCALAR_MSM_veneer>
  else
  {
    /* Change motor control state machine to stop */
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
  }
}
 80229ce:	e003      	b.n	80229d8 <Motor0_BLDC_SCALAR_MotorStop+0x40>
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
 80229d0:	4b02      	ldr	r3, [pc, #8]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229d2:	2200      	movs	r2, #0
 80229d4:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 80229d8:	bf00      	nop
 80229da:	bd80      	pop	{r7, pc}
 80229dc:	2000018c 	.word	0x2000018c

080229e0 <Motor0_BLDC_SCALAR_GetMotorSpeed>:
 *
 * \par<b>Description:</b><br>
 * Updates the reference variable with the motor mechanical speed in RPM
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetMotorSpeed(int32_t *speed)
{
 80229e0:	b480      	push	{r7}
 80229e2:	b083      	sub	sp, #12
 80229e4:	af00      	add	r7, sp, #0
 80229e6:	6078      	str	r0, [r7, #4]
  *speed = ((Motor0_BLDC_SCALAR.motor_speed * (int32_t)Motor0_BLDC_SCALAR.speed_scale) >> BLDC_SCALAR_15);
 80229e8:	4b07      	ldr	r3, [pc, #28]	; (8022a08 <Motor0_BLDC_SCALAR_GetMotorSpeed+0x28>)
 80229ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80229ec:	4a06      	ldr	r2, [pc, #24]	; (8022a08 <Motor0_BLDC_SCALAR_GetMotorSpeed+0x28>)
 80229ee:	f8d2 20b0 	ldr.w	r2, [r2, #176]	; 0xb0
 80229f2:	fb02 f303 	mul.w	r3, r2, r3
 80229f6:	13da      	asrs	r2, r3, #15
 80229f8:	687b      	ldr	r3, [r7, #4]
 80229fa:	601a      	str	r2, [r3, #0]
}
 80229fc:	bf00      	nop
 80229fe:	370c      	adds	r7, #12
 8022a00:	46bd      	mov	sp, r7
 8022a02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022a06:	4770      	bx	lr
 8022a08:	2000018c 	.word	0x2000018c

08022a0c <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent>:
 *
 * \par<b>Description:</b><br>
 * Updates the reference variable with the motor DC link average current in mA
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent(int32_t *avg_current)
{
 8022a0c:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022a10:	b085      	sub	sp, #20
 8022a12:	af00      	add	r7, sp, #0
 8022a14:	60f8      	str	r0, [r7, #12]
  *avg_current = (int32_t)(((int64_t)BLDC_SCALAR_MILLI * Motor0_BLDC_SCALAR.motor_average_current *
 8022a16:	492a      	ldr	r1, [pc, #168]	; (8022ac0 <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent+0xb4>)
 8022a18:	6f49      	ldr	r1, [r1, #116]	; 0x74
 8022a1a:	17c8      	asrs	r0, r1, #31
 8022a1c:	6039      	str	r1, [r7, #0]
 8022a1e:	6078      	str	r0, [r7, #4]
                 (int32_t)Motor0_BLDC_SCALAR.current_scale) >> BLDC_SCALAR_15);
 8022a20:	4927      	ldr	r1, [pc, #156]	; (8022ac0 <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent+0xb4>)
 8022a22:	f8d1 10b4 	ldr.w	r1, [r1, #180]	; 0xb4
 8022a26:	17c8      	asrs	r0, r1, #31
 8022a28:	468a      	mov	sl, r1
 8022a2a:	4683      	mov	fp, r0
  *avg_current = (int32_t)(((int64_t)BLDC_SCALAR_MILLI * Motor0_BLDC_SCALAR.motor_average_current *
 8022a2c:	6879      	ldr	r1, [r7, #4]
 8022a2e:	fb0a f001 	mul.w	r0, sl, r1
 8022a32:	6839      	ldr	r1, [r7, #0]
 8022a34:	fb01 f10b 	mul.w	r1, r1, fp
 8022a38:	4401      	add	r1, r0
 8022a3a:	6838      	ldr	r0, [r7, #0]
 8022a3c:	fba0 230a 	umull	r2, r3, r0, sl
 8022a40:	4419      	add	r1, r3
 8022a42:	460b      	mov	r3, r1
 8022a44:	4610      	mov	r0, r2
 8022a46:	4619      	mov	r1, r3
 8022a48:	f04f 0a00 	mov.w	sl, #0
 8022a4c:	f04f 0b00 	mov.w	fp, #0
 8022a50:	ea4f 1b41 	mov.w	fp, r1, lsl #5
 8022a54:	ea4b 6bd0 	orr.w	fp, fp, r0, lsr #27
 8022a58:	ea4f 1a40 	mov.w	sl, r0, lsl #5
 8022a5c:	4650      	mov	r0, sl
 8022a5e:	4659      	mov	r1, fp
 8022a60:	1a84      	subs	r4, r0, r2
 8022a62:	eb61 0503 	sbc.w	r5, r1, r3
 8022a66:	f04f 0000 	mov.w	r0, #0
 8022a6a:	f04f 0100 	mov.w	r1, #0
 8022a6e:	00a9      	lsls	r1, r5, #2
 8022a70:	ea41 7194 	orr.w	r1, r1, r4, lsr #30
 8022a74:	00a0      	lsls	r0, r4, #2
 8022a76:	4604      	mov	r4, r0
 8022a78:	460d      	mov	r5, r1
 8022a7a:	eb14 0802 	adds.w	r8, r4, r2
 8022a7e:	eb45 0903 	adc.w	r9, r5, r3
 8022a82:	f04f 0200 	mov.w	r2, #0
 8022a86:	f04f 0300 	mov.w	r3, #0
 8022a8a:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8022a8e:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8022a92:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8022a96:	4690      	mov	r8, r2
 8022a98:	4699      	mov	r9, r3
 8022a9a:	4640      	mov	r0, r8
 8022a9c:	4649      	mov	r1, r9
                 (int32_t)Motor0_BLDC_SCALAR.current_scale) >> BLDC_SCALAR_15);
 8022a9e:	f04f 0200 	mov.w	r2, #0
 8022aa2:	f04f 0300 	mov.w	r3, #0
 8022aa6:	0bc2      	lsrs	r2, r0, #15
 8022aa8:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
 8022aac:	13cb      	asrs	r3, r1, #15
  *avg_current = (int32_t)(((int64_t)BLDC_SCALAR_MILLI * Motor0_BLDC_SCALAR.motor_average_current *
 8022aae:	68fb      	ldr	r3, [r7, #12]
 8022ab0:	601a      	str	r2, [r3, #0]
}
 8022ab2:	bf00      	nop
 8022ab4:	3714      	adds	r7, #20
 8022ab6:	46bd      	mov	sp, r7
 8022ab8:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022abc:	4770      	bx	lr
 8022abe:	bf00      	nop
 8022ac0:	2000018c 	.word	0x2000018c

08022ac4 <Motor0_BLDC_SCALAR_SetSpeedVal>:
 * -# -(MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED) to 0 for BLDC_SCALAR_NEGATIVE_DIR
 * -# 0 to (MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED) for BLDC_SCALAR_POSITIVE_DIR
 *
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedVal(int32_t speed)
{
 8022ac4:	b480      	push	{r7}
 8022ac6:	b085      	sub	sp, #20
 8022ac8:	af00      	add	r7, sp, #0
 8022aca:	6078      	str	r0, [r7, #4]
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022acc:	2302      	movs	r3, #2
 8022ace:	73fb      	strb	r3, [r7, #15]
  if ((speed <= (int32_t)MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED) && (speed >= -(int32_t)MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED))
 8022ad0:	687b      	ldr	r3, [r7, #4]
 8022ad2:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 8022ad6:	dc0e      	bgt.n	8022af6 <Motor0_BLDC_SCALAR_SetSpeedVal+0x32>
 8022ad8:	687b      	ldr	r3, [r7, #4]
 8022ada:	f513 6f96 	cmn.w	r3, #1200	; 0x4b0
 8022ade:	db0a      	blt.n	8022af6 <Motor0_BLDC_SCALAR_SetSpeedVal+0x32>
  {
    Motor0_BLDC_SCALAR_SpeedControl.user_speed_set =
        ((speed << BLDC_SCALAR_15) / (int32_t)Motor0_BLDC_SCALAR.speed_scale);
 8022ae0:	687b      	ldr	r3, [r7, #4]
 8022ae2:	03db      	lsls	r3, r3, #15
 8022ae4:	4a07      	ldr	r2, [pc, #28]	; (8022b04 <Motor0_BLDC_SCALAR_SetSpeedVal+0x40>)
 8022ae6:	f8d2 20b0 	ldr.w	r2, [r2, #176]	; 0xb0
 8022aea:	fb93 f3f2 	sdiv	r3, r3, r2
    Motor0_BLDC_SCALAR_SpeedControl.user_speed_set =
 8022aee:	4a06      	ldr	r2, [pc, #24]	; (8022b08 <Motor0_BLDC_SCALAR_SetSpeedVal+0x44>)
 8022af0:	6053      	str	r3, [r2, #4]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022af2:	2300      	movs	r3, #0
 8022af4:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022af6:	7bfb      	ldrb	r3, [r7, #15]
}
 8022af8:	4618      	mov	r0, r3
 8022afa:	3714      	adds	r7, #20
 8022afc:	46bd      	mov	sp, r7
 8022afe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b02:	4770      	bx	lr
 8022b04:	2000018c 	.word	0x2000018c
 8022b08:	20000148 	.word	0x20000148

08022b0c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain>:
 *
 * \par<b>Description:</b><br>
 * Sets the proportional gain of the speed PI control.
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedProportionalGain(uint16_t kp)
{
 8022b0c:	b480      	push	{r7}
 8022b0e:	b085      	sub	sp, #20
 8022b10:	af00      	add	r7, sp, #0
 8022b12:	4603      	mov	r3, r0
 8022b14:	80fb      	strh	r3, [r7, #6]
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022b16:	2302      	movs	r3, #2
 8022b18:	73fb      	strb	r3, [r7, #15]
  if (kp <= BLDC_SCALAR_POW_15)
 8022b1a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8022b1e:	2b00      	cmp	r3, #0
 8022b20:	db04      	blt.n	8022b2c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain+0x20>
  {
    Motor0_BLDC_SCALAR_SpeedControl_PI.kp = kp;
 8022b22:	4a06      	ldr	r2, [pc, #24]	; (8022b3c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain+0x30>)
 8022b24:	88fb      	ldrh	r3, [r7, #6]
 8022b26:	8213      	strh	r3, [r2, #16]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022b28:	2300      	movs	r3, #0
 8022b2a:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022b2c:	7bfb      	ldrb	r3, [r7, #15]
}
 8022b2e:	4618      	mov	r0, r3
 8022b30:	3714      	adds	r7, #20
 8022b32:	46bd      	mov	sp, r7
 8022b34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b38:	4770      	bx	lr
 8022b3a:	bf00      	nop
 8022b3c:	2000008c 	.word	0x2000008c

08022b40 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain>:
 *
 * \par<b>Description:</b><br>
 * Sets the integral gain of the speed PI control.
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedIntegralGain(uint16_t ki)
{
 8022b40:	b480      	push	{r7}
 8022b42:	b085      	sub	sp, #20
 8022b44:	af00      	add	r7, sp, #0
 8022b46:	4603      	mov	r3, r0
 8022b48:	80fb      	strh	r3, [r7, #6]
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022b4a:	2302      	movs	r3, #2
 8022b4c:	73fb      	strb	r3, [r7, #15]
  if (ki <= BLDC_SCALAR_POW_15)
 8022b4e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8022b52:	2b00      	cmp	r3, #0
 8022b54:	db04      	blt.n	8022b60 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain+0x20>
  {
    Motor0_BLDC_SCALAR_SpeedControl_PI.ki = ki;
 8022b56:	4a06      	ldr	r2, [pc, #24]	; (8022b70 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain+0x30>)
 8022b58:	88fb      	ldrh	r3, [r7, #6]
 8022b5a:	8253      	strh	r3, [r2, #18]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022b5c:	2300      	movs	r3, #0
 8022b5e:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022b60:	7bfb      	ldrb	r3, [r7, #15]
}
 8022b62:	4618      	mov	r0, r3
 8022b64:	3714      	adds	r7, #20
 8022b66:	46bd      	mov	sp, r7
 8022b68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b6c:	4770      	bx	lr
 8022b6e:	bf00      	nop
 8022b70:	2000008c 	.word	0x2000008c

08022b74 <Motor0_BLDC_SCALAR_SetSpeedPILimit>:
 *
 * \par<b>Description:</b><br>
 * Sets the speed PI output limit
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedPILimit(uint8_t percentage_limit)
{
 8022b74:	b480      	push	{r7}
 8022b76:	b085      	sub	sp, #20
 8022b78:	af00      	add	r7, sp, #0
 8022b7a:	4603      	mov	r3, r0
 8022b7c:	71fb      	strb	r3, [r7, #7]
  uint32_t limit;
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022b7e:	2302      	movs	r3, #2
 8022b80:	73fb      	strb	r3, [r7, #15]
  if (percentage_limit <= (uint8_t)BLDC_SCALAR_PERCENTAGE)
 8022b82:	79fb      	ldrb	r3, [r7, #7]
 8022b84:	2b64      	cmp	r3, #100	; 0x64
 8022b86:	d811      	bhi.n	8022bac <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x38>
  {
    limit = (BLDC_SCALAR_POW_14 * (uint32_t)percentage_limit) / (uint32_t)BLDC_SCALAR_PERCENTAGE;
 8022b88:	79fa      	ldrb	r2, [r7, #7]
 8022b8a:	4613      	mov	r3, r2
 8022b8c:	039b      	lsls	r3, r3, #14
 8022b8e:	1a9b      	subs	r3, r3, r2
 8022b90:	4a0a      	ldr	r2, [pc, #40]	; (8022bbc <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x48>)
 8022b92:	fba2 2303 	umull	r2, r3, r2, r3
 8022b96:	095b      	lsrs	r3, r3, #5
 8022b98:	60bb      	str	r3, [r7, #8]
    Motor0_BLDC_SCALAR_SpeedControl_PI.uk_limit_max = (int32_t)limit;
 8022b9a:	68bb      	ldr	r3, [r7, #8]
 8022b9c:	4a08      	ldr	r2, [pc, #32]	; (8022bc0 <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x4c>)
 8022b9e:	60d3      	str	r3, [r2, #12]
    Motor0_BLDC_SCALAR_SpeedControl_PI.uk_limit_min = -(int32_t)limit;
 8022ba0:	68bb      	ldr	r3, [r7, #8]
 8022ba2:	425b      	negs	r3, r3
 8022ba4:	4a06      	ldr	r2, [pc, #24]	; (8022bc0 <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x4c>)
 8022ba6:	6093      	str	r3, [r2, #8]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022ba8:	2300      	movs	r3, #0
 8022baa:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022bac:	7bfb      	ldrb	r3, [r7, #15]
}
 8022bae:	4618      	mov	r0, r3
 8022bb0:	3714      	adds	r7, #20
 8022bb2:	46bd      	mov	sp, r7
 8022bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022bb8:	4770      	bx	lr
 8022bba:	bf00      	nop
 8022bbc:	51eb851f 	.word	0x51eb851f
 8022bc0:	2000008c 	.word	0x2000008c

08022bc4 <Motor0_BLDC_SCALAR_ClearErrorState>:
 *
 * \par<b>Description:</b><br>
 * This API should be called to clear errors before restarting the motor.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_ClearErrorState(void)
{
 8022bc4:	b480      	push	{r7}
 8022bc6:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR.error_status = 0U;
 8022bc8:	4b03      	ldr	r3, [pc, #12]	; (8022bd8 <Motor0_BLDC_SCALAR_ClearErrorState+0x14>)
 8022bca:	2200      	movs	r2, #0
 8022bcc:	669a      	str	r2, [r3, #104]	; 0x68
}
 8022bce:	bf00      	nop
 8022bd0:	46bd      	mov	sp, r7
 8022bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022bd6:	4770      	bx	lr
 8022bd8:	2000018c 	.word	0x2000018c

08022bdc <MotorInit>:
void HallTimerProc(void *args);
void MotorStepProc(void *args);


void MotorInit (void)
{
 8022bdc:	b580      	push	{r7, lr}
 8022bde:	af00      	add	r7, sp, #0
    MotorStepTimer = SYSTIMER_CreateTimer(1000, SYSTIMER_MODE_PERIODIC, MotorStepProc, NULL );
 8022be0:	2300      	movs	r3, #0
 8022be2:	4a11      	ldr	r2, [pc, #68]	; (8022c28 <MotorInit+0x4c>)
 8022be4:	2101      	movs	r1, #1
 8022be6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8022bea:	f006 fa9d 	bl	8029128 <SYSTIMER_CreateTimer>
 8022bee:	4603      	mov	r3, r0
 8022bf0:	461a      	mov	r2, r3
 8022bf2:	4b0e      	ldr	r3, [pc, #56]	; (8022c2c <MotorInit+0x50>)
 8022bf4:	601a      	str	r2, [r3, #0]
	HallTimer = SYSTIMER_CreateTimer(100, SYSTIMER_MODE_PERIODIC, HallTimerProc, NULL );
 8022bf6:	2300      	movs	r3, #0
 8022bf8:	4a0d      	ldr	r2, [pc, #52]	; (8022c30 <MotorInit+0x54>)
 8022bfa:	2101      	movs	r1, #1
 8022bfc:	2064      	movs	r0, #100	; 0x64
 8022bfe:	f006 fa93 	bl	8029128 <SYSTIMER_CreateTimer>
 8022c02:	4603      	mov	r3, r0
 8022c04:	461a      	mov	r2, r3
 8022c06:	4b0b      	ldr	r3, [pc, #44]	; (8022c34 <MotorInit+0x58>)
 8022c08:	601a      	str	r2, [r3, #0]

	SYSTIMER_StartTimer(HallTimer);
 8022c0a:	4b0a      	ldr	r3, [pc, #40]	; (8022c34 <MotorInit+0x58>)
 8022c0c:	681b      	ldr	r3, [r3, #0]
 8022c0e:	4618      	mov	r0, r3
 8022c10:	f006 fb28 	bl	8029264 <SYSTIMER_StartTimer>
	SYSTIMER_StartTimer(MotorStepTimer);
 8022c14:	4b05      	ldr	r3, [pc, #20]	; (8022c2c <MotorInit+0x50>)
 8022c16:	681b      	ldr	r3, [r3, #0]
 8022c18:	4618      	mov	r0, r3
 8022c1a:	f006 fb23 	bl	8029264 <SYSTIMER_StartTimer>
    Motor0_BLDC_SCALAR_Init();
 8022c1e:	f7ff fe8d 	bl	802293c <Motor0_BLDC_SCALAR_Init>
}
 8022c22:	bf00      	nop
 8022c24:	bd80      	pop	{r7, pc}
 8022c26:	bf00      	nop
 8022c28:	08022e75 	.word	0x08022e75
 8022c2c:	20000618 	.word	0x20000618
 8022c30:	08022d11 	.word	0x08022d11
 8022c34:	2000061c 	.word	0x2000061c

08022c38 <MotorStart>:

void MotorStart(void)
{
 8022c38:	b580      	push	{r7, lr}
 8022c3a:	af00      	add	r7, sp, #0
	Motor0_BLDC_SCALAR_MotorStart();
 8022c3c:	f7ff fe9a 	bl	8022974 <Motor0_BLDC_SCALAR_MotorStart>
}
 8022c40:	bf00      	nop
 8022c42:	bd80      	pop	{r7, pc}

08022c44 <MotorStop>:
void MotorStop(void)
{
 8022c44:	b580      	push	{r7, lr}
 8022c46:	af00      	add	r7, sp, #0
	Motor0_BLDC_SCALAR_MotorStop();
 8022c48:	f7ff fea6 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
}
 8022c4c:	bf00      	nop
 8022c4e:	bd80      	pop	{r7, pc}

08022c50 <MotorSetSpeed>:

void MotorSetSpeed(int32_t speed)
{
 8022c50:	b580      	push	{r7, lr}
 8022c52:	b082      	sub	sp, #8
 8022c54:	af00      	add	r7, sp, #0
 8022c56:	6078      	str	r0, [r7, #4]
	Motor0_BLDC_SCALAR_SetSpeedVal(speed);
 8022c58:	6878      	ldr	r0, [r7, #4]
 8022c5a:	f7ff ff33 	bl	8022ac4 <Motor0_BLDC_SCALAR_SetSpeedVal>
}
 8022c5e:	bf00      	nop
 8022c60:	3708      	adds	r7, #8
 8022c62:	46bd      	mov	sp, r7
 8022c64:	bd80      	pop	{r7, pc}

08022c66 <MotorSetProportionalGain>:
void MotorSetProportionalGain(uint16_t kp)
{
 8022c66:	b580      	push	{r7, lr}
 8022c68:	b082      	sub	sp, #8
 8022c6a:	af00      	add	r7, sp, #0
 8022c6c:	4603      	mov	r3, r0
 8022c6e:	80fb      	strh	r3, [r7, #6]
	Motor0_BLDC_SCALAR_SetSpeedProportionalGain(kp);
 8022c70:	88fb      	ldrh	r3, [r7, #6]
 8022c72:	4618      	mov	r0, r3
 8022c74:	f7ff ff4a 	bl	8022b0c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain>
}
 8022c78:	bf00      	nop
 8022c7a:	3708      	adds	r7, #8
 8022c7c:	46bd      	mov	sp, r7
 8022c7e:	bd80      	pop	{r7, pc}

08022c80 <MotorSetIntegralGain>:
void MotorSetIntegralGain(uint16_t ki)
{
 8022c80:	b580      	push	{r7, lr}
 8022c82:	b082      	sub	sp, #8
 8022c84:	af00      	add	r7, sp, #0
 8022c86:	4603      	mov	r3, r0
 8022c88:	80fb      	strh	r3, [r7, #6]
	Motor0_BLDC_SCALAR_SetSpeedIntegralGain(ki);
 8022c8a:	88fb      	ldrh	r3, [r7, #6]
 8022c8c:	4618      	mov	r0, r3
 8022c8e:	f7ff ff57 	bl	8022b40 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain>
}
 8022c92:	bf00      	nop
 8022c94:	3708      	adds	r7, #8
 8022c96:	46bd      	mov	sp, r7
 8022c98:	bd80      	pop	{r7, pc}

08022c9a <MotorSetPILimit>:
void MotorSetPILimit(uint8_t percent_limit)
{
 8022c9a:	b580      	push	{r7, lr}
 8022c9c:	b082      	sub	sp, #8
 8022c9e:	af00      	add	r7, sp, #0
 8022ca0:	4603      	mov	r3, r0
 8022ca2:	71fb      	strb	r3, [r7, #7]
	Motor0_BLDC_SCALAR_SetSpeedPILimit(percent_limit);
 8022ca4:	79fb      	ldrb	r3, [r7, #7]
 8022ca6:	4618      	mov	r0, r3
 8022ca8:	f7ff ff64 	bl	8022b74 <Motor0_BLDC_SCALAR_SetSpeedPILimit>
}
 8022cac:	bf00      	nop
 8022cae:	3708      	adds	r7, #8
 8022cb0:	46bd      	mov	sp, r7
 8022cb2:	bd80      	pop	{r7, pc}

08022cb4 <MotorClearError>:

void MotorClearError(void)
{
 8022cb4:	b580      	push	{r7, lr}
 8022cb6:	af00      	add	r7, sp, #0
	Motor0_BLDC_SCALAR_ClearErrorState();
 8022cb8:	f7ff ff84 	bl	8022bc4 <Motor0_BLDC_SCALAR_ClearErrorState>
}
 8022cbc:	bf00      	nop
 8022cbe:	bd80      	pop	{r7, pc}

08022cc0 <MotorRead>:

void MotorRead(void)
{
 8022cc0:	b580      	push	{r7, lr}
 8022cc2:	b082      	sub	sp, #8
 8022cc4:	af00      	add	r7, sp, #0
	int32_t Cur,Vel;

	Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent(&drive.RAWCurrent);
 8022cc6:	480f      	ldr	r0, [pc, #60]	; (8022d04 <MotorRead+0x44>)
 8022cc8:	f7ff fea0 	bl	8022a0c <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent>
	Cur = abs(drive.RAWCurrent);
 8022ccc:	4b0e      	ldr	r3, [pc, #56]	; (8022d08 <MotorRead+0x48>)
 8022cce:	691b      	ldr	r3, [r3, #16]
 8022cd0:	2b00      	cmp	r3, #0
 8022cd2:	bfb8      	it	lt
 8022cd4:	425b      	neglt	r3, r3
 8022cd6:	607b      	str	r3, [r7, #4]
	drive.Current = (uint16_t)Cur;
 8022cd8:	687b      	ldr	r3, [r7, #4]
 8022cda:	b29a      	uxth	r2, r3
 8022cdc:	4b0a      	ldr	r3, [pc, #40]	; (8022d08 <MotorRead+0x48>)
 8022cde:	805a      	strh	r2, [r3, #2]
	Motor0_BLDC_SCALAR_GetMotorSpeed(&drive.RAWVelocity);
 8022ce0:	480a      	ldr	r0, [pc, #40]	; (8022d0c <MotorRead+0x4c>)
 8022ce2:	f7ff fe7d 	bl	80229e0 <Motor0_BLDC_SCALAR_GetMotorSpeed>
	Vel = abs(drive.RAWVelocity);
 8022ce6:	4b08      	ldr	r3, [pc, #32]	; (8022d08 <MotorRead+0x48>)
 8022ce8:	68db      	ldr	r3, [r3, #12]
 8022cea:	2b00      	cmp	r3, #0
 8022cec:	bfb8      	it	lt
 8022cee:	425b      	neglt	r3, r3
 8022cf0:	603b      	str	r3, [r7, #0]
	drive.Velocity = (uint16_t)Vel;
 8022cf2:	683b      	ldr	r3, [r7, #0]
 8022cf4:	b29a      	uxth	r2, r3
 8022cf6:	4b04      	ldr	r3, [pc, #16]	; (8022d08 <MotorRead+0x48>)
 8022cf8:	809a      	strh	r2, [r3, #4]
}
 8022cfa:	bf00      	nop
 8022cfc:	3708      	adds	r7, #8
 8022cfe:	46bd      	mov	sp, r7
 8022d00:	bd80      	pop	{r7, pc}
 8022d02:	bf00      	nop
 8022d04:	20000610 	.word	0x20000610
 8022d08:	20000600 	.word	0x20000600
 8022d0c:	2000060c 	.word	0x2000060c

08022d10 <HallTimerProc>:
void HallTimerProc(void *args)
{
 8022d10:	b580      	push	{r7, lr}
 8022d12:	b084      	sub	sp, #16
 8022d14:	af00      	add	r7, sp, #0
 8022d16:	6078      	str	r0, [r7, #4]
	uint32_t hall  = 0;
 8022d18:	2300      	movs	r3, #0
 8022d1a:	60fb      	str	r3, [r7, #12]
	static uint32_t prev_hall = 0;

	hall = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 8022d1c:	f7fd ff7e 	bl	8020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 8022d20:	60f8      	str	r0, [r7, #12]
	if (hall != prev_hall)
 8022d22:	4b52      	ldr	r3, [pc, #328]	; (8022e6c <HallTimerProc+0x15c>)
 8022d24:	681b      	ldr	r3, [r3, #0]
 8022d26:	68fa      	ldr	r2, [r7, #12]
 8022d28:	429a      	cmp	r2, r3
 8022d2a:	f000 8090 	beq.w	8022e4e <HallTimerProc+0x13e>
	{
		if ((hall == 1) && (prev_hall == 5)) drive.RAWPosition++;
 8022d2e:	68fb      	ldr	r3, [r7, #12]
 8022d30:	2b01      	cmp	r3, #1
 8022d32:	d108      	bne.n	8022d46 <HallTimerProc+0x36>
 8022d34:	4b4d      	ldr	r3, [pc, #308]	; (8022e6c <HallTimerProc+0x15c>)
 8022d36:	681b      	ldr	r3, [r3, #0]
 8022d38:	2b05      	cmp	r3, #5
 8022d3a:	d104      	bne.n	8022d46 <HallTimerProc+0x36>
 8022d3c:	4b4c      	ldr	r3, [pc, #304]	; (8022e70 <HallTimerProc+0x160>)
 8022d3e:	689b      	ldr	r3, [r3, #8]
 8022d40:	3301      	adds	r3, #1
 8022d42:	4a4b      	ldr	r2, [pc, #300]	; (8022e70 <HallTimerProc+0x160>)
 8022d44:	6093      	str	r3, [r2, #8]
		if ((hall == 1) && (prev_hall == 3)) drive.RAWPosition--;
 8022d46:	68fb      	ldr	r3, [r7, #12]
 8022d48:	2b01      	cmp	r3, #1
 8022d4a:	d108      	bne.n	8022d5e <HallTimerProc+0x4e>
 8022d4c:	4b47      	ldr	r3, [pc, #284]	; (8022e6c <HallTimerProc+0x15c>)
 8022d4e:	681b      	ldr	r3, [r3, #0]
 8022d50:	2b03      	cmp	r3, #3
 8022d52:	d104      	bne.n	8022d5e <HallTimerProc+0x4e>
 8022d54:	4b46      	ldr	r3, [pc, #280]	; (8022e70 <HallTimerProc+0x160>)
 8022d56:	689b      	ldr	r3, [r3, #8]
 8022d58:	3b01      	subs	r3, #1
 8022d5a:	4a45      	ldr	r2, [pc, #276]	; (8022e70 <HallTimerProc+0x160>)
 8022d5c:	6093      	str	r3, [r2, #8]

		if ((hall == 3) && (prev_hall == 1)) drive.RAWPosition++;
 8022d5e:	68fb      	ldr	r3, [r7, #12]
 8022d60:	2b03      	cmp	r3, #3
 8022d62:	d108      	bne.n	8022d76 <HallTimerProc+0x66>
 8022d64:	4b41      	ldr	r3, [pc, #260]	; (8022e6c <HallTimerProc+0x15c>)
 8022d66:	681b      	ldr	r3, [r3, #0]
 8022d68:	2b01      	cmp	r3, #1
 8022d6a:	d104      	bne.n	8022d76 <HallTimerProc+0x66>
 8022d6c:	4b40      	ldr	r3, [pc, #256]	; (8022e70 <HallTimerProc+0x160>)
 8022d6e:	689b      	ldr	r3, [r3, #8]
 8022d70:	3301      	adds	r3, #1
 8022d72:	4a3f      	ldr	r2, [pc, #252]	; (8022e70 <HallTimerProc+0x160>)
 8022d74:	6093      	str	r3, [r2, #8]
		if ((hall == 3) && (prev_hall == 2)) drive.RAWPosition--;
 8022d76:	68fb      	ldr	r3, [r7, #12]
 8022d78:	2b03      	cmp	r3, #3
 8022d7a:	d108      	bne.n	8022d8e <HallTimerProc+0x7e>
 8022d7c:	4b3b      	ldr	r3, [pc, #236]	; (8022e6c <HallTimerProc+0x15c>)
 8022d7e:	681b      	ldr	r3, [r3, #0]
 8022d80:	2b02      	cmp	r3, #2
 8022d82:	d104      	bne.n	8022d8e <HallTimerProc+0x7e>
 8022d84:	4b3a      	ldr	r3, [pc, #232]	; (8022e70 <HallTimerProc+0x160>)
 8022d86:	689b      	ldr	r3, [r3, #8]
 8022d88:	3b01      	subs	r3, #1
 8022d8a:	4a39      	ldr	r2, [pc, #228]	; (8022e70 <HallTimerProc+0x160>)
 8022d8c:	6093      	str	r3, [r2, #8]

		if ((hall == 2) && (prev_hall == 3)) drive.RAWPosition++;
 8022d8e:	68fb      	ldr	r3, [r7, #12]
 8022d90:	2b02      	cmp	r3, #2
 8022d92:	d108      	bne.n	8022da6 <HallTimerProc+0x96>
 8022d94:	4b35      	ldr	r3, [pc, #212]	; (8022e6c <HallTimerProc+0x15c>)
 8022d96:	681b      	ldr	r3, [r3, #0]
 8022d98:	2b03      	cmp	r3, #3
 8022d9a:	d104      	bne.n	8022da6 <HallTimerProc+0x96>
 8022d9c:	4b34      	ldr	r3, [pc, #208]	; (8022e70 <HallTimerProc+0x160>)
 8022d9e:	689b      	ldr	r3, [r3, #8]
 8022da0:	3301      	adds	r3, #1
 8022da2:	4a33      	ldr	r2, [pc, #204]	; (8022e70 <HallTimerProc+0x160>)
 8022da4:	6093      	str	r3, [r2, #8]
		if ((hall == 2) && (prev_hall == 6)) drive.RAWPosition--;
 8022da6:	68fb      	ldr	r3, [r7, #12]
 8022da8:	2b02      	cmp	r3, #2
 8022daa:	d108      	bne.n	8022dbe <HallTimerProc+0xae>
 8022dac:	4b2f      	ldr	r3, [pc, #188]	; (8022e6c <HallTimerProc+0x15c>)
 8022dae:	681b      	ldr	r3, [r3, #0]
 8022db0:	2b06      	cmp	r3, #6
 8022db2:	d104      	bne.n	8022dbe <HallTimerProc+0xae>
 8022db4:	4b2e      	ldr	r3, [pc, #184]	; (8022e70 <HallTimerProc+0x160>)
 8022db6:	689b      	ldr	r3, [r3, #8]
 8022db8:	3b01      	subs	r3, #1
 8022dba:	4a2d      	ldr	r2, [pc, #180]	; (8022e70 <HallTimerProc+0x160>)
 8022dbc:	6093      	str	r3, [r2, #8]

		if ((hall == 6) && (prev_hall == 2)) drive.RAWPosition++;
 8022dbe:	68fb      	ldr	r3, [r7, #12]
 8022dc0:	2b06      	cmp	r3, #6
 8022dc2:	d108      	bne.n	8022dd6 <HallTimerProc+0xc6>
 8022dc4:	4b29      	ldr	r3, [pc, #164]	; (8022e6c <HallTimerProc+0x15c>)
 8022dc6:	681b      	ldr	r3, [r3, #0]
 8022dc8:	2b02      	cmp	r3, #2
 8022dca:	d104      	bne.n	8022dd6 <HallTimerProc+0xc6>
 8022dcc:	4b28      	ldr	r3, [pc, #160]	; (8022e70 <HallTimerProc+0x160>)
 8022dce:	689b      	ldr	r3, [r3, #8]
 8022dd0:	3301      	adds	r3, #1
 8022dd2:	4a27      	ldr	r2, [pc, #156]	; (8022e70 <HallTimerProc+0x160>)
 8022dd4:	6093      	str	r3, [r2, #8]
		if ((hall == 6) && (prev_hall == 4)) drive.RAWPosition--;
 8022dd6:	68fb      	ldr	r3, [r7, #12]
 8022dd8:	2b06      	cmp	r3, #6
 8022dda:	d108      	bne.n	8022dee <HallTimerProc+0xde>
 8022ddc:	4b23      	ldr	r3, [pc, #140]	; (8022e6c <HallTimerProc+0x15c>)
 8022dde:	681b      	ldr	r3, [r3, #0]
 8022de0:	2b04      	cmp	r3, #4
 8022de2:	d104      	bne.n	8022dee <HallTimerProc+0xde>
 8022de4:	4b22      	ldr	r3, [pc, #136]	; (8022e70 <HallTimerProc+0x160>)
 8022de6:	689b      	ldr	r3, [r3, #8]
 8022de8:	3b01      	subs	r3, #1
 8022dea:	4a21      	ldr	r2, [pc, #132]	; (8022e70 <HallTimerProc+0x160>)
 8022dec:	6093      	str	r3, [r2, #8]

		if ((hall == 4) && (prev_hall == 6)) drive.RAWPosition++;
 8022dee:	68fb      	ldr	r3, [r7, #12]
 8022df0:	2b04      	cmp	r3, #4
 8022df2:	d108      	bne.n	8022e06 <HallTimerProc+0xf6>
 8022df4:	4b1d      	ldr	r3, [pc, #116]	; (8022e6c <HallTimerProc+0x15c>)
 8022df6:	681b      	ldr	r3, [r3, #0]
 8022df8:	2b06      	cmp	r3, #6
 8022dfa:	d104      	bne.n	8022e06 <HallTimerProc+0xf6>
 8022dfc:	4b1c      	ldr	r3, [pc, #112]	; (8022e70 <HallTimerProc+0x160>)
 8022dfe:	689b      	ldr	r3, [r3, #8]
 8022e00:	3301      	adds	r3, #1
 8022e02:	4a1b      	ldr	r2, [pc, #108]	; (8022e70 <HallTimerProc+0x160>)
 8022e04:	6093      	str	r3, [r2, #8]
		if ((hall == 4) && (prev_hall == 5)) drive.RAWPosition--;
 8022e06:	68fb      	ldr	r3, [r7, #12]
 8022e08:	2b04      	cmp	r3, #4
 8022e0a:	d108      	bne.n	8022e1e <HallTimerProc+0x10e>
 8022e0c:	4b17      	ldr	r3, [pc, #92]	; (8022e6c <HallTimerProc+0x15c>)
 8022e0e:	681b      	ldr	r3, [r3, #0]
 8022e10:	2b05      	cmp	r3, #5
 8022e12:	d104      	bne.n	8022e1e <HallTimerProc+0x10e>
 8022e14:	4b16      	ldr	r3, [pc, #88]	; (8022e70 <HallTimerProc+0x160>)
 8022e16:	689b      	ldr	r3, [r3, #8]
 8022e18:	3b01      	subs	r3, #1
 8022e1a:	4a15      	ldr	r2, [pc, #84]	; (8022e70 <HallTimerProc+0x160>)
 8022e1c:	6093      	str	r3, [r2, #8]

		if ((hall == 5) && (prev_hall == 4)) drive.RAWPosition++;
 8022e1e:	68fb      	ldr	r3, [r7, #12]
 8022e20:	2b05      	cmp	r3, #5
 8022e22:	d108      	bne.n	8022e36 <HallTimerProc+0x126>
 8022e24:	4b11      	ldr	r3, [pc, #68]	; (8022e6c <HallTimerProc+0x15c>)
 8022e26:	681b      	ldr	r3, [r3, #0]
 8022e28:	2b04      	cmp	r3, #4
 8022e2a:	d104      	bne.n	8022e36 <HallTimerProc+0x126>
 8022e2c:	4b10      	ldr	r3, [pc, #64]	; (8022e70 <HallTimerProc+0x160>)
 8022e2e:	689b      	ldr	r3, [r3, #8]
 8022e30:	3301      	adds	r3, #1
 8022e32:	4a0f      	ldr	r2, [pc, #60]	; (8022e70 <HallTimerProc+0x160>)
 8022e34:	6093      	str	r3, [r2, #8]
		if ((hall == 5) && (prev_hall == 1)) drive.RAWPosition--;
 8022e36:	68fb      	ldr	r3, [r7, #12]
 8022e38:	2b05      	cmp	r3, #5
 8022e3a:	d108      	bne.n	8022e4e <HallTimerProc+0x13e>
 8022e3c:	4b0b      	ldr	r3, [pc, #44]	; (8022e6c <HallTimerProc+0x15c>)
 8022e3e:	681b      	ldr	r3, [r3, #0]
 8022e40:	2b01      	cmp	r3, #1
 8022e42:	d104      	bne.n	8022e4e <HallTimerProc+0x13e>
 8022e44:	4b0a      	ldr	r3, [pc, #40]	; (8022e70 <HallTimerProc+0x160>)
 8022e46:	689b      	ldr	r3, [r3, #8]
 8022e48:	3b01      	subs	r3, #1
 8022e4a:	4a09      	ldr	r2, [pc, #36]	; (8022e70 <HallTimerProc+0x160>)
 8022e4c:	6093      	str	r3, [r2, #8]
	}
	prev_hall = hall;
 8022e4e:	4a07      	ldr	r2, [pc, #28]	; (8022e6c <HallTimerProc+0x15c>)
 8022e50:	68fb      	ldr	r3, [r7, #12]
 8022e52:	6013      	str	r3, [r2, #0]
	drive.Position = (uint16_t) abs(drive.RAWPosition);
 8022e54:	4b06      	ldr	r3, [pc, #24]	; (8022e70 <HallTimerProc+0x160>)
 8022e56:	689b      	ldr	r3, [r3, #8]
 8022e58:	2b00      	cmp	r3, #0
 8022e5a:	bfb8      	it	lt
 8022e5c:	425b      	neglt	r3, r3
 8022e5e:	b29a      	uxth	r2, r3
 8022e60:	4b03      	ldr	r3, [pc, #12]	; (8022e70 <HallTimerProc+0x160>)
 8022e62:	801a      	strh	r2, [r3, #0]
}
 8022e64:	bf00      	nop
 8022e66:	3710      	adds	r7, #16
 8022e68:	46bd      	mov	sp, r7
 8022e6a:	bd80      	pop	{r7, pc}
 8022e6c:	20000620 	.word	0x20000620
 8022e70:	20000600 	.word	0x20000600

08022e74 <MotorStepProc>:

void MotorStepProc(void *args)
{
 8022e74:	b580      	push	{r7, lr}
 8022e76:	b082      	sub	sp, #8
 8022e78:	af00      	add	r7, sp, #0
 8022e7a:	6078      	str	r0, [r7, #4]
	Motor0_BLDC_SCALAR_MSM();
 8022e7c:	f008 f970 	bl	802b160 <__Motor0_BLDC_SCALAR_MSM_veneer>
}
 8022e80:	bf00      	nop
 8022e82:	3708      	adds	r7, #8
 8022e84:	46bd      	mov	sp, r7
 8022e86:	bd80      	pop	{r7, pc}

08022e88 <XMC_GPIO_SetOutputHigh>:
{
 8022e88:	b480      	push	{r7}
 8022e8a:	b083      	sub	sp, #12
 8022e8c:	af00      	add	r7, sp, #0
 8022e8e:	6078      	str	r0, [r7, #4]
 8022e90:	460b      	mov	r3, r1
 8022e92:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8022e94:	78fb      	ldrb	r3, [r7, #3]
 8022e96:	2201      	movs	r2, #1
 8022e98:	409a      	lsls	r2, r3
 8022e9a:	687b      	ldr	r3, [r7, #4]
 8022e9c:	605a      	str	r2, [r3, #4]
}
 8022e9e:	bf00      	nop
 8022ea0:	370c      	adds	r7, #12
 8022ea2:	46bd      	mov	sp, r7
 8022ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022ea8:	4770      	bx	lr

08022eaa <XMC_GPIO_SetOutputLow>:
{
 8022eaa:	b480      	push	{r7}
 8022eac:	b083      	sub	sp, #12
 8022eae:	af00      	add	r7, sp, #0
 8022eb0:	6078      	str	r0, [r7, #4]
 8022eb2:	460b      	mov	r3, r1
 8022eb4:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8022eb6:	78fb      	ldrb	r3, [r7, #3]
 8022eb8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8022ebc:	409a      	lsls	r2, r3
 8022ebe:	687b      	ldr	r3, [r7, #4]
 8022ec0:	605a      	str	r2, [r3, #4]
}
 8022ec2:	bf00      	nop
 8022ec4:	370c      	adds	r7, #12
 8022ec6:	46bd      	mov	sp, r7
 8022ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022ecc:	4770      	bx	lr

08022ece <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
 8022ece:	b580      	push	{r7, lr}
 8022ed0:	b082      	sub	sp, #8
 8022ed2:	af00      	add	r7, sp, #0
 8022ed4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8022ed6:	687b      	ldr	r3, [r7, #4]
 8022ed8:	681a      	ldr	r2, [r3, #0]
 8022eda:	687b      	ldr	r3, [r7, #4]
 8022edc:	7c1b      	ldrb	r3, [r3, #16]
 8022ede:	4619      	mov	r1, r3
 8022ee0:	4610      	mov	r0, r2
 8022ee2:	f7ff ffd1 	bl	8022e88 <XMC_GPIO_SetOutputHigh>
}
 8022ee6:	bf00      	nop
 8022ee8:	3708      	adds	r7, #8
 8022eea:	46bd      	mov	sp, r7
 8022eec:	bd80      	pop	{r7, pc}

08022eee <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
 8022eee:	b580      	push	{r7, lr}
 8022ef0:	b082      	sub	sp, #8
 8022ef2:	af00      	add	r7, sp, #0
 8022ef4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8022ef6:	687b      	ldr	r3, [r7, #4]
 8022ef8:	681a      	ldr	r2, [r3, #0]
 8022efa:	687b      	ldr	r3, [r7, #4]
 8022efc:	7c1b      	ldrb	r3, [r3, #16]
 8022efe:	4619      	mov	r1, r3
 8022f00:	4610      	mov	r0, r2
 8022f02:	f7ff ffd2 	bl	8022eaa <XMC_GPIO_SetOutputLow>
}
 8022f06:	bf00      	nop
 8022f08:	3708      	adds	r7, #8
 8022f0a:	46bd      	mov	sp, r7
 8022f0c:	bd80      	pop	{r7, pc}
	...

08022f10 <WriteBuzzer>:
void InitBuzzer(int32_t buzzer_type)
{

}
void WriteBuzzer(int32_t cmd)
{
 8022f10:	b580      	push	{r7, lr}
 8022f12:	b082      	sub	sp, #8
 8022f14:	af00      	add	r7, sp, #0
 8022f16:	6078      	str	r0, [r7, #4]
static int32_t blink = 0;

	if((Presets.BUZZER_TYPE == BUZZER_TYPE_SFM) && (cmd == BUZZER_ON))
 8022f18:	4b42      	ldr	r3, [pc, #264]	; (8023024 <WriteBuzzer+0x114>)
 8022f1a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8022f1c:	2b00      	cmp	r3, #0
 8022f1e:	d134      	bne.n	8022f8a <WriteBuzzer+0x7a>
 8022f20:	687b      	ldr	r3, [r7, #4]
 8022f22:	2b01      	cmp	r3, #1
 8022f24:	d131      	bne.n	8022f8a <WriteBuzzer+0x7a>
	{
		blink++;
 8022f26:	4b40      	ldr	r3, [pc, #256]	; (8023028 <WriteBuzzer+0x118>)
 8022f28:	681b      	ldr	r3, [r3, #0]
 8022f2a:	3301      	adds	r3, #1
 8022f2c:	4a3e      	ldr	r2, [pc, #248]	; (8023028 <WriteBuzzer+0x118>)
 8022f2e:	6013      	str	r3, [r2, #0]
//
//		if(blink >= 100)
//		{
//			blink = 0;
//		}
		if((blink >= 4) && (blink < 8))
 8022f30:	4b3d      	ldr	r3, [pc, #244]	; (8023028 <WriteBuzzer+0x118>)
 8022f32:	681b      	ldr	r3, [r3, #0]
 8022f34:	2b03      	cmp	r3, #3
 8022f36:	dd10      	ble.n	8022f5a <WriteBuzzer+0x4a>
 8022f38:	4b3b      	ldr	r3, [pc, #236]	; (8023028 <WriteBuzzer+0x118>)
 8022f3a:	681b      	ldr	r3, [r3, #0]
 8022f3c:	2b07      	cmp	r3, #7
 8022f3e:	dc0c      	bgt.n	8022f5a <WriteBuzzer+0x4a>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022f40:	483a      	ldr	r0, [pc, #232]	; (802302c <WriteBuzzer+0x11c>)
 8022f42:	f7ff ffc4 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 830, 2000); //1500
 8022f46:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8022f4a:	f240 313e 	movw	r1, #830	; 0x33e
 8022f4e:	4838      	ldr	r0, [pc, #224]	; (8023030 <WriteBuzzer+0x120>)
 8022f50:	f006 fcba 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8022f54:	4836      	ldr	r0, [pc, #216]	; (8023030 <WriteBuzzer+0x120>)
 8022f56:	f006 fc6d 	bl	8029834 <PWM_CCU4_Start>
		}
		if(blink < 4)
 8022f5a:	4b33      	ldr	r3, [pc, #204]	; (8023028 <WriteBuzzer+0x118>)
 8022f5c:	681b      	ldr	r3, [r3, #0]
 8022f5e:	2b03      	cmp	r3, #3
 8022f60:	dc0c      	bgt.n	8022f7c <WriteBuzzer+0x6c>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022f62:	4832      	ldr	r0, [pc, #200]	; (802302c <WriteBuzzer+0x11c>)
 8022f64:	f7ff ffb3 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 1047, 2000); //1200
 8022f68:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8022f6c:	f240 4117 	movw	r1, #1047	; 0x417
 8022f70:	482f      	ldr	r0, [pc, #188]	; (8023030 <WriteBuzzer+0x120>)
 8022f72:	f006 fca9 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8022f76:	482e      	ldr	r0, [pc, #184]	; (8023030 <WriteBuzzer+0x120>)
 8022f78:	f006 fc5c 	bl	8029834 <PWM_CCU4_Start>
		}
		if(blink >= 8)
 8022f7c:	4b2a      	ldr	r3, [pc, #168]	; (8023028 <WriteBuzzer+0x118>)
 8022f7e:	681b      	ldr	r3, [r3, #0]
 8022f80:	2b07      	cmp	r3, #7
 8022f82:	dd02      	ble.n	8022f8a <WriteBuzzer+0x7a>
		{
			blink = 0;
 8022f84:	4b28      	ldr	r3, [pc, #160]	; (8023028 <WriteBuzzer+0x118>)
 8022f86:	2200      	movs	r2, #0
 8022f88:	601a      	str	r2, [r3, #0]
		}

	}

	if((Presets.BUZZER_TYPE == BUZZER_TYPE_BPT) && (cmd == BUZZER_ON))
 8022f8a:	4b26      	ldr	r3, [pc, #152]	; (8023024 <WriteBuzzer+0x114>)
 8022f8c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8022f8e:	2b01      	cmp	r3, #1
 8022f90:	d134      	bne.n	8022ffc <WriteBuzzer+0xec>
 8022f92:	687b      	ldr	r3, [r7, #4]
 8022f94:	2b01      	cmp	r3, #1
 8022f96:	d131      	bne.n	8022ffc <WriteBuzzer+0xec>
	{
		blink++;
 8022f98:	4b23      	ldr	r3, [pc, #140]	; (8023028 <WriteBuzzer+0x118>)
 8022f9a:	681b      	ldr	r3, [r3, #0]
 8022f9c:	3301      	adds	r3, #1
 8022f9e:	4a22      	ldr	r2, [pc, #136]	; (8023028 <WriteBuzzer+0x118>)
 8022fa0:	6013      	str	r3, [r2, #0]

		if((blink >= 4) && (blink < 8))
 8022fa2:	4b21      	ldr	r3, [pc, #132]	; (8023028 <WriteBuzzer+0x118>)
 8022fa4:	681b      	ldr	r3, [r3, #0]
 8022fa6:	2b03      	cmp	r3, #3
 8022fa8:	dd10      	ble.n	8022fcc <WriteBuzzer+0xbc>
 8022faa:	4b1f      	ldr	r3, [pc, #124]	; (8023028 <WriteBuzzer+0x118>)
 8022fac:	681b      	ldr	r3, [r3, #0]
 8022fae:	2b07      	cmp	r3, #7
 8022fb0:	dc0c      	bgt.n	8022fcc <WriteBuzzer+0xbc>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022fb2:	481e      	ldr	r0, [pc, #120]	; (802302c <WriteBuzzer+0x11c>)
 8022fb4:	f7ff ff8b 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 830, 8500); //1500
 8022fb8:	f242 1234 	movw	r2, #8500	; 0x2134
 8022fbc:	f240 313e 	movw	r1, #830	; 0x33e
 8022fc0:	481b      	ldr	r0, [pc, #108]	; (8023030 <WriteBuzzer+0x120>)
 8022fc2:	f006 fc81 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8022fc6:	481a      	ldr	r0, [pc, #104]	; (8023030 <WriteBuzzer+0x120>)
 8022fc8:	f006 fc34 	bl	8029834 <PWM_CCU4_Start>
		}
		if(blink < 4)
 8022fcc:	4b16      	ldr	r3, [pc, #88]	; (8023028 <WriteBuzzer+0x118>)
 8022fce:	681b      	ldr	r3, [r3, #0]
 8022fd0:	2b03      	cmp	r3, #3
 8022fd2:	dc0c      	bgt.n	8022fee <WriteBuzzer+0xde>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022fd4:	4815      	ldr	r0, [pc, #84]	; (802302c <WriteBuzzer+0x11c>)
 8022fd6:	f7ff ff7a 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 1047, 8500); //1200
 8022fda:	f242 1234 	movw	r2, #8500	; 0x2134
 8022fde:	f240 4117 	movw	r1, #1047	; 0x417
 8022fe2:	4813      	ldr	r0, [pc, #76]	; (8023030 <WriteBuzzer+0x120>)
 8022fe4:	f006 fc70 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8022fe8:	4811      	ldr	r0, [pc, #68]	; (8023030 <WriteBuzzer+0x120>)
 8022fea:	f006 fc23 	bl	8029834 <PWM_CCU4_Start>
		}
		if(blink >= 8)
 8022fee:	4b0e      	ldr	r3, [pc, #56]	; (8023028 <WriteBuzzer+0x118>)
 8022ff0:	681b      	ldr	r3, [r3, #0]
 8022ff2:	2b07      	cmp	r3, #7
 8022ff4:	dd02      	ble.n	8022ffc <WriteBuzzer+0xec>
		{
			blink = 0;
 8022ff6:	4b0c      	ldr	r3, [pc, #48]	; (8023028 <WriteBuzzer+0x118>)
 8022ff8:	2200      	movs	r2, #0
 8022ffa:	601a      	str	r2, [r3, #0]
		}
	}
	if((cmd == BUZZER_OFF))
 8022ffc:	687b      	ldr	r3, [r7, #4]
 8022ffe:	2b00      	cmp	r3, #0
 8023000:	d10b      	bne.n	802301a <WriteBuzzer+0x10a>
	{
		DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8023002:	480c      	ldr	r0, [pc, #48]	; (8023034 <WriteBuzzer+0x124>)
 8023004:	f7ff ff63 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputLow(&HS_SW_8);
 8023008:	4808      	ldr	r0, [pc, #32]	; (802302c <WriteBuzzer+0x11c>)
 802300a:	f7ff ff70 	bl	8022eee <DIGITAL_IO_SetOutputLow>
		PWM_CCU4_Stop(&BUZZ_PWM);
 802300e:	4808      	ldr	r0, [pc, #32]	; (8023030 <WriteBuzzer+0x120>)
 8023010:	f006 fc3b 	bl	802988a <PWM_CCU4_Stop>
		blink = 0;
 8023014:	4b04      	ldr	r3, [pc, #16]	; (8023028 <WriteBuzzer+0x118>)
 8023016:	2200      	movs	r2, #0
 8023018:	601a      	str	r2, [r3, #0]
	}
}
 802301a:	bf00      	nop
 802301c:	3708      	adds	r7, #8
 802301e:	46bd      	mov	sp, r7
 8023020:	bd80      	pop	{r7, pc}
 8023022:	bf00      	nop
 8023024:	20000770 	.word	0x20000770
 8023028:	20000624 	.word	0x20000624
 802302c:	0802b544 	.word	0x0802b544
 8023030:	20000290 	.word	0x20000290
 8023034:	0802b42c 	.word	0x0802b42c

08023038 <CCU43_3_IRQHandler>:




void BuzzerCmpISRHandler (void)
{
 8023038:	b580      	push	{r7, lr}
 802303a:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&BUZZ_PWM,XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 802303c:	2102      	movs	r1, #2
 802303e:	4804      	ldr	r0, [pc, #16]	; (8023050 <CCU43_3_IRQHandler+0x18>)
 8023040:	f006 fca6 	bl	8029990 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputLow(&TRANS_OUT);
 8023044:	4803      	ldr	r0, [pc, #12]	; (8023054 <CCU43_3_IRQHandler+0x1c>)
 8023046:	f7ff ff52 	bl	8022eee <DIGITAL_IO_SetOutputLow>
}
 802304a:	bf00      	nop
 802304c:	bd80      	pop	{r7, pc}
 802304e:	bf00      	nop
 8023050:	20000290 	.word	0x20000290
 8023054:	0802b42c 	.word	0x0802b42c

08023058 <CCU43_2_IRQHandler>:

void BuzzerOvfISRHandler (void)
{
 8023058:	b580      	push	{r7, lr}
 802305a:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&BUZZ_PWM,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 802305c:	2100      	movs	r1, #0
 802305e:	4804      	ldr	r0, [pc, #16]	; (8023070 <CCU43_2_IRQHandler+0x18>)
 8023060:	f006 fc96 	bl	8029990 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8023064:	4803      	ldr	r0, [pc, #12]	; (8023074 <CCU43_2_IRQHandler+0x1c>)
 8023066:	f7ff ff32 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
}
 802306a:	bf00      	nop
 802306c:	bd80      	pop	{r7, pc}
 802306e:	bf00      	nop
 8023070:	20000290 	.word	0x20000290
 8023074:	0802b42c 	.word	0x0802b42c

08023078 <XMC_GPIO_SetOutputHigh>:
{
 8023078:	b480      	push	{r7}
 802307a:	b083      	sub	sp, #12
 802307c:	af00      	add	r7, sp, #0
 802307e:	6078      	str	r0, [r7, #4]
 8023080:	460b      	mov	r3, r1
 8023082:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8023084:	78fb      	ldrb	r3, [r7, #3]
 8023086:	2201      	movs	r2, #1
 8023088:	409a      	lsls	r2, r3
 802308a:	687b      	ldr	r3, [r7, #4]
 802308c:	605a      	str	r2, [r3, #4]
}
 802308e:	bf00      	nop
 8023090:	370c      	adds	r7, #12
 8023092:	46bd      	mov	sp, r7
 8023094:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023098:	4770      	bx	lr

0802309a <XMC_GPIO_SetOutputLow>:
{
 802309a:	b480      	push	{r7}
 802309c:	b083      	sub	sp, #12
 802309e:	af00      	add	r7, sp, #0
 80230a0:	6078      	str	r0, [r7, #4]
 80230a2:	460b      	mov	r3, r1
 80230a4:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 80230a6:	78fb      	ldrb	r3, [r7, #3]
 80230a8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80230ac:	409a      	lsls	r2, r3
 80230ae:	687b      	ldr	r3, [r7, #4]
 80230b0:	605a      	str	r2, [r3, #4]
}
 80230b2:	bf00      	nop
 80230b4:	370c      	adds	r7, #12
 80230b6:	46bd      	mov	sp, r7
 80230b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80230bc:	4770      	bx	lr

080230be <XMC_GPIO_GetInput>:
{
 80230be:	b480      	push	{r7}
 80230c0:	b083      	sub	sp, #12
 80230c2:	af00      	add	r7, sp, #0
 80230c4:	6078      	str	r0, [r7, #4]
 80230c6:	460b      	mov	r3, r1
 80230c8:	70fb      	strb	r3, [r7, #3]
  return (((port->IN) >> pin) & 0x1U);
 80230ca:	687b      	ldr	r3, [r7, #4]
 80230cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80230ce:	78fb      	ldrb	r3, [r7, #3]
 80230d0:	fa22 f303 	lsr.w	r3, r2, r3
 80230d4:	f003 0301 	and.w	r3, r3, #1
}
 80230d8:	4618      	mov	r0, r3
 80230da:	370c      	adds	r7, #12
 80230dc:	46bd      	mov	sp, r7
 80230de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80230e2:	4770      	bx	lr

080230e4 <DIGITAL_IO_SetOutputHigh>:
{
 80230e4:	b580      	push	{r7, lr}
 80230e6:	b082      	sub	sp, #8
 80230e8:	af00      	add	r7, sp, #0
 80230ea:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 80230ec:	687b      	ldr	r3, [r7, #4]
 80230ee:	681a      	ldr	r2, [r3, #0]
 80230f0:	687b      	ldr	r3, [r7, #4]
 80230f2:	7c1b      	ldrb	r3, [r3, #16]
 80230f4:	4619      	mov	r1, r3
 80230f6:	4610      	mov	r0, r2
 80230f8:	f7ff ffbe 	bl	8023078 <XMC_GPIO_SetOutputHigh>
}
 80230fc:	bf00      	nop
 80230fe:	3708      	adds	r7, #8
 8023100:	46bd      	mov	sp, r7
 8023102:	bd80      	pop	{r7, pc}

08023104 <DIGITAL_IO_SetOutputLow>:
{
 8023104:	b580      	push	{r7, lr}
 8023106:	b082      	sub	sp, #8
 8023108:	af00      	add	r7, sp, #0
 802310a:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 802310c:	687b      	ldr	r3, [r7, #4]
 802310e:	681a      	ldr	r2, [r3, #0]
 8023110:	687b      	ldr	r3, [r7, #4]
 8023112:	7c1b      	ldrb	r3, [r3, #16]
 8023114:	4619      	mov	r1, r3
 8023116:	4610      	mov	r0, r2
 8023118:	f7ff ffbf 	bl	802309a <XMC_GPIO_SetOutputLow>
}
 802311c:	bf00      	nop
 802311e:	3708      	adds	r7, #8
 8023120:	46bd      	mov	sp, r7
 8023122:	bd80      	pop	{r7, pc}

08023124 <DIGITAL_IO_GetInput>:
* }
*  @endcode
*/

__STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
{
 8023124:	b580      	push	{r7, lr}
 8023126:	b082      	sub	sp, #8
 8023128:	af00      	add	r7, sp, #0
 802312a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
  return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
 802312c:	687b      	ldr	r3, [r7, #4]
 802312e:	681a      	ldr	r2, [r3, #0]
 8023130:	687b      	ldr	r3, [r7, #4]
 8023132:	7c1b      	ldrb	r3, [r3, #16]
 8023134:	4619      	mov	r1, r3
 8023136:	4610      	mov	r0, r2
 8023138:	f7ff ffc1 	bl	80230be <XMC_GPIO_GetInput>
 802313c:	4603      	mov	r3, r0
}
 802313e:	4618      	mov	r0, r3
 8023140:	3708      	adds	r7, #8
 8023142:	46bd      	mov	sp, r7
 8023144:	bd80      	pop	{r7, pc}
	...

08023148 <DoorPeriphInit>:
LED_RUBBER_LIGHT_t led_rubber;
INPUT_SIGNALS_t Inputs;


void DoorPeriphInit(void)
{
 8023148:	b580      	push	{r7, lr}
 802314a:	af00      	add	r7, sp, #0
	  LedPwmTimer = SYSTIMER_CreateTimer(100, SYSTIMER_MODE_PERIODIC, LedPwmTimerProc, NULL );
 802314c:	2300      	movs	r3, #0
 802314e:	4a1a      	ldr	r2, [pc, #104]	; (80231b8 <DoorPeriphInit+0x70>)
 8023150:	2101      	movs	r1, #1
 8023152:	2064      	movs	r0, #100	; 0x64
 8023154:	f005 ffe8 	bl	8029128 <SYSTIMER_CreateTimer>
 8023158:	4603      	mov	r3, r0
 802315a:	461a      	mov	r2, r3
 802315c:	4b17      	ldr	r3, [pc, #92]	; (80231bc <DoorPeriphInit+0x74>)
 802315e:	601a      	str	r2, [r3, #0]
	  SYSTIMER_StartTimer(LedPwmTimer);
 8023160:	4b16      	ldr	r3, [pc, #88]	; (80231bc <DoorPeriphInit+0x74>)
 8023162:	681b      	ldr	r3, [r3, #0]
 8023164:	4618      	mov	r0, r3
 8023166:	f006 f87d 	bl	8029264 <SYSTIMER_StartTimer>


	  DIGITAL_IO_SetOutputHigh(&LED_SW_NRES);
 802316a:	4815      	ldr	r0, [pc, #84]	; (80231c0 <DoorPeriphInit+0x78>)
 802316c:	f7ff ffba 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
	  DIGITAL_IO_SetOutputHigh(&LS_SW_NRES);
 8023170:	4814      	ldr	r0, [pc, #80]	; (80231c4 <DoorPeriphInit+0x7c>)
 8023172:	f7ff ffb7 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
	  DIGITAL_IO_SetOutputLow(&DI_PNP_EN);
 8023176:	4814      	ldr	r0, [pc, #80]	; (80231c8 <DoorPeriphInit+0x80>)
 8023178:	f7ff ffc4 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	  DIGITAL_IO_SetOutputLow(&DI_NPN_EN);
 802317c:	4813      	ldr	r0, [pc, #76]	; (80231cc <DoorPeriphInit+0x84>)
 802317e:	f7ff ffc1 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	  DIGITAL_IO_SetOutputLow(&GROUP_IN_EN);
 8023182:	4813      	ldr	r0, [pc, #76]	; (80231d0 <DoorPeriphInit+0x88>)
 8023184:	f7ff ffbe 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	  DIGITAL_IO_SetOutputHigh(&POWER_SWITCH);
 8023188:	4812      	ldr	r0, [pc, #72]	; (80231d4 <DoorPeriphInit+0x8c>)
 802318a:	f7ff ffab 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>

	  DIGITAL_IO_SetOutputHigh(&LED_POWER_EN2);
 802318e:	4812      	ldr	r0, [pc, #72]	; (80231d8 <DoorPeriphInit+0x90>)
 8023190:	f7ff ffa8 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
	  DIGITAL_IO_SetOutputHigh(&LED_POWER_EN1);
 8023194:	4811      	ldr	r0, [pc, #68]	; (80231dc <DoorPeriphInit+0x94>)
 8023196:	f7ff ffa5 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>

	  PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 2000, 6000); //5200///5600
 802319a:	f241 7270 	movw	r2, #6000	; 0x1770
 802319e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80231a2:	480f      	ldr	r0, [pc, #60]	; (80231e0 <DoorPeriphInit+0x98>)
 80231a4:	f006 fb90 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
	  //PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 440, 1000);
	  DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 80231a8:	480e      	ldr	r0, [pc, #56]	; (80231e4 <DoorPeriphInit+0x9c>)
 80231aa:	f7ff ff9b 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
	  DIGITAL_IO_SetOutputLow(&HS_SW_8);
 80231ae:	480e      	ldr	r0, [pc, #56]	; (80231e8 <DoorPeriphInit+0xa0>)
 80231b0:	f7ff ffa8 	bl	8023104 <DIGITAL_IO_SetOutputLow>
}
 80231b4:	bf00      	nop
 80231b6:	bd80      	pop	{r7, pc}
 80231b8:	080237c1 	.word	0x080237c1
 80231bc:	2000064c 	.word	0x2000064c
 80231c0:	0802b454 	.word	0x0802b454
 80231c4:	0802b558 	.word	0x0802b558
 80231c8:	0802b56c 	.word	0x0802b56c
 80231cc:	0802b580 	.word	0x0802b580
 80231d0:	0802b440 	.word	0x0802b440
 80231d4:	0802b5bc 	.word	0x0802b5bc
 80231d8:	0802b5a8 	.word	0x0802b5a8
 80231dc:	0802b594 	.word	0x0802b594
 80231e0:	20000268 	.word	0x20000268
 80231e4:	0802b42c 	.word	0x0802b42c
 80231e8:	0802b544 	.word	0x0802b544

080231ec <ReadInputs>:




void ReadInputs(void)
{
 80231ec:	b580      	push	{r7, lr}
 80231ee:	af00      	add	r7, sp, #0
	Inputs.PNP = BUS_IO_Read(&DI_PNP);
 80231f0:	4813      	ldr	r0, [pc, #76]	; (8023240 <ReadInputs+0x54>)
 80231f2:	f007 f8f3 	bl	802a3dc <BUS_IO_Read>
 80231f6:	4603      	mov	r3, r0
 80231f8:	461a      	mov	r2, r3
 80231fa:	4b12      	ldr	r3, [pc, #72]	; (8023244 <ReadInputs+0x58>)
 80231fc:	801a      	strh	r2, [r3, #0]
	Inputs.NPN = BUS_IO_Read(&DI_NPN);
 80231fe:	4812      	ldr	r0, [pc, #72]	; (8023248 <ReadInputs+0x5c>)
 8023200:	f007 f8ec 	bl	802a3dc <BUS_IO_Read>
 8023204:	4603      	mov	r3, r0
 8023206:	461a      	mov	r2, r3
 8023208:	4b0e      	ldr	r3, [pc, #56]	; (8023244 <ReadInputs+0x58>)
 802320a:	805a      	strh	r2, [r3, #2]
	Inputs.GIO =  BUS_IO_Read(&GROUP_IN);
 802320c:	480f      	ldr	r0, [pc, #60]	; (802324c <ReadInputs+0x60>)
 802320e:	f007 f8e5 	bl	802a3dc <BUS_IO_Read>
 8023212:	4603      	mov	r3, r0
 8023214:	461a      	mov	r2, r3
 8023216:	4b0b      	ldr	r3, [pc, #44]	; (8023244 <ReadInputs+0x58>)
 8023218:	809a      	strh	r2, [r3, #4]

	if (DIGITAL_IO_GetInput(&SERVICE_BUT))
 802321a:	480d      	ldr	r0, [pc, #52]	; (8023250 <ReadInputs+0x64>)
 802321c:	f7ff ff82 	bl	8023124 <DIGITAL_IO_GetInput>
 8023220:	4603      	mov	r3, r0
 8023222:	2b00      	cmp	r3, #0
 8023224:	d003      	beq.n	802322e <ReadInputs+0x42>
	{
		Inputs.SB = 0;
 8023226:	4b07      	ldr	r3, [pc, #28]	; (8023244 <ReadInputs+0x58>)
 8023228:	2200      	movs	r2, #0
 802322a:	80da      	strh	r2, [r3, #6]
 802322c:	e002      	b.n	8023234 <ReadInputs+0x48>
	}
	else
	{
		Inputs.SB = 1;
 802322e:	4b05      	ldr	r3, [pc, #20]	; (8023244 <ReadInputs+0x58>)
 8023230:	2201      	movs	r2, #1
 8023232:	80da      	strh	r2, [r3, #6]
	}

	ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 8023234:	4807      	ldr	r0, [pc, #28]	; (8023254 <ReadInputs+0x68>)
 8023236:	f007 fad7 	bl	802a7e8 <ADC_MEASUREMENT_StartConversion>
}
 802323a:	bf00      	nop
 802323c:	bd80      	pop	{r7, pc}
 802323e:	bf00      	nop
 8023240:	20000548 	.word	0x20000548
 8023244:	20000668 	.word	0x20000668
 8023248:	2000055c 	.word	0x2000055c
 802324c:	20000520 	.word	0x20000520
 8023250:	0802b3dc 	.word	0x0802b3dc
 8023254:	200005dc 	.word	0x200005dc

08023258 <ReadOpen1DoorButton>:

void ReadOpen1DoorButton(void)
{
 8023258:	b480      	push	{r7}
 802325a:	af00      	add	r7, sp, #0
	if (Inputs.PNP & 0x0004)
 802325c:	4b08      	ldr	r3, [pc, #32]	; (8023280 <ReadOpen1DoorButton+0x28>)
 802325e:	881b      	ldrh	r3, [r3, #0]
 8023260:	f003 0304 	and.w	r3, r3, #4
 8023264:	2b00      	cmp	r3, #0
 8023266:	d003      	beq.n	8023270 <ReadOpen1DoorButton+0x18>
	{
		Open1DoorBut = 1;
 8023268:	4b06      	ldr	r3, [pc, #24]	; (8023284 <ReadOpen1DoorButton+0x2c>)
 802326a:	2201      	movs	r2, #1
 802326c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		Open1DoorBut = 0;
	}
}
 802326e:	e002      	b.n	8023276 <ReadOpen1DoorButton+0x1e>
		Open1DoorBut = 0;
 8023270:	4b04      	ldr	r3, [pc, #16]	; (8023284 <ReadOpen1DoorButton+0x2c>)
 8023272:	2200      	movs	r2, #0
 8023274:	601a      	str	r2, [r3, #0]
}
 8023276:	bf00      	nop
 8023278:	46bd      	mov	sp, r7
 802327a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802327e:	4770      	bx	lr
 8023280:	20000668 	.word	0x20000668
 8023284:	20000648 	.word	0x20000648

08023288 <ReadCloseSensor>:

void ReadCloseSensor (void)
{
 8023288:	b480      	push	{r7}
 802328a:	af00      	add	r7, sp, #0

	if (Presets.CLOSE_SENSOR_TYPE)
 802328c:	4b11      	ldr	r3, [pc, #68]	; (80232d4 <ReadCloseSensor+0x4c>)
 802328e:	685b      	ldr	r3, [r3, #4]
 8023290:	2b00      	cmp	r3, #0
 8023292:	d00d      	beq.n	80232b0 <ReadCloseSensor+0x28>
	{
		if (Inputs.PNP & 0x0008)
 8023294:	4b10      	ldr	r3, [pc, #64]	; (80232d8 <ReadCloseSensor+0x50>)
 8023296:	881b      	ldrh	r3, [r3, #0]
 8023298:	f003 0308 	and.w	r3, r3, #8
 802329c:	2b00      	cmp	r3, #0
 802329e:	d003      	beq.n	80232a8 <ReadCloseSensor+0x20>
		{
			CloseSensor = 0;
 80232a0:	4b0e      	ldr	r3, [pc, #56]	; (80232dc <ReadCloseSensor+0x54>)
 80232a2:	2200      	movs	r2, #0
 80232a4:	601a      	str	r2, [r3, #0]
		else
		{
			CloseSensor = 0;
		}
	}
}
 80232a6:	e010      	b.n	80232ca <ReadCloseSensor+0x42>
			CloseSensor = 1;
 80232a8:	4b0c      	ldr	r3, [pc, #48]	; (80232dc <ReadCloseSensor+0x54>)
 80232aa:	2201      	movs	r2, #1
 80232ac:	601a      	str	r2, [r3, #0]
}
 80232ae:	e00c      	b.n	80232ca <ReadCloseSensor+0x42>
		if (Inputs.PNP & 0x0008)
 80232b0:	4b09      	ldr	r3, [pc, #36]	; (80232d8 <ReadCloseSensor+0x50>)
 80232b2:	881b      	ldrh	r3, [r3, #0]
 80232b4:	f003 0308 	and.w	r3, r3, #8
 80232b8:	2b00      	cmp	r3, #0
 80232ba:	d003      	beq.n	80232c4 <ReadCloseSensor+0x3c>
			CloseSensor = 1;
 80232bc:	4b07      	ldr	r3, [pc, #28]	; (80232dc <ReadCloseSensor+0x54>)
 80232be:	2201      	movs	r2, #1
 80232c0:	601a      	str	r2, [r3, #0]
}
 80232c2:	e002      	b.n	80232ca <ReadCloseSensor+0x42>
			CloseSensor = 0;
 80232c4:	4b05      	ldr	r3, [pc, #20]	; (80232dc <ReadCloseSensor+0x54>)
 80232c6:	2200      	movs	r2, #0
 80232c8:	601a      	str	r2, [r3, #0]
}
 80232ca:	bf00      	nop
 80232cc:	46bd      	mov	sp, r7
 80232ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232d2:	4770      	bx	lr
 80232d4:	20000770 	.word	0x20000770
 80232d8:	20000668 	.word	0x20000668
 80232dc:	2000062c 	.word	0x2000062c

080232e0 <ReadServiceButton>:
		PhotoSensor = 1;
	}
}

void ReadServiceButton(void)
{
 80232e0:	b580      	push	{r7, lr}
 80232e2:	af00      	add	r7, sp, #0
	static uint32_t previous_state;

	if (DIGITAL_IO_GetInput(&SERVICE_BUT))
 80232e4:	4811      	ldr	r0, [pc, #68]	; (802332c <ReadServiceButton+0x4c>)
 80232e6:	f7ff ff1d 	bl	8023124 <DIGITAL_IO_GetInput>
 80232ea:	4603      	mov	r3, r0
 80232ec:	2b00      	cmp	r3, #0
 80232ee:	d003      	beq.n	80232f8 <ReadServiceButton+0x18>
	{
		ServiceButton = 0;
 80232f0:	4b0f      	ldr	r3, [pc, #60]	; (8023330 <ReadServiceButton+0x50>)
 80232f2:	2200      	movs	r2, #0
 80232f4:	601a      	str	r2, [r3, #0]
 80232f6:	e002      	b.n	80232fe <ReadServiceButton+0x1e>
		//PassengerButton = 0;
	}
	else
	{
		ServiceButton = 1;
 80232f8:	4b0d      	ldr	r3, [pc, #52]	; (8023330 <ReadServiceButton+0x50>)
 80232fa:	2201      	movs	r2, #1
 80232fc:	601a      	str	r2, [r3, #0]
		//PassengerButton = 1;
	}
	if (ServiceButton && !previous_state)
 80232fe:	4b0c      	ldr	r3, [pc, #48]	; (8023330 <ReadServiceButton+0x50>)
 8023300:	681b      	ldr	r3, [r3, #0]
 8023302:	2b00      	cmp	r3, #0
 8023304:	d007      	beq.n	8023316 <ReadServiceButton+0x36>
 8023306:	4b0b      	ldr	r3, [pc, #44]	; (8023334 <ReadServiceButton+0x54>)
 8023308:	681b      	ldr	r3, [r3, #0]
 802330a:	2b00      	cmp	r3, #0
 802330c:	d103      	bne.n	8023316 <ReadServiceButton+0x36>
	{
		ServiceButtonFront = 1;
 802330e:	4b0a      	ldr	r3, [pc, #40]	; (8023338 <ReadServiceButton+0x58>)
 8023310:	2201      	movs	r2, #1
 8023312:	601a      	str	r2, [r3, #0]
 8023314:	e002      	b.n	802331c <ReadServiceButton+0x3c>
	}
	else
	{
		ServiceButtonFront = 0;
 8023316:	4b08      	ldr	r3, [pc, #32]	; (8023338 <ReadServiceButton+0x58>)
 8023318:	2200      	movs	r2, #0
 802331a:	601a      	str	r2, [r3, #0]
	}

	previous_state = ServiceButton;
 802331c:	4b04      	ldr	r3, [pc, #16]	; (8023330 <ReadServiceButton+0x50>)
 802331e:	681b      	ldr	r3, [r3, #0]
 8023320:	461a      	mov	r2, r3
 8023322:	4b04      	ldr	r3, [pc, #16]	; (8023334 <ReadServiceButton+0x54>)
 8023324:	601a      	str	r2, [r3, #0]

}
 8023326:	bf00      	nop
 8023328:	bd80      	pop	{r7, pc}
 802332a:	bf00      	nop
 802332c:	0802b3dc 	.word	0x0802b3dc
 8023330:	20000638 	.word	0x20000638
 8023334:	20000678 	.word	0x20000678
 8023338:	2000063c 	.word	0x2000063c

0802333c <ReadPassengerButton>:
void ReadPassengerButton(void)
{
 802333c:	b580      	push	{r7, lr}
 802333e:	b082      	sub	sp, #8
 8023340:	af00      	add	r7, sp, #0
	uint16_t Group_inputs = 0;
 8023342:	2300      	movs	r3, #0
 8023344:	80fb      	strh	r3, [r7, #6]

	Group_inputs = BUS_IO_Read(&GROUP_IN);
 8023346:	480a      	ldr	r0, [pc, #40]	; (8023370 <ReadPassengerButton+0x34>)
 8023348:	f007 f848 	bl	802a3dc <BUS_IO_Read>
 802334c:	4603      	mov	r3, r0
 802334e:	80fb      	strh	r3, [r7, #6]

	if ((Group_inputs & 0x0001))
 8023350:	88fb      	ldrh	r3, [r7, #6]
 8023352:	f003 0301 	and.w	r3, r3, #1
 8023356:	2b00      	cmp	r3, #0
 8023358:	d003      	beq.n	8023362 <ReadPassengerButton+0x26>
	{
		 PassengerButton = 1;
 802335a:	4b06      	ldr	r3, [pc, #24]	; (8023374 <ReadPassengerButton+0x38>)
 802335c:	2201      	movs	r2, #1
 802335e:	601a      	str	r2, [r3, #0]
	else
	{
		 PassengerButton = 0;
	}

}
 8023360:	e002      	b.n	8023368 <ReadPassengerButton+0x2c>
		 PassengerButton = 0;
 8023362:	4b04      	ldr	r3, [pc, #16]	; (8023374 <ReadPassengerButton+0x38>)
 8023364:	2200      	movs	r2, #0
 8023366:	601a      	str	r2, [r3, #0]
}
 8023368:	bf00      	nop
 802336a:	3708      	adds	r7, #8
 802336c:	46bd      	mov	sp, r7
 802336e:	bd80      	pop	{r7, pc}
 8023370:	20000520 	.word	0x20000520
 8023374:	20000630 	.word	0x20000630

08023378 <ReadDisabledButton>:

void ReadDisabledButton(void)
{
 8023378:	b580      	push	{r7, lr}
 802337a:	b082      	sub	sp, #8
 802337c:	af00      	add	r7, sp, #0
	uint16_t Group_inputs = 0;
 802337e:	2300      	movs	r3, #0
 8023380:	80fb      	strh	r3, [r7, #6]

	Group_inputs = BUS_IO_Read(&GROUP_IN);
 8023382:	480a      	ldr	r0, [pc, #40]	; (80233ac <ReadDisabledButton+0x34>)
 8023384:	f007 f82a 	bl	802a3dc <BUS_IO_Read>
 8023388:	4603      	mov	r3, r0
 802338a:	80fb      	strh	r3, [r7, #6]

	if ((Group_inputs & 0x0002))
 802338c:	88fb      	ldrh	r3, [r7, #6]
 802338e:	f003 0302 	and.w	r3, r3, #2
 8023392:	2b00      	cmp	r3, #0
 8023394:	d003      	beq.n	802339e <ReadDisabledButton+0x26>
	{
		 DisabledButton = 1;
 8023396:	4b06      	ldr	r3, [pc, #24]	; (80233b0 <ReadDisabledButton+0x38>)
 8023398:	2201      	movs	r2, #1
 802339a:	601a      	str	r2, [r3, #0]
	}
	else
	{
		 DisabledButton = 0;
	}
}
 802339c:	e002      	b.n	80233a4 <ReadDisabledButton+0x2c>
		 DisabledButton = 0;
 802339e:	4b04      	ldr	r3, [pc, #16]	; (80233b0 <ReadDisabledButton+0x38>)
 80233a0:	2200      	movs	r2, #0
 80233a2:	601a      	str	r2, [r3, #0]
}
 80233a4:	bf00      	nop
 80233a6:	3708      	adds	r7, #8
 80233a8:	46bd      	mov	sp, r7
 80233aa:	bd80      	pop	{r7, pc}
 80233ac:	20000520 	.word	0x20000520
 80233b0:	20000634 	.word	0x20000634

080233b4 <ReadActiveRubber>:

void ReadActiveRubber(void)
{
 80233b4:	b480      	push	{r7}
 80233b6:	af00      	add	r7, sp, #0
	if(Inputs.RIN1 >= 2000)
 80233b8:	4b08      	ldr	r3, [pc, #32]	; (80233dc <ReadActiveRubber+0x28>)
 80233ba:	891b      	ldrh	r3, [r3, #8]
 80233bc:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 80233c0:	d303      	bcc.n	80233ca <ReadActiveRubber+0x16>
	{
		ActiveRubberL = 1;
 80233c2:	4b07      	ldr	r3, [pc, #28]	; (80233e0 <ReadActiveRubber+0x2c>)
 80233c4:	2201      	movs	r2, #1
 80233c6:	601a      	str	r2, [r3, #0]
	}
	else
	{
		ActiveRubberL = 0;
	}
}
 80233c8:	e002      	b.n	80233d0 <ReadActiveRubber+0x1c>
		ActiveRubberL = 0;
 80233ca:	4b05      	ldr	r3, [pc, #20]	; (80233e0 <ReadActiveRubber+0x2c>)
 80233cc:	2200      	movs	r2, #0
 80233ce:	601a      	str	r2, [r3, #0]
}
 80233d0:	bf00      	nop
 80233d2:	46bd      	mov	sp, r7
 80233d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80233d8:	4770      	bx	lr
 80233da:	bf00      	nop
 80233dc:	20000668 	.word	0x20000668
 80233e0:	20000628 	.word	0x20000628

080233e4 <WriteClutch>:


void WriteClutch(int32_t cmd)
{
 80233e4:	b580      	push	{r7, lr}
 80233e6:	b082      	sub	sp, #8
 80233e8:	af00      	add	r7, sp, #0
 80233ea:	6078      	str	r0, [r7, #4]
	static int32_t cmd_prev = 0;
	static int32_t timer = 0;
	static int32_t count_en = 0;

	if(cmd && !cmd_prev)
 80233ec:	687b      	ldr	r3, [r7, #4]
 80233ee:	2b00      	cmp	r3, #0
 80233f0:	d010      	beq.n	8023414 <WriteClutch+0x30>
 80233f2:	4b25      	ldr	r3, [pc, #148]	; (8023488 <WriteClutch+0xa4>)
 80233f4:	681b      	ldr	r3, [r3, #0]
 80233f6:	2b00      	cmp	r3, #0
 80233f8:	d10c      	bne.n	8023414 <WriteClutch+0x30>
	{
		PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 400,(10000 - 5000)); //12V
 80233fa:	f241 3288 	movw	r2, #5000	; 0x1388
 80233fe:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8023402:	4822      	ldr	r0, [pc, #136]	; (802348c <WriteClutch+0xa8>)
 8023404:	f006 fa60 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
		PWM_CCU4_Start(&CLUTCH_PWM);
 8023408:	4820      	ldr	r0, [pc, #128]	; (802348c <WriteClutch+0xa8>)
 802340a:	f006 fa13 	bl	8029834 <PWM_CCU4_Start>
		count_en = 1;
 802340e:	4b20      	ldr	r3, [pc, #128]	; (8023490 <WriteClutch+0xac>)
 8023410:	2201      	movs	r2, #1
 8023412:	601a      	str	r2, [r3, #0]
	}

	if(count_en)
 8023414:	4b1e      	ldr	r3, [pc, #120]	; (8023490 <WriteClutch+0xac>)
 8023416:	681b      	ldr	r3, [r3, #0]
 8023418:	2b00      	cmp	r3, #0
 802341a:	d018      	beq.n	802344e <WriteClutch+0x6a>
	{
		timer++;
 802341c:	4b1d      	ldr	r3, [pc, #116]	; (8023494 <WriteClutch+0xb0>)
 802341e:	681b      	ldr	r3, [r3, #0]
 8023420:	3301      	adds	r3, #1
 8023422:	4a1c      	ldr	r2, [pc, #112]	; (8023494 <WriteClutch+0xb0>)
 8023424:	6013      	str	r3, [r2, #0]

		if(timer >= 200)
 8023426:	4b1b      	ldr	r3, [pc, #108]	; (8023494 <WriteClutch+0xb0>)
 8023428:	681b      	ldr	r3, [r3, #0]
 802342a:	2bc7      	cmp	r3, #199	; 0xc7
 802342c:	dd0f      	ble.n	802344e <WriteClutch+0x6a>
		{
			count_en = 0;
 802342e:	4b18      	ldr	r3, [pc, #96]	; (8023490 <WriteClutch+0xac>)
 8023430:	2200      	movs	r2, #0
 8023432:	601a      	str	r2, [r3, #0]
			timer = 0;
 8023434:	4b17      	ldr	r3, [pc, #92]	; (8023494 <WriteClutch+0xb0>)
 8023436:	2200      	movs	r2, #0
 8023438:	601a      	str	r2, [r3, #0]
			PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 400, (10000 - 2500)); // <15V
 802343a:	f641 524c 	movw	r2, #7500	; 0x1d4c
 802343e:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8023442:	4812      	ldr	r0, [pc, #72]	; (802348c <WriteClutch+0xa8>)
 8023444:	f006 fa40 	bl	80298c8 <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&CLUTCH_PWM);
 8023448:	4810      	ldr	r0, [pc, #64]	; (802348c <WriteClutch+0xa8>)
 802344a:	f006 f9f3 	bl	8029834 <PWM_CCU4_Start>
		}
	}

	if(cmd)
 802344e:	687b      	ldr	r3, [r7, #4]
 8023450:	2b00      	cmp	r3, #0
 8023452:	d003      	beq.n	802345c <WriteClutch+0x78>
	{
		PWM_CCU4_Start(&CLUTCH_PWM);
 8023454:	480d      	ldr	r0, [pc, #52]	; (802348c <WriteClutch+0xa8>)
 8023456:	f006 f9ed 	bl	8029834 <PWM_CCU4_Start>
 802345a:	e00e      	b.n	802347a <WriteClutch+0x96>
	}
	else
	{
		PWM_CCU4_Stop(&CLUTCH_PWM);
 802345c:	480b      	ldr	r0, [pc, #44]	; (802348c <WriteClutch+0xa8>)
 802345e:	f006 fa14 	bl	802988a <PWM_CCU4_Stop>
		DIGITAL_IO_SetOutputLow(&HS_SW_1);
 8023462:	480d      	ldr	r0, [pc, #52]	; (8023498 <WriteClutch+0xb4>)
 8023464:	f7ff fe4e 	bl	8023104 <DIGITAL_IO_SetOutputLow>
		DIGITAL_IO_SetOutputLow(&HS_SW_2);
 8023468:	480c      	ldr	r0, [pc, #48]	; (802349c <WriteClutch+0xb8>)
 802346a:	f7ff fe4b 	bl	8023104 <DIGITAL_IO_SetOutputLow>
		count_en = 0;
 802346e:	4b08      	ldr	r3, [pc, #32]	; (8023490 <WriteClutch+0xac>)
 8023470:	2200      	movs	r2, #0
 8023472:	601a      	str	r2, [r3, #0]
		timer = 0;
 8023474:	4b07      	ldr	r3, [pc, #28]	; (8023494 <WriteClutch+0xb0>)
 8023476:	2200      	movs	r2, #0
 8023478:	601a      	str	r2, [r3, #0]
	}
	cmd_prev = cmd;
 802347a:	4a03      	ldr	r2, [pc, #12]	; (8023488 <WriteClutch+0xa4>)
 802347c:	687b      	ldr	r3, [r7, #4]
 802347e:	6013      	str	r3, [r2, #0]
}
 8023480:	bf00      	nop
 8023482:	3708      	adds	r7, #8
 8023484:	46bd      	mov	sp, r7
 8023486:	bd80      	pop	{r7, pc}
 8023488:	2000067c 	.word	0x2000067c
 802348c:	20000268 	.word	0x20000268
 8023490:	20000680 	.word	0x20000680
 8023494:	20000684 	.word	0x20000684
 8023498:	0802b4b8 	.word	0x0802b4b8
 802349c:	0802b4cc 	.word	0x0802b4cc

080234a0 <WritePassengerButton>:

void WritePassengerButton(int32_t cmd)
{
 80234a0:	b580      	push	{r7, lr}
 80234a2:	b082      	sub	sp, #8
 80234a4:	af00      	add	r7, sp, #0
 80234a6:	6078      	str	r0, [r7, #4]
	if(cmd)
 80234a8:	687b      	ldr	r3, [r7, #4]
 80234aa:	2b00      	cmp	r3, #0
 80234ac:	d004      	beq.n	80234b8 <WritePassengerButton+0x18>
	{
		BUS_IO_Write(&GROUP_OUT, 0xFF);
 80234ae:	21ff      	movs	r1, #255	; 0xff
 80234b0:	4805      	ldr	r0, [pc, #20]	; (80234c8 <WritePassengerButton+0x28>)
 80234b2:	f006 ffc0 	bl	802a436 <BUS_IO_Write>
	}
	else
	{
		BUS_IO_Write(&GROUP_OUT, 0x00);
	}
}
 80234b6:	e003      	b.n	80234c0 <WritePassengerButton+0x20>
		BUS_IO_Write(&GROUP_OUT, 0x00);
 80234b8:	2100      	movs	r1, #0
 80234ba:	4803      	ldr	r0, [pc, #12]	; (80234c8 <WritePassengerButton+0x28>)
 80234bc:	f006 ffbb 	bl	802a436 <BUS_IO_Write>
}
 80234c0:	bf00      	nop
 80234c2:	3708      	adds	r7, #8
 80234c4:	46bd      	mov	sp, r7
 80234c6:	bd80      	pop	{r7, pc}
 80234c8:	20000534 	.word	0x20000534

080234cc <WriteRubberLights>:
	}
}


void WriteRubberLights(uint32_t color, int32_t mode, int32_t time_ms)
{
 80234cc:	b480      	push	{r7}
 80234ce:	b085      	sub	sp, #20
 80234d0:	af00      	add	r7, sp, #0
 80234d2:	60f8      	str	r0, [r7, #12]
 80234d4:	60b9      	str	r1, [r7, #8]
 80234d6:	607a      	str	r2, [r7, #4]
static int32_t timer = 0;
static int32_t previous_mode = 0;

	if ((mode == previous_mode)) // если режим не поменялся
 80234d8:	4b12      	ldr	r3, [pc, #72]	; (8023524 <WriteRubberLights+0x58>)
 80234da:	681b      	ldr	r3, [r3, #0]
 80234dc:	68ba      	ldr	r2, [r7, #8]
 80234de:	429a      	cmp	r2, r3
 80234e0:	f040 8151 	bne.w	8023786 <WriteRubberLights+0x2ba>
	{
		if (mode == MODE_TIME_ON) // Светим время time_ms, затем гасим
 80234e4:	68bb      	ldr	r3, [r7, #8]
 80234e6:	2b03      	cmp	r3, #3
 80234e8:	d169      	bne.n	80235be <WriteRubberLights+0xf2>
		{
			if (timer * MAIN_TIMER_TIME_MS >= time_ms)
 80234ea:	4b0f      	ldr	r3, [pc, #60]	; (8023528 <WriteRubberLights+0x5c>)
 80234ec:	681a      	ldr	r2, [r3, #0]
 80234ee:	4613      	mov	r3, r2
 80234f0:	009b      	lsls	r3, r3, #2
 80234f2:	4413      	add	r3, r2
 80234f4:	005b      	lsls	r3, r3, #1
 80234f6:	461a      	mov	r2, r3
 80234f8:	687b      	ldr	r3, [r7, #4]
 80234fa:	4293      	cmp	r3, r2
 80234fc:	dc18      	bgt.n	8023530 <WriteRubberLights+0x64>
			{
				led_rubber.red_outern = 0;
 80234fe:	4b0b      	ldr	r3, [pc, #44]	; (802352c <WriteRubberLights+0x60>)
 8023500:	2200      	movs	r2, #0
 8023502:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = 0;
 8023504:	4b09      	ldr	r3, [pc, #36]	; (802352c <WriteRubberLights+0x60>)
 8023506:	2200      	movs	r2, #0
 8023508:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 802350a:	4b08      	ldr	r3, [pc, #32]	; (802352c <WriteRubberLights+0x60>)
 802350c:	2200      	movs	r2, #0
 802350e:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = 0;
 8023510:	4b06      	ldr	r3, [pc, #24]	; (802352c <WriteRubberLights+0x60>)
 8023512:	2200      	movs	r2, #0
 8023514:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = 0;
 8023516:	4b05      	ldr	r3, [pc, #20]	; (802352c <WriteRubberLights+0x60>)
 8023518:	2200      	movs	r2, #0
 802351a:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 802351c:	4b03      	ldr	r3, [pc, #12]	; (802352c <WriteRubberLights+0x60>)
 802351e:	2200      	movs	r2, #0
 8023520:	615a      	str	r2, [r3, #20]
 8023522:	e04c      	b.n	80235be <WriteRubberLights+0xf2>
 8023524:	20000688 	.word	0x20000688
 8023528:	2000068c 	.word	0x2000068c
 802352c:	20000650 	.word	0x20000650
			}
			else
			{
				timer ++;
 8023530:	4b98      	ldr	r3, [pc, #608]	; (8023794 <WriteRubberLights+0x2c8>)
 8023532:	681b      	ldr	r3, [r3, #0]
 8023534:	3301      	adds	r3, #1
 8023536:	4a97      	ldr	r2, [pc, #604]	; (8023794 <WriteRubberLights+0x2c8>)
 8023538:	6013      	str	r3, [r2, #0]
				if (color == CL_RED)
 802353a:	68fb      	ldr	r3, [r7, #12]
 802353c:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 8023540:	d111      	bne.n	8023566 <WriteRubberLights+0x9a>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT;
 8023542:	4b95      	ldr	r3, [pc, #596]	; (8023798 <WriteRubberLights+0x2cc>)
 8023544:	223c      	movs	r2, #60	; 0x3c
 8023546:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = 0;
 8023548:	4b93      	ldr	r3, [pc, #588]	; (8023798 <WriteRubberLights+0x2cc>)
 802354a:	2200      	movs	r2, #0
 802354c:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 802354e:	4b92      	ldr	r3, [pc, #584]	; (8023798 <WriteRubberLights+0x2cc>)
 8023550:	2200      	movs	r2, #0
 8023552:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023554:	4b90      	ldr	r3, [pc, #576]	; (8023798 <WriteRubberLights+0x2cc>)
 8023556:	2214      	movs	r2, #20
 8023558:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = 0;
 802355a:	4b8f      	ldr	r3, [pc, #572]	; (8023798 <WriteRubberLights+0x2cc>)
 802355c:	2200      	movs	r2, #0
 802355e:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 8023560:	4b8d      	ldr	r3, [pc, #564]	; (8023798 <WriteRubberLights+0x2cc>)
 8023562:	2200      	movs	r2, #0
 8023564:	615a      	str	r2, [r3, #20]

				}
				if (color == CL_GREEN)
 8023566:	68fb      	ldr	r3, [r7, #12]
 8023568:	f5b3 0f7f 	cmp.w	r3, #16711680	; 0xff0000
 802356c:	d111      	bne.n	8023592 <WriteRubberLights+0xc6>
				{
					led_rubber.red_outern = 0;
 802356e:	4b8a      	ldr	r3, [pc, #552]	; (8023798 <WriteRubberLights+0x2cc>)
 8023570:	2200      	movs	r2, #0
 8023572:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT;
 8023574:	4b88      	ldr	r3, [pc, #544]	; (8023798 <WriteRubberLights+0x2cc>)
 8023576:	223c      	movs	r2, #60	; 0x3c
 8023578:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 802357a:	4b87      	ldr	r3, [pc, #540]	; (8023798 <WriteRubberLights+0x2cc>)
 802357c:	2200      	movs	r2, #0
 802357e:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = 0;
 8023580:	4b85      	ldr	r3, [pc, #532]	; (8023798 <WriteRubberLights+0x2cc>)
 8023582:	2200      	movs	r2, #0
 8023584:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 8023586:	4b84      	ldr	r3, [pc, #528]	; (8023798 <WriteRubberLights+0x2cc>)
 8023588:	2214      	movs	r2, #20
 802358a:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 802358c:	4b82      	ldr	r3, [pc, #520]	; (8023798 <WriteRubberLights+0x2cc>)
 802358e:	2200      	movs	r2, #0
 8023590:	615a      	str	r2, [r3, #20]

				}
				if (color == CL_YELLOW)
 8023592:	68fb      	ldr	r3, [r7, #12]
 8023594:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8023598:	d111      	bne.n	80235be <WriteRubberLights+0xf2>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT/2;
 802359a:	4b7f      	ldr	r3, [pc, #508]	; (8023798 <WriteRubberLights+0x2cc>)
 802359c:	221e      	movs	r2, #30
 802359e:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT/2;
 80235a0:	4b7d      	ldr	r3, [pc, #500]	; (8023798 <WriteRubberLights+0x2cc>)
 80235a2:	221e      	movs	r2, #30
 80235a4:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 80235a6:	4b7c      	ldr	r3, [pc, #496]	; (8023798 <WriteRubberLights+0x2cc>)
 80235a8:	2200      	movs	r2, #0
 80235aa:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 80235ac:	4b7a      	ldr	r3, [pc, #488]	; (8023798 <WriteRubberLights+0x2cc>)
 80235ae:	2214      	movs	r2, #20
 80235b0:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 80235b2:	4b79      	ldr	r3, [pc, #484]	; (8023798 <WriteRubberLights+0x2cc>)
 80235b4:	2214      	movs	r2, #20
 80235b6:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 80235b8:	4b77      	ldr	r3, [pc, #476]	; (8023798 <WriteRubberLights+0x2cc>)
 80235ba:	2200      	movs	r2, #0
 80235bc:	615a      	str	r2, [r3, #20]

				}
			}
		}// end mode time on

		if (mode == MODE_BLINK)
 80235be:	68bb      	ldr	r3, [r7, #8]
 80235c0:	2b02      	cmp	r3, #2
 80235c2:	f040 8086 	bne.w	80236d2 <WriteRubberLights+0x206>
		{
			timer ++;
 80235c6:	4b73      	ldr	r3, [pc, #460]	; (8023794 <WriteRubberLights+0x2c8>)
 80235c8:	681b      	ldr	r3, [r3, #0]
 80235ca:	3301      	adds	r3, #1
 80235cc:	4a71      	ldr	r2, [pc, #452]	; (8023794 <WriteRubberLights+0x2c8>)
 80235ce:	6013      	str	r3, [r2, #0]

			if (timer*10 < time_ms) // если меньше полупериода
 80235d0:	4b70      	ldr	r3, [pc, #448]	; (8023794 <WriteRubberLights+0x2c8>)
 80235d2:	681a      	ldr	r2, [r3, #0]
 80235d4:	4613      	mov	r3, r2
 80235d6:	009b      	lsls	r3, r3, #2
 80235d8:	4413      	add	r3, r2
 80235da:	005b      	lsls	r3, r3, #1
 80235dc:	461a      	mov	r2, r3
 80235de:	687b      	ldr	r3, [r7, #4]
 80235e0:	4293      	cmp	r3, r2
 80235e2:	dd41      	ble.n	8023668 <WriteRubberLights+0x19c>
			{
				if (color == CL_RED)
 80235e4:	68fb      	ldr	r3, [r7, #12]
 80235e6:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 80235ea:	d111      	bne.n	8023610 <WriteRubberLights+0x144>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT;
 80235ec:	4b6a      	ldr	r3, [pc, #424]	; (8023798 <WriteRubberLights+0x2cc>)
 80235ee:	223c      	movs	r2, #60	; 0x3c
 80235f0:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = 0;
 80235f2:	4b69      	ldr	r3, [pc, #420]	; (8023798 <WriteRubberLights+0x2cc>)
 80235f4:	2200      	movs	r2, #0
 80235f6:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 80235f8:	4b67      	ldr	r3, [pc, #412]	; (8023798 <WriteRubberLights+0x2cc>)
 80235fa:	2200      	movs	r2, #0
 80235fc:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 80235fe:	4b66      	ldr	r3, [pc, #408]	; (8023798 <WriteRubberLights+0x2cc>)
 8023600:	2214      	movs	r2, #20
 8023602:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = 0;
 8023604:	4b64      	ldr	r3, [pc, #400]	; (8023798 <WriteRubberLights+0x2cc>)
 8023606:	2200      	movs	r2, #0
 8023608:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 802360a:	4b63      	ldr	r3, [pc, #396]	; (8023798 <WriteRubberLights+0x2cc>)
 802360c:	2200      	movs	r2, #0
 802360e:	615a      	str	r2, [r3, #20]

				}
				if (color == CL_GREEN)
 8023610:	68fb      	ldr	r3, [r7, #12]
 8023612:	f5b3 0f7f 	cmp.w	r3, #16711680	; 0xff0000
 8023616:	d111      	bne.n	802363c <WriteRubberLights+0x170>
				{
					led_rubber.red_outern = 0;
 8023618:	4b5f      	ldr	r3, [pc, #380]	; (8023798 <WriteRubberLights+0x2cc>)
 802361a:	2200      	movs	r2, #0
 802361c:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT;
 802361e:	4b5e      	ldr	r3, [pc, #376]	; (8023798 <WriteRubberLights+0x2cc>)
 8023620:	223c      	movs	r2, #60	; 0x3c
 8023622:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 8023624:	4b5c      	ldr	r3, [pc, #368]	; (8023798 <WriteRubberLights+0x2cc>)
 8023626:	2200      	movs	r2, #0
 8023628:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = 0;
 802362a:	4b5b      	ldr	r3, [pc, #364]	; (8023798 <WriteRubberLights+0x2cc>)
 802362c:	2200      	movs	r2, #0
 802362e:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 8023630:	4b59      	ldr	r3, [pc, #356]	; (8023798 <WriteRubberLights+0x2cc>)
 8023632:	2214      	movs	r2, #20
 8023634:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 8023636:	4b58      	ldr	r3, [pc, #352]	; (8023798 <WriteRubberLights+0x2cc>)
 8023638:	2200      	movs	r2, #0
 802363a:	615a      	str	r2, [r3, #20]
				}
				if (color == CL_YELLOW)
 802363c:	68fb      	ldr	r3, [r7, #12]
 802363e:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8023642:	d111      	bne.n	8023668 <WriteRubberLights+0x19c>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT/2;
 8023644:	4b54      	ldr	r3, [pc, #336]	; (8023798 <WriteRubberLights+0x2cc>)
 8023646:	221e      	movs	r2, #30
 8023648:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT/2;
 802364a:	4b53      	ldr	r3, [pc, #332]	; (8023798 <WriteRubberLights+0x2cc>)
 802364c:	221e      	movs	r2, #30
 802364e:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 8023650:	4b51      	ldr	r3, [pc, #324]	; (8023798 <WriteRubberLights+0x2cc>)
 8023652:	2200      	movs	r2, #0
 8023654:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023656:	4b50      	ldr	r3, [pc, #320]	; (8023798 <WriteRubberLights+0x2cc>)
 8023658:	2214      	movs	r2, #20
 802365a:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 802365c:	4b4e      	ldr	r3, [pc, #312]	; (8023798 <WriteRubberLights+0x2cc>)
 802365e:	2214      	movs	r2, #20
 8023660:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 8023662:	4b4d      	ldr	r3, [pc, #308]	; (8023798 <WriteRubberLights+0x2cc>)
 8023664:	2200      	movs	r2, #0
 8023666:	615a      	str	r2, [r3, #20]

				}
			}
			if ((timer*10 < time_ms*2) && (timer*10 >= time_ms)) // если больше полупериода и меньше периода
 8023668:	4b4a      	ldr	r3, [pc, #296]	; (8023794 <WriteRubberLights+0x2c8>)
 802366a:	681a      	ldr	r2, [r3, #0]
 802366c:	4613      	mov	r3, r2
 802366e:	009b      	lsls	r3, r3, #2
 8023670:	4413      	add	r3, r2
 8023672:	005b      	lsls	r3, r3, #1
 8023674:	461a      	mov	r2, r3
 8023676:	687b      	ldr	r3, [r7, #4]
 8023678:	005b      	lsls	r3, r3, #1
 802367a:	429a      	cmp	r2, r3
 802367c:	da1b      	bge.n	80236b6 <WriteRubberLights+0x1ea>
 802367e:	4b45      	ldr	r3, [pc, #276]	; (8023794 <WriteRubberLights+0x2c8>)
 8023680:	681a      	ldr	r2, [r3, #0]
 8023682:	4613      	mov	r3, r2
 8023684:	009b      	lsls	r3, r3, #2
 8023686:	4413      	add	r3, r2
 8023688:	005b      	lsls	r3, r3, #1
 802368a:	461a      	mov	r2, r3
 802368c:	687b      	ldr	r3, [r7, #4]
 802368e:	4293      	cmp	r3, r2
 8023690:	dc11      	bgt.n	80236b6 <WriteRubberLights+0x1ea>
			{
				led_rubber.red_outern = 0;
 8023692:	4b41      	ldr	r3, [pc, #260]	; (8023798 <WriteRubberLights+0x2cc>)
 8023694:	2200      	movs	r2, #0
 8023696:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = 0;
 8023698:	4b3f      	ldr	r3, [pc, #252]	; (8023798 <WriteRubberLights+0x2cc>)
 802369a:	2200      	movs	r2, #0
 802369c:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 802369e:	4b3e      	ldr	r3, [pc, #248]	; (8023798 <WriteRubberLights+0x2cc>)
 80236a0:	2200      	movs	r2, #0
 80236a2:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = 0;
 80236a4:	4b3c      	ldr	r3, [pc, #240]	; (8023798 <WriteRubberLights+0x2cc>)
 80236a6:	2200      	movs	r2, #0
 80236a8:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = 0;
 80236aa:	4b3b      	ldr	r3, [pc, #236]	; (8023798 <WriteRubberLights+0x2cc>)
 80236ac:	2200      	movs	r2, #0
 80236ae:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 80236b0:	4b39      	ldr	r3, [pc, #228]	; (8023798 <WriteRubberLights+0x2cc>)
 80236b2:	2200      	movs	r2, #0
 80236b4:	615a      	str	r2, [r3, #20]
			}
			if (timer*10 >= time_ms*2)
 80236b6:	4b37      	ldr	r3, [pc, #220]	; (8023794 <WriteRubberLights+0x2c8>)
 80236b8:	681a      	ldr	r2, [r3, #0]
 80236ba:	4613      	mov	r3, r2
 80236bc:	009b      	lsls	r3, r3, #2
 80236be:	4413      	add	r3, r2
 80236c0:	005b      	lsls	r3, r3, #1
 80236c2:	461a      	mov	r2, r3
 80236c4:	687b      	ldr	r3, [r7, #4]
 80236c6:	005b      	lsls	r3, r3, #1
 80236c8:	429a      	cmp	r2, r3
 80236ca:	db02      	blt.n	80236d2 <WriteRubberLights+0x206>
			{
				timer = 0;
 80236cc:	4b31      	ldr	r3, [pc, #196]	; (8023794 <WriteRubberLights+0x2c8>)
 80236ce:	2200      	movs	r2, #0
 80236d0:	601a      	str	r2, [r3, #0]
			}
		}
		if (mode == MODE_OFF)
 80236d2:	68bb      	ldr	r3, [r7, #8]
 80236d4:	2b00      	cmp	r3, #0
 80236d6:	d111      	bne.n	80236fc <WriteRubberLights+0x230>
		{
			led_rubber.red_outern = 0;
 80236d8:	4b2f      	ldr	r3, [pc, #188]	; (8023798 <WriteRubberLights+0x2cc>)
 80236da:	2200      	movs	r2, #0
 80236dc:	601a      	str	r2, [r3, #0]
			led_rubber.green_outern = 0;
 80236de:	4b2e      	ldr	r3, [pc, #184]	; (8023798 <WriteRubberLights+0x2cc>)
 80236e0:	2200      	movs	r2, #0
 80236e2:	605a      	str	r2, [r3, #4]
			led_rubber.blue_outern = 0;
 80236e4:	4b2c      	ldr	r3, [pc, #176]	; (8023798 <WriteRubberLights+0x2cc>)
 80236e6:	2200      	movs	r2, #0
 80236e8:	609a      	str	r2, [r3, #8]
			led_rubber.red_intern = 0;
 80236ea:	4b2b      	ldr	r3, [pc, #172]	; (8023798 <WriteRubberLights+0x2cc>)
 80236ec:	2200      	movs	r2, #0
 80236ee:	60da      	str	r2, [r3, #12]
			led_rubber.green_intern = 0;
 80236f0:	4b29      	ldr	r3, [pc, #164]	; (8023798 <WriteRubberLights+0x2cc>)
 80236f2:	2200      	movs	r2, #0
 80236f4:	611a      	str	r2, [r3, #16]
			led_rubber.blue_intern = 0;
 80236f6:	4b28      	ldr	r3, [pc, #160]	; (8023798 <WriteRubberLights+0x2cc>)
 80236f8:	2200      	movs	r2, #0
 80236fa:	615a      	str	r2, [r3, #20]
		}
		if (mode == MODE_ON)
 80236fc:	68bb      	ldr	r3, [r7, #8]
 80236fe:	2b01      	cmp	r3, #1
 8023700:	d141      	bne.n	8023786 <WriteRubberLights+0x2ba>
		{
			if (color == CL_RED)
 8023702:	68fb      	ldr	r3, [r7, #12]
 8023704:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 8023708:	d111      	bne.n	802372e <WriteRubberLights+0x262>
			{
				led_rubber.red_outern = OUTER_RUBBER_PERCENT;
 802370a:	4b23      	ldr	r3, [pc, #140]	; (8023798 <WriteRubberLights+0x2cc>)
 802370c:	223c      	movs	r2, #60	; 0x3c
 802370e:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = 0;
 8023710:	4b21      	ldr	r3, [pc, #132]	; (8023798 <WriteRubberLights+0x2cc>)
 8023712:	2200      	movs	r2, #0
 8023714:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 8023716:	4b20      	ldr	r3, [pc, #128]	; (8023798 <WriteRubberLights+0x2cc>)
 8023718:	2200      	movs	r2, #0
 802371a:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = INTER_RUBBER_PERCENT;
 802371c:	4b1e      	ldr	r3, [pc, #120]	; (8023798 <WriteRubberLights+0x2cc>)
 802371e:	2214      	movs	r2, #20
 8023720:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = 0;
 8023722:	4b1d      	ldr	r3, [pc, #116]	; (8023798 <WriteRubberLights+0x2cc>)
 8023724:	2200      	movs	r2, #0
 8023726:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 8023728:	4b1b      	ldr	r3, [pc, #108]	; (8023798 <WriteRubberLights+0x2cc>)
 802372a:	2200      	movs	r2, #0
 802372c:	615a      	str	r2, [r3, #20]

			}
			if (color == CL_GREEN)
 802372e:	68fb      	ldr	r3, [r7, #12]
 8023730:	f5b3 0f7f 	cmp.w	r3, #16711680	; 0xff0000
 8023734:	d111      	bne.n	802375a <WriteRubberLights+0x28e>
			{
				led_rubber.red_outern = 0;
 8023736:	4b18      	ldr	r3, [pc, #96]	; (8023798 <WriteRubberLights+0x2cc>)
 8023738:	2200      	movs	r2, #0
 802373a:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = OUTER_RUBBER_PERCENT;
 802373c:	4b16      	ldr	r3, [pc, #88]	; (8023798 <WriteRubberLights+0x2cc>)
 802373e:	223c      	movs	r2, #60	; 0x3c
 8023740:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 8023742:	4b15      	ldr	r3, [pc, #84]	; (8023798 <WriteRubberLights+0x2cc>)
 8023744:	2200      	movs	r2, #0
 8023746:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = 0;
 8023748:	4b13      	ldr	r3, [pc, #76]	; (8023798 <WriteRubberLights+0x2cc>)
 802374a:	2200      	movs	r2, #0
 802374c:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = INTER_RUBBER_PERCENT;
 802374e:	4b12      	ldr	r3, [pc, #72]	; (8023798 <WriteRubberLights+0x2cc>)
 8023750:	2214      	movs	r2, #20
 8023752:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 8023754:	4b10      	ldr	r3, [pc, #64]	; (8023798 <WriteRubberLights+0x2cc>)
 8023756:	2200      	movs	r2, #0
 8023758:	615a      	str	r2, [r3, #20]

			}
			if (color == CL_YELLOW)
 802375a:	68fb      	ldr	r3, [r7, #12]
 802375c:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8023760:	d111      	bne.n	8023786 <WriteRubberLights+0x2ba>
			{
				led_rubber.red_outern = OUTER_RUBBER_PERCENT/2;
 8023762:	4b0d      	ldr	r3, [pc, #52]	; (8023798 <WriteRubberLights+0x2cc>)
 8023764:	221e      	movs	r2, #30
 8023766:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = OUTER_RUBBER_PERCENT/2;
 8023768:	4b0b      	ldr	r3, [pc, #44]	; (8023798 <WriteRubberLights+0x2cc>)
 802376a:	221e      	movs	r2, #30
 802376c:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 802376e:	4b0a      	ldr	r3, [pc, #40]	; (8023798 <WriteRubberLights+0x2cc>)
 8023770:	2200      	movs	r2, #0
 8023772:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023774:	4b08      	ldr	r3, [pc, #32]	; (8023798 <WriteRubberLights+0x2cc>)
 8023776:	2214      	movs	r2, #20
 8023778:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = INTER_RUBBER_PERCENT;
 802377a:	4b07      	ldr	r3, [pc, #28]	; (8023798 <WriteRubberLights+0x2cc>)
 802377c:	2214      	movs	r2, #20
 802377e:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 8023780:	4b05      	ldr	r3, [pc, #20]	; (8023798 <WriteRubberLights+0x2cc>)
 8023782:	2200      	movs	r2, #0
 8023784:	615a      	str	r2, [r3, #20]
			}

		}
	} // end_of mode not changed

	if (mode != previous_mode)
 8023786:	4b05      	ldr	r3, [pc, #20]	; (802379c <WriteRubberLights+0x2d0>)
 8023788:	681b      	ldr	r3, [r3, #0]
 802378a:	68ba      	ldr	r2, [r7, #8]
 802378c:	429a      	cmp	r2, r3
 802378e:	d00a      	beq.n	80237a6 <WriteRubberLights+0x2da>
 8023790:	e006      	b.n	80237a0 <WriteRubberLights+0x2d4>
 8023792:	bf00      	nop
 8023794:	2000068c 	.word	0x2000068c
 8023798:	20000650 	.word	0x20000650
 802379c:	20000688 	.word	0x20000688
	{
		timer = 0;
 80237a0:	4b05      	ldr	r3, [pc, #20]	; (80237b8 <WriteRubberLights+0x2ec>)
 80237a2:	2200      	movs	r2, #0
 80237a4:	601a      	str	r2, [r3, #0]
	}
	previous_mode = mode;
 80237a6:	4a05      	ldr	r2, [pc, #20]	; (80237bc <WriteRubberLights+0x2f0>)
 80237a8:	68bb      	ldr	r3, [r7, #8]
 80237aa:	6013      	str	r3, [r2, #0]

}
 80237ac:	bf00      	nop
 80237ae:	3714      	adds	r7, #20
 80237b0:	46bd      	mov	sp, r7
 80237b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80237b6:	4770      	bx	lr
 80237b8:	2000068c 	.word	0x2000068c
 80237bc:	20000688 	.word	0x20000688

080237c0 <LedPwmTimerProc>:
void LedPwmTimerProc(void *args)
{
 80237c0:	b580      	push	{r7, lr}
 80237c2:	b082      	sub	sp, #8
 80237c4:	af00      	add	r7, sp, #0
 80237c6:	6078      	str	r0, [r7, #4]
	static int32_t timer = 0;

	if (timer >= 100)
 80237c8:	4b39      	ldr	r3, [pc, #228]	; (80238b0 <LedPwmTimerProc+0xf0>)
 80237ca:	681b      	ldr	r3, [r3, #0]
 80237cc:	2b63      	cmp	r3, #99	; 0x63
 80237ce:	dd02      	ble.n	80237d6 <LedPwmTimerProc+0x16>
	{
		timer = 0;
 80237d0:	4b37      	ldr	r3, [pc, #220]	; (80238b0 <LedPwmTimerProc+0xf0>)
 80237d2:	2200      	movs	r2, #0
 80237d4:	601a      	str	r2, [r3, #0]
	}
	if(!timer)
 80237d6:	4b36      	ldr	r3, [pc, #216]	; (80238b0 <LedPwmTimerProc+0xf0>)
 80237d8:	681b      	ldr	r3, [r3, #0]
 80237da:	2b00      	cmp	r3, #0
 80237dc:	d129      	bne.n	8023832 <LedPwmTimerProc+0x72>
	{
		if(led_rubber.red_outern)
 80237de:	4b35      	ldr	r3, [pc, #212]	; (80238b4 <LedPwmTimerProc+0xf4>)
 80237e0:	681b      	ldr	r3, [r3, #0]
 80237e2:	2b00      	cmp	r3, #0
 80237e4:	d002      	beq.n	80237ec <LedPwmTimerProc+0x2c>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_1);
 80237e6:	4834      	ldr	r0, [pc, #208]	; (80238b8 <LedPwmTimerProc+0xf8>)
 80237e8:	f7ff fc7c 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.green_outern)
 80237ec:	4b31      	ldr	r3, [pc, #196]	; (80238b4 <LedPwmTimerProc+0xf4>)
 80237ee:	685b      	ldr	r3, [r3, #4]
 80237f0:	2b00      	cmp	r3, #0
 80237f2:	d002      	beq.n	80237fa <LedPwmTimerProc+0x3a>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_2);
 80237f4:	4831      	ldr	r0, [pc, #196]	; (80238bc <LedPwmTimerProc+0xfc>)
 80237f6:	f7ff fc75 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.blue_outern)
 80237fa:	4b2e      	ldr	r3, [pc, #184]	; (80238b4 <LedPwmTimerProc+0xf4>)
 80237fc:	689b      	ldr	r3, [r3, #8]
 80237fe:	2b00      	cmp	r3, #0
 8023800:	d002      	beq.n	8023808 <LedPwmTimerProc+0x48>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_3);
 8023802:	482f      	ldr	r0, [pc, #188]	; (80238c0 <LedPwmTimerProc+0x100>)
 8023804:	f7ff fc6e 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.red_intern)
 8023808:	4b2a      	ldr	r3, [pc, #168]	; (80238b4 <LedPwmTimerProc+0xf4>)
 802380a:	68db      	ldr	r3, [r3, #12]
 802380c:	2b00      	cmp	r3, #0
 802380e:	d002      	beq.n	8023816 <LedPwmTimerProc+0x56>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_4);
 8023810:	482c      	ldr	r0, [pc, #176]	; (80238c4 <LedPwmTimerProc+0x104>)
 8023812:	f7ff fc67 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.green_intern)
 8023816:	4b27      	ldr	r3, [pc, #156]	; (80238b4 <LedPwmTimerProc+0xf4>)
 8023818:	691b      	ldr	r3, [r3, #16]
 802381a:	2b00      	cmp	r3, #0
 802381c:	d002      	beq.n	8023824 <LedPwmTimerProc+0x64>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_5);
 802381e:	482a      	ldr	r0, [pc, #168]	; (80238c8 <LedPwmTimerProc+0x108>)
 8023820:	f7ff fc60 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.blue_intern)
 8023824:	4b23      	ldr	r3, [pc, #140]	; (80238b4 <LedPwmTimerProc+0xf4>)
 8023826:	695b      	ldr	r3, [r3, #20]
 8023828:	2b00      	cmp	r3, #0
 802382a:	d002      	beq.n	8023832 <LedPwmTimerProc+0x72>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_6);
 802382c:	4827      	ldr	r0, [pc, #156]	; (80238cc <LedPwmTimerProc+0x10c>)
 802382e:	f7ff fc59 	bl	80230e4 <DIGITAL_IO_SetOutputHigh>
		}
	}


	if ((led_rubber.red_outern <= timer))
 8023832:	4b20      	ldr	r3, [pc, #128]	; (80238b4 <LedPwmTimerProc+0xf4>)
 8023834:	681a      	ldr	r2, [r3, #0]
 8023836:	4b1e      	ldr	r3, [pc, #120]	; (80238b0 <LedPwmTimerProc+0xf0>)
 8023838:	681b      	ldr	r3, [r3, #0]
 802383a:	429a      	cmp	r2, r3
 802383c:	dc02      	bgt.n	8023844 <LedPwmTimerProc+0x84>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_1);
 802383e:	481e      	ldr	r0, [pc, #120]	; (80238b8 <LedPwmTimerProc+0xf8>)
 8023840:	f7ff fc60 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.green_outern <= timer))
 8023844:	4b1b      	ldr	r3, [pc, #108]	; (80238b4 <LedPwmTimerProc+0xf4>)
 8023846:	685a      	ldr	r2, [r3, #4]
 8023848:	4b19      	ldr	r3, [pc, #100]	; (80238b0 <LedPwmTimerProc+0xf0>)
 802384a:	681b      	ldr	r3, [r3, #0]
 802384c:	429a      	cmp	r2, r3
 802384e:	dc02      	bgt.n	8023856 <LedPwmTimerProc+0x96>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_2);
 8023850:	481a      	ldr	r0, [pc, #104]	; (80238bc <LedPwmTimerProc+0xfc>)
 8023852:	f7ff fc57 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.blue_outern <= timer))
 8023856:	4b17      	ldr	r3, [pc, #92]	; (80238b4 <LedPwmTimerProc+0xf4>)
 8023858:	689a      	ldr	r2, [r3, #8]
 802385a:	4b15      	ldr	r3, [pc, #84]	; (80238b0 <LedPwmTimerProc+0xf0>)
 802385c:	681b      	ldr	r3, [r3, #0]
 802385e:	429a      	cmp	r2, r3
 8023860:	dc02      	bgt.n	8023868 <LedPwmTimerProc+0xa8>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_3);
 8023862:	4817      	ldr	r0, [pc, #92]	; (80238c0 <LedPwmTimerProc+0x100>)
 8023864:	f7ff fc4e 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.red_intern <= timer))
 8023868:	4b12      	ldr	r3, [pc, #72]	; (80238b4 <LedPwmTimerProc+0xf4>)
 802386a:	68da      	ldr	r2, [r3, #12]
 802386c:	4b10      	ldr	r3, [pc, #64]	; (80238b0 <LedPwmTimerProc+0xf0>)
 802386e:	681b      	ldr	r3, [r3, #0]
 8023870:	429a      	cmp	r2, r3
 8023872:	dc02      	bgt.n	802387a <LedPwmTimerProc+0xba>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_4);
 8023874:	4813      	ldr	r0, [pc, #76]	; (80238c4 <LedPwmTimerProc+0x104>)
 8023876:	f7ff fc45 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.green_intern <= timer))
 802387a:	4b0e      	ldr	r3, [pc, #56]	; (80238b4 <LedPwmTimerProc+0xf4>)
 802387c:	691a      	ldr	r2, [r3, #16]
 802387e:	4b0c      	ldr	r3, [pc, #48]	; (80238b0 <LedPwmTimerProc+0xf0>)
 8023880:	681b      	ldr	r3, [r3, #0]
 8023882:	429a      	cmp	r2, r3
 8023884:	dc02      	bgt.n	802388c <LedPwmTimerProc+0xcc>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_5);
 8023886:	4810      	ldr	r0, [pc, #64]	; (80238c8 <LedPwmTimerProc+0x108>)
 8023888:	f7ff fc3c 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.blue_intern <= timer))
 802388c:	4b09      	ldr	r3, [pc, #36]	; (80238b4 <LedPwmTimerProc+0xf4>)
 802388e:	695a      	ldr	r2, [r3, #20]
 8023890:	4b07      	ldr	r3, [pc, #28]	; (80238b0 <LedPwmTimerProc+0xf0>)
 8023892:	681b      	ldr	r3, [r3, #0]
 8023894:	429a      	cmp	r2, r3
 8023896:	dc02      	bgt.n	802389e <LedPwmTimerProc+0xde>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_6);
 8023898:	480c      	ldr	r0, [pc, #48]	; (80238cc <LedPwmTimerProc+0x10c>)
 802389a:	f7ff fc33 	bl	8023104 <DIGITAL_IO_SetOutputLow>
	}

	timer++;
 802389e:	4b04      	ldr	r3, [pc, #16]	; (80238b0 <LedPwmTimerProc+0xf0>)
 80238a0:	681b      	ldr	r3, [r3, #0]
 80238a2:	3301      	adds	r3, #1
 80238a4:	4a02      	ldr	r2, [pc, #8]	; (80238b0 <LedPwmTimerProc+0xf0>)
 80238a6:	6013      	str	r3, [r2, #0]
}
 80238a8:	bf00      	nop
 80238aa:	3708      	adds	r7, #8
 80238ac:	46bd      	mov	sp, r7
 80238ae:	bd80      	pop	{r7, pc}
 80238b0:	20000690 	.word	0x20000690
 80238b4:	20000650 	.word	0x20000650
 80238b8:	0802b5d0 	.word	0x0802b5d0
 80238bc:	0802b5e4 	.word	0x0802b5e4
 80238c0:	0802b5f8 	.word	0x0802b5f8
 80238c4:	0802b60c 	.word	0x0802b60c
 80238c8:	0802b620 	.word	0x0802b620
 80238cc:	0802b634 	.word	0x0802b634

080238d0 <CAN_NODE_MO_UpdateID>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_UpdateID(const CAN_NODE_LMO_t * const lmo_ptr, const uint32_t id)
{
 80238d0:	b580      	push	{r7, lr}
 80238d2:	b082      	sub	sp, #8
 80238d4:	af00      	add	r7, sp, #0
 80238d6:	6078      	str	r0, [r7, #4]
 80238d8:	6039      	str	r1, [r7, #0]
  XMC_CAN_MO_SetIdentifier(lmo_ptr->mo_ptr, id);
 80238da:	687b      	ldr	r3, [r7, #4]
 80238dc:	681b      	ldr	r3, [r3, #0]
 80238de:	6839      	ldr	r1, [r7, #0]
 80238e0:	4618      	mov	r0, r3
 80238e2:	f003 fd21 	bl	8027328 <XMC_CAN_MO_SetIdentifier>
 }
 80238e6:	bf00      	nop
 80238e8:	3708      	adds	r7, #8
 80238ea:	46bd      	mov	sp, r7
 80238ec:	bd80      	pop	{r7, pc}
	...

080238f0 <Can1Tx1Send>:
int32_t CanCmdCloseAll = 0;
int32_t CanCmdEnablePassengersButton = 0;


void Can1Tx1Send(void)
{
 80238f0:	b580      	push	{r7, lr}
 80238f2:	af00      	add	r7, sp, #0
	CAN_NODE_MO_UpdateID(&CAN_EXT_LMO_07_Config, (0x100 + Presets.CAN_ADRESS));
 80238f4:	4b08      	ldr	r3, [pc, #32]	; (8023918 <Can1Tx1Send+0x28>)
 80238f6:	689b      	ldr	r3, [r3, #8]
 80238f8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80238fc:	4619      	mov	r1, r3
 80238fe:	4807      	ldr	r0, [pc, #28]	; (802391c <Can1Tx1Send+0x2c>)
 8023900:	f7ff ffe6 	bl	80238d0 <CAN_NODE_MO_UpdateID>
	CAN_NODE_MO_UpdateData(&CAN_EXT_LMO_07_Config, &Can1TxData1[0]);
 8023904:	4906      	ldr	r1, [pc, #24]	; (8023920 <Can1Tx1Send+0x30>)
 8023906:	4805      	ldr	r0, [pc, #20]	; (802391c <Can1Tx1Send+0x2c>)
 8023908:	f006 fc48 	bl	802a19c <CAN_NODE_MO_UpdateData>
	CAN_NODE_MO_Transmit(&CAN_EXT_LMO_07_Config);
 802390c:	4803      	ldr	r0, [pc, #12]	; (802391c <Can1Tx1Send+0x2c>)
 802390e:	f006 fc21 	bl	802a154 <CAN_NODE_MO_Transmit>
}
 8023912:	bf00      	nop
 8023914:	bd80      	pop	{r7, pc}
 8023916:	bf00      	nop
 8023918:	20000770 	.word	0x20000770
 802391c:	0802b718 	.word	0x0802b718
 8023920:	200006cc 	.word	0x200006cc

08023924 <Can1Rx1Parce>:

void Can1Rx1Parce(void)
{
 8023924:	b480      	push	{r7}
 8023926:	b083      	sub	sp, #12
 8023928:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 802392a:	2300      	movs	r3, #0
 802392c:	71fb      	strb	r3, [r7, #7]
	uint8_t temp2 = 0;
 802392e:	2300      	movs	r3, #0
 8023930:	71bb      	strb	r3, [r7, #6]

	temp = Can1Rx1Data[0];
 8023932:	4b12      	ldr	r3, [pc, #72]	; (802397c <Can1Rx1Parce+0x58>)
 8023934:	781b      	ldrb	r3, [r3, #0]
 8023936:	71fb      	strb	r3, [r7, #7]

	if(temp & (1<<2))
 8023938:	79fb      	ldrb	r3, [r7, #7]
 802393a:	f003 0304 	and.w	r3, r3, #4
 802393e:	2b00      	cmp	r3, #0
 8023940:	d003      	beq.n	802394a <Can1Rx1Parce+0x26>
	{
		CanCmdUnlock = 1;
 8023942:	4b0f      	ldr	r3, [pc, #60]	; (8023980 <Can1Rx1Parce+0x5c>)
 8023944:	2201      	movs	r2, #1
 8023946:	601a      	str	r2, [r3, #0]
 8023948:	e002      	b.n	8023950 <Can1Rx1Parce+0x2c>
	}
	else
	{
		CanCmdUnlock = 0;
 802394a:	4b0d      	ldr	r3, [pc, #52]	; (8023980 <Can1Rx1Parce+0x5c>)
 802394c:	2200      	movs	r2, #0
 802394e:	601a      	str	r2, [r3, #0]
	}
	temp2 = Can1Rx1Data[5];
 8023950:	4b0a      	ldr	r3, [pc, #40]	; (802397c <Can1Rx1Parce+0x58>)
 8023952:	795b      	ldrb	r3, [r3, #5]
 8023954:	71bb      	strb	r3, [r7, #6]
// Enable open all
	if ((temp & (1<<0)))// && (temp2 & (1<<Presets.CAN_ADRESS)))
 8023956:	79fb      	ldrb	r3, [r7, #7]
 8023958:	f003 0301 	and.w	r3, r3, #1
 802395c:	2b00      	cmp	r3, #0
 802395e:	d003      	beq.n	8023968 <Can1Rx1Parce+0x44>
	{
		CanCmdOpenEnable = 1;
 8023960:	4b08      	ldr	r3, [pc, #32]	; (8023984 <Can1Rx1Parce+0x60>)
 8023962:	2201      	movs	r2, #1
 8023964:	601a      	str	r2, [r3, #0]
	{
		CanCmdOpenEnable = 0;
	}


}
 8023966:	e002      	b.n	802396e <Can1Rx1Parce+0x4a>
		CanCmdOpenEnable = 0;
 8023968:	4b06      	ldr	r3, [pc, #24]	; (8023984 <Can1Rx1Parce+0x60>)
 802396a:	2200      	movs	r2, #0
 802396c:	601a      	str	r2, [r3, #0]
}
 802396e:	bf00      	nop
 8023970:	370c      	adds	r7, #12
 8023972:	46bd      	mov	sp, r7
 8023974:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023978:	4770      	bx	lr
 802397a:	bf00      	nop
 802397c:	20000694 	.word	0x20000694
 8023980:	200006b4 	.word	0x200006b4
 8023984:	200006b0 	.word	0x200006b0

08023988 <Can1Rx2Parce>:
void Can1Rx2Parce(void)
{
 8023988:	b480      	push	{r7}
 802398a:	b083      	sub	sp, #12
 802398c:	af00      	add	r7, sp, #0
	uint32_t temp = 0;
 802398e:	2300      	movs	r3, #0
 8023990:	607b      	str	r3, [r7, #4]
	uint32_t *pt;

	pt = (uint32_t*)(Can1Rx2Data);
 8023992:	4b0e      	ldr	r3, [pc, #56]	; (80239cc <Can1Rx2Parce+0x44>)
 8023994:	603b      	str	r3, [r7, #0]
	temp = *pt;
 8023996:	683b      	ldr	r3, [r7, #0]
 8023998:	681b      	ldr	r3, [r3, #0]
 802399a:	607b      	str	r3, [r7, #4]

	if(temp & (1<<(Presets.CAN_ADRESS * 4)))
 802399c:	4b0c      	ldr	r3, [pc, #48]	; (80239d0 <Can1Rx2Parce+0x48>)
 802399e:	689b      	ldr	r3, [r3, #8]
 80239a0:	009b      	lsls	r3, r3, #2
 80239a2:	2201      	movs	r2, #1
 80239a4:	fa02 f303 	lsl.w	r3, r2, r3
 80239a8:	461a      	mov	r2, r3
 80239aa:	687b      	ldr	r3, [r7, #4]
 80239ac:	4013      	ands	r3, r2
 80239ae:	2b00      	cmp	r3, #0
 80239b0:	d003      	beq.n	80239ba <Can1Rx2Parce+0x32>
	{
		CanCmdOpenCmd = 1;
 80239b2:	4b08      	ldr	r3, [pc, #32]	; (80239d4 <Can1Rx2Parce+0x4c>)
 80239b4:	2201      	movs	r2, #1
 80239b6:	601a      	str	r2, [r3, #0]
	}
	else
	{
		CanCmdOpenCmd = 0;
	}
}
 80239b8:	e002      	b.n	80239c0 <Can1Rx2Parce+0x38>
		CanCmdOpenCmd = 0;
 80239ba:	4b06      	ldr	r3, [pc, #24]	; (80239d4 <Can1Rx2Parce+0x4c>)
 80239bc:	2200      	movs	r2, #0
 80239be:	601a      	str	r2, [r3, #0]
}
 80239c0:	bf00      	nop
 80239c2:	370c      	adds	r7, #12
 80239c4:	46bd      	mov	sp, r7
 80239c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80239ca:	4770      	bx	lr
 80239cc:	2000069c 	.word	0x2000069c
 80239d0:	20000770 	.word	0x20000770
 80239d4:	200006b8 	.word	0x200006b8

080239d8 <Can1Rx3Parce>:

void Can1Rx3Parce(void)
{
 80239d8:	b480      	push	{r7}
 80239da:	b083      	sub	sp, #12
 80239dc:	af00      	add	r7, sp, #0
	uint32_t temp = 0;
 80239de:	2300      	movs	r3, #0
 80239e0:	607b      	str	r3, [r7, #4]
	uint32_t *pt;

	pt = (uint32_t*)(Can1Rx3Data);
 80239e2:	4b19      	ldr	r3, [pc, #100]	; (8023a48 <Can1Rx3Parce+0x70>)
 80239e4:	603b      	str	r3, [r7, #0]
	temp = *pt;
 80239e6:	683b      	ldr	r3, [r7, #0]
 80239e8:	681b      	ldr	r3, [r3, #0]
 80239ea:	607b      	str	r3, [r7, #4]

	if(temp & (1<<(Presets.CAN_ADRESS * 4)))
 80239ec:	4b17      	ldr	r3, [pc, #92]	; (8023a4c <Can1Rx3Parce+0x74>)
 80239ee:	689b      	ldr	r3, [r3, #8]
 80239f0:	009b      	lsls	r3, r3, #2
 80239f2:	2201      	movs	r2, #1
 80239f4:	fa02 f303 	lsl.w	r3, r2, r3
 80239f8:	461a      	mov	r2, r3
 80239fa:	687b      	ldr	r3, [r7, #4]
 80239fc:	4013      	ands	r3, r2
 80239fe:	2b00      	cmp	r3, #0
 8023a00:	d003      	beq.n	8023a0a <Can1Rx3Parce+0x32>
	{
		CanCmdCloseCmd = 1;
 8023a02:	4b13      	ldr	r3, [pc, #76]	; (8023a50 <Can1Rx3Parce+0x78>)
 8023a04:	2201      	movs	r2, #1
 8023a06:	601a      	str	r2, [r3, #0]
 8023a08:	e002      	b.n	8023a10 <Can1Rx3Parce+0x38>
	}
	else
	{
		CanCmdCloseCmd = 0;
 8023a0a:	4b11      	ldr	r3, [pc, #68]	; (8023a50 <Can1Rx3Parce+0x78>)
 8023a0c:	2200      	movs	r2, #0
 8023a0e:	601a      	str	r2, [r3, #0]
	}

	pt = (uint32_t*)(Can1Rx2Data);
 8023a10:	4b10      	ldr	r3, [pc, #64]	; (8023a54 <Can1Rx3Parce+0x7c>)
 8023a12:	603b      	str	r3, [r7, #0]
	//temp = *pt;

	if (!temp && CanCmdOpenEnable && !(*pt)) // 22/04/2022 // need dbg
 8023a14:	687b      	ldr	r3, [r7, #4]
 8023a16:	2b00      	cmp	r3, #0
 8023a18:	d10b      	bne.n	8023a32 <Can1Rx3Parce+0x5a>
 8023a1a:	4b0f      	ldr	r3, [pc, #60]	; (8023a58 <Can1Rx3Parce+0x80>)
 8023a1c:	681b      	ldr	r3, [r3, #0]
 8023a1e:	2b00      	cmp	r3, #0
 8023a20:	d007      	beq.n	8023a32 <Can1Rx3Parce+0x5a>
 8023a22:	683b      	ldr	r3, [r7, #0]
 8023a24:	681b      	ldr	r3, [r3, #0]
 8023a26:	2b00      	cmp	r3, #0
 8023a28:	d103      	bne.n	8023a32 <Can1Rx3Parce+0x5a>
	{
		CanCmdEnablePassengersButton = 1;
 8023a2a:	4b0c      	ldr	r3, [pc, #48]	; (8023a5c <Can1Rx3Parce+0x84>)
 8023a2c:	2201      	movs	r2, #1
 8023a2e:	601a      	str	r2, [r3, #0]
 8023a30:	e003      	b.n	8023a3a <Can1Rx3Parce+0x62>
	}
	else
	{
		CanCmdEnablePassengersButton = 0;
 8023a32:	4b0a      	ldr	r3, [pc, #40]	; (8023a5c <Can1Rx3Parce+0x84>)
 8023a34:	2200      	movs	r2, #0
 8023a36:	601a      	str	r2, [r3, #0]
	}

}
 8023a38:	bf00      	nop
 8023a3a:	bf00      	nop
 8023a3c:	370c      	adds	r7, #12
 8023a3e:	46bd      	mov	sp, r7
 8023a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023a44:	4770      	bx	lr
 8023a46:	bf00      	nop
 8023a48:	200006a4 	.word	0x200006a4
 8023a4c:	20000770 	.word	0x20000770
 8023a50:	200006bc 	.word	0x200006bc
 8023a54:	2000069c 	.word	0x2000069c
 8023a58:	200006b0 	.word	0x200006b0
 8023a5c:	200006c0 	.word	0x200006c0

08023a60 <Can1Tx1Prep>:

void Can1Tx1Prep (void)
{
 8023a60:	b480      	push	{r7}
 8023a62:	b083      	sub	sp, #12
 8023a64:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 8023a66:	2300      	movs	r3, #0
 8023a68:	71fb      	strb	r3, [r7, #7]

	temp = 0x01;
 8023a6a:	2301      	movs	r3, #1
 8023a6c:	71fb      	strb	r3, [r7, #7]

	Can1TxData1[0] = temp;
 8023a6e:	4a65      	ldr	r2, [pc, #404]	; (8023c04 <Can1Tx1Prep+0x1a4>)
 8023a70:	79fb      	ldrb	r3, [r7, #7]
 8023a72:	7013      	strb	r3, [r2, #0]

	temp = 0;
 8023a74:	2300      	movs	r3, #0
 8023a76:	71fb      	strb	r3, [r7, #7]

	switch (MainState)
 8023a78:	4b63      	ldr	r3, [pc, #396]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023a7a:	681b      	ldr	r3, [r3, #0]
 8023a7c:	3b03      	subs	r3, #3
 8023a7e:	2b09      	cmp	r3, #9
 8023a80:	d833      	bhi.n	8023aea <Can1Tx1Prep+0x8a>
 8023a82:	a201      	add	r2, pc, #4	; (adr r2, 8023a88 <Can1Tx1Prep+0x28>)
 8023a84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8023a88:	08023ab1 	.word	0x08023ab1
 8023a8c:	08023acf 	.word	0x08023acf
 8023a90:	08023ac5 	.word	0x08023ac5
 8023a94:	08023abb 	.word	0x08023abb
 8023a98:	08023aeb 	.word	0x08023aeb
 8023a9c:	08023aeb 	.word	0x08023aeb
 8023aa0:	08023aeb 	.word	0x08023aeb
 8023aa4:	08023aeb 	.word	0x08023aeb
 8023aa8:	08023ae3 	.word	0x08023ae3
 8023aac:	08023ad9 	.word	0x08023ad9
	{
		case MS_CLOSED:
		{
			temp |= (1<<0);
 8023ab0:	79fb      	ldrb	r3, [r7, #7]
 8023ab2:	f043 0301 	orr.w	r3, r3, #1
 8023ab6:	71fb      	strb	r3, [r7, #7]
		}break;
 8023ab8:	e017      	b.n	8023aea <Can1Tx1Prep+0x8a>
		case MS_CLOSING:
		{
			temp |= (1<<1);
 8023aba:	79fb      	ldrb	r3, [r7, #7]
 8023abc:	f043 0302 	orr.w	r3, r3, #2
 8023ac0:	71fb      	strb	r3, [r7, #7]
		}break;
 8023ac2:	e012      	b.n	8023aea <Can1Tx1Prep+0x8a>
		case MS_OPENED:
		{
			temp |= (1<<2);
 8023ac4:	79fb      	ldrb	r3, [r7, #7]
 8023ac6:	f043 0304 	orr.w	r3, r3, #4
 8023aca:	71fb      	strb	r3, [r7, #7]
		}break;
 8023acc:	e00d      	b.n	8023aea <Can1Tx1Prep+0x8a>
		case MS_OPENING:
		{
			temp |= (1<<3);
 8023ace:	79fb      	ldrb	r3, [r7, #7]
 8023ad0:	f043 0308 	orr.w	r3, r3, #8
 8023ad4:	71fb      	strb	r3, [r7, #7]
		}break;
 8023ad6:	e008      	b.n	8023aea <Can1Tx1Prep+0x8a>
		case MS_BLOCKAGE_ALL:
		{
			temp |= (1<<4);
 8023ad8:	79fb      	ldrb	r3, [r7, #7]
 8023ada:	f043 0310 	orr.w	r3, r3, #16
 8023ade:	71fb      	strb	r3, [r7, #7]
		}break;
 8023ae0:	e003      	b.n	8023aea <Can1Tx1Prep+0x8a>
		case MS_BLOCKAGE_OPN:
		{
			temp |= (1<<4);
 8023ae2:	79fb      	ldrb	r3, [r7, #7]
 8023ae4:	f043 0310 	orr.w	r3, r3, #16
 8023ae8:	71fb      	strb	r3, [r7, #7]
		}
	}
	if (CloseSensor)
 8023aea:	4b48      	ldr	r3, [pc, #288]	; (8023c0c <Can1Tx1Prep+0x1ac>)
 8023aec:	681b      	ldr	r3, [r3, #0]
 8023aee:	2b00      	cmp	r3, #0
 8023af0:	d003      	beq.n	8023afa <Can1Tx1Prep+0x9a>
	{
		temp |= 1;
 8023af2:	79fb      	ldrb	r3, [r7, #7]
 8023af4:	f043 0301 	orr.w	r3, r3, #1
 8023af8:	71fb      	strb	r3, [r7, #7]
	}
//	if(PassengerButton)
//	{
//		temp |= (1<<6);
//	}
	Can1TxData1[1] = temp;
 8023afa:	4a42      	ldr	r2, [pc, #264]	; (8023c04 <Can1Tx1Prep+0x1a4>)
 8023afc:	79fb      	ldrb	r3, [r7, #7]
 8023afe:	7053      	strb	r3, [r2, #1]

	temp = 0;
 8023b00:	2300      	movs	r3, #0
 8023b02:	71fb      	strb	r3, [r7, #7]
	if(ActiveRubberL)
 8023b04:	4b42      	ldr	r3, [pc, #264]	; (8023c10 <Can1Tx1Prep+0x1b0>)
 8023b06:	681b      	ldr	r3, [r3, #0]
 8023b08:	2b00      	cmp	r3, #0
 8023b0a:	d003      	beq.n	8023b14 <Can1Tx1Prep+0xb4>
	{
		temp |= (1<<0);
 8023b0c:	79fb      	ldrb	r3, [r7, #7]
 8023b0e:	f043 0301 	orr.w	r3, r3, #1
 8023b12:	71fb      	strb	r3, [r7, #7]
	}

	if(MainState == MS_BLOCKAGE_CLS)
 8023b14:	4b3c      	ldr	r3, [pc, #240]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b16:	681b      	ldr	r3, [r3, #0]
 8023b18:	2b0a      	cmp	r3, #10
 8023b1a:	d103      	bne.n	8023b24 <Can1Tx1Prep+0xc4>
	{
		temp |= (1<<1);
 8023b1c:	79fb      	ldrb	r3, [r7, #7]
 8023b1e:	f043 0302 	orr.w	r3, r3, #2
 8023b22:	71fb      	strb	r3, [r7, #7]
/*	if(PhotoSensor)
	{
		temp |= (1<<2);
	}
*/
	Can1TxData1[2] = temp;
 8023b24:	4a37      	ldr	r2, [pc, #220]	; (8023c04 <Can1Tx1Prep+0x1a4>)
 8023b26:	79fb      	ldrb	r3, [r7, #7]
 8023b28:	7093      	strb	r3, [r2, #2]

	temp = 0;
 8023b2a:	2300      	movs	r3, #0
 8023b2c:	71fb      	strb	r3, [r7, #7]

	if(DisabledButton)
 8023b2e:	4b39      	ldr	r3, [pc, #228]	; (8023c14 <Can1Tx1Prep+0x1b4>)
 8023b30:	681b      	ldr	r3, [r3, #0]
 8023b32:	2b00      	cmp	r3, #0
 8023b34:	d003      	beq.n	8023b3e <Can1Tx1Prep+0xde>
	{
		temp |= (0x04);
 8023b36:	79fb      	ldrb	r3, [r7, #7]
 8023b38:	f043 0304 	orr.w	r3, r3, #4
 8023b3c:	71fb      	strb	r3, [r7, #7]
	}

	Can1TxData1[3] = temp;
 8023b3e:	4a31      	ldr	r2, [pc, #196]	; (8023c04 <Can1Tx1Prep+0x1a4>)
 8023b40:	79fb      	ldrb	r3, [r7, #7]
 8023b42:	70d3      	strb	r3, [r2, #3]

	temp = 0;
 8023b44:	2300      	movs	r3, #0
 8023b46:	71fb      	strb	r3, [r7, #7]
		temp = ((1<<2) || (1<<6));
	}

	Can1TxData1[4] = temp;
*/
	temp = 0;
 8023b48:	2300      	movs	r3, #0
 8023b4a:	71fb      	strb	r3, [r7, #7]
	if(MainState == MS_OPENING || MainState == MS_BLOCKAGE_OPN)
 8023b4c:	4b2e      	ldr	r3, [pc, #184]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b4e:	681b      	ldr	r3, [r3, #0]
 8023b50:	2b04      	cmp	r3, #4
 8023b52:	d003      	beq.n	8023b5c <Can1Tx1Prep+0xfc>
 8023b54:	4b2c      	ldr	r3, [pc, #176]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b56:	681b      	ldr	r3, [r3, #0]
 8023b58:	2b0b      	cmp	r3, #11
 8023b5a:	d101      	bne.n	8023b60 <Can1Tx1Prep+0x100>
	{
		temp = 0x40;
 8023b5c:	2340      	movs	r3, #64	; 0x40
 8023b5e:	71fb      	strb	r3, [r7, #7]
	}
	if(MainState == MS_OPENED || MainState == MS_CLOSING || MainState == MS_OPENED_BLOCK || MainState == MS_BLOCKAGE_CLS || MainState == MS_HOMING)
 8023b60:	4b29      	ldr	r3, [pc, #164]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b62:	681b      	ldr	r3, [r3, #0]
 8023b64:	2b05      	cmp	r3, #5
 8023b66:	d00f      	beq.n	8023b88 <Can1Tx1Prep+0x128>
 8023b68:	4b27      	ldr	r3, [pc, #156]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b6a:	681b      	ldr	r3, [r3, #0]
 8023b6c:	2b06      	cmp	r3, #6
 8023b6e:	d00b      	beq.n	8023b88 <Can1Tx1Prep+0x128>
 8023b70:	4b25      	ldr	r3, [pc, #148]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b72:	681b      	ldr	r3, [r3, #0]
 8023b74:	2b07      	cmp	r3, #7
 8023b76:	d007      	beq.n	8023b88 <Can1Tx1Prep+0x128>
 8023b78:	4b23      	ldr	r3, [pc, #140]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b7a:	681b      	ldr	r3, [r3, #0]
 8023b7c:	2b0a      	cmp	r3, #10
 8023b7e:	d003      	beq.n	8023b88 <Can1Tx1Prep+0x128>
 8023b80:	4b21      	ldr	r3, [pc, #132]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b82:	681b      	ldr	r3, [r3, #0]
 8023b84:	2b02      	cmp	r3, #2
 8023b86:	d101      	bne.n	8023b8c <Can1Tx1Prep+0x12c>
	{
		temp = 0x60;
 8023b88:	2360      	movs	r3, #96	; 0x60
 8023b8a:	71fb      	strb	r3, [r7, #7]
	}
	if(MainState == MS_CLOSED)
 8023b8c:	4b1e      	ldr	r3, [pc, #120]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b8e:	681b      	ldr	r3, [r3, #0]
 8023b90:	2b03      	cmp	r3, #3
 8023b92:	d101      	bne.n	8023b98 <Can1Tx1Prep+0x138>
	{
		temp = 0;
 8023b94:	2300      	movs	r3, #0
 8023b96:	71fb      	strb	r3, [r7, #7]
	}
	if(MainState == MS_BLOCKAGE_ALL || MainState == MS_BLOCKAGE_CLS || MainState == MS_ERROR_MAX_CURRENT || MainState == MS_ERROR_MOV_TIMEOUT)
 8023b98:	4b1b      	ldr	r3, [pc, #108]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023b9a:	681b      	ldr	r3, [r3, #0]
 8023b9c:	2b0c      	cmp	r3, #12
 8023b9e:	d00b      	beq.n	8023bb8 <Can1Tx1Prep+0x158>
 8023ba0:	4b19      	ldr	r3, [pc, #100]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023ba2:	681b      	ldr	r3, [r3, #0]
 8023ba4:	2b0a      	cmp	r3, #10
 8023ba6:	d007      	beq.n	8023bb8 <Can1Tx1Prep+0x158>
 8023ba8:	4b17      	ldr	r3, [pc, #92]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023baa:	681b      	ldr	r3, [r3, #0]
 8023bac:	2b16      	cmp	r3, #22
 8023bae:	d003      	beq.n	8023bb8 <Can1Tx1Prep+0x158>
 8023bb0:	4b15      	ldr	r3, [pc, #84]	; (8023c08 <Can1Tx1Prep+0x1a8>)
 8023bb2:	681b      	ldr	r3, [r3, #0]
 8023bb4:	2b15      	cmp	r3, #21
 8023bb6:	d103      	bne.n	8023bc0 <Can1Tx1Prep+0x160>
	{
		temp |= 0x01;
 8023bb8:	79fb      	ldrb	r3, [r7, #7]
 8023bba:	f043 0301 	orr.w	r3, r3, #1
 8023bbe:	71fb      	strb	r3, [r7, #7]
	}

	Can1TxData1[6] = temp;
 8023bc0:	4a10      	ldr	r2, [pc, #64]	; (8023c04 <Can1Tx1Prep+0x1a4>)
 8023bc2:	79fb      	ldrb	r3, [r7, #7]
 8023bc4:	7193      	strb	r3, [r2, #6]

	if(Presets.CAN_ADRESS == 0)
 8023bc6:	4b14      	ldr	r3, [pc, #80]	; (8023c18 <Can1Tx1Prep+0x1b8>)
 8023bc8:	689b      	ldr	r3, [r3, #8]
 8023bca:	2b00      	cmp	r3, #0
 8023bcc:	d101      	bne.n	8023bd2 <Can1Tx1Prep+0x172>
	{
		temp = 0x86;
 8023bce:	2386      	movs	r3, #134	; 0x86
 8023bd0:	71fb      	strb	r3, [r7, #7]
	}
	if(Presets.CAN_ADRESS == 5)
 8023bd2:	4b11      	ldr	r3, [pc, #68]	; (8023c18 <Can1Tx1Prep+0x1b8>)
 8023bd4:	689b      	ldr	r3, [r3, #8]
 8023bd6:	2b05      	cmp	r3, #5
 8023bd8:	d101      	bne.n	8023bde <Can1Tx1Prep+0x17e>
	{
		temp = 0x87;
 8023bda:	2387      	movs	r3, #135	; 0x87
 8023bdc:	71fb      	strb	r3, [r7, #7]
	}
	if((Presets.CAN_ADRESS != 0) && (Presets.CAN_ADRESS != 5))
 8023bde:	4b0e      	ldr	r3, [pc, #56]	; (8023c18 <Can1Tx1Prep+0x1b8>)
 8023be0:	689b      	ldr	r3, [r3, #8]
 8023be2:	2b00      	cmp	r3, #0
 8023be4:	d005      	beq.n	8023bf2 <Can1Tx1Prep+0x192>
 8023be6:	4b0c      	ldr	r3, [pc, #48]	; (8023c18 <Can1Tx1Prep+0x1b8>)
 8023be8:	689b      	ldr	r3, [r3, #8]
 8023bea:	2b05      	cmp	r3, #5
 8023bec:	d001      	beq.n	8023bf2 <Can1Tx1Prep+0x192>
	{
		temp = 0x96;
 8023bee:	2396      	movs	r3, #150	; 0x96
 8023bf0:	71fb      	strb	r3, [r7, #7]
	}
	Can1TxData1[7] = temp;
 8023bf2:	4a04      	ldr	r2, [pc, #16]	; (8023c04 <Can1Tx1Prep+0x1a4>)
 8023bf4:	79fb      	ldrb	r3, [r7, #7]
 8023bf6:	71d3      	strb	r3, [r2, #7]
}
 8023bf8:	bf00      	nop
 8023bfa:	370c      	adds	r7, #12
 8023bfc:	46bd      	mov	sp, r7
 8023bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023c02:	4770      	bx	lr
 8023c04:	200006cc 	.word	0x200006cc
 8023c08:	200006f4 	.word	0x200006f4
 8023c0c:	2000062c 	.word	0x2000062c
 8023c10:	20000628 	.word	0x20000628
 8023c14:	20000634 	.word	0x20000634
 8023c18:	20000770 	.word	0x20000770

08023c1c <CAN0_6_IRQHandler>:



void CAN1RxHandler (void)
{
 8023c1c:	b580      	push	{r7, lr}
 8023c1e:	b084      	sub	sp, #16
 8023c20:	af00      	add	r7, sp, #0
	static uint32_t pack_counter = 0;

	//DIGITAL_IO_ToggleOutput(&STATUS_LED_G);

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_01_Config);
 8023c22:	4835      	ldr	r0, [pc, #212]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023c24:	f006 faa8 	bl	802a178 <CAN_NODE_MO_Receive>

	pack_counter ++; // for ident no link
 8023c28:	4b34      	ldr	r3, [pc, #208]	; (8023cfc <CAN0_6_IRQHandler+0xe0>)
 8023c2a:	681b      	ldr	r3, [r3, #0]
 8023c2c:	3301      	adds	r3, #1
 8023c2e:	4a33      	ldr	r2, [pc, #204]	; (8023cfc <CAN0_6_IRQHandler+0xe0>)
 8023c30:	6013      	str	r3, [r2, #0]

	if(pack_counter >= 200)
 8023c32:	4b32      	ldr	r3, [pc, #200]	; (8023cfc <CAN0_6_IRQHandler+0xe0>)
 8023c34:	681b      	ldr	r3, [r3, #0]
 8023c36:	2bc7      	cmp	r3, #199	; 0xc7
 8023c38:	d902      	bls.n	8023c40 <CAN0_6_IRQHandler+0x24>
	{
		ExtCanOnline = 1;
 8023c3a:	4b31      	ldr	r3, [pc, #196]	; (8023d00 <CAN0_6_IRQHandler+0xe4>)
 8023c3c:	2201      	movs	r2, #1
 8023c3e:	601a      	str	r2, [r3, #0]
	}


	if (CAN_EXT_LMO_01_Config.mo_ptr->can_identifier == 0x80)
 8023c40:	4b2d      	ldr	r3, [pc, #180]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023c42:	681b      	ldr	r3, [r3, #0]
 8023c44:	685b      	ldr	r3, [r3, #4]
 8023c46:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023c4a:	2b80      	cmp	r3, #128	; 0x80
 8023c4c:	d115      	bne.n	8023c7a <CAN0_6_IRQHandler+0x5e>
	{

		for (int i = 0; i < 8; i++)
 8023c4e:	2300      	movs	r3, #0
 8023c50:	60fb      	str	r3, [r7, #12]
 8023c52:	e00d      	b.n	8023c70 <CAN0_6_IRQHandler+0x54>
		{
			Can1Rx1Data[i] = CAN_EXT_LMO_01_Config.mo_ptr->can_data_byte[i];
 8023c54:	4b28      	ldr	r3, [pc, #160]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023c56:	681a      	ldr	r2, [r3, #0]
 8023c58:	68fb      	ldr	r3, [r7, #12]
 8023c5a:	4413      	add	r3, r2
 8023c5c:	3310      	adds	r3, #16
 8023c5e:	7819      	ldrb	r1, [r3, #0]
 8023c60:	4a28      	ldr	r2, [pc, #160]	; (8023d04 <CAN0_6_IRQHandler+0xe8>)
 8023c62:	68fb      	ldr	r3, [r7, #12]
 8023c64:	4413      	add	r3, r2
 8023c66:	460a      	mov	r2, r1
 8023c68:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 8023c6a:	68fb      	ldr	r3, [r7, #12]
 8023c6c:	3301      	adds	r3, #1
 8023c6e:	60fb      	str	r3, [r7, #12]
 8023c70:	68fb      	ldr	r3, [r7, #12]
 8023c72:	2b07      	cmp	r3, #7
 8023c74:	ddee      	ble.n	8023c54 <CAN0_6_IRQHandler+0x38>
		}

		Can1Rx1Parce();
 8023c76:	f7ff fe55 	bl	8023924 <Can1Rx1Parce>
	}

	if (CAN_EXT_LMO_01_Config.mo_ptr->can_identifier == 0x81)
 8023c7a:	4b1f      	ldr	r3, [pc, #124]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023c7c:	681b      	ldr	r3, [r3, #0]
 8023c7e:	685b      	ldr	r3, [r3, #4]
 8023c80:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023c84:	2b81      	cmp	r3, #129	; 0x81
 8023c86:	d115      	bne.n	8023cb4 <CAN0_6_IRQHandler+0x98>
	{

		for (int i = 0; i < 8; i++)
 8023c88:	2300      	movs	r3, #0
 8023c8a:	60bb      	str	r3, [r7, #8]
 8023c8c:	e00d      	b.n	8023caa <CAN0_6_IRQHandler+0x8e>
		{
			Can1Rx2Data[i] = CAN_EXT_LMO_01_Config.mo_ptr->can_data_byte[i];
 8023c8e:	4b1a      	ldr	r3, [pc, #104]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023c90:	681a      	ldr	r2, [r3, #0]
 8023c92:	68bb      	ldr	r3, [r7, #8]
 8023c94:	4413      	add	r3, r2
 8023c96:	3310      	adds	r3, #16
 8023c98:	7819      	ldrb	r1, [r3, #0]
 8023c9a:	4a1b      	ldr	r2, [pc, #108]	; (8023d08 <CAN0_6_IRQHandler+0xec>)
 8023c9c:	68bb      	ldr	r3, [r7, #8]
 8023c9e:	4413      	add	r3, r2
 8023ca0:	460a      	mov	r2, r1
 8023ca2:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 8023ca4:	68bb      	ldr	r3, [r7, #8]
 8023ca6:	3301      	adds	r3, #1
 8023ca8:	60bb      	str	r3, [r7, #8]
 8023caa:	68bb      	ldr	r3, [r7, #8]
 8023cac:	2b07      	cmp	r3, #7
 8023cae:	ddee      	ble.n	8023c8e <CAN0_6_IRQHandler+0x72>
		}

		Can1Rx2Parce();
 8023cb0:	f7ff fe6a 	bl	8023988 <Can1Rx2Parce>
	}

	if (CAN_EXT_LMO_01_Config.mo_ptr->can_identifier == 0x82)
 8023cb4:	4b10      	ldr	r3, [pc, #64]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023cb6:	681b      	ldr	r3, [r3, #0]
 8023cb8:	685b      	ldr	r3, [r3, #4]
 8023cba:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023cbe:	2b82      	cmp	r3, #130	; 0x82
 8023cc0:	d115      	bne.n	8023cee <CAN0_6_IRQHandler+0xd2>
	{

		for (int i = 0; i < 8; i++)
 8023cc2:	2300      	movs	r3, #0
 8023cc4:	607b      	str	r3, [r7, #4]
 8023cc6:	e00d      	b.n	8023ce4 <CAN0_6_IRQHandler+0xc8>
		{
			Can1Rx3Data[i] = CAN_EXT_LMO_01_Config.mo_ptr->can_data_byte[i];
 8023cc8:	4b0b      	ldr	r3, [pc, #44]	; (8023cf8 <CAN0_6_IRQHandler+0xdc>)
 8023cca:	681a      	ldr	r2, [r3, #0]
 8023ccc:	687b      	ldr	r3, [r7, #4]
 8023cce:	4413      	add	r3, r2
 8023cd0:	3310      	adds	r3, #16
 8023cd2:	7819      	ldrb	r1, [r3, #0]
 8023cd4:	4a0d      	ldr	r2, [pc, #52]	; (8023d0c <CAN0_6_IRQHandler+0xf0>)
 8023cd6:	687b      	ldr	r3, [r7, #4]
 8023cd8:	4413      	add	r3, r2
 8023cda:	460a      	mov	r2, r1
 8023cdc:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 8023cde:	687b      	ldr	r3, [r7, #4]
 8023ce0:	3301      	adds	r3, #1
 8023ce2:	607b      	str	r3, [r7, #4]
 8023ce4:	687b      	ldr	r3, [r7, #4]
 8023ce6:	2b07      	cmp	r3, #7
 8023ce8:	ddee      	ble.n	8023cc8 <CAN0_6_IRQHandler+0xac>
		}

		Can1Rx3Parce();
 8023cea:	f7ff fe75 	bl	80239d8 <Can1Rx3Parce>
	}
}
 8023cee:	bf00      	nop
 8023cf0:	3710      	adds	r7, #16
 8023cf2:	46bd      	mov	sp, r7
 8023cf4:	bd80      	pop	{r7, pc}
 8023cf6:	bf00      	nop
 8023cf8:	0802b6d0 	.word	0x0802b6d0
 8023cfc:	200006c4 	.word	0x200006c4
 8023d00:	200006ac 	.word	0x200006ac
 8023d04:	20000694 	.word	0x20000694
 8023d08:	2000069c 	.word	0x2000069c
 8023d0c:	200006a4 	.word	0x200006a4

08023d10 <CAN0_3_IRQHandler>:

void TrapSensorISRHandler(void)
{
 8023d10:	b580      	push	{r7, lr}
 8023d12:	b082      	sub	sp, #8
 8023d14:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 8023d16:	2300      	movs	r3, #0
 8023d18:	71fb      	strb	r3, [r7, #7]

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_05_Config);
 8023d1a:	4811      	ldr	r0, [pc, #68]	; (8023d60 <CAN0_3_IRQHandler+0x50>)
 8023d1c:	f006 fa2c 	bl	802a178 <CAN_NODE_MO_Receive>

	if (((CAN_EXT_LMO_05_Config.mo_ptr->can_identifier == 0x240000) && (Presets.CAN_ADRESS == 2)))
 8023d20:	4b0f      	ldr	r3, [pc, #60]	; (8023d60 <CAN0_3_IRQHandler+0x50>)
 8023d22:	681b      	ldr	r3, [r3, #0]
 8023d24:	685b      	ldr	r3, [r3, #4]
 8023d26:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023d2a:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 8023d2e:	d113      	bne.n	8023d58 <CAN0_3_IRQHandler+0x48>
 8023d30:	4b0c      	ldr	r3, [pc, #48]	; (8023d64 <CAN0_3_IRQHandler+0x54>)
 8023d32:	689b      	ldr	r3, [r3, #8]
 8023d34:	2b02      	cmp	r3, #2
 8023d36:	d10f      	bne.n	8023d58 <CAN0_3_IRQHandler+0x48>
	{
		temp = CAN_EXT_LMO_05_Config.mo_ptr->can_data_byte[0];
 8023d38:	4b09      	ldr	r3, [pc, #36]	; (8023d60 <CAN0_3_IRQHandler+0x50>)
 8023d3a:	681b      	ldr	r3, [r3, #0]
 8023d3c:	7c1b      	ldrb	r3, [r3, #16]
 8023d3e:	71fb      	strb	r3, [r7, #7]

		//DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);

		if(temp & (1<<1)) // trap sensor transmit via CAN in 0x240000[0].1
 8023d40:	79fb      	ldrb	r3, [r7, #7]
 8023d42:	f003 0302 	and.w	r3, r3, #2
 8023d46:	2b00      	cmp	r3, #0
 8023d48:	d003      	beq.n	8023d52 <CAN0_3_IRQHandler+0x42>
		{
			TrapSensor = 1;
 8023d4a:	4b07      	ldr	r3, [pc, #28]	; (8023d68 <CAN0_3_IRQHandler+0x58>)
 8023d4c:	2201      	movs	r2, #1
 8023d4e:	601a      	str	r2, [r3, #0]
		else
		{
			TrapSensor = 0;
		}
	}
}
 8023d50:	e002      	b.n	8023d58 <CAN0_3_IRQHandler+0x48>
			TrapSensor = 0;
 8023d52:	4b05      	ldr	r3, [pc, #20]	; (8023d68 <CAN0_3_IRQHandler+0x58>)
 8023d54:	2200      	movs	r2, #0
 8023d56:	601a      	str	r2, [r3, #0]
}
 8023d58:	bf00      	nop
 8023d5a:	3708      	adds	r7, #8
 8023d5c:	46bd      	mov	sp, r7
 8023d5e:	bd80      	pop	{r7, pc}
 8023d60:	0802b700 	.word	0x0802b700
 8023d64:	20000770 	.word	0x20000770
 8023d68:	20000644 	.word	0x20000644

08023d6c <CAN0_5_IRQHandler>:

void StopButISRHanler (void)
{
 8023d6c:	b580      	push	{r7, lr}
 8023d6e:	b082      	sub	sp, #8
 8023d70:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 8023d72:	2300      	movs	r3, #0
 8023d74:	71fb      	strb	r3, [r7, #7]


	CAN_NODE_MO_Receive(&CAN_EXT_LMO_04_Config);
 8023d76:	481a      	ldr	r0, [pc, #104]	; (8023de0 <CAN0_5_IRQHandler+0x74>)
 8023d78:	f006 f9fe 	bl	802a178 <CAN_NODE_MO_Receive>

	// In Lionet Stop Buttons transmit via CAN in 0x600000[0].3; 0x602000[0].3; 0x604000[0].3; 0x608000[0].3
	// In Vityaz' Stop Buttons transmit via CAN in 0x600000[0].3; 0x602000[0].3; 0x604000[0].3; 0x60A000[0].3; 0x60C000[0].3; 0x60E000[0].3
	// In Bogatyr' I DON'T KNOW
	if (((Presets.CAN_ADRESS <= 2) && (CAN_EXT_LMO_04_Config.mo_ptr->can_identifier == (0x600000 + (Presets.CAN_ADRESS * 2) * 0x1000))) || ((Presets.CAN_ADRESS == 3) && (CAN_EXT_LMO_04_Config.mo_ptr->can_identifier == 0x608000)))
 8023d7c:	4b19      	ldr	r3, [pc, #100]	; (8023de4 <CAN0_5_IRQHandler+0x78>)
 8023d7e:	689b      	ldr	r3, [r3, #8]
 8023d80:	2b02      	cmp	r3, #2
 8023d82:	d80c      	bhi.n	8023d9e <CAN0_5_IRQHandler+0x32>
 8023d84:	4b16      	ldr	r3, [pc, #88]	; (8023de0 <CAN0_5_IRQHandler+0x74>)
 8023d86:	681b      	ldr	r3, [r3, #0]
 8023d88:	685b      	ldr	r3, [r3, #4]
 8023d8a:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8023d8e:	461a      	mov	r2, r3
 8023d90:	4b14      	ldr	r3, [pc, #80]	; (8023de4 <CAN0_5_IRQHandler+0x78>)
 8023d92:	689b      	ldr	r3, [r3, #8]
 8023d94:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8023d98:	035b      	lsls	r3, r3, #13
 8023d9a:	429a      	cmp	r2, r3
 8023d9c:	d00b      	beq.n	8023db6 <CAN0_5_IRQHandler+0x4a>
 8023d9e:	4b11      	ldr	r3, [pc, #68]	; (8023de4 <CAN0_5_IRQHandler+0x78>)
 8023da0:	689b      	ldr	r3, [r3, #8]
 8023da2:	2b03      	cmp	r3, #3
 8023da4:	d117      	bne.n	8023dd6 <CAN0_5_IRQHandler+0x6a>
 8023da6:	4b0e      	ldr	r3, [pc, #56]	; (8023de0 <CAN0_5_IRQHandler+0x74>)
 8023da8:	681b      	ldr	r3, [r3, #0]
 8023daa:	685b      	ldr	r3, [r3, #4]
 8023dac:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023db0:	f5b3 0fc1 	cmp.w	r3, #6324224	; 0x608000
 8023db4:	d10f      	bne.n	8023dd6 <CAN0_5_IRQHandler+0x6a>
	{
		//DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
		temp = CAN_EXT_LMO_04_Config.mo_ptr->can_data_byte[0];
 8023db6:	4b0a      	ldr	r3, [pc, #40]	; (8023de0 <CAN0_5_IRQHandler+0x74>)
 8023db8:	681b      	ldr	r3, [r3, #0]
 8023dba:	7c1b      	ldrb	r3, [r3, #16]
 8023dbc:	71fb      	strb	r3, [r7, #7]

		if(temp & (1<<3))
 8023dbe:	79fb      	ldrb	r3, [r7, #7]
 8023dc0:	f003 0308 	and.w	r3, r3, #8
 8023dc4:	2b00      	cmp	r3, #0
 8023dc6:	d003      	beq.n	8023dd0 <CAN0_5_IRQHandler+0x64>
		{
			StopButton = 1;
 8023dc8:	4b07      	ldr	r3, [pc, #28]	; (8023de8 <CAN0_5_IRQHandler+0x7c>)
 8023dca:	2201      	movs	r2, #1
 8023dcc:	601a      	str	r2, [r3, #0]
		else
		{
			StopButton = 0;
		}
	}
}
 8023dce:	e002      	b.n	8023dd6 <CAN0_5_IRQHandler+0x6a>
			StopButton = 0;
 8023dd0:	4b05      	ldr	r3, [pc, #20]	; (8023de8 <CAN0_5_IRQHandler+0x7c>)
 8023dd2:	2200      	movs	r2, #0
 8023dd4:	601a      	str	r2, [r3, #0]
}
 8023dd6:	bf00      	nop
 8023dd8:	3708      	adds	r7, #8
 8023dda:	46bd      	mov	sp, r7
 8023ddc:	bd80      	pop	{r7, pc}
 8023dde:	bf00      	nop
 8023de0:	0802b6f4 	.word	0x0802b6f4
 8023de4:	20000770 	.word	0x20000770
 8023de8:	20000640 	.word	0x20000640

08023dec <CAN0_0_IRQHandler>:


void CanNodeAllertIsrHandler(void)
{
 8023dec:	b580      	push	{r7, lr}
 8023dee:	af00      	add	r7, sp, #0
	// If CAN node not OK
	//DIGITAL_IO_ToggleOutput(&STATUS_LED_R);

	if (CAN_NODE_GetStatus(&CAN_EXT))
 8023df0:	4805      	ldr	r0, [pc, #20]	; (8023e08 <CAN0_0_IRQHandler+0x1c>)
 8023df2:	f006 f9f2 	bl	802a1da <CAN_NODE_GetStatus>
 8023df6:	4603      	mov	r3, r0
 8023df8:	2b00      	cmp	r3, #0
 8023dfa:	d002      	beq.n	8023e02 <CAN0_0_IRQHandler+0x16>
	{
		CAN_NODE_Init(&CAN_EXT); // Reset node
 8023dfc:	4802      	ldr	r0, [pc, #8]	; (8023e08 <CAN0_0_IRQHandler+0x1c>)
 8023dfe:	f006 f9fc 	bl	802a1fa <CAN_NODE_Init>
	}
}
 8023e02:	bf00      	nop
 8023e04:	bd80      	pop	{r7, pc}
 8023e06:	bf00      	nop
 8023e08:	0802b730 	.word	0x0802b730

08023e0c <XMC_GPIO_SetOutputHigh>:
{
 8023e0c:	b480      	push	{r7}
 8023e0e:	b083      	sub	sp, #12
 8023e10:	af00      	add	r7, sp, #0
 8023e12:	6078      	str	r0, [r7, #4]
 8023e14:	460b      	mov	r3, r1
 8023e16:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8023e18:	78fb      	ldrb	r3, [r7, #3]
 8023e1a:	2201      	movs	r2, #1
 8023e1c:	409a      	lsls	r2, r3
 8023e1e:	687b      	ldr	r3, [r7, #4]
 8023e20:	605a      	str	r2, [r3, #4]
}
 8023e22:	bf00      	nop
 8023e24:	370c      	adds	r7, #12
 8023e26:	46bd      	mov	sp, r7
 8023e28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e2c:	4770      	bx	lr

08023e2e <XMC_GPIO_SetOutputLow>:
{
 8023e2e:	b480      	push	{r7}
 8023e30:	b083      	sub	sp, #12
 8023e32:	af00      	add	r7, sp, #0
 8023e34:	6078      	str	r0, [r7, #4]
 8023e36:	460b      	mov	r3, r1
 8023e38:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8023e3a:	78fb      	ldrb	r3, [r7, #3]
 8023e3c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8023e40:	409a      	lsls	r2, r3
 8023e42:	687b      	ldr	r3, [r7, #4]
 8023e44:	605a      	str	r2, [r3, #4]
}
 8023e46:	bf00      	nop
 8023e48:	370c      	adds	r7, #12
 8023e4a:	46bd      	mov	sp, r7
 8023e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e50:	4770      	bx	lr

08023e52 <XMC_GPIO_ToggleOutput>:
{
 8023e52:	b480      	push	{r7}
 8023e54:	b083      	sub	sp, #12
 8023e56:	af00      	add	r7, sp, #0
 8023e58:	6078      	str	r0, [r7, #4]
 8023e5a:	460b      	mov	r3, r1
 8023e5c:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10001U << pin;
 8023e5e:	78fb      	ldrb	r3, [r7, #3]
 8023e60:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8023e64:	409a      	lsls	r2, r3
 8023e66:	687b      	ldr	r3, [r7, #4]
 8023e68:	605a      	str	r2, [r3, #4]
}
 8023e6a:	bf00      	nop
 8023e6c:	370c      	adds	r7, #12
 8023e6e:	46bd      	mov	sp, r7
 8023e70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e74:	4770      	bx	lr

08023e76 <DIGITAL_IO_SetOutputHigh>:
{
 8023e76:	b580      	push	{r7, lr}
 8023e78:	b082      	sub	sp, #8
 8023e7a:	af00      	add	r7, sp, #0
 8023e7c:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8023e7e:	687b      	ldr	r3, [r7, #4]
 8023e80:	681a      	ldr	r2, [r3, #0]
 8023e82:	687b      	ldr	r3, [r7, #4]
 8023e84:	7c1b      	ldrb	r3, [r3, #16]
 8023e86:	4619      	mov	r1, r3
 8023e88:	4610      	mov	r0, r2
 8023e8a:	f7ff ffbf 	bl	8023e0c <XMC_GPIO_SetOutputHigh>
}
 8023e8e:	bf00      	nop
 8023e90:	3708      	adds	r7, #8
 8023e92:	46bd      	mov	sp, r7
 8023e94:	bd80      	pop	{r7, pc}

08023e96 <DIGITAL_IO_SetOutputLow>:
{
 8023e96:	b580      	push	{r7, lr}
 8023e98:	b082      	sub	sp, #8
 8023e9a:	af00      	add	r7, sp, #0
 8023e9c:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8023e9e:	687b      	ldr	r3, [r7, #4]
 8023ea0:	681a      	ldr	r2, [r3, #0]
 8023ea2:	687b      	ldr	r3, [r7, #4]
 8023ea4:	7c1b      	ldrb	r3, [r3, #16]
 8023ea6:	4619      	mov	r1, r3
 8023ea8:	4610      	mov	r0, r2
 8023eaa:	f7ff ffc0 	bl	8023e2e <XMC_GPIO_SetOutputLow>
}
 8023eae:	bf00      	nop
 8023eb0:	3708      	adds	r7, #8
 8023eb2:	46bd      	mov	sp, r7
 8023eb4:	bd80      	pop	{r7, pc}

08023eb6 <DIGITAL_IO_ToggleOutput>:
{
 8023eb6:	b580      	push	{r7, lr}
 8023eb8:	b082      	sub	sp, #8
 8023eba:	af00      	add	r7, sp, #0
 8023ebc:	6078      	str	r0, [r7, #4]
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 8023ebe:	687b      	ldr	r3, [r7, #4]
 8023ec0:	681a      	ldr	r2, [r3, #0]
 8023ec2:	687b      	ldr	r3, [r7, #4]
 8023ec4:	7c1b      	ldrb	r3, [r3, #16]
 8023ec6:	4619      	mov	r1, r3
 8023ec8:	4610      	mov	r0, r2
 8023eca:	f7ff ffc2 	bl	8023e52 <XMC_GPIO_ToggleOutput>
}
 8023ece:	bf00      	nop
 8023ed0:	3708      	adds	r7, #8
 8023ed2:	46bd      	mov	sp, r7
 8023ed4:	bd80      	pop	{r7, pc}

08023ed6 <CAN_NODE_MO_UpdateID>:
{
 8023ed6:	b580      	push	{r7, lr}
 8023ed8:	b082      	sub	sp, #8
 8023eda:	af00      	add	r7, sp, #0
 8023edc:	6078      	str	r0, [r7, #4]
 8023ede:	6039      	str	r1, [r7, #0]
  XMC_CAN_MO_SetIdentifier(lmo_ptr->mo_ptr, id);
 8023ee0:	687b      	ldr	r3, [r7, #4]
 8023ee2:	681b      	ldr	r3, [r3, #0]
 8023ee4:	6839      	ldr	r1, [r7, #0]
 8023ee6:	4618      	mov	r0, r3
 8023ee8:	f003 fa1e 	bl	8027328 <XMC_CAN_MO_SetIdentifier>
 }
 8023eec:	bf00      	nop
 8023eee:	3708      	adds	r7, #8
 8023ef0:	46bd      	mov	sp, r7
 8023ef2:	bd80      	pop	{r7, pc}

08023ef4 <MainAlgInit>:
int32_t serv_from_but = 0;



void MainAlgInit(void)
{
 8023ef4:	b580      	push	{r7, lr}
 8023ef6:	af00      	add	r7, sp, #0

	DoorPeriphInit();
 8023ef8:	f7ff f926 	bl	8023148 <DoorPeriphInit>
	MotorInit();
 8023efc:	f7fe fe6e 	bl	8022bdc <MotorInit>

	MainTimer = SYSTIMER_CreateTimer((MAIN_TIMER_TIME_MS * 1000), SYSTIMER_MODE_PERIODIC, MainProc, NULL );
 8023f00:	2300      	movs	r3, #0
 8023f02:	4a12      	ldr	r2, [pc, #72]	; (8023f4c <MainAlgInit+0x58>)
 8023f04:	2101      	movs	r1, #1
 8023f06:	f242 7010 	movw	r0, #10000	; 0x2710
 8023f0a:	f005 f90d 	bl	8029128 <SYSTIMER_CreateTimer>
 8023f0e:	4603      	mov	r3, r0
 8023f10:	461a      	mov	r2, r3
 8023f12:	4b0f      	ldr	r3, [pc, #60]	; (8023f50 <MainAlgInit+0x5c>)
 8023f14:	601a      	str	r2, [r3, #0]
	SYSTIMER_StartTimer(MainTimer);
 8023f16:	4b0e      	ldr	r3, [pc, #56]	; (8023f50 <MainAlgInit+0x5c>)
 8023f18:	681b      	ldr	r3, [r3, #0]
 8023f1a:	4618      	mov	r0, r3
 8023f1c:	f005 f9a2 	bl	8029264 <SYSTIMER_StartTimer>

	SaveTimer = SYSTIMER_CreateTimer((1000*1000), SYSTIMER_MODE_PERIODIC, SaveProc, NULL);
 8023f20:	2300      	movs	r3, #0
 8023f22:	4a0c      	ldr	r2, [pc, #48]	; (8023f54 <MainAlgInit+0x60>)
 8023f24:	2101      	movs	r1, #1
 8023f26:	480c      	ldr	r0, [pc, #48]	; (8023f58 <MainAlgInit+0x64>)
 8023f28:	f005 f8fe 	bl	8029128 <SYSTIMER_CreateTimer>
 8023f2c:	4603      	mov	r3, r0
 8023f2e:	461a      	mov	r2, r3
 8023f30:	4b0a      	ldr	r3, [pc, #40]	; (8023f5c <MainAlgInit+0x68>)
 8023f32:	601a      	str	r2, [r3, #0]
	SYSTIMER_StartTimer(SaveTimer);
 8023f34:	4b09      	ldr	r3, [pc, #36]	; (8023f5c <MainAlgInit+0x68>)
 8023f36:	681b      	ldr	r3, [r3, #0]
 8023f38:	4618      	mov	r0, r3
 8023f3a:	f005 f993 	bl	8029264 <SYSTIMER_StartTimer>

	OPEN_DIR = -Presets.CLOSE_DIR;
 8023f3e:	4b08      	ldr	r3, [pc, #32]	; (8023f60 <MainAlgInit+0x6c>)
 8023f40:	681b      	ldr	r3, [r3, #0]
 8023f42:	425b      	negs	r3, r3
 8023f44:	4a07      	ldr	r2, [pc, #28]	; (8023f64 <MainAlgInit+0x70>)
 8023f46:	6013      	str	r3, [r2, #0]

}
 8023f48:	bf00      	nop
 8023f4a:	bd80      	pop	{r7, pc}
 8023f4c:	08023f69 	.word	0x08023f69
 8023f50:	200006ec 	.word	0x200006ec
 8023f54:	08024f25 	.word	0x08024f25
 8023f58:	000f4240 	.word	0x000f4240
 8023f5c:	200006f0 	.word	0x200006f0
 8023f60:	20000770 	.word	0x20000770
 8023f64:	20000250 	.word	0x20000250

08023f68 <MainProc>:

void MainProc (void *args)
{
 8023f68:	b580      	push	{r7, lr}
 8023f6a:	b084      	sub	sp, #16
 8023f6c:	af00      	add	r7, sp, #0
 8023f6e:	6078      	str	r0, [r7, #4]
	int32_t temp = 0;
 8023f70:	2300      	movs	r3, #0
 8023f72:	60fb      	str	r3, [r7, #12]
	static int32_t CanCmdOpenEnablePrev = 0;

	static fallen_edge = 5;


	ReadInputs();
 8023f74:	f7ff f93a 	bl	80231ec <ReadInputs>
	ReadPeripherials();
 8023f78:	f000 fece 	bl	8024d18 <ReadPeripherials>
	MotorRead();
 8023f7c:	f7fe fea0 	bl	8022cc0 <MotorRead>


	if ((Inputs.GIO & 0x0008)) // enter to service mode
 8023f80:	4b9b      	ldr	r3, [pc, #620]	; (80241f0 <MainProc+0x288>)
 8023f82:	889b      	ldrh	r3, [r3, #4]
 8023f84:	f003 0308 	and.w	r3, r3, #8
 8023f88:	2b00      	cmp	r3, #0
 8023f8a:	d003      	beq.n	8023f94 <MainProc+0x2c>
	{
		ServiceMode = 1;
 8023f8c:	4b99      	ldr	r3, [pc, #612]	; (80241f4 <MainProc+0x28c>)
 8023f8e:	2201      	movs	r2, #1
 8023f90:	601a      	str	r2, [r3, #0]
 8023f92:	e002      	b.n	8023f9a <MainProc+0x32>
	}
	else
	{
		ServiceMode = 0;
 8023f94:	4b97      	ldr	r3, [pc, #604]	; (80241f4 <MainProc+0x28c>)
 8023f96:	2200      	movs	r2, #0
 8023f98:	601a      	str	r2, [r3, #0]
//		{
//			butt_blink = 0;
//		}
//	}

if (!ServiceMode) // main algorithm from cabine commands
 8023f9a:	4b96      	ldr	r3, [pc, #600]	; (80241f4 <MainProc+0x28c>)
 8023f9c:	681b      	ldr	r3, [r3, #0]
 8023f9e:	2b00      	cmp	r3, #0
 8023fa0:	f040 83c0 	bne.w	8024724 <MainProc+0x7bc>
{
	switch (MainState)
 8023fa4:	4b94      	ldr	r3, [pc, #592]	; (80241f8 <MainProc+0x290>)
 8023fa6:	681b      	ldr	r3, [r3, #0]
 8023fa8:	2b25      	cmp	r3, #37	; 0x25
 8023faa:	f200 8374 	bhi.w	8024696 <MainProc+0x72e>
 8023fae:	a201      	add	r2, pc, #4	; (adr r2, 8023fb4 <MainProc+0x4c>)
 8023fb0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8023fb4:	0802404d 	.word	0x0802404d
 8023fb8:	080240ab 	.word	0x080240ab
 8023fbc:	08024103 	.word	0x08024103
 8023fc0:	080241a9 	.word	0x080241a9
 8023fc4:	0802429f 	.word	0x0802429f
 8023fc8:	08024359 	.word	0x08024359
 8023fcc:	080243ff 	.word	0x080243ff
 8023fd0:	080243ab 	.word	0x080243ab
 8023fd4:	08024697 	.word	0x08024697
 8023fd8:	08024697 	.word	0x08024697
 8023fdc:	080244d9 	.word	0x080244d9
 8023fe0:	080245cd 	.word	0x080245cd
 8023fe4:	08024697 	.word	0x08024697
 8023fe8:	08024697 	.word	0x08024697
 8023fec:	08024697 	.word	0x08024697
 8023ff0:	08024697 	.word	0x08024697
 8023ff4:	08024697 	.word	0x08024697
 8023ff8:	08024697 	.word	0x08024697
 8023ffc:	08024697 	.word	0x08024697
 8024000:	08024697 	.word	0x08024697
 8024004:	08024697 	.word	0x08024697
 8024008:	08024697 	.word	0x08024697
 802400c:	08024697 	.word	0x08024697
 8024010:	08024697 	.word	0x08024697
 8024014:	08024697 	.word	0x08024697
 8024018:	08024697 	.word	0x08024697
 802401c:	08024697 	.word	0x08024697
 8024020:	08024697 	.word	0x08024697
 8024024:	08024697 	.word	0x08024697
 8024028:	08024697 	.word	0x08024697
 802402c:	08024697 	.word	0x08024697
 8024030:	08024697 	.word	0x08024697
 8024034:	08024697 	.word	0x08024697
 8024038:	08024697 	.word	0x08024697
 802403c:	08024697 	.word	0x08024697
 8024040:	08024697 	.word	0x08024697
 8024044:	08024697 	.word	0x08024697
 8024048:	08024617 	.word	0x08024617
	{
		case MS_START:
		{
			wait_timer++;
 802404c:	4b6b      	ldr	r3, [pc, #428]	; (80241fc <MainProc+0x294>)
 802404e:	681b      	ldr	r3, [r3, #0]
 8024050:	3301      	adds	r3, #1
 8024052:	4a6a      	ldr	r2, [pc, #424]	; (80241fc <MainProc+0x294>)
 8024054:	6013      	str	r3, [r2, #0]
			if(wait_timer >= Presets.STARTUP_TIME)
 8024056:	4b6a      	ldr	r3, [pc, #424]	; (8024200 <MainProc+0x298>)
 8024058:	69db      	ldr	r3, [r3, #28]
 802405a:	4a68      	ldr	r2, [pc, #416]	; (80241fc <MainProc+0x294>)
 802405c:	6812      	ldr	r2, [r2, #0]
 802405e:	4293      	cmp	r3, r2
 8024060:	d813      	bhi.n	802408a <MainProc+0x122>
			{
				wait_timer = 0;
 8024062:	4b66      	ldr	r3, [pc, #408]	; (80241fc <MainProc+0x294>)
 8024064:	2200      	movs	r2, #0
 8024066:	601a      	str	r2, [r3, #0]
				WritePassengerButton(CMD_ON);
 8024068:	2001      	movs	r0, #1
 802406a:	f7ff fa19 	bl	80234a0 <WritePassengerButton>

				if(CloseSensor)
 802406e:	4b65      	ldr	r3, [pc, #404]	; (8024204 <MainProc+0x29c>)
 8024070:	681b      	ldr	r3, [r3, #0]
 8024072:	2b00      	cmp	r3, #0
 8024074:	d004      	beq.n	8024080 <MainProc+0x118>
				{
					MainState = MS_CLOSED;
 8024076:	4b60      	ldr	r3, [pc, #384]	; (80241f8 <MainProc+0x290>)
 8024078:	2203      	movs	r2, #3
 802407a:	601a      	str	r2, [r3, #0]
//			if(blink >= 4)
//			{
//				blink = 0;
//			}
		}
			break;
 802407c:	f000 be38 	b.w	8024cf0 <MainProc+0xd88>
					MainState = MS_UNKNOWN;
 8024080:	4b5d      	ldr	r3, [pc, #372]	; (80241f8 <MainProc+0x290>)
 8024082:	2201      	movs	r2, #1
 8024084:	601a      	str	r2, [r3, #0]
			break;
 8024086:	f000 be33 	b.w	8024cf0 <MainProc+0xd88>
				OpenDoor(0);
 802408a:	2000      	movs	r0, #0
 802408c:	f001 fa48 	bl	8025520 <OpenDoor>
				CloseDoor(0);
 8024090:	2000      	movs	r0, #0
 8024092:	f001 f8f5 	bl	8025280 <CloseDoor>
				Homing(0);
 8024096:	2000      	movs	r0, #0
 8024098:	f000 ff68 	bl	8024f6c <Homing>
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
 802409c:	2200      	movs	r2, #0
 802409e:	2100      	movs	r1, #0
 80240a0:	2000      	movs	r0, #0
 80240a2:	f7ff fa13 	bl	80234cc <WriteRubberLights>
			break;
 80240a6:	f000 be23 	b.w	8024cf0 <MainProc+0xd88>
//			WritePassengerButton(CMD_ON);
			//WriteRubberLights(CL_GREEN, MODE_TIME_ON, 1000);

			//WriteClutch(CLUTCH_LOCK);

			wait_timer ++;
 80240aa:	4b54      	ldr	r3, [pc, #336]	; (80241fc <MainProc+0x294>)
 80240ac:	681b      	ldr	r3, [r3, #0]
 80240ae:	3301      	adds	r3, #1
 80240b0:	4a52      	ldr	r2, [pc, #328]	; (80241fc <MainProc+0x294>)
 80240b2:	6013      	str	r3, [r2, #0]
//					wait_timer = 0;				}
//
//			}

//			if((CanCmdCloseAll || CanCmdCloseCmd || !CanCmdUnlock) && !TrapSensor)
			if(HomingDone)
 80240b4:	4b54      	ldr	r3, [pc, #336]	; (8024208 <MainProc+0x2a0>)
 80240b6:	681b      	ldr	r3, [r3, #0]
 80240b8:	2b00      	cmp	r3, #0
 80240ba:	d005      	beq.n	80240c8 <MainProc+0x160>
			{
				WriteRubberLights(CL_RED, MODE_BLINK, 200);
 80240bc:	22c8      	movs	r2, #200	; 0xc8
 80240be:	2102      	movs	r1, #2
 80240c0:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80240c4:	f7ff fa02 	bl	80234cc <WriteRubberLights>
			}

			if((PassengerButton || DisabledButton) || ((wait_timer >= 500) && !HomingDone))
 80240c8:	4b50      	ldr	r3, [pc, #320]	; (802420c <MainProc+0x2a4>)
 80240ca:	681b      	ldr	r3, [r3, #0]
 80240cc:	2b00      	cmp	r3, #0
 80240ce:	d10c      	bne.n	80240ea <MainProc+0x182>
 80240d0:	4b4f      	ldr	r3, [pc, #316]	; (8024210 <MainProc+0x2a8>)
 80240d2:	681b      	ldr	r3, [r3, #0]
 80240d4:	2b00      	cmp	r3, #0
 80240d6:	d108      	bne.n	80240ea <MainProc+0x182>
 80240d8:	4b48      	ldr	r3, [pc, #288]	; (80241fc <MainProc+0x294>)
 80240da:	681b      	ldr	r3, [r3, #0]
 80240dc:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 80240e0:	db0b      	blt.n	80240fa <MainProc+0x192>
 80240e2:	4b49      	ldr	r3, [pc, #292]	; (8024208 <MainProc+0x2a0>)
 80240e4:	681b      	ldr	r3, [r3, #0]
 80240e6:	2b00      	cmp	r3, #0
 80240e8:	d107      	bne.n	80240fa <MainProc+0x192>
			{
				MainState = MS_HOMING;
 80240ea:	4b43      	ldr	r3, [pc, #268]	; (80241f8 <MainProc+0x290>)
 80240ec:	2202      	movs	r2, #2
 80240ee:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 80240f0:	4b42      	ldr	r3, [pc, #264]	; (80241fc <MainProc+0x294>)
 80240f2:	2200      	movs	r2, #0
 80240f4:	601a      	str	r2, [r3, #0]
//			{
//				MainState = MS_HOMING;
//			}

		}
			break;
 80240f6:	f000 bdfb 	b.w	8024cf0 <MainProc+0xd88>
				MotorStop();
 80240fa:	f7fe fda3 	bl	8022c44 <MotorStop>
			break;
 80240fe:	f000 bdf7 	b.w	8024cf0 <MainProc+0xd88>

		case MS_HOMING:
		{

			temp = Homing(1);
 8024102:	2001      	movs	r0, #1
 8024104:	f000 ff32 	bl	8024f6c <Homing>
 8024108:	60f8      	str	r0, [r7, #12]
			WriteRubberLights(CL_YELLOW, MODE_BLINK, 1000);
 802410a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802410e:	2102      	movs	r1, #2
 8024110:	4840      	ldr	r0, [pc, #256]	; (8024214 <MainProc+0x2ac>)
 8024112:	f7ff f9db 	bl	80234cc <WriteRubberLights>
			if (temp == 1) // homing done success!
 8024116:	68fb      	ldr	r3, [r7, #12]
 8024118:	2b01      	cmp	r3, #1
 802411a:	d114      	bne.n	8024146 <MainProc+0x1de>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);

				DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 802411c:	483e      	ldr	r0, [pc, #248]	; (8024218 <MainProc+0x2b0>)
 802411e:	f7ff feaa 	bl	8023e76 <DIGITAL_IO_SetOutputHigh>
				DIGITAL_IO_SetOutputLow(&HS_SW_8);
 8024122:	483e      	ldr	r0, [pc, #248]	; (802421c <MainProc+0x2b4>)
 8024124:	f7ff feb7 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				PWM_CCU4_Stop(&BUZZ_PWM);
 8024128:	483d      	ldr	r0, [pc, #244]	; (8024220 <MainProc+0x2b8>)
 802412a:	f005 fbae 	bl	802988a <PWM_CCU4_Stop>

				HomingDone = 1;
 802412e:	4b36      	ldr	r3, [pc, #216]	; (8024208 <MainProc+0x2a0>)
 8024130:	2201      	movs	r2, #1
 8024132:	601a      	str	r2, [r3, #0]
				MainState = MS_CLOSED;
 8024134:	4b30      	ldr	r3, [pc, #192]	; (80241f8 <MainProc+0x290>)
 8024136:	2203      	movs	r2, #3
 8024138:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 802413a:	4b30      	ldr	r3, [pc, #192]	; (80241fc <MainProc+0x294>)
 802413c:	2200      	movs	r2, #0
 802413e:	601a      	str	r2, [r3, #0]
				fallen_edge = 5;
 8024140:	4b38      	ldr	r3, [pc, #224]	; (8024224 <MainProc+0x2bc>)
 8024142:	2205      	movs	r2, #5
 8024144:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024146:	68fb      	ldr	r3, [r7, #12]
 8024148:	2b00      	cmp	r3, #0
 802414a:	d102      	bne.n	8024152 <MainProc+0x1ea>
			{
				WriteBuzzer(BUZZER_ON);
 802414c:	2001      	movs	r0, #1
 802414e:	f7fe fedf 	bl	8022f10 <WriteBuzzer>
			}
			if (temp == -1)
 8024152:	68fb      	ldr	r3, [r7, #12]
 8024154:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024158:	d105      	bne.n	8024166 <MainProc+0x1fe>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 802415a:	4b27      	ldr	r3, [pc, #156]	; (80241f8 <MainProc+0x290>)
 802415c:	2215      	movs	r2, #21
 802415e:	601a      	str	r2, [r3, #0]
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				Homing(0);
 8024160:	2000      	movs	r0, #0
 8024162:	f000 ff03 	bl	8024f6c <Homing>
			}
			if (temp == -2)
 8024166:	68fb      	ldr	r3, [r7, #12]
 8024168:	f113 0f02 	cmn.w	r3, #2
 802416c:	d105      	bne.n	802417a <MainProc+0x212>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_MAX_CURRENT;
 802416e:	4b22      	ldr	r3, [pc, #136]	; (80241f8 <MainProc+0x290>)
 8024170:	2216      	movs	r2, #22
 8024172:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024174:	2000      	movs	r0, #0
 8024176:	f000 fef9 	bl	8024f6c <Homing>
			}
			if (temp == -3)
 802417a:	68fb      	ldr	r3, [r7, #12]
 802417c:	f113 0f03 	cmn.w	r3, #3
 8024180:	d105      	bne.n	802418e <MainProc+0x226>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_BAD_HOMING;
 8024182:	4b1d      	ldr	r3, [pc, #116]	; (80241f8 <MainProc+0x290>)
 8024184:	2214      	movs	r2, #20
 8024186:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024188:	2000      	movs	r0, #0
 802418a:	f000 feef 	bl	8024f6c <Homing>
			}
			if (-4 == temp)
 802418e:	68fb      	ldr	r3, [r7, #12]
 8024190:	f113 0f04 	cmn.w	r3, #4
 8024194:	f040 858f 	bne.w	8024cb6 <MainProc+0xd4e>
			{
				MainState = MS_UNKNOWN;
 8024198:	4b17      	ldr	r3, [pc, #92]	; (80241f8 <MainProc+0x290>)
 802419a:	2201      	movs	r2, #1
 802419c:	601a      	str	r2, [r3, #0]
				Homing(0);
 802419e:	2000      	movs	r0, #0
 80241a0:	f000 fee4 	bl	8024f6c <Homing>
			}
		}
			break;
 80241a4:	f000 bd87 	b.w	8024cb6 <MainProc+0xd4e>

		case MS_CLOSED:
		{
			wait_timer++;
 80241a8:	4b14      	ldr	r3, [pc, #80]	; (80241fc <MainProc+0x294>)
 80241aa:	681b      	ldr	r3, [r3, #0]
 80241ac:	3301      	adds	r3, #1
 80241ae:	4a13      	ldr	r2, [pc, #76]	; (80241fc <MainProc+0x294>)
 80241b0:	6013      	str	r3, [r2, #0]


			if(wait_timer >= 200)
 80241b2:	4b12      	ldr	r3, [pc, #72]	; (80241fc <MainProc+0x294>)
 80241b4:	681b      	ldr	r3, [r3, #0]
 80241b6:	2bc7      	cmp	r3, #199	; 0xc7
 80241b8:	dd01      	ble.n	80241be <MainProc+0x256>
			{
				MotorStop();
 80241ba:	f7fe fd43 	bl	8022c44 <MotorStop>
//			{
//				DIGITAL_IO_SetOutputHigh(&HS_SW_5);
//				//DIGITAL_IO_SetOutputHigh(&HS_SW_2);
//			}

			if(wait_timer > 50)
 80241be:	4b0f      	ldr	r3, [pc, #60]	; (80241fc <MainProc+0x294>)
 80241c0:	681b      	ldr	r3, [r3, #0]
 80241c2:	2b32      	cmp	r3, #50	; 0x32
 80241c4:	dd34      	ble.n	8024230 <MainProc+0x2c8>
			{
				if(CanCmdUnlock && CanCmdOpenEnable)
 80241c6:	4b18      	ldr	r3, [pc, #96]	; (8024228 <MainProc+0x2c0>)
 80241c8:	681b      	ldr	r3, [r3, #0]
 80241ca:	2b00      	cmp	r3, #0
 80241cc:	d00a      	beq.n	80241e4 <MainProc+0x27c>
 80241ce:	4b17      	ldr	r3, [pc, #92]	; (802422c <MainProc+0x2c4>)
 80241d0:	681b      	ldr	r3, [r3, #0]
 80241d2:	2b00      	cmp	r3, #0
 80241d4:	d006      	beq.n	80241e4 <MainProc+0x27c>
				{
					WriteRubberLights(CL_GREEN, MODE_ON, 0);
 80241d6:	2200      	movs	r2, #0
 80241d8:	2101      	movs	r1, #1
 80241da:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 80241de:	f7ff f975 	bl	80234cc <WriteRubberLights>
 80241e2:	e02c      	b.n	802423e <MainProc+0x2d6>
				}
				else
				{
					WriteRubberLights(CL_BLACK, MODE_OFF, 0);
 80241e4:	2200      	movs	r2, #0
 80241e6:	2100      	movs	r1, #0
 80241e8:	2000      	movs	r0, #0
 80241ea:	f7ff f96f 	bl	80234cc <WriteRubberLights>
 80241ee:	e026      	b.n	802423e <MainProc+0x2d6>
 80241f0:	20000668 	.word	0x20000668
 80241f4:	20000fd0 	.word	0x20000fd0
 80241f8:	200006f4 	.word	0x200006f4
 80241fc:	20000708 	.word	0x20000708
 8024200:	20000770 	.word	0x20000770
 8024204:	2000062c 	.word	0x2000062c
 8024208:	200006f8 	.word	0x200006f8
 802420c:	20000630 	.word	0x20000630
 8024210:	20000634 	.word	0x20000634
 8024214:	ffff0000 	.word	0xffff0000
 8024218:	0802b42c 	.word	0x0802b42c
 802421c:	0802b544 	.word	0x0802b544
 8024220:	20000290 	.word	0x20000290
 8024224:	20000254 	.word	0x20000254
 8024228:	200006b4 	.word	0x200006b4
 802422c:	200006b0 	.word	0x200006b0
				}
			}
			else
			{
				WriteRubberLights(CL_RED, MODE_TIME_ON, 500);
 8024230:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024234:	2103      	movs	r1, #3
 8024236:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 802423a:	f7ff f947 	bl	80234cc <WriteRubberLights>
			}

			WriteBuzzer(BUZZER_OFF);
 802423e:	2000      	movs	r0, #0
 8024240:	f7fe fe66 	bl	8022f10 <WriteBuzzer>

//			if(CanCmdOpenCmd && CanCmdOpenEnable && CanCmdUnlock)
			if(PassengerButton || DisabledButton || (wait_timer >= 2000))
 8024244:	4b96      	ldr	r3, [pc, #600]	; (80244a0 <MainProc+0x538>)
 8024246:	681b      	ldr	r3, [r3, #0]
 8024248:	2b00      	cmp	r3, #0
 802424a:	d108      	bne.n	802425e <MainProc+0x2f6>
 802424c:	4b95      	ldr	r3, [pc, #596]	; (80244a4 <MainProc+0x53c>)
 802424e:	681b      	ldr	r3, [r3, #0]
 8024250:	2b00      	cmp	r3, #0
 8024252:	d104      	bne.n	802425e <MainProc+0x2f6>
 8024254:	4b94      	ldr	r3, [pc, #592]	; (80244a8 <MainProc+0x540>)
 8024256:	681b      	ldr	r3, [r3, #0]
 8024258:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 802425c:	db11      	blt.n	8024282 <MainProc+0x31a>
			{
				MainState = MS_OPENING;
 802425e:	4b93      	ldr	r3, [pc, #588]	; (80244ac <MainProc+0x544>)
 8024260:	2204      	movs	r2, #4
 8024262:	601a      	str	r2, [r3, #0]
				FromCan = 1;
 8024264:	4b92      	ldr	r3, [pc, #584]	; (80244b0 <MainProc+0x548>)
 8024266:	2201      	movs	r2, #1
 8024268:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 802426a:	4b92      	ldr	r3, [pc, #584]	; (80244b4 <MainProc+0x54c>)
 802426c:	2200      	movs	r2, #0
 802426e:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024270:	4b8d      	ldr	r3, [pc, #564]	; (80244a8 <MainProc+0x540>)
 8024272:	2200      	movs	r2, #0
 8024274:	601a      	str	r2, [r3, #0]
				ForceHold(0);
 8024276:	2000      	movs	r0, #0
 8024278:	f001 fd10 	bl	8025c9c <ForceHold>
				fail_counter = 0;
 802427c:	4b8e      	ldr	r3, [pc, #568]	; (80244b8 <MainProc+0x550>)
 802427e:	2200      	movs	r2, #0
 8024280:	601a      	str	r2, [r3, #0]
//				MainState = MS_OPENING;
//				OpenTime = 0;
//				wait_timer = 0;
//			}

			if(!CloseSensor || (drive.Position >= 10))
 8024282:	4b8e      	ldr	r3, [pc, #568]	; (80244bc <MainProc+0x554>)
 8024284:	681b      	ldr	r3, [r3, #0]
 8024286:	2b00      	cmp	r3, #0
 8024288:	d004      	beq.n	8024294 <MainProc+0x32c>
 802428a:	4b8d      	ldr	r3, [pc, #564]	; (80244c0 <MainProc+0x558>)
 802428c:	881b      	ldrh	r3, [r3, #0]
 802428e:	2b09      	cmp	r3, #9
 8024290:	f240 8513 	bls.w	8024cba <MainProc+0xd52>
			{
				MainState = MS_UNKNOWN;
 8024294:	4b85      	ldr	r3, [pc, #532]	; (80244ac <MainProc+0x544>)
 8024296:	2201      	movs	r2, #1
 8024298:	601a      	str	r2, [r3, #0]
				MainState = MS_OPENING;
			}
*/
//
		}
			break;
 802429a:	f000 bd0e 	b.w	8024cba <MainProc+0xd52>
		case MS_OPENING:
		{
			WriteRubberLights(CL_GREEN, MODE_BLINK, 500);
 802429e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80242a2:	2102      	movs	r1, #2
 80242a4:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 80242a8:	f7ff f910 	bl	80234cc <WriteRubberLights>
			WriteBuzzer(BUZZER_OFF);
 80242ac:	2000      	movs	r0, #0
 80242ae:	f7fe fe2f 	bl	8022f10 <WriteBuzzer>
			OpenTime++;
 80242b2:	4b80      	ldr	r3, [pc, #512]	; (80244b4 <MainProc+0x54c>)
 80242b4:	881b      	ldrh	r3, [r3, #0]
 80242b6:	3301      	adds	r3, #1
 80242b8:	b29a      	uxth	r2, r3
 80242ba:	4b7e      	ldr	r3, [pc, #504]	; (80244b4 <MainProc+0x54c>)
 80242bc:	801a      	strh	r2, [r3, #0]
			PassMemo = 0;
 80242be:	4b81      	ldr	r3, [pc, #516]	; (80244c4 <MainProc+0x55c>)
 80242c0:	2200      	movs	r2, #0
 80242c2:	601a      	str	r2, [r3, #0]
			butt_blink = 0;
 80242c4:	4b80      	ldr	r3, [pc, #512]	; (80244c8 <MainProc+0x560>)
 80242c6:	2200      	movs	r2, #0
 80242c8:	601a      	str	r2, [r3, #0]

			temp = OpenDoor(1);
 80242ca:	2001      	movs	r0, #1
 80242cc:	f001 f928 	bl	8025520 <OpenDoor>
 80242d0:	60f8      	str	r0, [r7, #12]
			if (temp == 1)
 80242d2:	68fb      	ldr	r3, [r7, #12]
 80242d4:	2b01      	cmp	r3, #1
 80242d6:	d105      	bne.n	80242e4 <MainProc+0x37c>
			{
				//if(Presets.CYCLES_COUNTER % 200)
				//{
				wait_timer = 0;
 80242d8:	4b73      	ldr	r3, [pc, #460]	; (80244a8 <MainProc+0x540>)
 80242da:	2200      	movs	r2, #0
 80242dc:	601a      	str	r2, [r3, #0]
				MainState = MS_OPENED;
 80242de:	4b73      	ldr	r3, [pc, #460]	; (80244ac <MainProc+0x544>)
 80242e0:	2205      	movs	r2, #5
 80242e2:	601a      	str	r2, [r3, #0]

				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);

			}
			if (temp == 0)
 80242e4:	68fb      	ldr	r3, [r7, #12]
 80242e6:	2b00      	cmp	r3, #0
 80242e8:	d10b      	bne.n	8024302 <MainProc+0x39a>
			{
				blink++;
 80242ea:	4b78      	ldr	r3, [pc, #480]	; (80244cc <MainProc+0x564>)
 80242ec:	681b      	ldr	r3, [r3, #0]
 80242ee:	3301      	adds	r3, #1
 80242f0:	4a76      	ldr	r2, [pc, #472]	; (80244cc <MainProc+0x564>)
 80242f2:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 80242f4:	4b75      	ldr	r3, [pc, #468]	; (80244cc <MainProc+0x564>)
 80242f6:	681b      	ldr	r3, [r3, #0]
 80242f8:	2b31      	cmp	r3, #49	; 0x31
 80242fa:	dd02      	ble.n	8024302 <MainProc+0x39a>
				{
					//DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
//					DIGITAL_IO_ToggleOutput(&TRANS_OUT);
//					DIGITAL_IO_ToggleOutput(&HS_SW_8);
					blink = 0;
 80242fc:	4b73      	ldr	r3, [pc, #460]	; (80244cc <MainProc+0x564>)
 80242fe:	2200      	movs	r2, #0
 8024300:	601a      	str	r2, [r3, #0]
				}
			}
			if (temp == -1)
 8024302:	68fb      	ldr	r3, [r7, #12]
 8024304:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024308:	d105      	bne.n	8024316 <MainProc+0x3ae>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 802430a:	4b68      	ldr	r3, [pc, #416]	; (80244ac <MainProc+0x544>)
 802430c:	2215      	movs	r2, #21
 802430e:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024310:	2000      	movs	r0, #0
 8024312:	f001 f905 	bl	8025520 <OpenDoor>
			}
			if (temp == -2)
 8024316:	68fb      	ldr	r3, [r7, #12]
 8024318:	f113 0f02 	cmn.w	r3, #2
 802431c:	d105      	bne.n	802432a <MainProc+0x3c2>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 802431e:	4b63      	ldr	r3, [pc, #396]	; (80244ac <MainProc+0x544>)
 8024320:	2216      	movs	r2, #22
 8024322:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024324:	2000      	movs	r0, #0
 8024326:	f001 f8fb 	bl	8025520 <OpenDoor>
			}
			if (temp == -3)
 802432a:	68fb      	ldr	r3, [r7, #12]
 802432c:	f113 0f03 	cmn.w	r3, #3
 8024330:	d105      	bne.n	802433e <MainProc+0x3d6>
			{
				MainState = MS_ERROR_BAD_STATE;
 8024332:	4b5e      	ldr	r3, [pc, #376]	; (80244ac <MainProc+0x544>)
 8024334:	2217      	movs	r2, #23
 8024336:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024338:	2000      	movs	r0, #0
 802433a:	f001 f8f1 	bl	8025520 <OpenDoor>
			}
			if(-4 == temp)
 802433e:	68fb      	ldr	r3, [r7, #12]
 8024340:	f113 0f04 	cmn.w	r3, #4
 8024344:	f040 84bb 	bne.w	8024cbe <MainProc+0xd56>
			{
				OpenDoor(0);
 8024348:	2000      	movs	r0, #0
 802434a:	f001 f8e9 	bl	8025520 <OpenDoor>
				MainState = MS_BLOCKAGE_OPN;
 802434e:	4b57      	ldr	r3, [pc, #348]	; (80244ac <MainProc+0x544>)
 8024350:	220b      	movs	r2, #11
 8024352:	601a      	str	r2, [r3, #0]
//				OpenDoor(0);
//				MainState = MS_CLOSING;
//			}

		}
			break;
 8024354:	f000 bcb3 	b.w	8024cbe <MainProc+0xd56>
		case MS_OPENED:
		{
			WriteBuzzer(BUZZER_OFF);
 8024358:	2000      	movs	r0, #0
 802435a:	f7fe fdd9 	bl	8022f10 <WriteBuzzer>

			WriteRubberLights(CL_GREEN, MODE_ON, 0);
 802435e:	2200      	movs	r2, #0
 8024360:	2101      	movs	r1, #1
 8024362:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024366:	f7ff f8b1 	bl	80234cc <WriteRubberLights>


//				if(((CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline))))//&& !Open1DoorBut)))//
			if(PassengerButton || DisabledButton || (wait_timer >= 1000))
 802436a:	4b4d      	ldr	r3, [pc, #308]	; (80244a0 <MainProc+0x538>)
 802436c:	681b      	ldr	r3, [r3, #0]
 802436e:	2b00      	cmp	r3, #0
 8024370:	d108      	bne.n	8024384 <MainProc+0x41c>
 8024372:	4b4c      	ldr	r3, [pc, #304]	; (80244a4 <MainProc+0x53c>)
 8024374:	681b      	ldr	r3, [r3, #0]
 8024376:	2b00      	cmp	r3, #0
 8024378:	d104      	bne.n	8024384 <MainProc+0x41c>
 802437a:	4b4b      	ldr	r3, [pc, #300]	; (80244a8 <MainProc+0x540>)
 802437c:	681b      	ldr	r3, [r3, #0]
 802437e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8024382:	db0b      	blt.n	802439c <MainProc+0x434>
			{
					wait_timer = 0;
 8024384:	4b48      	ldr	r3, [pc, #288]	; (80244a8 <MainProc+0x540>)
 8024386:	2200      	movs	r2, #0
 8024388:	601a      	str	r2, [r3, #0]
					MainState = MS_CLOSING;
 802438a:	4b48      	ldr	r3, [pc, #288]	; (80244ac <MainProc+0x544>)
 802438c:	2206      	movs	r2, #6
 802438e:	601a      	str	r2, [r3, #0]
					CloseTime = 0;
 8024390:	4b4f      	ldr	r3, [pc, #316]	; (80244d0 <MainProc+0x568>)
 8024392:	2200      	movs	r2, #0
 8024394:	801a      	strh	r2, [r3, #0]
					FromCan = 0;
 8024396:	4b46      	ldr	r3, [pc, #280]	; (80244b0 <MainProc+0x548>)
 8024398:	2200      	movs	r2, #0
 802439a:	601a      	str	r2, [r3, #0]
			}

			wait_timer++;
 802439c:	4b42      	ldr	r3, [pc, #264]	; (80244a8 <MainProc+0x540>)
 802439e:	681b      	ldr	r3, [r3, #0]
 80243a0:	3301      	adds	r3, #1
 80243a2:	4a41      	ldr	r2, [pc, #260]	; (80244a8 <MainProc+0x540>)
 80243a4:	6013      	str	r3, [r2, #0]
//			{
//				MainState = MS_CLOSING;
//			}

		}
			break;
 80243a6:	f000 bca3 	b.w	8024cf0 <MainProc+0xd88>
		case MS_OPENED_BLOCK:
		{
//			DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
//			DIGITAL_IO_SetOutputLow(&HS_SW_8);
			WriteRubberLights(CL_RED, MODE_BLINK, 500);
 80243aa:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80243ae:	2102      	movs	r1, #2
 80243b0:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80243b4:	f7ff f88a 	bl	80234cc <WriteRubberLights>
//			WriteBuzzer(BUZZER_OFF);

			wait_timer++;
 80243b8:	4b3b      	ldr	r3, [pc, #236]	; (80244a8 <MainProc+0x540>)
 80243ba:	681b      	ldr	r3, [r3, #0]
 80243bc:	3301      	adds	r3, #1
 80243be:	4a3a      	ldr	r2, [pc, #232]	; (80244a8 <MainProc+0x540>)
 80243c0:	6013      	str	r3, [r2, #0]

//				if(((CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline)) && (wait_timer  >= 2) ))//(((DSC1.DoorCmd == 0x02) || (!DSC1.VelocityIsZero && ExtCanOnline)))// || (wait_timer >= 200))
				if(PassengerButton || DisabledButton || (wait_timer >= 1000))
 80243c2:	4b37      	ldr	r3, [pc, #220]	; (80244a0 <MainProc+0x538>)
 80243c4:	681b      	ldr	r3, [r3, #0]
 80243c6:	2b00      	cmp	r3, #0
 80243c8:	d108      	bne.n	80243dc <MainProc+0x474>
 80243ca:	4b36      	ldr	r3, [pc, #216]	; (80244a4 <MainProc+0x53c>)
 80243cc:	681b      	ldr	r3, [r3, #0]
 80243ce:	2b00      	cmp	r3, #0
 80243d0:	d104      	bne.n	80243dc <MainProc+0x474>
 80243d2:	4b35      	ldr	r3, [pc, #212]	; (80244a8 <MainProc+0x540>)
 80243d4:	681b      	ldr	r3, [r3, #0]
 80243d6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80243da:	db0b      	blt.n	80243f4 <MainProc+0x48c>
				{
					wait_timer = 0;
 80243dc:	4b32      	ldr	r3, [pc, #200]	; (80244a8 <MainProc+0x540>)
 80243de:	2200      	movs	r2, #0
 80243e0:	601a      	str	r2, [r3, #0]
					MainState = MS_CLOSING;
 80243e2:	4b32      	ldr	r3, [pc, #200]	; (80244ac <MainProc+0x544>)
 80243e4:	2206      	movs	r2, #6
 80243e6:	601a      	str	r2, [r3, #0]
					CloseTime = 0;
 80243e8:	4b39      	ldr	r3, [pc, #228]	; (80244d0 <MainProc+0x568>)
 80243ea:	2200      	movs	r2, #0
 80243ec:	801a      	strh	r2, [r3, #0]
					//wait_timer = 0;
					blink = 0;
 80243ee:	4b37      	ldr	r3, [pc, #220]	; (80244cc <MainProc+0x564>)
 80243f0:	2200      	movs	r2, #0
 80243f2:	601a      	str	r2, [r3, #0]
//				{
//					MainState = MS_CLOSING;
//					blink = 0;
//				}
//
				WriteBuzzer(BUZZER_ON);
 80243f4:	2001      	movs	r0, #1
 80243f6:	f7fe fd8b 	bl	8022f10 <WriteBuzzer>
		}
			break;
 80243fa:	f000 bc79 	b.w	8024cf0 <MainProc+0xd88>

		case MS_CLOSING:
		{
			WriteRubberLights(CL_RED, MODE_BLINK, 500);
 80243fe:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024402:	2102      	movs	r1, #2
 8024404:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024408:	f7ff f860 	bl	80234cc <WriteRubberLights>
			CloseTime++;
 802440c:	4b30      	ldr	r3, [pc, #192]	; (80244d0 <MainProc+0x568>)
 802440e:	881b      	ldrh	r3, [r3, #0]
 8024410:	3301      	adds	r3, #1
 8024412:	b29a      	uxth	r2, r3
 8024414:	4b2e      	ldr	r3, [pc, #184]	; (80244d0 <MainProc+0x568>)
 8024416:	801a      	strh	r2, [r3, #0]
			temp = CloseDoor(1);
 8024418:	2001      	movs	r0, #1
 802441a:	f000 ff31 	bl	8025280 <CloseDoor>
 802441e:	60f8      	str	r0, [r7, #12]
			if (temp == 1) //
 8024420:	68fb      	ldr	r3, [r7, #12]
 8024422:	2b01      	cmp	r3, #1
 8024424:	d10b      	bne.n	802443e <MainProc+0x4d6>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
				MainState = MS_CLOSED;
 8024426:	4b21      	ldr	r3, [pc, #132]	; (80244ac <MainProc+0x544>)
 8024428:	2203      	movs	r2, #3
 802442a:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 802442c:	4b1e      	ldr	r3, [pc, #120]	; (80244a8 <MainProc+0x540>)
 802442e:	2200      	movs	r2, #0
 8024430:	601a      	str	r2, [r3, #0]
				blink = 0;
 8024432:	4b26      	ldr	r3, [pc, #152]	; (80244cc <MainProc+0x564>)
 8024434:	2200      	movs	r2, #0
 8024436:	601a      	str	r2, [r3, #0]
				fallen_edge = 5;
 8024438:	4b26      	ldr	r3, [pc, #152]	; (80244d4 <MainProc+0x56c>)
 802443a:	2205      	movs	r2, #5
 802443c:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 802443e:	68fb      	ldr	r3, [r7, #12]
 8024440:	2b00      	cmp	r3, #0
 8024442:	d102      	bne.n	802444a <MainProc+0x4e2>
			{
				WriteBuzzer(BUZZER_ON);
 8024444:	2001      	movs	r0, #1
 8024446:	f7fe fd63 	bl	8022f10 <WriteBuzzer>
			}
			if (temp == -1)
 802444a:	68fb      	ldr	r3, [r7, #12]
 802444c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024450:	d105      	bne.n	802445e <MainProc+0x4f6>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024452:	4b16      	ldr	r3, [pc, #88]	; (80244ac <MainProc+0x544>)
 8024454:	2215      	movs	r2, #21
 8024456:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024458:	2000      	movs	r0, #0
 802445a:	f000 ff11 	bl	8025280 <CloseDoor>
			}
			if (temp == -2)
 802445e:	68fb      	ldr	r3, [r7, #12]
 8024460:	f113 0f02 	cmn.w	r3, #2
 8024464:	d105      	bne.n	8024472 <MainProc+0x50a>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024466:	4b11      	ldr	r3, [pc, #68]	; (80244ac <MainProc+0x544>)
 8024468:	2216      	movs	r2, #22
 802446a:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 802446c:	2000      	movs	r0, #0
 802446e:	f000 ff07 	bl	8025280 <CloseDoor>
			}
			if (temp == -3)
 8024472:	68fb      	ldr	r3, [r7, #12]
 8024474:	f113 0f03 	cmn.w	r3, #3
 8024478:	d105      	bne.n	8024486 <MainProc+0x51e>
			{
				MainState = MS_ERROR_BAD_STATE;
 802447a:	4b0c      	ldr	r3, [pc, #48]	; (80244ac <MainProc+0x544>)
 802447c:	2217      	movs	r2, #23
 802447e:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024480:	2000      	movs	r0, #0
 8024482:	f000 fefd 	bl	8025280 <CloseDoor>
			}
			if(-4 == temp)
 8024486:	68fb      	ldr	r3, [r7, #12]
 8024488:	f113 0f04 	cmn.w	r3, #4
 802448c:	f040 8419 	bne.w	8024cc2 <MainProc+0xd5a>
			{
				CloseDoor(0);
 8024490:	2000      	movs	r0, #0
 8024492:	f000 fef5 	bl	8025280 <CloseDoor>
				MainState = MS_BLOCKAGE_CLS;
 8024496:	4b05      	ldr	r3, [pc, #20]	; (80244ac <MainProc+0x544>)
 8024498:	220a      	movs	r2, #10
 802449a:	601a      	str	r2, [r3, #0]
//				MainState = MS_OPENING;
//			}


		}
			break;
 802449c:	f000 bc11 	b.w	8024cc2 <MainProc+0xd5a>
 80244a0:	20000630 	.word	0x20000630
 80244a4:	20000634 	.word	0x20000634
 80244a8:	20000708 	.word	0x20000708
 80244ac:	200006f4 	.word	0x200006f4
 80244b0:	20000700 	.word	0x20000700
 80244b4:	200006c8 	.word	0x200006c8
 80244b8:	2000070c 	.word	0x2000070c
 80244bc:	2000062c 	.word	0x2000062c
 80244c0:	20000600 	.word	0x20000600
 80244c4:	200006fc 	.word	0x200006fc
 80244c8:	20000710 	.word	0x20000710
 80244cc:	20000714 	.word	0x20000714
 80244d0:	200006ca 	.word	0x200006ca
 80244d4:	20000254 	.word	0x20000254

		case MS_BLOCKAGE_CLS:
		{
//			DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
//			DIGITAL_IO_SetOutputLow(&HS_SW_8);
			wait_timer++;
 80244d8:	4b87      	ldr	r3, [pc, #540]	; (80246f8 <MainProc+0x790>)
 80244da:	681b      	ldr	r3, [r3, #0]
 80244dc:	3301      	adds	r3, #1
 80244de:	4a86      	ldr	r2, [pc, #536]	; (80246f8 <MainProc+0x790>)
 80244e0:	6013      	str	r3, [r2, #0]
			pause++;
 80244e2:	4b86      	ldr	r3, [pc, #536]	; (80246fc <MainProc+0x794>)
 80244e4:	681b      	ldr	r3, [r3, #0]
 80244e6:	3301      	adds	r3, #1
 80244e8:	4a84      	ldr	r2, [pc, #528]	; (80246fc <MainProc+0x794>)
 80244ea:	6013      	str	r3, [r2, #0]
			if (pause >= 50)
 80244ec:	4b83      	ldr	r3, [pc, #524]	; (80246fc <MainProc+0x794>)
 80244ee:	681b      	ldr	r3, [r3, #0]
 80244f0:	2b31      	cmp	r3, #49	; 0x31
 80244f2:	dd68      	ble.n	80245c6 <MainProc+0x65e>
			{
				temp = OpenAfterBlockage(1);
 80244f4:	2001      	movs	r0, #1
 80244f6:	f001 fa4b 	bl	8025990 <OpenAfterBlockage>
 80244fa:	60f8      	str	r0, [r7, #12]
				WriteRubberLights(CL_RED, MODE_BLINK, 500);
 80244fc:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024500:	2102      	movs	r1, #2
 8024502:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024506:	f7fe ffe1 	bl	80234cc <WriteRubberLights>
				if (temp == 1)
 802450a:	68fb      	ldr	r3, [r7, #12]
 802450c:	2b01      	cmp	r3, #1
 802450e:	d108      	bne.n	8024522 <MainProc+0x5ba>
				{
					MainState = MS_OPENED_BLOCK;
 8024510:	4b7b      	ldr	r3, [pc, #492]	; (8024700 <MainProc+0x798>)
 8024512:	2207      	movs	r2, #7
 8024514:	601a      	str	r2, [r3, #0]
					pause = 0;
 8024516:	4b79      	ldr	r3, [pc, #484]	; (80246fc <MainProc+0x794>)
 8024518:	2200      	movs	r2, #0
 802451a:	601a      	str	r2, [r3, #0]
					//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
					//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
					blink = 0;
 802451c:	4b79      	ldr	r3, [pc, #484]	; (8024704 <MainProc+0x79c>)
 802451e:	2200      	movs	r2, #0
 8024520:	601a      	str	r2, [r3, #0]
				}
				if (temp == 0)
 8024522:	68fb      	ldr	r3, [r7, #12]
 8024524:	2b00      	cmp	r3, #0
 8024526:	d102      	bne.n	802452e <MainProc+0x5c6>
				{
					WriteBuzzer(BUZZER_ON);
 8024528:	2001      	movs	r0, #1
 802452a:	f7fe fcf1 	bl	8022f10 <WriteBuzzer>
				}
				if (temp == -1)
 802452e:	68fb      	ldr	r3, [r7, #12]
 8024530:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024534:	d108      	bne.n	8024548 <MainProc+0x5e0>
				{
					pause = 0;
 8024536:	4b71      	ldr	r3, [pc, #452]	; (80246fc <MainProc+0x794>)
 8024538:	2200      	movs	r2, #0
 802453a:	601a      	str	r2, [r3, #0]
					MainState = MS_ERROR_MOV_TIMEOUT;
 802453c:	4b70      	ldr	r3, [pc, #448]	; (8024700 <MainProc+0x798>)
 802453e:	2215      	movs	r2, #21
 8024540:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 8024542:	2000      	movs	r0, #0
 8024544:	f001 fa24 	bl	8025990 <OpenAfterBlockage>
				}
				if (temp == -2)
 8024548:	68fb      	ldr	r3, [r7, #12]
 802454a:	f113 0f02 	cmn.w	r3, #2
 802454e:	d108      	bne.n	8024562 <MainProc+0x5fa>
				{
					pause = 0;
 8024550:	4b6a      	ldr	r3, [pc, #424]	; (80246fc <MainProc+0x794>)
 8024552:	2200      	movs	r2, #0
 8024554:	601a      	str	r2, [r3, #0]
					MainState = MS_ERROR_MAX_CURRENT;
 8024556:	4b6a      	ldr	r3, [pc, #424]	; (8024700 <MainProc+0x798>)
 8024558:	2216      	movs	r2, #22
 802455a:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 802455c:	2000      	movs	r0, #0
 802455e:	f001 fa17 	bl	8025990 <OpenAfterBlockage>
				}
				if (temp == -3)
 8024562:	68fb      	ldr	r3, [r7, #12]
 8024564:	f113 0f03 	cmn.w	r3, #3
 8024568:	d108      	bne.n	802457c <MainProc+0x614>
				{
					pause = 0;
 802456a:	4b64      	ldr	r3, [pc, #400]	; (80246fc <MainProc+0x794>)
 802456c:	2200      	movs	r2, #0
 802456e:	601a      	str	r2, [r3, #0]
					MainState = MS_ERROR_BAD_STATE;
 8024570:	4b63      	ldr	r3, [pc, #396]	; (8024700 <MainProc+0x798>)
 8024572:	2217      	movs	r2, #23
 8024574:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 8024576:	2000      	movs	r0, #0
 8024578:	f001 fa0a 	bl	8025990 <OpenAfterBlockage>
				}
				if(-4 == temp)
 802457c:	68fb      	ldr	r3, [r7, #12]
 802457e:	f113 0f04 	cmn.w	r3, #4
 8024582:	d108      	bne.n	8024596 <MainProc+0x62e>
				{
					pause = 0;
 8024584:	4b5d      	ldr	r3, [pc, #372]	; (80246fc <MainProc+0x794>)
 8024586:	2200      	movs	r2, #0
 8024588:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 802458a:	2000      	movs	r0, #0
 802458c:	f001 fa00 	bl	8025990 <OpenAfterBlockage>
					MainState = MS_BLOCKAGE_OPN;
 8024590:	4b5b      	ldr	r3, [pc, #364]	; (8024700 <MainProc+0x798>)
 8024592:	220b      	movs	r2, #11
 8024594:	601a      	str	r2, [r3, #0]
				}
 //maybe off
//				if((CanCmdCloseAll || CanCmdCloseCmd && (pause >= 150))|| (!CanCmdUnlock))
				if(PassengerButton || DisabledButton || (wait_timer >= 1000))
 8024596:	4b5c      	ldr	r3, [pc, #368]	; (8024708 <MainProc+0x7a0>)
 8024598:	681b      	ldr	r3, [r3, #0]
 802459a:	2b00      	cmp	r3, #0
 802459c:	d109      	bne.n	80245b2 <MainProc+0x64a>
 802459e:	4b5b      	ldr	r3, [pc, #364]	; (802470c <MainProc+0x7a4>)
 80245a0:	681b      	ldr	r3, [r3, #0]
 80245a2:	2b00      	cmp	r3, #0
 80245a4:	d105      	bne.n	80245b2 <MainProc+0x64a>
 80245a6:	4b54      	ldr	r3, [pc, #336]	; (80246f8 <MainProc+0x790>)
 80245a8:	681b      	ldr	r3, [r3, #0]
 80245aa:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80245ae:	f2c0 838a 	blt.w	8024cc6 <MainProc+0xd5e>
				{
					OpenAfterBlockage(0);
 80245b2:	2000      	movs	r0, #0
 80245b4:	f001 f9ec 	bl	8025990 <OpenAfterBlockage>
					MainState = MS_CLOSING;
 80245b8:	4b51      	ldr	r3, [pc, #324]	; (8024700 <MainProc+0x798>)
 80245ba:	2206      	movs	r2, #6
 80245bc:	601a      	str	r2, [r3, #0]
					pause = 0;
 80245be:	4b4f      	ldr	r3, [pc, #316]	; (80246fc <MainProc+0x794>)
 80245c0:	2200      	movs	r2, #0
 80245c2:	601a      	str	r2, [r3, #0]
			{
				MotorStop();
				//WriteRubberLights(CL_YELLOW, MODE_ON, 100);
			}
		}
			break;
 80245c4:	e37f      	b.n	8024cc6 <MainProc+0xd5e>
				MotorStop();
 80245c6:	f7fe fb3d 	bl	8022c44 <MotorStop>
			break;
 80245ca:	e37c      	b.n	8024cc6 <MainProc+0xd5e>

		case MS_BLOCKAGE_OPN:
		{
			wait_timer ++;
 80245cc:	4b4a      	ldr	r3, [pc, #296]	; (80246f8 <MainProc+0x790>)
 80245ce:	681b      	ldr	r3, [r3, #0]
 80245d0:	3301      	adds	r3, #1
 80245d2:	4a49      	ldr	r2, [pc, #292]	; (80246f8 <MainProc+0x790>)
 80245d4:	6013      	str	r3, [r2, #0]

			MotorStop();
 80245d6:	f7fe fb35 	bl	8022c44 <MotorStop>
			WriteBuzzer(BUZZER_OFF);
 80245da:	2000      	movs	r0, #0
 80245dc:	f7fe fc98 	bl	8022f10 <WriteBuzzer>

			WriteRubberLights(CL_GREEN, MODE_ON, 100);
 80245e0:	2264      	movs	r2, #100	; 0x64
 80245e2:	2101      	movs	r1, #1
 80245e4:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 80245e8:	f7fe ff70 	bl	80234cc <WriteRubberLights>

//			if((CanCmdCloseAll || CanCmdCloseCmd || !CanCmdUnlock) && !TrapSensor )//if((DSC1.DoorCmd == 0x02) || (!DSC1.VelocityIsZero && ExtCanOnline))
			if(PassengerButton || DisabledButton || (wait_timer >= 1000))
 80245ec:	4b46      	ldr	r3, [pc, #280]	; (8024708 <MainProc+0x7a0>)
 80245ee:	681b      	ldr	r3, [r3, #0]
 80245f0:	2b00      	cmp	r3, #0
 80245f2:	d109      	bne.n	8024608 <MainProc+0x6a0>
 80245f4:	4b45      	ldr	r3, [pc, #276]	; (802470c <MainProc+0x7a4>)
 80245f6:	681b      	ldr	r3, [r3, #0]
 80245f8:	2b00      	cmp	r3, #0
 80245fa:	d105      	bne.n	8024608 <MainProc+0x6a0>
 80245fc:	4b3e      	ldr	r3, [pc, #248]	; (80246f8 <MainProc+0x790>)
 80245fe:	681b      	ldr	r3, [r3, #0]
 8024600:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8024604:	f2c0 8361 	blt.w	8024cca <MainProc+0xd62>
			{
				//Motor0_BLDC_SCALAR_ClearErrorState();
				MainState = MS_CLOSING;
 8024608:	4b3d      	ldr	r3, [pc, #244]	; (8024700 <MainProc+0x798>)
 802460a:	2206      	movs	r2, #6
 802460c:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 802460e:	4b3a      	ldr	r3, [pc, #232]	; (80246f8 <MainProc+0x790>)
 8024610:	2200      	movs	r2, #0
 8024612:	601a      	str	r2, [r3, #0]
//				//Motor0_BLDC_SCALAR_ClearErrorState();
//				MainState = MS_OPENING;
//				wait_timer = 0;
//			}
		}
			break;
 8024614:	e359      	b.n	8024cca <MainProc+0xd62>
//		}
//			break;
//
		case MS_FORCE_CLS:
		{
			temp = ForceClose(1);
 8024616:	2001      	movs	r0, #1
 8024618:	f001 fb64 	bl	8025ce4 <ForceClose>
 802461c:	60f8      	str	r0, [r7, #12]
			if (temp == 1) // homing done success!
 802461e:	68fb      	ldr	r3, [r7, #12]
 8024620:	2b01      	cmp	r3, #1
 8024622:	d10e      	bne.n	8024642 <MainProc+0x6da>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);

				DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8024624:	483a      	ldr	r0, [pc, #232]	; (8024710 <MainProc+0x7a8>)
 8024626:	f7ff fc26 	bl	8023e76 <DIGITAL_IO_SetOutputHigh>
				DIGITAL_IO_SetOutputLow(&HS_SW_8);
 802462a:	483a      	ldr	r0, [pc, #232]	; (8024714 <MainProc+0x7ac>)
 802462c:	f7ff fc33 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				PWM_CCU4_Stop(&BUZZ_PWM);
 8024630:	4839      	ldr	r0, [pc, #228]	; (8024718 <MainProc+0x7b0>)
 8024632:	f005 f92a 	bl	802988a <PWM_CCU4_Stop>

				//HomingDone = 1;
				MainState = MS_CLOSED;
 8024636:	4b32      	ldr	r3, [pc, #200]	; (8024700 <MainProc+0x798>)
 8024638:	2203      	movs	r2, #3
 802463a:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 802463c:	4b2e      	ldr	r3, [pc, #184]	; (80246f8 <MainProc+0x790>)
 802463e:	2200      	movs	r2, #0
 8024640:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
			{
				//WriteBuzzer(BUZZER_ON);
			}
			if (temp == -1)
 8024642:	68fb      	ldr	r3, [r7, #12]
 8024644:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024648:	d105      	bne.n	8024656 <MainProc+0x6ee>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 802464a:	4b2d      	ldr	r3, [pc, #180]	; (8024700 <MainProc+0x798>)
 802464c:	2215      	movs	r2, #21
 802464e:	601a      	str	r2, [r3, #0]
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				ForceClose(0);
 8024650:	2000      	movs	r0, #0
 8024652:	f001 fb47 	bl	8025ce4 <ForceClose>
			}
			if (temp == -2)
 8024656:	68fb      	ldr	r3, [r7, #12]
 8024658:	f113 0f02 	cmn.w	r3, #2
 802465c:	d105      	bne.n	802466a <MainProc+0x702>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_MAX_CURRENT;
 802465e:	4b28      	ldr	r3, [pc, #160]	; (8024700 <MainProc+0x798>)
 8024660:	2216      	movs	r2, #22
 8024662:	601a      	str	r2, [r3, #0]
				ForceClose(0);
 8024664:	2000      	movs	r0, #0
 8024666:	f001 fb3d 	bl	8025ce4 <ForceClose>
			}
			if (temp == -3)
 802466a:	68fb      	ldr	r3, [r7, #12]
 802466c:	f113 0f03 	cmn.w	r3, #3
 8024670:	d105      	bne.n	802467e <MainProc+0x716>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_BAD_HOMING;
 8024672:	4b23      	ldr	r3, [pc, #140]	; (8024700 <MainProc+0x798>)
 8024674:	2214      	movs	r2, #20
 8024676:	601a      	str	r2, [r3, #0]
				ForceClose(0);
 8024678:	2000      	movs	r0, #0
 802467a:	f001 fb33 	bl	8025ce4 <ForceClose>
			}
			if (-4 == temp)
 802467e:	68fb      	ldr	r3, [r7, #12]
 8024680:	f113 0f04 	cmn.w	r3, #4
 8024684:	f040 8323 	bne.w	8024cce <MainProc+0xd66>
			{
				MainState = MS_UNKNOWN;
 8024688:	4b1d      	ldr	r3, [pc, #116]	; (8024700 <MainProc+0x798>)
 802468a:	2201      	movs	r2, #1
 802468c:	601a      	str	r2, [r3, #0]
				ForceClose(0);
 802468e:	2000      	movs	r0, #0
 8024690:	f001 fb28 	bl	8025ce4 <ForceClose>
			}
		}
		break;
 8024694:	e31b      	b.n	8024cce <MainProc+0xd66>

		default: // now it is error handler, todo: different errors
		{
//			blink++;
			wait_timer++;
 8024696:	4b18      	ldr	r3, [pc, #96]	; (80246f8 <MainProc+0x790>)
 8024698:	681b      	ldr	r3, [r3, #0]
 802469a:	3301      	adds	r3, #1
 802469c:	4a16      	ldr	r2, [pc, #88]	; (80246f8 <MainProc+0x790>)
 802469e:	6013      	str	r3, [r2, #0]
			WriteBuzzer(BUZZER_OFF);
 80246a0:	2000      	movs	r0, #0
 80246a2:	f7fe fc35 	bl	8022f10 <WriteBuzzer>

			MotorStop();
 80246a6:	f7fe facd 	bl	8022c44 <MotorStop>
//			WritePassengerButton(CMD_OFF);
//			WriteClutch(CLUTCH_LOCK);
			//DIGITAL_IO_SetOutputLow(&HS_SW_1);
			//DIGITAL_ IO_SetOutputLow(&HS_SW_2);
			WriteRubberLights(CL_RED, MODE_BLINK, 200);
 80246aa:	22c8      	movs	r2, #200	; 0xc8
 80246ac:	2102      	movs	r1, #2
 80246ae:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80246b2:	f7fe ff0b 	bl	80234cc <WriteRubberLights>
//				wait_timer = 0;
//			}
//

//			if((CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline)))
			if(PassengerButton || DisabledButton || (wait_timer >= 1000))
 80246b6:	4b14      	ldr	r3, [pc, #80]	; (8024708 <MainProc+0x7a0>)
 80246b8:	681b      	ldr	r3, [r3, #0]
 80246ba:	2b00      	cmp	r3, #0
 80246bc:	d108      	bne.n	80246d0 <MainProc+0x768>
 80246be:	4b13      	ldr	r3, [pc, #76]	; (802470c <MainProc+0x7a4>)
 80246c0:	681b      	ldr	r3, [r3, #0]
 80246c2:	2b00      	cmp	r3, #0
 80246c4:	d104      	bne.n	80246d0 <MainProc+0x768>
 80246c6:	4b0c      	ldr	r3, [pc, #48]	; (80246f8 <MainProc+0x790>)
 80246c8:	681b      	ldr	r3, [r3, #0]
 80246ca:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80246ce:	db02      	blt.n	80246d6 <MainProc+0x76e>
			{
				MainState = MS_CLOSING;
 80246d0:	4b0b      	ldr	r3, [pc, #44]	; (8024700 <MainProc+0x798>)
 80246d2:	2206      	movs	r2, #6
 80246d4:	601a      	str	r2, [r3, #0]
			}
			if((CanCmdOpenCmd) && CanCmdOpenEnable)
 80246d6:	4b11      	ldr	r3, [pc, #68]	; (802471c <MainProc+0x7b4>)
 80246d8:	681b      	ldr	r3, [r3, #0]
 80246da:	2b00      	cmp	r3, #0
 80246dc:	f000 82f9 	beq.w	8024cd2 <MainProc+0xd6a>
 80246e0:	4b0f      	ldr	r3, [pc, #60]	; (8024720 <MainProc+0x7b8>)
 80246e2:	681b      	ldr	r3, [r3, #0]
 80246e4:	2b00      	cmp	r3, #0
 80246e6:	f000 82f4 	beq.w	8024cd2 <MainProc+0xd6a>
			{
				MainState = MS_OPENING;
 80246ea:	4b05      	ldr	r3, [pc, #20]	; (8024700 <MainProc+0x798>)
 80246ec:	2204      	movs	r2, #4
 80246ee:	601a      	str	r2, [r3, #0]
				blink = 0;
 80246f0:	4b04      	ldr	r3, [pc, #16]	; (8024704 <MainProc+0x79c>)
 80246f2:	2200      	movs	r2, #0
 80246f4:	601a      	str	r2, [r3, #0]
				DIGITAL_IO_SetOutputLow(&STATUS_LED_R);
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
			}*/
			//DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
		}
		break;
 80246f6:	e2ec      	b.n	8024cd2 <MainProc+0xd6a>
 80246f8:	20000708 	.word	0x20000708
 80246fc:	20000718 	.word	0x20000718
 8024700:	200006f4 	.word	0x200006f4
 8024704:	20000714 	.word	0x20000714
 8024708:	20000630 	.word	0x20000630
 802470c:	20000634 	.word	0x20000634
 8024710:	0802b42c 	.word	0x0802b42c
 8024714:	0802b544 	.word	0x0802b544
 8024718:	20000290 	.word	0x20000290
 802471c:	200006b8 	.word	0x200006b8
 8024720:	200006b0 	.word	0x200006b0
	}
}
else
{
	if(ServiceButtonFront)
 8024724:	4ba2      	ldr	r3, [pc, #648]	; (80249b0 <MainProc+0xa48>)
 8024726:	681b      	ldr	r3, [r3, #0]
 8024728:	2b00      	cmp	r3, #0
 802472a:	d00b      	beq.n	8024744 <MainProc+0x7dc>
	{
		ClutchControl = 1;
 802472c:	4ba1      	ldr	r3, [pc, #644]	; (80249b4 <MainProc+0xa4c>)
 802472e:	2201      	movs	r2, #1
 8024730:	601a      	str	r2, [r3, #0]
		MainState = 0;
 8024732:	4ba1      	ldr	r3, [pc, #644]	; (80249b8 <MainProc+0xa50>)
 8024734:	2200      	movs	r2, #0
 8024736:	601a      	str	r2, [r3, #0]
		//Motor0_BLDC_SCALAR_MotorStop();
		WritePassengerButton(CMD_OFF);
 8024738:	2000      	movs	r0, #0
 802473a:	f7fe feb1 	bl	80234a0 <WritePassengerButton>
		wait_timer = 0;
 802473e:	4b9f      	ldr	r3, [pc, #636]	; (80249bc <MainProc+0xa54>)
 8024740:	2200      	movs	r2, #0
 8024742:	601a      	str	r2, [r3, #0]
	}
	if(PassengerButton || (Inputs.GIO & 0x0004))
 8024744:	4b9e      	ldr	r3, [pc, #632]	; (80249c0 <MainProc+0xa58>)
 8024746:	681b      	ldr	r3, [r3, #0]
 8024748:	2b00      	cmp	r3, #0
 802474a:	d105      	bne.n	8024758 <MainProc+0x7f0>
 802474c:	4b9d      	ldr	r3, [pc, #628]	; (80249c4 <MainProc+0xa5c>)
 802474e:	889b      	ldrh	r3, [r3, #4]
 8024750:	f003 0304 	and.w	r3, r3, #4
 8024754:	2b00      	cmp	r3, #0
 8024756:	d008      	beq.n	802476a <MainProc+0x802>
	{
		ClutchControl = 0;
 8024758:	4b96      	ldr	r3, [pc, #600]	; (80249b4 <MainProc+0xa4c>)
 802475a:	2200      	movs	r2, #0
 802475c:	601a      	str	r2, [r3, #0]
		ClutchGo = 0;
 802475e:	4b9a      	ldr	r3, [pc, #616]	; (80249c8 <MainProc+0xa60>)
 8024760:	2200      	movs	r2, #0
 8024762:	601a      	str	r2, [r3, #0]
		WritePassengerButton(CMD_ON);
 8024764:	2001      	movs	r0, #1
 8024766:	f7fe fe9b 	bl	80234a0 <WritePassengerButton>
	}

	if(ClutchControl)
 802476a:	4b92      	ldr	r3, [pc, #584]	; (80249b4 <MainProc+0xa4c>)
 802476c:	681b      	ldr	r3, [r3, #0]
 802476e:	2b00      	cmp	r3, #0
 8024770:	d04d      	beq.n	802480e <MainProc+0x8a6>
	{
		switch (ClutchGo)
 8024772:	4b95      	ldr	r3, [pc, #596]	; (80249c8 <MainProc+0xa60>)
 8024774:	681b      	ldr	r3, [r3, #0]
 8024776:	2b04      	cmp	r3, #4
 8024778:	d850      	bhi.n	802481c <MainProc+0x8b4>
 802477a:	a201      	add	r2, pc, #4	; (adr r2, 8024780 <MainProc+0x818>)
 802477c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8024780:	08024795 	.word	0x08024795
 8024784:	080247a1 	.word	0x080247a1
 8024788:	080247bb 	.word	0x080247bb
 802478c:	080247df 	.word	0x080247df
 8024790:	080247f9 	.word	0x080247f9
		{
			case 0:
			{
				ClutchGo++;
 8024794:	4b8c      	ldr	r3, [pc, #560]	; (80249c8 <MainProc+0xa60>)
 8024796:	681b      	ldr	r3, [r3, #0]
 8024798:	3301      	adds	r3, #1
 802479a:	4a8b      	ldr	r2, [pc, #556]	; (80249c8 <MainProc+0xa60>)
 802479c:	6013      	str	r3, [r2, #0]
			}
			break;
 802479e:	e03d      	b.n	802481c <MainProc+0x8b4>
			case 1:
			{
				if(ServiceButtonFront)
 80247a0:	4b83      	ldr	r3, [pc, #524]	; (80249b0 <MainProc+0xa48>)
 80247a2:	681b      	ldr	r3, [r3, #0]
 80247a4:	2b00      	cmp	r3, #0
 80247a6:	d004      	beq.n	80247b2 <MainProc+0x84a>
				{
					ClutchGo++;
 80247a8:	4b87      	ldr	r3, [pc, #540]	; (80249c8 <MainProc+0xa60>)
 80247aa:	681b      	ldr	r3, [r3, #0]
 80247ac:	3301      	adds	r3, #1
 80247ae:	4a86      	ldr	r2, [pc, #536]	; (80249c8 <MainProc+0xa60>)
 80247b0:	6013      	str	r3, [r2, #0]
				}
				WriteBuzzer(BUZZER_OFF);
 80247b2:	2000      	movs	r0, #0
 80247b4:	f7fe fbac 	bl	8022f10 <WriteBuzzer>
			}
			break;
 80247b8:	e030      	b.n	802481c <MainProc+0x8b4>
			case 2:
			{
				pause++;
 80247ba:	4b84      	ldr	r3, [pc, #528]	; (80249cc <MainProc+0xa64>)
 80247bc:	681b      	ldr	r3, [r3, #0]
 80247be:	3301      	adds	r3, #1
 80247c0:	4a82      	ldr	r2, [pc, #520]	; (80249cc <MainProc+0xa64>)
 80247c2:	6013      	str	r3, [r2, #0]
//				DIGITAL_IO_SetOutputHigh(&HS_SW_1);
//				DIGITAL_IO_SetOutputHigh(&HS_SW_2);

				if (pause >= 1)
 80247c4:	4b81      	ldr	r3, [pc, #516]	; (80249cc <MainProc+0xa64>)
 80247c6:	681b      	ldr	r3, [r3, #0]
 80247c8:	2b00      	cmp	r3, #0
 80247ca:	dd22      	ble.n	8024812 <MainProc+0x8aa>
				{
					ClutchGo++;
 80247cc:	4b7e      	ldr	r3, [pc, #504]	; (80249c8 <MainProc+0xa60>)
 80247ce:	681b      	ldr	r3, [r3, #0]
 80247d0:	3301      	adds	r3, #1
 80247d2:	4a7d      	ldr	r2, [pc, #500]	; (80249c8 <MainProc+0xa60>)
 80247d4:	6013      	str	r3, [r2, #0]
					pause = 0;
 80247d6:	4b7d      	ldr	r3, [pc, #500]	; (80249cc <MainProc+0xa64>)
 80247d8:	2200      	movs	r2, #0
 80247da:	601a      	str	r2, [r3, #0]
				}
			}
			break;
 80247dc:	e019      	b.n	8024812 <MainProc+0x8aa>
			case 3:
			{
				WriteClutch(CLUTCH_UNLOCK);
 80247de:	2001      	movs	r0, #1
 80247e0:	f7fe fe00 	bl	80233e4 <WriteClutch>
				//WriteBuzzer(BUZZER_ON);
				if(ServiceButtonFront)
 80247e4:	4b72      	ldr	r3, [pc, #456]	; (80249b0 <MainProc+0xa48>)
 80247e6:	681b      	ldr	r3, [r3, #0]
 80247e8:	2b00      	cmp	r3, #0
 80247ea:	d014      	beq.n	8024816 <MainProc+0x8ae>
				{
					ClutchGo++;
 80247ec:	4b76      	ldr	r3, [pc, #472]	; (80249c8 <MainProc+0xa60>)
 80247ee:	681b      	ldr	r3, [r3, #0]
 80247f0:	3301      	adds	r3, #1
 80247f2:	4a75      	ldr	r2, [pc, #468]	; (80249c8 <MainProc+0xa60>)
 80247f4:	6013      	str	r3, [r2, #0]
				}
			}
			break;
 80247f6:	e00e      	b.n	8024816 <MainProc+0x8ae>
			case 4:
			{
				WriteClutch(CLUTCH_LOCK);
 80247f8:	2000      	movs	r0, #0
 80247fa:	f7fe fdf3 	bl	80233e4 <WriteClutch>
				//WriteBuzzer(BUZZER_OFF);
				if(ServiceButtonFront)
 80247fe:	4b6c      	ldr	r3, [pc, #432]	; (80249b0 <MainProc+0xa48>)
 8024800:	681b      	ldr	r3, [r3, #0]
 8024802:	2b00      	cmp	r3, #0
 8024804:	d009      	beq.n	802481a <MainProc+0x8b2>
				{
					ClutchGo = 2;
 8024806:	4b70      	ldr	r3, [pc, #448]	; (80249c8 <MainProc+0xa60>)
 8024808:	2202      	movs	r2, #2
 802480a:	601a      	str	r2, [r3, #0]
				}
			}
			break;
 802480c:	e005      	b.n	802481a <MainProc+0x8b2>
		}
	}
 802480e:	bf00      	nop
 8024810:	e004      	b.n	802481c <MainProc+0x8b4>
			break;
 8024812:	bf00      	nop
 8024814:	e002      	b.n	802481c <MainProc+0x8b4>
			break;
 8024816:	bf00      	nop
 8024818:	e000      	b.n	802481c <MainProc+0x8b4>
			break;
 802481a:	bf00      	nop


if(!ClutchControl)
 802481c:	4b65      	ldr	r3, [pc, #404]	; (80249b4 <MainProc+0xa4c>)
 802481e:	681b      	ldr	r3, [r3, #0]
 8024820:	2b00      	cmp	r3, #0
 8024822:	f040 8258 	bne.w	8024cd6 <MainProc+0xd6e>
{
	WritePassengerButton(CMD_ON);
 8024826:	2001      	movs	r0, #1
 8024828:	f7fe fe3a 	bl	80234a0 <WritePassengerButton>

	switch (MainState)
 802482c:	4b62      	ldr	r3, [pc, #392]	; (80249b8 <MainProc+0xa50>)
 802482e:	681b      	ldr	r3, [r3, #0]
 8024830:	2b06      	cmp	r3, #6
 8024832:	f200 8221 	bhi.w	8024c78 <MainProc+0xd10>
 8024836:	a201      	add	r2, pc, #4	; (adr r2, 802483c <MainProc+0x8d4>)
 8024838:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802483c:	08024859 	.word	0x08024859
 8024840:	0802489b 	.word	0x0802489b
 8024844:	080248ef 	.word	0x080248ef
 8024848:	080249ed 	.word	0x080249ed
 802484c:	08024a6f 	.word	0x08024a6f
 8024850:	08024b2d 	.word	0x08024b2d
 8024854:	08024b8b 	.word	0x08024b8b
	{
		case MS_START:
		{
			wait_timer++;
 8024858:	4b58      	ldr	r3, [pc, #352]	; (80249bc <MainProc+0xa54>)
 802485a:	681b      	ldr	r3, [r3, #0]
 802485c:	3301      	adds	r3, #1
 802485e:	4a57      	ldr	r2, [pc, #348]	; (80249bc <MainProc+0xa54>)
 8024860:	6013      	str	r3, [r2, #0]
			if(wait_timer >= Presets.STARTUP_TIME)
 8024862:	4b5b      	ldr	r3, [pc, #364]	; (80249d0 <MainProc+0xa68>)
 8024864:	69db      	ldr	r3, [r3, #28]
 8024866:	4a55      	ldr	r2, [pc, #340]	; (80249bc <MainProc+0xa54>)
 8024868:	6812      	ldr	r2, [r2, #0]
 802486a:	4293      	cmp	r3, r2
 802486c:	d806      	bhi.n	802487c <MainProc+0x914>
			{
				wait_timer = 0;
 802486e:	4b53      	ldr	r3, [pc, #332]	; (80249bc <MainProc+0xa54>)
 8024870:	2200      	movs	r2, #0
 8024872:	601a      	str	r2, [r3, #0]
				//	Motor0_BLDC_SCALAR_ClearErrorState();
				//	DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
				//}
				//else
				//{
					MainState = MS_UNKNOWN;
 8024874:	4b50      	ldr	r3, [pc, #320]	; (80249b8 <MainProc+0xa50>)
 8024876:	2201      	movs	r2, #1
 8024878:	601a      	str	r2, [r3, #0]
				Homing(0);
				//Motor0_BLDC_SCALAR_ClearErrorState();
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
			}
		}
			break;
 802487a:	e239      	b.n	8024cf0 <MainProc+0xd88>
				OpenDoor(0);
 802487c:	2000      	movs	r0, #0
 802487e:	f000 fe4f 	bl	8025520 <OpenDoor>
				CloseDoor(0);
 8024882:	2000      	movs	r0, #0
 8024884:	f000 fcfc 	bl	8025280 <CloseDoor>
				Homing(0);
 8024888:	2000      	movs	r0, #0
 802488a:	f000 fb6f 	bl	8024f6c <Homing>
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
 802488e:	2200      	movs	r2, #0
 8024890:	2100      	movs	r1, #0
 8024892:	2000      	movs	r0, #0
 8024894:	f7fe fe1a 	bl	80234cc <WriteRubberLights>
			break;
 8024898:	e22a      	b.n	8024cf0 <MainProc+0xd88>

		case MS_UNKNOWN:
		{
			//WritePassengerButton(CMD_ON);

			wait_timer++;
 802489a:	4b48      	ldr	r3, [pc, #288]	; (80249bc <MainProc+0xa54>)
 802489c:	681b      	ldr	r3, [r3, #0]
 802489e:	3301      	adds	r3, #1
 80248a0:	4a46      	ldr	r2, [pc, #280]	; (80249bc <MainProc+0xa54>)
 80248a2:	6013      	str	r3, [r2, #0]

			if((PassengerButton))// || (wait_timer >= Presets.STARTUP_TIME))
 80248a4:	4b46      	ldr	r3, [pc, #280]	; (80249c0 <MainProc+0xa58>)
 80248a6:	681b      	ldr	r3, [r3, #0]
 80248a8:	2b00      	cmp	r3, #0
 80248aa:	d005      	beq.n	80248b8 <MainProc+0x950>
			{
				MainState = MS_HOMING;
 80248ac:	4b42      	ldr	r3, [pc, #264]	; (80249b8 <MainProc+0xa50>)
 80248ae:	2202      	movs	r2, #2
 80248b0:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 80248b2:	4b42      	ldr	r3, [pc, #264]	; (80249bc <MainProc+0xa54>)
 80248b4:	2200      	movs	r2, #0
 80248b6:	601a      	str	r2, [r3, #0]
			}

			if(Inputs.GIO & 0x0004)
 80248b8:	4b42      	ldr	r3, [pc, #264]	; (80249c4 <MainProc+0xa5c>)
 80248ba:	889b      	ldrh	r3, [r3, #4]
 80248bc:	f003 0304 	and.w	r3, r3, #4
 80248c0:	2b00      	cmp	r3, #0
 80248c2:	d008      	beq.n	80248d6 <MainProc+0x96e>
			{
				MainState = MS_HOMING;
 80248c4:	4b3c      	ldr	r3, [pc, #240]	; (80249b8 <MainProc+0xa50>)
 80248c6:	2202      	movs	r2, #2
 80248c8:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 80248ca:	4b3c      	ldr	r3, [pc, #240]	; (80249bc <MainProc+0xa54>)
 80248cc:	2200      	movs	r2, #0
 80248ce:	601a      	str	r2, [r3, #0]
				serv_from_but = 1;
 80248d0:	4b40      	ldr	r3, [pc, #256]	; (80249d4 <MainProc+0xa6c>)
 80248d2:	2201      	movs	r2, #1
 80248d4:	601a      	str	r2, [r3, #0]
			}

			if(HomingDone)
 80248d6:	4b40      	ldr	r3, [pc, #256]	; (80249d8 <MainProc+0xa70>)
 80248d8:	681b      	ldr	r3, [r3, #0]
 80248da:	2b00      	cmp	r3, #0
 80248dc:	f000 81fd 	beq.w	8024cda <MainProc+0xd72>
			{
				WriteRubberLights(CL_RED, MODE_BLINK, 200);
 80248e0:	22c8      	movs	r2, #200	; 0xc8
 80248e2:	2102      	movs	r1, #2
 80248e4:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80248e8:	f7fe fdf0 	bl	80234cc <WriteRubberLights>
			}


		}
			break;
 80248ec:	e1f5      	b.n	8024cda <MainProc+0xd72>

		case MS_HOMING:
		{
			WriteRubberLights(CL_YELLOW, MODE_BLINK, 1000);
 80248ee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80248f2:	2102      	movs	r1, #2
 80248f4:	4839      	ldr	r0, [pc, #228]	; (80249dc <MainProc+0xa74>)
 80248f6:	f7fe fde9 	bl	80234cc <WriteRubberLights>
			temp = Homing(1);
 80248fa:	2001      	movs	r0, #1
 80248fc:	f000 fb36 	bl	8024f6c <Homing>
 8024900:	60f8      	str	r0, [r7, #12]
			if (temp == 1) // homing done success!
 8024902:	68fb      	ldr	r3, [r7, #12]
 8024904:	2b01      	cmp	r3, #1
 8024906:	d10e      	bne.n	8024926 <MainProc+0x9be>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024908:	4835      	ldr	r0, [pc, #212]	; (80249e0 <MainProc+0xa78>)
 802490a:	f7ff fac4 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 802490e:	4835      	ldr	r0, [pc, #212]	; (80249e4 <MainProc+0xa7c>)
 8024910:	f7ff fab1 	bl	8023e76 <DIGITAL_IO_SetOutputHigh>
				HomingDone = 1;
 8024914:	4b30      	ldr	r3, [pc, #192]	; (80249d8 <MainProc+0xa70>)
 8024916:	2201      	movs	r2, #1
 8024918:	601a      	str	r2, [r3, #0]
				MainState = MS_CLOSED;
 802491a:	4b27      	ldr	r3, [pc, #156]	; (80249b8 <MainProc+0xa50>)
 802491c:	2203      	movs	r2, #3
 802491e:	601a      	str	r2, [r3, #0]
				serv_from_but = 0;
 8024920:	4b2c      	ldr	r3, [pc, #176]	; (80249d4 <MainProc+0xa6c>)
 8024922:	2200      	movs	r2, #0
 8024924:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024926:	68fb      	ldr	r3, [r7, #12]
 8024928:	2b00      	cmp	r3, #0
 802492a:	d111      	bne.n	8024950 <MainProc+0x9e8>
			{
				blink++;
 802492c:	4b2e      	ldr	r3, [pc, #184]	; (80249e8 <MainProc+0xa80>)
 802492e:	681b      	ldr	r3, [r3, #0]
 8024930:	3301      	adds	r3, #1
 8024932:	4a2d      	ldr	r2, [pc, #180]	; (80249e8 <MainProc+0xa80>)
 8024934:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 8024936:	4b2c      	ldr	r3, [pc, #176]	; (80249e8 <MainProc+0xa80>)
 8024938:	681b      	ldr	r3, [r3, #0]
 802493a:	2b31      	cmp	r3, #49	; 0x31
 802493c:	dd05      	ble.n	802494a <MainProc+0x9e2>
				{
					DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 802493e:	4828      	ldr	r0, [pc, #160]	; (80249e0 <MainProc+0xa78>)
 8024940:	f7ff fab9 	bl	8023eb6 <DIGITAL_IO_ToggleOutput>
					blink = 0;
 8024944:	4b28      	ldr	r3, [pc, #160]	; (80249e8 <MainProc+0xa80>)
 8024946:	2200      	movs	r2, #0
 8024948:	601a      	str	r2, [r3, #0]
				}
				WriteBuzzer(BUZZER_ON);
 802494a:	2001      	movs	r0, #1
 802494c:	f7fe fae0 	bl	8022f10 <WriteBuzzer>
			}
			if (temp == -1)
 8024950:	68fb      	ldr	r3, [r7, #12]
 8024952:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024956:	d10b      	bne.n	8024970 <MainProc+0xa08>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024958:	4b17      	ldr	r3, [pc, #92]	; (80249b8 <MainProc+0xa50>)
 802495a:	2215      	movs	r2, #21
 802495c:	601a      	str	r2, [r3, #0]
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 802495e:	4820      	ldr	r0, [pc, #128]	; (80249e0 <MainProc+0xa78>)
 8024960:	f7ff fa99 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
 8024964:	481f      	ldr	r0, [pc, #124]	; (80249e4 <MainProc+0xa7c>)
 8024966:	f7ff fa96 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				Homing(0);
 802496a:	2000      	movs	r0, #0
 802496c:	f000 fafe 	bl	8024f6c <Homing>
			}
			if (temp == -2)
 8024970:	68fb      	ldr	r3, [r7, #12]
 8024972:	f113 0f02 	cmn.w	r3, #2
 8024976:	d108      	bne.n	802498a <MainProc+0xa22>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024978:	4819      	ldr	r0, [pc, #100]	; (80249e0 <MainProc+0xa78>)
 802497a:	f7ff fa8c 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_MAX_CURRENT;
 802497e:	4b0e      	ldr	r3, [pc, #56]	; (80249b8 <MainProc+0xa50>)
 8024980:	2216      	movs	r2, #22
 8024982:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024984:	2000      	movs	r0, #0
 8024986:	f000 faf1 	bl	8024f6c <Homing>
			}
			if (temp == -3)
 802498a:	68fb      	ldr	r3, [r7, #12]
 802498c:	f113 0f03 	cmn.w	r3, #3
 8024990:	f040 81a5 	bne.w	8024cde <MainProc+0xd76>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024994:	4812      	ldr	r0, [pc, #72]	; (80249e0 <MainProc+0xa78>)
 8024996:	f7ff fa7e 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
 802499a:	4812      	ldr	r0, [pc, #72]	; (80249e4 <MainProc+0xa7c>)
 802499c:	f7ff fa7b 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				MainState = MS_ERROR_BAD_HOMING;
 80249a0:	4b05      	ldr	r3, [pc, #20]	; (80249b8 <MainProc+0xa50>)
 80249a2:	2214      	movs	r2, #20
 80249a4:	601a      	str	r2, [r3, #0]
				Homing(0);
 80249a6:	2000      	movs	r0, #0
 80249a8:	f000 fae0 	bl	8024f6c <Homing>
			}
		}
			break;
 80249ac:	e197      	b.n	8024cde <MainProc+0xd76>
 80249ae:	bf00      	nop
 80249b0:	2000063c 	.word	0x2000063c
 80249b4:	2000071c 	.word	0x2000071c
 80249b8:	200006f4 	.word	0x200006f4
 80249bc:	20000708 	.word	0x20000708
 80249c0:	20000630 	.word	0x20000630
 80249c4:	20000668 	.word	0x20000668
 80249c8:	20000720 	.word	0x20000720
 80249cc:	20000718 	.word	0x20000718
 80249d0:	20000770 	.word	0x20000770
 80249d4:	20000704 	.word	0x20000704
 80249d8:	200006f8 	.word	0x200006f8
 80249dc:	ffff0000 	.word	0xffff0000
 80249e0:	0802b404 	.word	0x0802b404
 80249e4:	0802b3f0 	.word	0x0802b3f0
 80249e8:	20000714 	.word	0x20000714

		case MS_CLOSED:
		{
			//wait_timer++;
			wait_timer++;
 80249ec:	4b96      	ldr	r3, [pc, #600]	; (8024c48 <MainProc+0xce0>)
 80249ee:	681b      	ldr	r3, [r3, #0]
 80249f0:	3301      	adds	r3, #1
 80249f2:	4a95      	ldr	r2, [pc, #596]	; (8024c48 <MainProc+0xce0>)
 80249f4:	6013      	str	r3, [r2, #0]
			//WriteClutch(CLUTCH_LOCK);


			if(wait_timer >= 200)
 80249f6:	4b94      	ldr	r3, [pc, #592]	; (8024c48 <MainProc+0xce0>)
 80249f8:	681b      	ldr	r3, [r3, #0]
 80249fa:	2bc7      	cmp	r3, #199	; 0xc7
 80249fc:	dd01      	ble.n	8024a02 <MainProc+0xa9a>
			{
				MotorStop();
 80249fe:	f7fe f921 	bl	8022c44 <MotorStop>
			}

			WriteBuzzer(BUZZER_OFF);
 8024a02:	2000      	movs	r0, #0
 8024a04:	f7fe fa84 	bl	8022f10 <WriteBuzzer>
			//
			if((PassengerButton))// || (wait_timer >= 2000))
 8024a08:	4b90      	ldr	r3, [pc, #576]	; (8024c4c <MainProc+0xce4>)
 8024a0a:	681b      	ldr	r3, [r3, #0]
 8024a0c:	2b00      	cmp	r3, #0
 8024a0e:	d008      	beq.n	8024a22 <MainProc+0xaba>
			{
				MainState = MS_OPENING;
 8024a10:	4b8f      	ldr	r3, [pc, #572]	; (8024c50 <MainProc+0xce8>)
 8024a12:	2204      	movs	r2, #4
 8024a14:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 8024a16:	4b8f      	ldr	r3, [pc, #572]	; (8024c54 <MainProc+0xcec>)
 8024a18:	2200      	movs	r2, #0
 8024a1a:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024a1c:	4b8a      	ldr	r3, [pc, #552]	; (8024c48 <MainProc+0xce0>)
 8024a1e:	2200      	movs	r2, #0
 8024a20:	601a      	str	r2, [r3, #0]
			}
			if(Inputs.GIO & 0x0004)// || (wait_timer >= 2000))
 8024a22:	4b8d      	ldr	r3, [pc, #564]	; (8024c58 <MainProc+0xcf0>)
 8024a24:	889b      	ldrh	r3, [r3, #4]
 8024a26:	f003 0304 	and.w	r3, r3, #4
 8024a2a:	2b00      	cmp	r3, #0
 8024a2c:	d00b      	beq.n	8024a46 <MainProc+0xade>
			{
				MainState = MS_OPENING;
 8024a2e:	4b88      	ldr	r3, [pc, #544]	; (8024c50 <MainProc+0xce8>)
 8024a30:	2204      	movs	r2, #4
 8024a32:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 8024a34:	4b87      	ldr	r3, [pc, #540]	; (8024c54 <MainProc+0xcec>)
 8024a36:	2200      	movs	r2, #0
 8024a38:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024a3a:	4b83      	ldr	r3, [pc, #524]	; (8024c48 <MainProc+0xce0>)
 8024a3c:	2200      	movs	r2, #0
 8024a3e:	601a      	str	r2, [r3, #0]
				serv_from_but = 1;
 8024a40:	4b86      	ldr	r3, [pc, #536]	; (8024c5c <MainProc+0xcf4>)
 8024a42:	2201      	movs	r2, #1
 8024a44:	601a      	str	r2, [r3, #0]
			}

			WriteRubberLights(CL_RED, MODE_TIME_ON, 1000);
 8024a46:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8024a4a:	2103      	movs	r1, #3
 8024a4c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024a50:	f7fe fd3c 	bl	80234cc <WriteRubberLights>

			if(!CloseSensor || (drive.Position >= 10))
 8024a54:	4b82      	ldr	r3, [pc, #520]	; (8024c60 <MainProc+0xcf8>)
 8024a56:	681b      	ldr	r3, [r3, #0]
 8024a58:	2b00      	cmp	r3, #0
 8024a5a:	d004      	beq.n	8024a66 <MainProc+0xafe>
 8024a5c:	4b81      	ldr	r3, [pc, #516]	; (8024c64 <MainProc+0xcfc>)
 8024a5e:	881b      	ldrh	r3, [r3, #0]
 8024a60:	2b09      	cmp	r3, #9
 8024a62:	f240 813e 	bls.w	8024ce2 <MainProc+0xd7a>
			{
				MainState = MS_UNKNOWN;
 8024a66:	4b7a      	ldr	r3, [pc, #488]	; (8024c50 <MainProc+0xce8>)
 8024a68:	2201      	movs	r2, #1
 8024a6a:	601a      	str	r2, [r3, #0]
			}

		}
			break;
 8024a6c:	e139      	b.n	8024ce2 <MainProc+0xd7a>
		case MS_OPENING:
		{
			WriteRubberLights(CL_GREEN, MODE_BLINK, 500);
 8024a6e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024a72:	2102      	movs	r1, #2
 8024a74:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024a78:	f7fe fd28 	bl	80234cc <WriteRubberLights>
			OpenTime++;
 8024a7c:	4b75      	ldr	r3, [pc, #468]	; (8024c54 <MainProc+0xcec>)
 8024a7e:	881b      	ldrh	r3, [r3, #0]
 8024a80:	3301      	adds	r3, #1
 8024a82:	b29a      	uxth	r2, r3
 8024a84:	4b73      	ldr	r3, [pc, #460]	; (8024c54 <MainProc+0xcec>)
 8024a86:	801a      	strh	r2, [r3, #0]
			WriteBuzzer(BUZZER_OFF);
 8024a88:	2000      	movs	r0, #0
 8024a8a:	f7fe fa41 	bl	8022f10 <WriteBuzzer>
			temp = OpenDoor(1);
 8024a8e:	2001      	movs	r0, #1
 8024a90:	f000 fd46 	bl	8025520 <OpenDoor>
 8024a94:	60f8      	str	r0, [r7, #12]
			if (temp == 1)
 8024a96:	68fb      	ldr	r3, [r7, #12]
 8024a98:	2b01      	cmp	r3, #1
 8024a9a:	d10b      	bne.n	8024ab4 <MainProc+0xb4c>
			{
//				if(Presets.CYCLES_COUNTER % 200)
//				{
					MainState = MS_OPENED;
 8024a9c:	4b6c      	ldr	r3, [pc, #432]	; (8024c50 <MainProc+0xce8>)
 8024a9e:	2205      	movs	r2, #5
 8024aa0:	601a      	str	r2, [r3, #0]
					serv_from_but = 0;
 8024aa2:	4b6e      	ldr	r3, [pc, #440]	; (8024c5c <MainProc+0xcf4>)
 8024aa4:	2200      	movs	r2, #0
 8024aa6:	601a      	str	r2, [r3, #0]
//				else
//				{
//					MainState = MS_START;
//				}
//
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024aa8:	486f      	ldr	r0, [pc, #444]	; (8024c68 <MainProc+0xd00>)
 8024aaa:	f7ff f9f4 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 8024aae:	486f      	ldr	r0, [pc, #444]	; (8024c6c <MainProc+0xd04>)
 8024ab0:	f7ff f9e1 	bl	8023e76 <DIGITAL_IO_SetOutputHigh>

			}
			if (temp == 0)
 8024ab4:	68fb      	ldr	r3, [r7, #12]
 8024ab6:	2b00      	cmp	r3, #0
 8024ab8:	d10e      	bne.n	8024ad8 <MainProc+0xb70>
			{
				blink++;
 8024aba:	4b6d      	ldr	r3, [pc, #436]	; (8024c70 <MainProc+0xd08>)
 8024abc:	681b      	ldr	r3, [r3, #0]
 8024abe:	3301      	adds	r3, #1
 8024ac0:	4a6b      	ldr	r2, [pc, #428]	; (8024c70 <MainProc+0xd08>)
 8024ac2:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 8024ac4:	4b6a      	ldr	r3, [pc, #424]	; (8024c70 <MainProc+0xd08>)
 8024ac6:	681b      	ldr	r3, [r3, #0]
 8024ac8:	2b31      	cmp	r3, #49	; 0x31
 8024aca:	dd05      	ble.n	8024ad8 <MainProc+0xb70>
				{
					DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 8024acc:	4866      	ldr	r0, [pc, #408]	; (8024c68 <MainProc+0xd00>)
 8024ace:	f7ff f9f2 	bl	8023eb6 <DIGITAL_IO_ToggleOutput>
					blink = 0;
 8024ad2:	4b67      	ldr	r3, [pc, #412]	; (8024c70 <MainProc+0xd08>)
 8024ad4:	2200      	movs	r2, #0
 8024ad6:	601a      	str	r2, [r3, #0]
				}
			}
			if (temp == -1)
 8024ad8:	68fb      	ldr	r3, [r7, #12]
 8024ada:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024ade:	d105      	bne.n	8024aec <MainProc+0xb84>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024ae0:	4b5b      	ldr	r3, [pc, #364]	; (8024c50 <MainProc+0xce8>)
 8024ae2:	2215      	movs	r2, #21
 8024ae4:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024ae6:	2000      	movs	r0, #0
 8024ae8:	f000 fd1a 	bl	8025520 <OpenDoor>
			}
			if (temp == -2)
 8024aec:	68fb      	ldr	r3, [r7, #12]
 8024aee:	f113 0f02 	cmn.w	r3, #2
 8024af2:	d105      	bne.n	8024b00 <MainProc+0xb98>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024af4:	4b56      	ldr	r3, [pc, #344]	; (8024c50 <MainProc+0xce8>)
 8024af6:	2216      	movs	r2, #22
 8024af8:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024afa:	2000      	movs	r0, #0
 8024afc:	f000 fd10 	bl	8025520 <OpenDoor>
			}
			if (temp == -3)
 8024b00:	68fb      	ldr	r3, [r7, #12]
 8024b02:	f113 0f03 	cmn.w	r3, #3
 8024b06:	d105      	bne.n	8024b14 <MainProc+0xbac>
			{
				MainState = MS_ERROR_BAD_STATE;
 8024b08:	4b51      	ldr	r3, [pc, #324]	; (8024c50 <MainProc+0xce8>)
 8024b0a:	2217      	movs	r2, #23
 8024b0c:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024b0e:	2000      	movs	r0, #0
 8024b10:	f000 fd06 	bl	8025520 <OpenDoor>
			}
			if(-4 == temp)
 8024b14:	68fb      	ldr	r3, [r7, #12]
 8024b16:	f113 0f04 	cmn.w	r3, #4
 8024b1a:	f040 80e4 	bne.w	8024ce6 <MainProc+0xd7e>
			{
				OpenDoor(0);
 8024b1e:	2000      	movs	r0, #0
 8024b20:	f000 fcfe 	bl	8025520 <OpenDoor>
				MainState = MS_CLOSING;
 8024b24:	4b4a      	ldr	r3, [pc, #296]	; (8024c50 <MainProc+0xce8>)
 8024b26:	2206      	movs	r2, #6
 8024b28:	601a      	str	r2, [r3, #0]
			}

		}
			break;
 8024b2a:	e0dc      	b.n	8024ce6 <MainProc+0xd7e>
		case MS_OPENED:
		{
			WriteRubberLights(CL_GREEN, MODE_ON, 0);
 8024b2c:	2200      	movs	r2, #0
 8024b2e:	2101      	movs	r1, #1
 8024b30:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024b34:	f7fe fcca 	bl	80234cc <WriteRubberLights>
			WriteBuzzer(BUZZER_OFF);
 8024b38:	2000      	movs	r0, #0
 8024b3a:	f7fe f9e9 	bl	8022f10 <WriteBuzzer>
			wait_timer++;
 8024b3e:	4b42      	ldr	r3, [pc, #264]	; (8024c48 <MainProc+0xce0>)
 8024b40:	681b      	ldr	r3, [r3, #0]
 8024b42:	3301      	adds	r3, #1
 8024b44:	4a40      	ldr	r2, [pc, #256]	; (8024c48 <MainProc+0xce0>)
 8024b46:	6013      	str	r3, [r2, #0]
			if((PassengerButton))// || (wait_timer >= 200))
 8024b48:	4b40      	ldr	r3, [pc, #256]	; (8024c4c <MainProc+0xce4>)
 8024b4a:	681b      	ldr	r3, [r3, #0]
 8024b4c:	2b00      	cmp	r3, #0
 8024b4e:	d008      	beq.n	8024b62 <MainProc+0xbfa>
			{
				MainState = MS_CLOSING;
 8024b50:	4b3f      	ldr	r3, [pc, #252]	; (8024c50 <MainProc+0xce8>)
 8024b52:	2206      	movs	r2, #6
 8024b54:	601a      	str	r2, [r3, #0]
				CloseTime = 0;
 8024b56:	4b47      	ldr	r3, [pc, #284]	; (8024c74 <MainProc+0xd0c>)
 8024b58:	2200      	movs	r2, #0
 8024b5a:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024b5c:	4b3a      	ldr	r3, [pc, #232]	; (8024c48 <MainProc+0xce0>)
 8024b5e:	2200      	movs	r2, #0
 8024b60:	601a      	str	r2, [r3, #0]
			}
			if((Inputs.GIO & 0x0004))// || (wait_timer >= 200))
 8024b62:	4b3d      	ldr	r3, [pc, #244]	; (8024c58 <MainProc+0xcf0>)
 8024b64:	889b      	ldrh	r3, [r3, #4]
 8024b66:	f003 0304 	and.w	r3, r3, #4
 8024b6a:	2b00      	cmp	r3, #0
 8024b6c:	f000 80bd 	beq.w	8024cea <MainProc+0xd82>
			{
				MainState = MS_CLOSING;
 8024b70:	4b37      	ldr	r3, [pc, #220]	; (8024c50 <MainProc+0xce8>)
 8024b72:	2206      	movs	r2, #6
 8024b74:	601a      	str	r2, [r3, #0]
				CloseTime = 0;
 8024b76:	4b3f      	ldr	r3, [pc, #252]	; (8024c74 <MainProc+0xd0c>)
 8024b78:	2200      	movs	r2, #0
 8024b7a:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024b7c:	4b32      	ldr	r3, [pc, #200]	; (8024c48 <MainProc+0xce0>)
 8024b7e:	2200      	movs	r2, #0
 8024b80:	601a      	str	r2, [r3, #0]
				serv_from_but = 1;
 8024b82:	4b36      	ldr	r3, [pc, #216]	; (8024c5c <MainProc+0xcf4>)
 8024b84:	2201      	movs	r2, #1
 8024b86:	601a      	str	r2, [r3, #0]
			}

		}
			break;
 8024b88:	e0af      	b.n	8024cea <MainProc+0xd82>
		case MS_CLOSING:
		{
			WriteRubberLights(CL_RED, MODE_BLINK, 500);
 8024b8a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024b8e:	2102      	movs	r1, #2
 8024b90:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024b94:	f7fe fc9a 	bl	80234cc <WriteRubberLights>
			CloseTime++;
 8024b98:	4b36      	ldr	r3, [pc, #216]	; (8024c74 <MainProc+0xd0c>)
 8024b9a:	881b      	ldrh	r3, [r3, #0]
 8024b9c:	3301      	adds	r3, #1
 8024b9e:	b29a      	uxth	r2, r3
 8024ba0:	4b34      	ldr	r3, [pc, #208]	; (8024c74 <MainProc+0xd0c>)
 8024ba2:	801a      	strh	r2, [r3, #0]
			temp = CloseDoor(1);
 8024ba4:	2001      	movs	r0, #1
 8024ba6:	f000 fb6b 	bl	8025280 <CloseDoor>
 8024baa:	60f8      	str	r0, [r7, #12]
			if (temp == 1) //
 8024bac:	68fb      	ldr	r3, [r7, #12]
 8024bae:	2b01      	cmp	r3, #1
 8024bb0:	d10b      	bne.n	8024bca <MainProc+0xc62>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024bb2:	482d      	ldr	r0, [pc, #180]	; (8024c68 <MainProc+0xd00>)
 8024bb4:	f7ff f96f 	bl	8023e96 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 8024bb8:	482c      	ldr	r0, [pc, #176]	; (8024c6c <MainProc+0xd04>)
 8024bba:	f7ff f95c 	bl	8023e76 <DIGITAL_IO_SetOutputHigh>
				MainState = MS_CLOSED;
 8024bbe:	4b24      	ldr	r3, [pc, #144]	; (8024c50 <MainProc+0xce8>)
 8024bc0:	2203      	movs	r2, #3
 8024bc2:	601a      	str	r2, [r3, #0]
				serv_from_but = 0;
 8024bc4:	4b25      	ldr	r3, [pc, #148]	; (8024c5c <MainProc+0xcf4>)
 8024bc6:	2200      	movs	r2, #0
 8024bc8:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024bca:	68fb      	ldr	r3, [r7, #12]
 8024bcc:	2b00      	cmp	r3, #0
 8024bce:	d111      	bne.n	8024bf4 <MainProc+0xc8c>
			{
				blink++;
 8024bd0:	4b27      	ldr	r3, [pc, #156]	; (8024c70 <MainProc+0xd08>)
 8024bd2:	681b      	ldr	r3, [r3, #0]
 8024bd4:	3301      	adds	r3, #1
 8024bd6:	4a26      	ldr	r2, [pc, #152]	; (8024c70 <MainProc+0xd08>)
 8024bd8:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 8024bda:	4b25      	ldr	r3, [pc, #148]	; (8024c70 <MainProc+0xd08>)
 8024bdc:	681b      	ldr	r3, [r3, #0]
 8024bde:	2b31      	cmp	r3, #49	; 0x31
 8024be0:	dd05      	ble.n	8024bee <MainProc+0xc86>
				{
					DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 8024be2:	4821      	ldr	r0, [pc, #132]	; (8024c68 <MainProc+0xd00>)
 8024be4:	f7ff f967 	bl	8023eb6 <DIGITAL_IO_ToggleOutput>
					blink = 0;
 8024be8:	4b21      	ldr	r3, [pc, #132]	; (8024c70 <MainProc+0xd08>)
 8024bea:	2200      	movs	r2, #0
 8024bec:	601a      	str	r2, [r3, #0]
				}
				WriteBuzzer(BUZZER_ON);
 8024bee:	2001      	movs	r0, #1
 8024bf0:	f7fe f98e 	bl	8022f10 <WriteBuzzer>
			}
			if (temp == -1)
 8024bf4:	68fb      	ldr	r3, [r7, #12]
 8024bf6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024bfa:	d105      	bne.n	8024c08 <MainProc+0xca0>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024bfc:	4b14      	ldr	r3, [pc, #80]	; (8024c50 <MainProc+0xce8>)
 8024bfe:	2215      	movs	r2, #21
 8024c00:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024c02:	2000      	movs	r0, #0
 8024c04:	f000 fb3c 	bl	8025280 <CloseDoor>
			}
			if (temp == -2)
 8024c08:	68fb      	ldr	r3, [r7, #12]
 8024c0a:	f113 0f02 	cmn.w	r3, #2
 8024c0e:	d105      	bne.n	8024c1c <MainProc+0xcb4>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024c10:	4b0f      	ldr	r3, [pc, #60]	; (8024c50 <MainProc+0xce8>)
 8024c12:	2216      	movs	r2, #22
 8024c14:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024c16:	2000      	movs	r0, #0
 8024c18:	f000 fb32 	bl	8025280 <CloseDoor>
			}
			if (temp == -3)
 8024c1c:	68fb      	ldr	r3, [r7, #12]
 8024c1e:	f113 0f03 	cmn.w	r3, #3
 8024c22:	d105      	bne.n	8024c30 <MainProc+0xcc8>
			{
				MainState = MS_ERROR_BAD_STATE;
 8024c24:	4b0a      	ldr	r3, [pc, #40]	; (8024c50 <MainProc+0xce8>)
 8024c26:	2217      	movs	r2, #23
 8024c28:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024c2a:	2000      	movs	r0, #0
 8024c2c:	f000 fb28 	bl	8025280 <CloseDoor>
			}
			if(-4 == temp)
 8024c30:	68fb      	ldr	r3, [r7, #12]
 8024c32:	f113 0f04 	cmn.w	r3, #4
 8024c36:	d15a      	bne.n	8024cee <MainProc+0xd86>
			{
				CloseDoor(0);
 8024c38:	2000      	movs	r0, #0
 8024c3a:	f000 fb21 	bl	8025280 <CloseDoor>
				MainState = MS_OPENING;
 8024c3e:	4b04      	ldr	r3, [pc, #16]	; (8024c50 <MainProc+0xce8>)
 8024c40:	2204      	movs	r2, #4
 8024c42:	601a      	str	r2, [r3, #0]
			}
		}
			break;
 8024c44:	e053      	b.n	8024cee <MainProc+0xd86>
 8024c46:	bf00      	nop
 8024c48:	20000708 	.word	0x20000708
 8024c4c:	20000630 	.word	0x20000630
 8024c50:	200006f4 	.word	0x200006f4
 8024c54:	200006c8 	.word	0x200006c8
 8024c58:	20000668 	.word	0x20000668
 8024c5c:	20000704 	.word	0x20000704
 8024c60:	2000062c 	.word	0x2000062c
 8024c64:	20000600 	.word	0x20000600
 8024c68:	0802b404 	.word	0x0802b404
 8024c6c:	0802b3f0 	.word	0x0802b3f0
 8024c70:	20000714 	.word	0x20000714
 8024c74:	200006ca 	.word	0x200006ca

		default: // now it is error handler, todo: different errors
		{
			blink++;
 8024c78:	4b23      	ldr	r3, [pc, #140]	; (8024d08 <MainProc+0xda0>)
 8024c7a:	681b      	ldr	r3, [r3, #0]
 8024c7c:	3301      	adds	r3, #1
 8024c7e:	4a22      	ldr	r2, [pc, #136]	; (8024d08 <MainProc+0xda0>)
 8024c80:	6013      	str	r3, [r2, #0]
			//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
			//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);

			if(blink >= 10)
 8024c82:	4b21      	ldr	r3, [pc, #132]	; (8024d08 <MainProc+0xda0>)
 8024c84:	681b      	ldr	r3, [r3, #0]
 8024c86:	2b09      	cmp	r3, #9
 8024c88:	dd05      	ble.n	8024c96 <MainProc+0xd2e>
			{
				DIGITAL_IO_ToggleOutput(&STATUS_LED_R);
 8024c8a:	4820      	ldr	r0, [pc, #128]	; (8024d0c <MainProc+0xda4>)
 8024c8c:	f7ff f913 	bl	8023eb6 <DIGITAL_IO_ToggleOutput>
				blink = 0;
 8024c90:	4b1d      	ldr	r3, [pc, #116]	; (8024d08 <MainProc+0xda0>)
 8024c92:	2200      	movs	r2, #0
 8024c94:	601a      	str	r2, [r3, #0]
			}
			WriteBuzzer(BUZZER_ON);
 8024c96:	2001      	movs	r0, #1
 8024c98:	f7fe f93a 	bl	8022f10 <WriteBuzzer>
			//Motor0_BLDC_SCALAR_MotorStop();
			WritePassengerButton(CMD_OFF);
 8024c9c:	2000      	movs	r0, #0
 8024c9e:	f7fe fbff 	bl	80234a0 <WritePassengerButton>
			WriteClutch(CLUTCH_LOCK);
 8024ca2:	2000      	movs	r0, #0
 8024ca4:	f7fe fb9e 	bl	80233e4 <WriteClutch>
			//DIGITAL_IO_SetOutputLow(&HS_SW_1);
			//DIGITAL_IO_SetOutputLow(&HS_SW_2);
			WriteRubberLights(CL_RED, MODE_BLINK, 200);
 8024ca8:	22c8      	movs	r2, #200	; 0xc8
 8024caa:	2102      	movs	r1, #2
 8024cac:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024cb0:	f7fe fc0c 	bl	80234cc <WriteRubberLights>
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
			}
			*/
			//DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
		}
		break;
 8024cb4:	e01c      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cb6:	bf00      	nop
 8024cb8:	e01a      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cba:	bf00      	nop
 8024cbc:	e018      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cbe:	bf00      	nop
 8024cc0:	e016      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cc2:	bf00      	nop
 8024cc4:	e014      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cc6:	bf00      	nop
 8024cc8:	e012      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cca:	bf00      	nop
 8024ccc:	e010      	b.n	8024cf0 <MainProc+0xd88>
		break;
 8024cce:	bf00      	nop
 8024cd0:	e00e      	b.n	8024cf0 <MainProc+0xd88>
		break;
 8024cd2:	bf00      	nop
 8024cd4:	e00c      	b.n	8024cf0 <MainProc+0xd88>
	}
	}
 8024cd6:	bf00      	nop
 8024cd8:	e00a      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cda:	bf00      	nop
 8024cdc:	e008      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cde:	bf00      	nop
 8024ce0:	e006      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024ce2:	bf00      	nop
 8024ce4:	e004      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024ce6:	bf00      	nop
 8024ce8:	e002      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cea:	bf00      	nop
 8024cec:	e000      	b.n	8024cf0 <MainProc+0xd88>
			break;
 8024cee:	bf00      	nop
}
	SendDiagnostics();
 8024cf0:	f000 f83e 	bl	8024d70 <SendDiagnostics>
	SendExtCan();
 8024cf4:	f000 f820 	bl	8024d38 <SendExtCan>
	CanCmdOpenEnablePrev = CanCmdOpenEnable;
 8024cf8:	4b05      	ldr	r3, [pc, #20]	; (8024d10 <MainProc+0xda8>)
 8024cfa:	681b      	ldr	r3, [r3, #0]
 8024cfc:	4a05      	ldr	r2, [pc, #20]	; (8024d14 <MainProc+0xdac>)
 8024cfe:	6013      	str	r3, [r2, #0]

}// end_main_proc
 8024d00:	bf00      	nop
 8024d02:	3710      	adds	r7, #16
 8024d04:	46bd      	mov	sp, r7
 8024d06:	bd80      	pop	{r7, pc}
 8024d08:	20000714 	.word	0x20000714
 8024d0c:	0802b418 	.word	0x0802b418
 8024d10:	200006b0 	.word	0x200006b0
 8024d14:	20000724 	.word	0x20000724

08024d18 <ReadPeripherials>:


void ReadPeripherials (void)
{
 8024d18:	b580      	push	{r7, lr}
 8024d1a:	af00      	add	r7, sp, #0
//	Velocity = abs(Velocity);

	//if (Current > Max_Close_current) Max_Close_current = Current;
	//if (Current > Max_Open_current) Max_Open_current = Current;

	ReadCloseSensor();
 8024d1c:	f7fe fab4 	bl	8023288 <ReadCloseSensor>
	ReadPassengerButton();
 8024d20:	f7fe fb0c 	bl	802333c <ReadPassengerButton>
	ReadServiceButton();
 8024d24:	f7fe fadc 	bl	80232e0 <ReadServiceButton>
	ReadActiveRubber();
 8024d28:	f7fe fb44 	bl	80233b4 <ReadActiveRubber>
//	ReadDisabledButton();
//	ReadPhotoSensor();
	ReadOpen1DoorButton();
 8024d2c:	f7fe fa94 	bl	8023258 <ReadOpen1DoorButton>
//	if ((2 == Presets.CAN_ADRESS) || (3 == Presets.CAN_ADRESS) )
//	{
		ReadDisabledButton();
 8024d30:	f7fe fb22 	bl	8023378 <ReadDisabledButton>
//		ReadTrapSensor();
//	}


}
 8024d34:	bf00      	nop
 8024d36:	bd80      	pop	{r7, pc}

08024d38 <SendExtCan>:

void SendExtCan(void)
{
 8024d38:	b580      	push	{r7, lr}
 8024d3a:	af00      	add	r7, sp, #0

//	int32_t new_data = 0;

	// todo: add OnChange

	edsc1_timer++;
 8024d3c:	4b0a      	ldr	r3, [pc, #40]	; (8024d68 <SendExtCan+0x30>)
 8024d3e:	681b      	ldr	r3, [r3, #0]
 8024d40:	3301      	adds	r3, #1
 8024d42:	4a09      	ldr	r2, [pc, #36]	; (8024d68 <SendExtCan+0x30>)
 8024d44:	6013      	str	r3, [r2, #0]
//	for(int32_t i = 0; i < 8; i++)
//	{
//		 PrevCan2TxData2[i] = Can2TxData2[i];
//	}

	if (10 <= edsc1_timer || DisabledButton)
 8024d46:	4b08      	ldr	r3, [pc, #32]	; (8024d68 <SendExtCan+0x30>)
 8024d48:	681b      	ldr	r3, [r3, #0]
 8024d4a:	2b09      	cmp	r3, #9
 8024d4c:	dc03      	bgt.n	8024d56 <SendExtCan+0x1e>
 8024d4e:	4b07      	ldr	r3, [pc, #28]	; (8024d6c <SendExtCan+0x34>)
 8024d50:	681b      	ldr	r3, [r3, #0]
 8024d52:	2b00      	cmp	r3, #0
 8024d54:	d006      	beq.n	8024d64 <SendExtCan+0x2c>
	{
		Can1Tx1Prep();
 8024d56:	f7fe fe83 	bl	8023a60 <Can1Tx1Prep>
		edsc1_timer = 0;
 8024d5a:	4b03      	ldr	r3, [pc, #12]	; (8024d68 <SendExtCan+0x30>)
 8024d5c:	2200      	movs	r2, #0
 8024d5e:	601a      	str	r2, [r3, #0]
		Can1Tx1Send();
 8024d60:	f7fe fdc6 	bl	80238f0 <Can1Tx1Send>
//	if (100 <= edsc2_timer)
//	{
//		edsc2_timer = 0;
//		Can1Tx2Send();
//	}
}
 8024d64:	bf00      	nop
 8024d66:	bd80      	pop	{r7, pc}
 8024d68:	20000728 	.word	0x20000728
 8024d6c:	20000634 	.word	0x20000634

08024d70 <SendDiagnostics>:

void SendDiagnostics(void)
{
 8024d70:	b580      	push	{r7, lr}
 8024d72:	b084      	sub	sp, #16
 8024d74:	af00      	add	r7, sp, #0
	uint16_t temp16;
	uint8_t	temp8;
	uint32_t * p32;
	uint16_t * p16;

	if ((MainState == MS_OPENING) || (MainState == MS_CLOSING) || (MainState == MS_BLOCKAGE_CLS) || (MainState == MS_BLOCKAGE_OPN) || (MainState == MS_HOMING) || ServiceMode )	// only when moving
 8024d76:	4b55      	ldr	r3, [pc, #340]	; (8024ecc <SendDiagnostics+0x15c>)
 8024d78:	681b      	ldr	r3, [r3, #0]
 8024d7a:	2b04      	cmp	r3, #4
 8024d7c:	d013      	beq.n	8024da6 <SendDiagnostics+0x36>
 8024d7e:	4b53      	ldr	r3, [pc, #332]	; (8024ecc <SendDiagnostics+0x15c>)
 8024d80:	681b      	ldr	r3, [r3, #0]
 8024d82:	2b06      	cmp	r3, #6
 8024d84:	d00f      	beq.n	8024da6 <SendDiagnostics+0x36>
 8024d86:	4b51      	ldr	r3, [pc, #324]	; (8024ecc <SendDiagnostics+0x15c>)
 8024d88:	681b      	ldr	r3, [r3, #0]
 8024d8a:	2b0a      	cmp	r3, #10
 8024d8c:	d00b      	beq.n	8024da6 <SendDiagnostics+0x36>
 8024d8e:	4b4f      	ldr	r3, [pc, #316]	; (8024ecc <SendDiagnostics+0x15c>)
 8024d90:	681b      	ldr	r3, [r3, #0]
 8024d92:	2b0b      	cmp	r3, #11
 8024d94:	d007      	beq.n	8024da6 <SendDiagnostics+0x36>
 8024d96:	4b4d      	ldr	r3, [pc, #308]	; (8024ecc <SendDiagnostics+0x15c>)
 8024d98:	681b      	ldr	r3, [r3, #0]
 8024d9a:	2b02      	cmp	r3, #2
 8024d9c:	d003      	beq.n	8024da6 <SendDiagnostics+0x36>
 8024d9e:	4b4c      	ldr	r3, [pc, #304]	; (8024ed0 <SendDiagnostics+0x160>)
 8024da0:	681b      	ldr	r3, [r3, #0]
 8024da2:	2b00      	cmp	r3, #0
 8024da4:	d024      	beq.n	8024df0 <SendDiagnostics+0x80>
	{

		p16 = (uint16_t*)(Can2TxData1 + 0);
 8024da6:	4b4b      	ldr	r3, [pc, #300]	; (8024ed4 <SendDiagnostics+0x164>)
 8024da8:	60fb      	str	r3, [r7, #12]
		*p16 = drive.Current;;
 8024daa:	4b4b      	ldr	r3, [pc, #300]	; (8024ed8 <SendDiagnostics+0x168>)
 8024dac:	885a      	ldrh	r2, [r3, #2]
 8024dae:	68fb      	ldr	r3, [r7, #12]
 8024db0:	801a      	strh	r2, [r3, #0]

		p16 = (uint16_t*)(Can2TxData1 + 2);
 8024db2:	4b4a      	ldr	r3, [pc, #296]	; (8024edc <SendDiagnostics+0x16c>)
 8024db4:	60fb      	str	r3, [r7, #12]
		*p16 = drive.Velocity;;
 8024db6:	4b48      	ldr	r3, [pc, #288]	; (8024ed8 <SendDiagnostics+0x168>)
 8024db8:	889a      	ldrh	r2, [r3, #4]
 8024dba:	68fb      	ldr	r3, [r7, #12]
 8024dbc:	801a      	strh	r2, [r3, #0]

		p16 = (uint16_t*)(Can2TxData1 + 4);
 8024dbe:	4b48      	ldr	r3, [pc, #288]	; (8024ee0 <SendDiagnostics+0x170>)
 8024dc0:	60fb      	str	r3, [r7, #12]
		*p16 = drive.Position;;
 8024dc2:	4b45      	ldr	r3, [pc, #276]	; (8024ed8 <SendDiagnostics+0x168>)
 8024dc4:	881a      	ldrh	r2, [r3, #0]
 8024dc6:	68fb      	ldr	r3, [r7, #12]
 8024dc8:	801a      	strh	r2, [r3, #0]

//		temp16 = (uint16_t)CloseSensor * 100;
//		p16 = (uint16_t*)(Can2TxData1 + 6);
//		*p16 = temp16;

		temp16 = Presets.OPEN_POSITION;
 8024dca:	4b46      	ldr	r3, [pc, #280]	; (8024ee4 <SendDiagnostics+0x174>)
 8024dcc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8024dce:	817b      	strh	r3, [r7, #10]
		p16 = (uint16_t*)(Can2TxData1 + 6);
 8024dd0:	4b45      	ldr	r3, [pc, #276]	; (8024ee8 <SendDiagnostics+0x178>)
 8024dd2:	60fb      	str	r3, [r7, #12]
		*p16 = temp16;
 8024dd4:	68fb      	ldr	r3, [r7, #12]
 8024dd6:	897a      	ldrh	r2, [r7, #10]
 8024dd8:	801a      	strh	r2, [r3, #0]

		CAN_NODE_MO_UpdateID(&CAN_INT_LMO_01_Config, 0x64);
 8024dda:	2164      	movs	r1, #100	; 0x64
 8024ddc:	4843      	ldr	r0, [pc, #268]	; (8024eec <SendDiagnostics+0x17c>)
 8024dde:	f7ff f87a 	bl	8023ed6 <CAN_NODE_MO_UpdateID>
		CAN_NODE_MO_UpdateData(&CAN_INT_LMO_01_Config, &Can2TxData1[0]);
 8024de2:	493c      	ldr	r1, [pc, #240]	; (8024ed4 <SendDiagnostics+0x164>)
 8024de4:	4841      	ldr	r0, [pc, #260]	; (8024eec <SendDiagnostics+0x17c>)
 8024de6:	f005 f9d9 	bl	802a19c <CAN_NODE_MO_UpdateData>
		CAN_NODE_MO_Transmit(&CAN_INT_LMO_01_Config);
 8024dea:	4840      	ldr	r0, [pc, #256]	; (8024eec <SendDiagnostics+0x17c>)
 8024dec:	f005 f9b2 	bl	802a154 <CAN_NODE_MO_Transmit>
	}


	Can2TxData3[0] = (uint8_t)Inputs.PNP;
 8024df0:	4b3f      	ldr	r3, [pc, #252]	; (8024ef0 <SendDiagnostics+0x180>)
 8024df2:	881b      	ldrh	r3, [r3, #0]
 8024df4:	b2da      	uxtb	r2, r3
 8024df6:	4b3f      	ldr	r3, [pc, #252]	; (8024ef4 <SendDiagnostics+0x184>)
 8024df8:	701a      	strb	r2, [r3, #0]
	Can2TxData3[1] = (uint8_t)Inputs.NPN;
 8024dfa:	4b3d      	ldr	r3, [pc, #244]	; (8024ef0 <SendDiagnostics+0x180>)
 8024dfc:	885b      	ldrh	r3, [r3, #2]
 8024dfe:	b2da      	uxtb	r2, r3
 8024e00:	4b3c      	ldr	r3, [pc, #240]	; (8024ef4 <SendDiagnostics+0x184>)
 8024e02:	705a      	strb	r2, [r3, #1]
	Can2TxData3[2] = (uint8_t)Inputs.GIO;
 8024e04:	4b3a      	ldr	r3, [pc, #232]	; (8024ef0 <SendDiagnostics+0x180>)
 8024e06:	889b      	ldrh	r3, [r3, #4]
 8024e08:	b2da      	uxtb	r2, r3
 8024e0a:	4b3a      	ldr	r3, [pc, #232]	; (8024ef4 <SendDiagnostics+0x184>)
 8024e0c:	709a      	strb	r2, [r3, #2]
	Can2TxData3[3] = (uint8_t)Inputs.SB;
 8024e0e:	4b38      	ldr	r3, [pc, #224]	; (8024ef0 <SendDiagnostics+0x180>)
 8024e10:	88db      	ldrh	r3, [r3, #6]
 8024e12:	b2da      	uxtb	r2, r3
 8024e14:	4b37      	ldr	r3, [pc, #220]	; (8024ef4 <SendDiagnostics+0x184>)
 8024e16:	70da      	strb	r2, [r3, #3]
	p16 = (uint16_t*)(Can2TxData3 + 4);
 8024e18:	4b37      	ldr	r3, [pc, #220]	; (8024ef8 <SendDiagnostics+0x188>)
 8024e1a:	60fb      	str	r3, [r7, #12]
	*p16 = Inputs.RIN1;
 8024e1c:	4b34      	ldr	r3, [pc, #208]	; (8024ef0 <SendDiagnostics+0x180>)
 8024e1e:	891a      	ldrh	r2, [r3, #8]
 8024e20:	68fb      	ldr	r3, [r7, #12]
 8024e22:	801a      	strh	r2, [r3, #0]

	p16 = (uint16_t*)(Can2TxData3 + 6);
 8024e24:	4b35      	ldr	r3, [pc, #212]	; (8024efc <SendDiagnostics+0x18c>)
 8024e26:	60fb      	str	r3, [r7, #12]
	*p16 = (uint16_t)MainState;//Inputs.ActiveRubberRVal;
 8024e28:	4b28      	ldr	r3, [pc, #160]	; (8024ecc <SendDiagnostics+0x15c>)
 8024e2a:	681b      	ldr	r3, [r3, #0]
 8024e2c:	b29a      	uxth	r2, r3
 8024e2e:	68fb      	ldr	r3, [r7, #12]
 8024e30:	801a      	strh	r2, [r3, #0]


	CAN_NODE_MO_UpdateID(&CAN_INT_LMO_03_Config, 0x66);
 8024e32:	2166      	movs	r1, #102	; 0x66
 8024e34:	4832      	ldr	r0, [pc, #200]	; (8024f00 <SendDiagnostics+0x190>)
 8024e36:	f7ff f84e 	bl	8023ed6 <CAN_NODE_MO_UpdateID>
	CAN_NODE_MO_UpdateData(&CAN_INT_LMO_03_Config, &Can2TxData3[0]);
 8024e3a:	492e      	ldr	r1, [pc, #184]	; (8024ef4 <SendDiagnostics+0x184>)
 8024e3c:	4830      	ldr	r0, [pc, #192]	; (8024f00 <SendDiagnostics+0x190>)
 8024e3e:	f005 f9ad 	bl	802a19c <CAN_NODE_MO_UpdateData>
	CAN_NODE_MO_Transmit(&CAN_INT_LMO_03_Config);
 8024e42:	482f      	ldr	r0, [pc, #188]	; (8024f00 <SendDiagnostics+0x190>)
 8024e44:	f005 f986 	bl	802a154 <CAN_NODE_MO_Transmit>
//	CAN_NODE_MO_UpdateID(&CAN_2_LMO_02_Config, 0x65);
//	CAN_NODE_MO_UpdateData(&CAN_2_LMO_02_Config, &Can2TxData2[0]);
//	CAN_NODE_MO_Transmit(&CAN_2_LMO_02_Config);
//

	send_timer++;
 8024e48:	4b2e      	ldr	r3, [pc, #184]	; (8024f04 <SendDiagnostics+0x194>)
 8024e4a:	681b      	ldr	r3, [r3, #0]
 8024e4c:	3301      	adds	r3, #1
 8024e4e:	4a2d      	ldr	r2, [pc, #180]	; (8024f04 <SendDiagnostics+0x194>)
 8024e50:	6013      	str	r3, [r2, #0]
	if((send_timer >= 10)) // send 1 message per second
 8024e52:	4b2c      	ldr	r3, [pc, #176]	; (8024f04 <SendDiagnostics+0x194>)
 8024e54:	681b      	ldr	r3, [r3, #0]
 8024e56:	2b09      	cmp	r3, #9
 8024e58:	dd33      	ble.n	8024ec2 <SendDiagnostics+0x152>
	{
		send_timer = 0;
 8024e5a:	4b2a      	ldr	r3, [pc, #168]	; (8024f04 <SendDiagnostics+0x194>)
 8024e5c:	2200      	movs	r2, #0
 8024e5e:	601a      	str	r2, [r3, #0]

		temp16 = OpenTime/10;
 8024e60:	4b29      	ldr	r3, [pc, #164]	; (8024f08 <SendDiagnostics+0x198>)
 8024e62:	881b      	ldrh	r3, [r3, #0]
 8024e64:	4a29      	ldr	r2, [pc, #164]	; (8024f0c <SendDiagnostics+0x19c>)
 8024e66:	fba2 2303 	umull	r2, r3, r2, r3
 8024e6a:	08db      	lsrs	r3, r3, #3
 8024e6c:	817b      	strh	r3, [r7, #10]
		temp8 = (uint8_t)temp16;
 8024e6e:	897b      	ldrh	r3, [r7, #10]
 8024e70:	727b      	strb	r3, [r7, #9]
		Can2TxData2[0] = temp8;
 8024e72:	4a27      	ldr	r2, [pc, #156]	; (8024f10 <SendDiagnostics+0x1a0>)
 8024e74:	7a7b      	ldrb	r3, [r7, #9]
 8024e76:	7013      	strb	r3, [r2, #0]

		temp16 = CloseTime/10;
 8024e78:	4b26      	ldr	r3, [pc, #152]	; (8024f14 <SendDiagnostics+0x1a4>)
 8024e7a:	881b      	ldrh	r3, [r3, #0]
 8024e7c:	4a23      	ldr	r2, [pc, #140]	; (8024f0c <SendDiagnostics+0x19c>)
 8024e7e:	fba2 2303 	umull	r2, r3, r2, r3
 8024e82:	08db      	lsrs	r3, r3, #3
 8024e84:	817b      	strh	r3, [r7, #10]
		temp8 = (uint8_t)temp16;
 8024e86:	897b      	ldrh	r3, [r7, #10]
 8024e88:	727b      	strb	r3, [r7, #9]
		Can2TxData2[1] = temp8;
 8024e8a:	4a21      	ldr	r2, [pc, #132]	; (8024f10 <SendDiagnostics+0x1a0>)
 8024e8c:	7a7b      	ldrb	r3, [r7, #9]
 8024e8e:	7053      	strb	r3, [r2, #1]

		p16 = (uint16_t*)(Can2TxData2 + 2);
 8024e90:	4b21      	ldr	r3, [pc, #132]	; (8024f18 <SendDiagnostics+0x1a8>)
 8024e92:	60fb      	str	r3, [r7, #12]
		temp16 = (uint16_t)Presets.OPEN_POSITION;
 8024e94:	4b13      	ldr	r3, [pc, #76]	; (8024ee4 <SendDiagnostics+0x174>)
 8024e96:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8024e98:	817b      	strh	r3, [r7, #10]
		*p16 = temp16;
 8024e9a:	68fb      	ldr	r3, [r7, #12]
 8024e9c:	897a      	ldrh	r2, [r7, #10]
 8024e9e:	801a      	strh	r2, [r3, #0]
		p32 = (uint32_t*)(Can2TxData2 + 4);
 8024ea0:	4b1e      	ldr	r3, [pc, #120]	; (8024f1c <SendDiagnostics+0x1ac>)
 8024ea2:	607b      	str	r3, [r7, #4]
		*p32 = Presets.CYCLES_COUNTER;
 8024ea4:	4b0f      	ldr	r3, [pc, #60]	; (8024ee4 <SendDiagnostics+0x174>)
 8024ea6:	699a      	ldr	r2, [r3, #24]
 8024ea8:	687b      	ldr	r3, [r7, #4]
 8024eaa:	601a      	str	r2, [r3, #0]

		//*p16 = Inputs.InputPower;

		CAN_NODE_MO_UpdateID(&CAN_INT_LMO_02_Config, 0x65);
 8024eac:	2165      	movs	r1, #101	; 0x65
 8024eae:	481c      	ldr	r0, [pc, #112]	; (8024f20 <SendDiagnostics+0x1b0>)
 8024eb0:	f7ff f811 	bl	8023ed6 <CAN_NODE_MO_UpdateID>
		CAN_NODE_MO_UpdateData(&CAN_INT_LMO_02_Config, &Can2TxData2[0]);
 8024eb4:	4916      	ldr	r1, [pc, #88]	; (8024f10 <SendDiagnostics+0x1a0>)
 8024eb6:	481a      	ldr	r0, [pc, #104]	; (8024f20 <SendDiagnostics+0x1b0>)
 8024eb8:	f005 f970 	bl	802a19c <CAN_NODE_MO_UpdateData>
		CAN_NODE_MO_Transmit(&CAN_INT_LMO_02_Config);
 8024ebc:	4818      	ldr	r0, [pc, #96]	; (8024f20 <SendDiagnostics+0x1b0>)
 8024ebe:	f005 f949 	bl	802a154 <CAN_NODE_MO_Transmit>

	}


}
 8024ec2:	bf00      	nop
 8024ec4:	3710      	adds	r7, #16
 8024ec6:	46bd      	mov	sp, r7
 8024ec8:	bd80      	pop	{r7, pc}
 8024eca:	bf00      	nop
 8024ecc:	200006f4 	.word	0x200006f4
 8024ed0:	20000fd0 	.word	0x20000fd0
 8024ed4:	200006d4 	.word	0x200006d4
 8024ed8:	20000600 	.word	0x20000600
 8024edc:	200006d6 	.word	0x200006d6
 8024ee0:	200006d8 	.word	0x200006d8
 8024ee4:	20000770 	.word	0x20000770
 8024ee8:	200006da 	.word	0x200006da
 8024eec:	0802b810 	.word	0x0802b810
 8024ef0:	20000668 	.word	0x20000668
 8024ef4:	200006e4 	.word	0x200006e4
 8024ef8:	200006e8 	.word	0x200006e8
 8024efc:	200006ea 	.word	0x200006ea
 8024f00:	0802b828 	.word	0x0802b828
 8024f04:	2000072c 	.word	0x2000072c
 8024f08:	200006c8 	.word	0x200006c8
 8024f0c:	cccccccd 	.word	0xcccccccd
 8024f10:	200006dc 	.word	0x200006dc
 8024f14:	200006ca 	.word	0x200006ca
 8024f18:	200006de 	.word	0x200006de
 8024f1c:	200006e0 	.word	0x200006e0
 8024f20:	0802b81c 	.word	0x0802b81c

08024f24 <SaveProc>:


void SaveProc(void *args)
{
 8024f24:	b580      	push	{r7, lr}
 8024f26:	b084      	sub	sp, #16
 8024f28:	af00      	add	r7, sp, #0
 8024f2a:	6078      	str	r0, [r7, #4]
	static int32_t count = 0;

	count++;
 8024f2c:	4b0c      	ldr	r3, [pc, #48]	; (8024f60 <SaveProc+0x3c>)
 8024f2e:	681b      	ldr	r3, [r3, #0]
 8024f30:	3301      	adds	r3, #1
 8024f32:	4a0b      	ldr	r2, [pc, #44]	; (8024f60 <SaveProc+0x3c>)
 8024f34:	6013      	str	r3, [r2, #0]
	if (count >= 300) // 1 time per 5 minutes
 8024f36:	4b0a      	ldr	r3, [pc, #40]	; (8024f60 <SaveProc+0x3c>)
 8024f38:	681b      	ldr	r3, [r3, #0]
 8024f3a:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8024f3e:	db0b      	blt.n	8024f58 <SaveProc+0x34>
	{
		if (MS_CLOSED == MainState)
 8024f40:	4b08      	ldr	r3, [pc, #32]	; (8024f64 <SaveProc+0x40>)
 8024f42:	681b      	ldr	r3, [r3, #0]
 8024f44:	2b03      	cmp	r3, #3
 8024f46:	d107      	bne.n	8024f58 <SaveProc+0x34>
			{
				E_EEPROM_XMC4_STATUS_t status = SaveAllPresets( &Presets);//
 8024f48:	4807      	ldr	r0, [pc, #28]	; (8024f68 <SaveProc+0x44>)
 8024f4a:	f000 ffd2 	bl	8025ef2 <SaveAllPresets>
 8024f4e:	4603      	mov	r3, r0
 8024f50:	73fb      	strb	r3, [r7, #15]
				count = 0;
 8024f52:	4b03      	ldr	r3, [pc, #12]	; (8024f60 <SaveProc+0x3c>)
 8024f54:	2200      	movs	r2, #0
 8024f56:	601a      	str	r2, [r3, #0]
			}
	}
}
 8024f58:	bf00      	nop
 8024f5a:	3710      	adds	r7, #16
 8024f5c:	46bd      	mov	sp, r7
 8024f5e:	bd80      	pop	{r7, pc}
 8024f60:	20000730 	.word	0x20000730
 8024f64:	200006f4 	.word	0x200006f4
 8024f68:	20000770 	.word	0x20000770

08024f6c <Homing>:
//int32_t Max_Velocity = 0;
//int32_t Min_Velocity = 0;
//

int32_t Homing(int32_t cmd)
{
 8024f6c:	b580      	push	{r7, lr}
 8024f6e:	b084      	sub	sp, #16
 8024f70:	af00      	add	r7, sp, #0
 8024f72:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8024f74:	2300      	movs	r3, #0
 8024f76:	60fb      	str	r3, [r7, #12]
	static int32_t state = 0;
	static int32_t pause = 0;
	static int32_t tim = 0;

	tim++;
 8024f78:	4ba3      	ldr	r3, [pc, #652]	; (8025208 <Homing+0x29c>)
 8024f7a:	681b      	ldr	r3, [r3, #0]
 8024f7c:	3301      	adds	r3, #1
 8024f7e:	4aa2      	ldr	r2, [pc, #648]	; (8025208 <Homing+0x29c>)
 8024f80:	6013      	str	r3, [r2, #0]

	if(tim >= 2000)
 8024f82:	4ba1      	ldr	r3, [pc, #644]	; (8025208 <Homing+0x29c>)
 8024f84:	681b      	ldr	r3, [r3, #0]
 8024f86:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8024f8a:	db0d      	blt.n	8024fa8 <Homing+0x3c>
	{
		MotorStop();
 8024f8c:	f7fd fe5a 	bl	8022c44 <MotorStop>
		state = 0;
 8024f90:	4b9e      	ldr	r3, [pc, #632]	; (802520c <Homing+0x2a0>)
 8024f92:	2200      	movs	r2, #0
 8024f94:	601a      	str	r2, [r3, #0]
		tim = 0;
 8024f96:	4b9c      	ldr	r3, [pc, #624]	; (8025208 <Homing+0x29c>)
 8024f98:	2200      	movs	r2, #0
 8024f9a:	601a      	str	r2, [r3, #0]
		pause = 0;
 8024f9c:	4b9c      	ldr	r3, [pc, #624]	; (8025210 <Homing+0x2a4>)
 8024f9e:	2200      	movs	r2, #0
 8024fa0:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 8024fa2:	f04f 33ff 	mov.w	r3, #4294967295
 8024fa6:	e160      	b.n	802526a <Homing+0x2fe>
	}
	if (drive.Current >= 1500)
 8024fa8:	4b9a      	ldr	r3, [pc, #616]	; (8025214 <Homing+0x2a8>)
 8024faa:	885b      	ldrh	r3, [r3, #2]
 8024fac:	f240 52db 	movw	r2, #1499	; 0x5db
 8024fb0:	4293      	cmp	r3, r2
 8024fb2:	d90d      	bls.n	8024fd0 <Homing+0x64>
	{
		MotorStop();
 8024fb4:	f7fd fe46 	bl	8022c44 <MotorStop>
		state = 0;
 8024fb8:	4b94      	ldr	r3, [pc, #592]	; (802520c <Homing+0x2a0>)
 8024fba:	2200      	movs	r2, #0
 8024fbc:	601a      	str	r2, [r3, #0]
		tim = 0;
 8024fbe:	4b92      	ldr	r3, [pc, #584]	; (8025208 <Homing+0x29c>)
 8024fc0:	2200      	movs	r2, #0
 8024fc2:	601a      	str	r2, [r3, #0]
		pause = 0;
 8024fc4:	4b92      	ldr	r3, [pc, #584]	; (8025210 <Homing+0x2a4>)
 8024fc6:	2200      	movs	r2, #0
 8024fc8:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 8024fca:	f06f 0301 	mvn.w	r3, #1
 8024fce:	e14c      	b.n	802526a <Homing+0x2fe>
	}


	if(!cmd)
 8024fd0:	687b      	ldr	r3, [r7, #4]
 8024fd2:	2b00      	cmp	r3, #0
 8024fd4:	d10c      	bne.n	8024ff0 <Homing+0x84>
	{
		MotorStop();
 8024fd6:	f7fd fe35 	bl	8022c44 <MotorStop>
		state = 0;
 8024fda:	4b8c      	ldr	r3, [pc, #560]	; (802520c <Homing+0x2a0>)
 8024fdc:	2200      	movs	r2, #0
 8024fde:	601a      	str	r2, [r3, #0]
		tim = 0;
 8024fe0:	4b89      	ldr	r3, [pc, #548]	; (8025208 <Homing+0x29c>)
 8024fe2:	2200      	movs	r2, #0
 8024fe4:	601a      	str	r2, [r3, #0]
		pause = 0;
 8024fe6:	4b8a      	ldr	r3, [pc, #552]	; (8025210 <Homing+0x2a4>)
 8024fe8:	2200      	movs	r2, #0
 8024fea:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8024fec:	2300      	movs	r3, #0
 8024fee:	e13c      	b.n	802526a <Homing+0x2fe>
	}
	else
	{
		switch (state)
 8024ff0:	4b86      	ldr	r3, [pc, #536]	; (802520c <Homing+0x2a0>)
 8024ff2:	681b      	ldr	r3, [r3, #0]
 8024ff4:	2b05      	cmp	r3, #5
 8024ff6:	f200 8131 	bhi.w	802525c <Homing+0x2f0>
 8024ffa:	a201      	add	r2, pc, #4	; (adr r2, 8025000 <Homing+0x94>)
 8024ffc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025000:	08025019 	.word	0x08025019
 8025004:	08025055 	.word	0x08025055
 8025008:	08025073 	.word	0x08025073
 802500c:	080250d7 	.word	0x080250d7
 8025010:	080251a7 	.word	0x080251a7
 8025014:	0802522d 	.word	0x0802522d
		{
		case 0:
		{
			MotorClearError();
 8025018:	f7fd fe4c 	bl	8022cb4 <MotorClearError>
			MotorSetPILimit(40);
 802501c:	2028      	movs	r0, #40	; 0x28
 802501e:	f7fd fe3c 	bl	8022c9a <MotorSetPILimit>
			MotorSetProportionalGain(500);
 8025022:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8025026:	f7fd fe1e 	bl	8022c66 <MotorSetProportionalGain>
			MotorSetIntegralGain(10);
 802502a:	200a      	movs	r0, #10
 802502c:	f7fd fe28 	bl	8022c80 <MotorSetIntegralGain>
			MotorSetSpeed(Presets.CLOSE_DIR * 150); //(Presets.CLOSE_DIR));
 8025030:	4b79      	ldr	r3, [pc, #484]	; (8025218 <Homing+0x2ac>)
 8025032:	681b      	ldr	r3, [r3, #0]
 8025034:	2296      	movs	r2, #150	; 0x96
 8025036:	fb02 f303 	mul.w	r3, r2, r3
 802503a:	4618      	mov	r0, r3
 802503c:	f7fd fe08 	bl	8022c50 <MotorSetSpeed>
			MotorStart();
 8025040:	f7fd fdfa 	bl	8022c38 <MotorStart>
			state++;
 8025044:	4b71      	ldr	r3, [pc, #452]	; (802520c <Homing+0x2a0>)
 8025046:	681b      	ldr	r3, [r3, #0]
 8025048:	3301      	adds	r3, #1
 802504a:	4a70      	ldr	r2, [pc, #448]	; (802520c <Homing+0x2a0>)
 802504c:	6013      	str	r3, [r2, #0]
			result = 0;
 802504e:	2300      	movs	r3, #0
 8025050:	60fb      	str	r3, [r7, #12]
		}
		break;
 8025052:	e109      	b.n	8025268 <Homing+0x2fc>
		case 1:
		{
			if(drive.Current >= 200)
 8025054:	4b6f      	ldr	r3, [pc, #444]	; (8025214 <Homing+0x2a8>)
 8025056:	885b      	ldrh	r3, [r3, #2]
 8025058:	2bc7      	cmp	r3, #199	; 0xc7
 802505a:	f240 8102 	bls.w	8025262 <Homing+0x2f6>
			{
				MotorStop();
 802505e:	f7fd fdf1 	bl	8022c44 <MotorStop>
				state++;
 8025062:	4b6a      	ldr	r3, [pc, #424]	; (802520c <Homing+0x2a0>)
 8025064:	681b      	ldr	r3, [r3, #0]
 8025066:	3301      	adds	r3, #1
 8025068:	4a68      	ldr	r2, [pc, #416]	; (802520c <Homing+0x2a0>)
 802506a:	6013      	str	r3, [r2, #0]
				result = 0;
 802506c:	2300      	movs	r3, #0
 802506e:	60fb      	str	r3, [r7, #12]
			}
		}
		break;
 8025070:	e0f7      	b.n	8025262 <Homing+0x2f6>

			case 2:
			{
				WriteClutch(CLUTCH_UNLOCK);
 8025072:	2001      	movs	r0, #1
 8025074:	f7fe f9b6 	bl	80233e4 <WriteClutch>
				pause++;
 8025078:	4b65      	ldr	r3, [pc, #404]	; (8025210 <Homing+0x2a4>)
 802507a:	681b      	ldr	r3, [r3, #0]
 802507c:	3301      	adds	r3, #1
 802507e:	4a64      	ldr	r2, [pc, #400]	; (8025210 <Homing+0x2a4>)
 8025080:	6013      	str	r3, [r2, #0]
				if(pause >= 20)
 8025082:	4b63      	ldr	r3, [pc, #396]	; (8025210 <Homing+0x2a4>)
 8025084:	681b      	ldr	r3, [r3, #0]
 8025086:	2b13      	cmp	r3, #19
 8025088:	dd16      	ble.n	80250b8 <Homing+0x14c>
				{
					//pause = 0;
					//state = 1;
					MotorClearError();
 802508a:	f7fd fe13 	bl	8022cb4 <MotorClearError>
					MotorSetPILimit(60);
 802508e:	203c      	movs	r0, #60	; 0x3c
 8025090:	f7fd fe03 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(500);
 8025094:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8025098:	f7fd fde5 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 802509c:	200a      	movs	r0, #10
 802509e:	f7fd fdef 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 300); //(Presets.CLOSE_DIR));
 80250a2:	4b5d      	ldr	r3, [pc, #372]	; (8025218 <Homing+0x2ac>)
 80250a4:	681b      	ldr	r3, [r3, #0]
 80250a6:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80250aa:	fb02 f303 	mul.w	r3, r2, r3
 80250ae:	4618      	mov	r0, r3
 80250b0:	f7fd fdce 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 80250b4:	f7fd fdc0 	bl	8022c38 <MotorStart>
				}
				if(pause >= 23) // to eat start stable
 80250b8:	4b55      	ldr	r3, [pc, #340]	; (8025210 <Homing+0x2a4>)
 80250ba:	681b      	ldr	r3, [r3, #0]
 80250bc:	2b16      	cmp	r3, #22
 80250be:	dd07      	ble.n	80250d0 <Homing+0x164>
				{
					pause = 0;
 80250c0:	4b53      	ldr	r3, [pc, #332]	; (8025210 <Homing+0x2a4>)
 80250c2:	2200      	movs	r2, #0
 80250c4:	601a      	str	r2, [r3, #0]
					state++;
 80250c6:	4b51      	ldr	r3, [pc, #324]	; (802520c <Homing+0x2a0>)
 80250c8:	681b      	ldr	r3, [r3, #0]
 80250ca:	3301      	adds	r3, #1
 80250cc:	4a4f      	ldr	r2, [pc, #316]	; (802520c <Homing+0x2a0>)
 80250ce:	6013      	str	r3, [r2, #0]
				}
				result = 0;
 80250d0:	2300      	movs	r3, #0
 80250d2:	60fb      	str	r3, [r7, #12]
			}
				break;
 80250d4:	e0c8      	b.n	8025268 <Homing+0x2fc>

			case 3:
			{

				if(((drive.Current >= 2000) && !CloseSensor && !ServiceMode) || ActiveRubberL)
 80250d6:	4b4f      	ldr	r3, [pc, #316]	; (8025214 <Homing+0x2a8>)
 80250d8:	885b      	ldrh	r3, [r3, #2]
 80250da:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 80250de:	d307      	bcc.n	80250f0 <Homing+0x184>
 80250e0:	4b4e      	ldr	r3, [pc, #312]	; (802521c <Homing+0x2b0>)
 80250e2:	681b      	ldr	r3, [r3, #0]
 80250e4:	2b00      	cmp	r3, #0
 80250e6:	d103      	bne.n	80250f0 <Homing+0x184>
 80250e8:	4b4d      	ldr	r3, [pc, #308]	; (8025220 <Homing+0x2b4>)
 80250ea:	681b      	ldr	r3, [r3, #0]
 80250ec:	2b00      	cmp	r3, #0
 80250ee:	d003      	beq.n	80250f8 <Homing+0x18c>
 80250f0:	4b4c      	ldr	r3, [pc, #304]	; (8025224 <Homing+0x2b8>)
 80250f2:	681b      	ldr	r3, [r3, #0]
 80250f4:	2b00      	cmp	r3, #0
 80250f6:	d008      	beq.n	802510a <Homing+0x19e>
				{
					WriteClutch(CLUTCH_UNLOCK);
 80250f8:	2001      	movs	r0, #1
 80250fa:	f7fe f973 	bl	80233e4 <WriteClutch>
					MotorStop();
 80250fe:	f7fd fda1 	bl	8022c44 <MotorStop>
					result = -4;
 8025102:	f06f 0303 	mvn.w	r3, #3
 8025106:	60fb      	str	r3, [r7, #12]
 8025108:	e001      	b.n	802510e <Homing+0x1a2>
				}
				else
				{
					result = 0;
 802510a:	2300      	movs	r3, #0
 802510c:	60fb      	str	r3, [r7, #12]
				}

				if((!ServiceMode && CloseSensor && (drive.Current >= 300)) || (ServiceMode && (drive.Current >= 300)) || (ServiceMode && (drive.Current >= 300) && serv_from_but))//
 802510e:	4b44      	ldr	r3, [pc, #272]	; (8025220 <Homing+0x2b4>)
 8025110:	681b      	ldr	r3, [r3, #0]
 8025112:	2b00      	cmp	r3, #0
 8025114:	d108      	bne.n	8025128 <Homing+0x1bc>
 8025116:	4b41      	ldr	r3, [pc, #260]	; (802521c <Homing+0x2b0>)
 8025118:	681b      	ldr	r3, [r3, #0]
 802511a:	2b00      	cmp	r3, #0
 802511c:	d004      	beq.n	8025128 <Homing+0x1bc>
 802511e:	4b3d      	ldr	r3, [pc, #244]	; (8025214 <Homing+0x2a8>)
 8025120:	885b      	ldrh	r3, [r3, #2]
 8025122:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8025126:	d215      	bcs.n	8025154 <Homing+0x1e8>
 8025128:	4b3d      	ldr	r3, [pc, #244]	; (8025220 <Homing+0x2b4>)
 802512a:	681b      	ldr	r3, [r3, #0]
 802512c:	2b00      	cmp	r3, #0
 802512e:	d004      	beq.n	802513a <Homing+0x1ce>
 8025130:	4b38      	ldr	r3, [pc, #224]	; (8025214 <Homing+0x2a8>)
 8025132:	885b      	ldrh	r3, [r3, #2]
 8025134:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8025138:	d20c      	bcs.n	8025154 <Homing+0x1e8>
 802513a:	4b39      	ldr	r3, [pc, #228]	; (8025220 <Homing+0x2b4>)
 802513c:	681b      	ldr	r3, [r3, #0]
 802513e:	2b00      	cmp	r3, #0
 8025140:	d029      	beq.n	8025196 <Homing+0x22a>
 8025142:	4b34      	ldr	r3, [pc, #208]	; (8025214 <Homing+0x2a8>)
 8025144:	885b      	ldrh	r3, [r3, #2]
 8025146:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 802514a:	d324      	bcc.n	8025196 <Homing+0x22a>
 802514c:	4b36      	ldr	r3, [pc, #216]	; (8025228 <Homing+0x2bc>)
 802514e:	681b      	ldr	r3, [r3, #0]
 8025150:	2b00      	cmp	r3, #0
 8025152:	d020      	beq.n	8025196 <Homing+0x22a>
				{
					WriteClutch(CLUTCH_LOCK);
 8025154:	2000      	movs	r0, #0
 8025156:	f7fe f945 	bl	80233e4 <WriteClutch>
					MotorSetProportionalGain(300);
 802515a:	f44f 7096 	mov.w	r0, #300	; 0x12c
 802515e:	f7fd fd82 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025162:	200a      	movs	r0, #10
 8025164:	f7fd fd8c 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetPILimit(20);
 8025168:	2014      	movs	r0, #20
 802516a:	f7fd fd96 	bl	8022c9a <MotorSetPILimit>
					MotorSetSpeed(Presets.CLOSE_DIR * 10);
 802516e:	4b2a      	ldr	r3, [pc, #168]	; (8025218 <Homing+0x2ac>)
 8025170:	681a      	ldr	r2, [r3, #0]
 8025172:	4613      	mov	r3, r2
 8025174:	009b      	lsls	r3, r3, #2
 8025176:	4413      	add	r3, r2
 8025178:	005b      	lsls	r3, r3, #1
 802517a:	4618      	mov	r0, r3
 802517c:	f7fd fd68 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025180:	f7fd fd5a 	bl	8022c38 <MotorStart>
					state++;
 8025184:	4b21      	ldr	r3, [pc, #132]	; (802520c <Homing+0x2a0>)
 8025186:	681b      	ldr	r3, [r3, #0]
 8025188:	3301      	adds	r3, #1
 802518a:	4a20      	ldr	r2, [pc, #128]	; (802520c <Homing+0x2a0>)
 802518c:	6013      	str	r3, [r2, #0]
					pause = 0;
 802518e:	4b20      	ldr	r3, [pc, #128]	; (8025210 <Homing+0x2a4>)
 8025190:	2200      	movs	r2, #0
 8025192:	601a      	str	r2, [r3, #0]
				else if(CloseSensor)
				{
					WriteClutch(CLUTCH_LOCK);
				}
			}
				break;
 8025194:	e067      	b.n	8025266 <Homing+0x2fa>
				else if(CloseSensor)
 8025196:	4b21      	ldr	r3, [pc, #132]	; (802521c <Homing+0x2b0>)
 8025198:	681b      	ldr	r3, [r3, #0]
 802519a:	2b00      	cmp	r3, #0
 802519c:	d063      	beq.n	8025266 <Homing+0x2fa>
					WriteClutch(CLUTCH_LOCK);
 802519e:	2000      	movs	r0, #0
 80251a0:	f7fe f920 	bl	80233e4 <WriteClutch>
				break;
 80251a4:	e05f      	b.n	8025266 <Homing+0x2fa>

			case 4:
			{
				WriteClutch(CLUTCH_LOCK);
 80251a6:	2000      	movs	r0, #0
 80251a8:	f7fe f91c 	bl	80233e4 <WriteClutch>
				pause++;
 80251ac:	4b18      	ldr	r3, [pc, #96]	; (8025210 <Homing+0x2a4>)
 80251ae:	681b      	ldr	r3, [r3, #0]
 80251b0:	3301      	adds	r3, #1
 80251b2:	4a17      	ldr	r2, [pc, #92]	; (8025210 <Homing+0x2a4>)
 80251b4:	6013      	str	r3, [r2, #0]

				if (pause >= 20)//Presets.HOMING_CLUTCH_LOCK_PAUSE)
 80251b6:	4b16      	ldr	r3, [pc, #88]	; (8025210 <Homing+0x2a4>)
 80251b8:	681b      	ldr	r3, [r3, #0]
 80251ba:	2b13      	cmp	r3, #19
 80251bc:	dd21      	ble.n	8025202 <Homing+0x296>
				{
					//MotorStop();
					drive.RAWPosition = 0;
 80251be:	4b15      	ldr	r3, [pc, #84]	; (8025214 <Homing+0x2a8>)
 80251c0:	2200      	movs	r2, #0
 80251c2:	609a      	str	r2, [r3, #8]
					MotorSetPILimit(5);
 80251c4:	2005      	movs	r0, #5
 80251c6:	f7fd fd68 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(100);
 80251ca:	2064      	movs	r0, #100	; 0x64
 80251cc:	f7fd fd4b 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(1);
 80251d0:	2001      	movs	r0, #1
 80251d2:	f7fd fd55 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 5);
 80251d6:	4b10      	ldr	r3, [pc, #64]	; (8025218 <Homing+0x2ac>)
 80251d8:	681a      	ldr	r2, [r3, #0]
 80251da:	4613      	mov	r3, r2
 80251dc:	009b      	lsls	r3, r3, #2
 80251de:	4413      	add	r3, r2
 80251e0:	4618      	mov	r0, r3
 80251e2:	f7fd fd35 	bl	8022c50 <MotorSetSpeed>
					result = 0; // success
 80251e6:	2300      	movs	r3, #0
 80251e8:	60fb      	str	r3, [r7, #12]
					pause = 0;
 80251ea:	4b09      	ldr	r3, [pc, #36]	; (8025210 <Homing+0x2a4>)
 80251ec:	2200      	movs	r2, #0
 80251ee:	601a      	str	r2, [r3, #0]
					tim = 0;
 80251f0:	4b05      	ldr	r3, [pc, #20]	; (8025208 <Homing+0x29c>)
 80251f2:	2200      	movs	r2, #0
 80251f4:	601a      	str	r2, [r3, #0]
					state++;
 80251f6:	4b05      	ldr	r3, [pc, #20]	; (802520c <Homing+0x2a0>)
 80251f8:	681b      	ldr	r3, [r3, #0]
 80251fa:	3301      	adds	r3, #1
 80251fc:	4a03      	ldr	r2, [pc, #12]	; (802520c <Homing+0x2a0>)
 80251fe:	6013      	str	r3, [r2, #0]
				else
				{
					result = 0;
				}
			}
				break;
 8025200:	e032      	b.n	8025268 <Homing+0x2fc>
					result = 0;
 8025202:	2300      	movs	r3, #0
 8025204:	60fb      	str	r3, [r7, #12]
				break;
 8025206:	e02f      	b.n	8025268 <Homing+0x2fc>
 8025208:	20000734 	.word	0x20000734
 802520c:	20000738 	.word	0x20000738
 8025210:	2000073c 	.word	0x2000073c
 8025214:	20000600 	.word	0x20000600
 8025218:	20000770 	.word	0x20000770
 802521c:	2000062c 	.word	0x2000062c
 8025220:	20000fd0 	.word	0x20000fd0
 8025224:	20000628 	.word	0x20000628
 8025228:	20000704 	.word	0x20000704
			case 5:
			{
				pause ++;
 802522c:	4b11      	ldr	r3, [pc, #68]	; (8025274 <Homing+0x308>)
 802522e:	681b      	ldr	r3, [r3, #0]
 8025230:	3301      	adds	r3, #1
 8025232:	4a10      	ldr	r2, [pc, #64]	; (8025274 <Homing+0x308>)
 8025234:	6013      	str	r3, [r2, #0]
				if (5 <= pause)
 8025236:	4b0f      	ldr	r3, [pc, #60]	; (8025274 <Homing+0x308>)
 8025238:	681b      	ldr	r3, [r3, #0]
 802523a:	2b04      	cmp	r3, #4
 802523c:	dd0b      	ble.n	8025256 <Homing+0x2ea>
				{
					pause = 0;
 802523e:	4b0d      	ldr	r3, [pc, #52]	; (8025274 <Homing+0x308>)
 8025240:	2200      	movs	r2, #0
 8025242:	601a      	str	r2, [r3, #0]
					result = 1;
 8025244:	2301      	movs	r3, #1
 8025246:	60fb      	str	r3, [r7, #12]
					//drive.RAWPosition = 0;
					tim = 0;
 8025248:	4b0b      	ldr	r3, [pc, #44]	; (8025278 <Homing+0x30c>)
 802524a:	2200      	movs	r2, #0
 802524c:	601a      	str	r2, [r3, #0]
					state = 0;
 802524e:	4b0b      	ldr	r3, [pc, #44]	; (802527c <Homing+0x310>)
 8025250:	2200      	movs	r2, #0
 8025252:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
			break;
 8025254:	e008      	b.n	8025268 <Homing+0x2fc>
					result = 0;
 8025256:	2300      	movs	r3, #0
 8025258:	60fb      	str	r3, [r7, #12]
			break;
 802525a:	e005      	b.n	8025268 <Homing+0x2fc>
			default:
				return -3; // bad case;
 802525c:	f06f 0302 	mvn.w	r3, #2
 8025260:	e003      	b.n	802526a <Homing+0x2fe>
		break;
 8025262:	bf00      	nop
 8025264:	e000      	b.n	8025268 <Homing+0x2fc>
				break;
 8025266:	bf00      	nop

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025268:	68fb      	ldr	r3, [r7, #12]
}
 802526a:	4618      	mov	r0, r3
 802526c:	3710      	adds	r7, #16
 802526e:	46bd      	mov	sp, r7
 8025270:	bd80      	pop	{r7, pc}
 8025272:	bf00      	nop
 8025274:	2000073c 	.word	0x2000073c
 8025278:	20000734 	.word	0x20000734
 802527c:	20000738 	.word	0x20000738

08025280 <CloseDoor>:


int32_t CloseDoor(int32_t cmd)
{
 8025280:	b580      	push	{r7, lr}
 8025282:	b084      	sub	sp, #16
 8025284:	af00      	add	r7, sp, #0
 8025286:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8025288:	2300      	movs	r3, #0
 802528a:	60fb      	str	r3, [r7, #12]
	static int32_t state = 0;
	static int32_t pause = 0;
	static int32_t tim = 0;


	tim++;
 802528c:	4b9e      	ldr	r3, [pc, #632]	; (8025508 <CloseDoor+0x288>)
 802528e:	681b      	ldr	r3, [r3, #0]
 8025290:	3301      	adds	r3, #1
 8025292:	4a9d      	ldr	r2, [pc, #628]	; (8025508 <CloseDoor+0x288>)
 8025294:	6013      	str	r3, [r2, #0]

	if(tim >= 1000)
 8025296:	4b9c      	ldr	r3, [pc, #624]	; (8025508 <CloseDoor+0x288>)
 8025298:	681b      	ldr	r3, [r3, #0]
 802529a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 802529e:	db0d      	blt.n	80252bc <CloseDoor+0x3c>
	{
		MotorStop();
 80252a0:	f7fd fcd0 	bl	8022c44 <MotorStop>
		state = 0;
 80252a4:	4b99      	ldr	r3, [pc, #612]	; (802550c <CloseDoor+0x28c>)
 80252a6:	2200      	movs	r2, #0
 80252a8:	601a      	str	r2, [r3, #0]
		tim = 0;
 80252aa:	4b97      	ldr	r3, [pc, #604]	; (8025508 <CloseDoor+0x288>)
 80252ac:	2200      	movs	r2, #0
 80252ae:	601a      	str	r2, [r3, #0]
		pause = 0;
 80252b0:	4b97      	ldr	r3, [pc, #604]	; (8025510 <CloseDoor+0x290>)
 80252b2:	2200      	movs	r2, #0
 80252b4:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 80252b6:	f04f 33ff 	mov.w	r3, #4294967295
 80252ba:	e121      	b.n	8025500 <CloseDoor+0x280>
	}
	if (drive.Current >= 1500)
 80252bc:	4b95      	ldr	r3, [pc, #596]	; (8025514 <CloseDoor+0x294>)
 80252be:	885b      	ldrh	r3, [r3, #2]
 80252c0:	f240 52db 	movw	r2, #1499	; 0x5db
 80252c4:	4293      	cmp	r3, r2
 80252c6:	d90d      	bls.n	80252e4 <CloseDoor+0x64>
	{
		MotorStop();
 80252c8:	f7fd fcbc 	bl	8022c44 <MotorStop>
		state = 0;
 80252cc:	4b8f      	ldr	r3, [pc, #572]	; (802550c <CloseDoor+0x28c>)
 80252ce:	2200      	movs	r2, #0
 80252d0:	601a      	str	r2, [r3, #0]
		tim = 0;
 80252d2:	4b8d      	ldr	r3, [pc, #564]	; (8025508 <CloseDoor+0x288>)
 80252d4:	2200      	movs	r2, #0
 80252d6:	601a      	str	r2, [r3, #0]
		pause = 0;
 80252d8:	4b8d      	ldr	r3, [pc, #564]	; (8025510 <CloseDoor+0x290>)
 80252da:	2200      	movs	r2, #0
 80252dc:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 80252de:	f06f 0301 	mvn.w	r3, #1
 80252e2:	e10d      	b.n	8025500 <CloseDoor+0x280>
	}


	if(!cmd)
 80252e4:	687b      	ldr	r3, [r7, #4]
 80252e6:	2b00      	cmp	r3, #0
 80252e8:	d10c      	bne.n	8025304 <CloseDoor+0x84>
	{
		MotorStop();
 80252ea:	f7fd fcab 	bl	8022c44 <MotorStop>
		state = 0;
 80252ee:	4b87      	ldr	r3, [pc, #540]	; (802550c <CloseDoor+0x28c>)
 80252f0:	2200      	movs	r2, #0
 80252f2:	601a      	str	r2, [r3, #0]
		tim = 0;
 80252f4:	4b84      	ldr	r3, [pc, #528]	; (8025508 <CloseDoor+0x288>)
 80252f6:	2200      	movs	r2, #0
 80252f8:	601a      	str	r2, [r3, #0]
		pause = 0;
 80252fa:	4b85      	ldr	r3, [pc, #532]	; (8025510 <CloseDoor+0x290>)
 80252fc:	2200      	movs	r2, #0
 80252fe:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8025300:	2300      	movs	r3, #0
 8025302:	e0fd      	b.n	8025500 <CloseDoor+0x280>
	}
	else
	{
		switch (state)
 8025304:	4b81      	ldr	r3, [pc, #516]	; (802550c <CloseDoor+0x28c>)
 8025306:	681b      	ldr	r3, [r3, #0]
 8025308:	2b02      	cmp	r3, #2
 802530a:	f000 80c9 	beq.w	80254a0 <CloseDoor+0x220>
 802530e:	2b02      	cmp	r3, #2
 8025310:	f300 80f2 	bgt.w	80254f8 <CloseDoor+0x278>
 8025314:	2b00      	cmp	r3, #0
 8025316:	d002      	beq.n	802531e <CloseDoor+0x9e>
 8025318:	2b01      	cmp	r3, #1
 802531a:	d02a      	beq.n	8025372 <CloseDoor+0xf2>
 802531c:	e0ec      	b.n	80254f8 <CloseDoor+0x278>
		{
			case 0:
			{
				WriteClutch(CLUTCH_UNLOCK);
 802531e:	2001      	movs	r0, #1
 8025320:	f7fe f860 	bl	80233e4 <WriteClutch>
				pause++;
 8025324:	4b7a      	ldr	r3, [pc, #488]	; (8025510 <CloseDoor+0x290>)
 8025326:	681b      	ldr	r3, [r3, #0]
 8025328:	3301      	adds	r3, #1
 802532a:	4a79      	ldr	r2, [pc, #484]	; (8025510 <CloseDoor+0x290>)
 802532c:	6013      	str	r3, [r2, #0]

				if(pause >= 20)
 802532e:	4b78      	ldr	r3, [pc, #480]	; (8025510 <CloseDoor+0x290>)
 8025330:	681b      	ldr	r3, [r3, #0]
 8025332:	2b13      	cmp	r3, #19
 8025334:	dd1a      	ble.n	802536c <CloseDoor+0xec>
				{
					pause = 0;
 8025336:	4b76      	ldr	r3, [pc, #472]	; (8025510 <CloseDoor+0x290>)
 8025338:	2200      	movs	r2, #0
 802533a:	601a      	str	r2, [r3, #0]
					state = 1;
 802533c:	4b73      	ldr	r3, [pc, #460]	; (802550c <CloseDoor+0x28c>)
 802533e:	2201      	movs	r2, #1
 8025340:	601a      	str	r2, [r3, #0]
					MotorSetPILimit(95);
 8025342:	205f      	movs	r0, #95	; 0x5f
 8025344:	f7fd fca9 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(1000);
 8025348:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802534c:	f7fd fc8b 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025350:	200a      	movs	r0, #10
 8025352:	f7fd fc95 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 1200);
 8025356:	4b70      	ldr	r3, [pc, #448]	; (8025518 <CloseDoor+0x298>)
 8025358:	681b      	ldr	r3, [r3, #0]
 802535a:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802535e:	fb02 f303 	mul.w	r3, r2, r3
 8025362:	4618      	mov	r0, r3
 8025364:	f7fd fc74 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025368:	f7fd fc66 	bl	8022c38 <MotorStart>
				}
				result = 0;
 802536c:	2300      	movs	r3, #0
 802536e:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025370:	e0c5      	b.n	80254fe <CloseDoor+0x27e>
					Motor0_BLDC_SCALAR_SetSpeedVal(Presets.CLOSE_DIR * 600);
					Motor0_BLDC_SCALAR_MotorStart();
					result = 0;
				}
*/
				if((drive.Position <= 570) && (drive.Position > 150))
 8025372:	4b68      	ldr	r3, [pc, #416]	; (8025514 <CloseDoor+0x294>)
 8025374:	881b      	ldrh	r3, [r3, #0]
 8025376:	f240 223a 	movw	r2, #570	; 0x23a
 802537a:	4293      	cmp	r3, r2
 802537c:	d810      	bhi.n	80253a0 <CloseDoor+0x120>
 802537e:	4b65      	ldr	r3, [pc, #404]	; (8025514 <CloseDoor+0x294>)
 8025380:	881b      	ldrh	r3, [r3, #0]
 8025382:	2b96      	cmp	r3, #150	; 0x96
 8025384:	d90c      	bls.n	80253a0 <CloseDoor+0x120>
				{
					MotorSetSpeed(Presets.CLOSE_DIR * 300);
 8025386:	4b64      	ldr	r3, [pc, #400]	; (8025518 <CloseDoor+0x298>)
 8025388:	681b      	ldr	r3, [r3, #0]
 802538a:	f44f 7296 	mov.w	r2, #300	; 0x12c
 802538e:	fb02 f303 	mul.w	r3, r2, r3
 8025392:	4618      	mov	r0, r3
 8025394:	f7fd fc5c 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025398:	f7fd fc4e 	bl	8022c38 <MotorStart>
					result = 0;
 802539c:	2300      	movs	r3, #0
 802539e:	60fb      	str	r3, [r7, #12]
					else
					{
						result = 0;
					}*/
				}
				if((drive.Position <= 150) && (drive.Position > 20))
 80253a0:	4b5c      	ldr	r3, [pc, #368]	; (8025514 <CloseDoor+0x294>)
 80253a2:	881b      	ldrh	r3, [r3, #0]
 80253a4:	2b96      	cmp	r3, #150	; 0x96
 80253a6:	d819      	bhi.n	80253dc <CloseDoor+0x15c>
 80253a8:	4b5a      	ldr	r3, [pc, #360]	; (8025514 <CloseDoor+0x294>)
 80253aa:	881b      	ldrh	r3, [r3, #0]
 80253ac:	2b14      	cmp	r3, #20
 80253ae:	d915      	bls.n	80253dc <CloseDoor+0x15c>
				{
					MotorSetProportionalGain(500);
 80253b0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80253b4:	f7fd fc57 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(5);
 80253b8:	2005      	movs	r0, #5
 80253ba:	f7fd fc61 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 150);
 80253be:	4b56      	ldr	r3, [pc, #344]	; (8025518 <CloseDoor+0x298>)
 80253c0:	681b      	ldr	r3, [r3, #0]
 80253c2:	2296      	movs	r2, #150	; 0x96
 80253c4:	fb02 f303 	mul.w	r3, r2, r3
 80253c8:	4618      	mov	r0, r3
 80253ca:	f7fd fc41 	bl	8022c50 <MotorSetSpeed>
					MotorSetPILimit(90);
 80253ce:	205a      	movs	r0, #90	; 0x5a
 80253d0:	f7fd fc63 	bl	8022c9a <MotorSetPILimit>
					MotorStart();
 80253d4:	f7fd fc30 	bl	8022c38 <MotorStart>
					result = 0;
 80253d8:	2300      	movs	r3, #0
 80253da:	60fb      	str	r3, [r7, #12]
						result = 0;
					}
					*/
				}
// blockge condition
				if(ActiveRubberL || ((drive.Current >= 1500) && (drive.Position >= (Presets.OPEN_POSITION - 400))) || ((drive.Position <= (200)) && (drive.Current >= 600)) || ((drive.Position < (Presets.OPEN_POSITION - 400)) && (drive.Position > 200)  && (drive.Current >= 1100)) )
 80253dc:	4b4f      	ldr	r3, [pc, #316]	; (802551c <CloseDoor+0x29c>)
 80253de:	681b      	ldr	r3, [r3, #0]
 80253e0:	2b00      	cmp	r3, #0
 80253e2:	d12a      	bne.n	802543a <CloseDoor+0x1ba>
 80253e4:	4b4b      	ldr	r3, [pc, #300]	; (8025514 <CloseDoor+0x294>)
 80253e6:	885b      	ldrh	r3, [r3, #2]
 80253e8:	f240 52db 	movw	r2, #1499	; 0x5db
 80253ec:	4293      	cmp	r3, r2
 80253ee:	d908      	bls.n	8025402 <CloseDoor+0x182>
 80253f0:	4b48      	ldr	r3, [pc, #288]	; (8025514 <CloseDoor+0x294>)
 80253f2:	881b      	ldrh	r3, [r3, #0]
 80253f4:	461a      	mov	r2, r3
 80253f6:	4b48      	ldr	r3, [pc, #288]	; (8025518 <CloseDoor+0x298>)
 80253f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80253fa:	f5a3 73c8 	sub.w	r3, r3, #400	; 0x190
 80253fe:	429a      	cmp	r2, r3
 8025400:	d21b      	bcs.n	802543a <CloseDoor+0x1ba>
 8025402:	4b44      	ldr	r3, [pc, #272]	; (8025514 <CloseDoor+0x294>)
 8025404:	881b      	ldrh	r3, [r3, #0]
 8025406:	2bc8      	cmp	r3, #200	; 0xc8
 8025408:	d804      	bhi.n	8025414 <CloseDoor+0x194>
 802540a:	4b42      	ldr	r3, [pc, #264]	; (8025514 <CloseDoor+0x294>)
 802540c:	885b      	ldrh	r3, [r3, #2]
 802540e:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8025412:	d212      	bcs.n	802543a <CloseDoor+0x1ba>
 8025414:	4b3f      	ldr	r3, [pc, #252]	; (8025514 <CloseDoor+0x294>)
 8025416:	881b      	ldrh	r3, [r3, #0]
 8025418:	461a      	mov	r2, r3
 802541a:	4b3f      	ldr	r3, [pc, #252]	; (8025518 <CloseDoor+0x298>)
 802541c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802541e:	f5a3 73c8 	sub.w	r3, r3, #400	; 0x190
 8025422:	429a      	cmp	r2, r3
 8025424:	d212      	bcs.n	802544c <CloseDoor+0x1cc>
 8025426:	4b3b      	ldr	r3, [pc, #236]	; (8025514 <CloseDoor+0x294>)
 8025428:	881b      	ldrh	r3, [r3, #0]
 802542a:	2bc8      	cmp	r3, #200	; 0xc8
 802542c:	d90e      	bls.n	802544c <CloseDoor+0x1cc>
 802542e:	4b39      	ldr	r3, [pc, #228]	; (8025514 <CloseDoor+0x294>)
 8025430:	885b      	ldrh	r3, [r3, #2]
 8025432:	f240 424b 	movw	r2, #1099	; 0x44b
 8025436:	4293      	cmp	r3, r2
 8025438:	d908      	bls.n	802544c <CloseDoor+0x1cc>
				{
					WriteClutch(CLUTCH_UNLOCK);
 802543a:	2001      	movs	r0, #1
 802543c:	f7fd ffd2 	bl	80233e4 <WriteClutch>
					MotorStop();
 8025440:	f7fd fc00 	bl	8022c44 <MotorStop>
					result = -4;
 8025444:	f06f 0303 	mvn.w	r3, #3
 8025448:	60fb      	str	r3, [r7, #12]
 802544a:	e001      	b.n	8025450 <CloseDoor+0x1d0>
				}
				else
				{
					result = 0;
 802544c:	2300      	movs	r3, #0
 802544e:	60fb      	str	r3, [r7, #12]
					WriteClutch(CLUTCH_LOCK);
					result = 0;
				}
*/
// closed successful
				if((/*(drive.Current > 400) && */(drive.Position <= 2)))// || ((CloseSensor) && (drive.Current >= 600)))//
 8025450:	4b30      	ldr	r3, [pc, #192]	; (8025514 <CloseDoor+0x294>)
 8025452:	881b      	ldrh	r3, [r3, #0]
 8025454:	2b02      	cmp	r3, #2
 8025456:	d81f      	bhi.n	8025498 <CloseDoor+0x218>
				{
					WriteClutch(CLUTCH_LOCK);
 8025458:	2000      	movs	r0, #0
 802545a:	f7fd ffc3 	bl	80233e4 <WriteClutch>
					MotorSetProportionalGain(100);
 802545e:	2064      	movs	r0, #100	; 0x64
 8025460:	f7fd fc01 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(1);
 8025464:	2001      	movs	r0, #1
 8025466:	f7fd fc0b 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 20);
 802546a:	4b2b      	ldr	r3, [pc, #172]	; (8025518 <CloseDoor+0x298>)
 802546c:	681a      	ldr	r2, [r3, #0]
 802546e:	4613      	mov	r3, r2
 8025470:	009b      	lsls	r3, r3, #2
 8025472:	4413      	add	r3, r2
 8025474:	009b      	lsls	r3, r3, #2
 8025476:	4618      	mov	r0, r3
 8025478:	f7fd fbea 	bl	8022c50 <MotorSetSpeed>
					MotorSetPILimit(5);
 802547c:	2005      	movs	r0, #5
 802547e:	f7fd fc0c 	bl	8022c9a <MotorSetPILimit>
					MotorStart();
 8025482:	f7fd fbd9 	bl	8022c38 <MotorStart>
					state = 2;
 8025486:	4b21      	ldr	r3, [pc, #132]	; (802550c <CloseDoor+0x28c>)
 8025488:	2202      	movs	r2, #2
 802548a:	601a      	str	r2, [r3, #0]
					result = 0;
 802548c:	2300      	movs	r3, #0
 802548e:	60fb      	str	r3, [r7, #12]
					pause = 0;
 8025490:	4b1f      	ldr	r3, [pc, #124]	; (8025510 <CloseDoor+0x290>)
 8025492:	2200      	movs	r2, #0
 8025494:	601a      	str	r2, [r3, #0]
				//{
				//	result = -4;
				//	Motor0_BLDC_SCALAR_MotorStop();
				//}
			}
				break;
 8025496:	e032      	b.n	80254fe <CloseDoor+0x27e>
					WriteClutch(CLUTCH_UNLOCK);
 8025498:	2001      	movs	r0, #1
 802549a:	f7fd ffa3 	bl	80233e4 <WriteClutch>
				break;
 802549e:	e02e      	b.n	80254fe <CloseDoor+0x27e>

			case 2:
			{
				WriteClutch(CLUTCH_LOCK);
 80254a0:	2000      	movs	r0, #0
 80254a2:	f7fd ff9f 	bl	80233e4 <WriteClutch>
				pause++;
 80254a6:	4b1a      	ldr	r3, [pc, #104]	; (8025510 <CloseDoor+0x290>)
 80254a8:	681b      	ldr	r3, [r3, #0]
 80254aa:	3301      	adds	r3, #1
 80254ac:	4a18      	ldr	r2, [pc, #96]	; (8025510 <CloseDoor+0x290>)
 80254ae:	6013      	str	r3, [r2, #0]
				if (pause >= 20)//Presets.CLOSING_CLUTCH_LOCK_PAUSE)
 80254b0:	4b17      	ldr	r3, [pc, #92]	; (8025510 <CloseDoor+0x290>)
 80254b2:	681b      	ldr	r3, [r3, #0]
 80254b4:	2b13      	cmp	r3, #19
 80254b6:	dd1c      	ble.n	80254f2 <CloseDoor+0x272>
				{
					{
						//MotorStop();
						MotorSetPILimit(10);
 80254b8:	200a      	movs	r0, #10
 80254ba:	f7fd fbee 	bl	8022c9a <MotorSetPILimit>
						MotorSetProportionalGain(100);
 80254be:	2064      	movs	r0, #100	; 0x64
 80254c0:	f7fd fbd1 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(1);
 80254c4:	2001      	movs	r0, #1
 80254c6:	f7fd fbdb 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(Presets.CLOSE_DIR * 5);
 80254ca:	4b13      	ldr	r3, [pc, #76]	; (8025518 <CloseDoor+0x298>)
 80254cc:	681a      	ldr	r2, [r3, #0]
 80254ce:	4613      	mov	r3, r2
 80254d0:	009b      	lsls	r3, r3, #2
 80254d2:	4413      	add	r3, r2
 80254d4:	4618      	mov	r0, r3
 80254d6:	f7fd fbbb 	bl	8022c50 <MotorSetSpeed>
						state = 0;
 80254da:	4b0c      	ldr	r3, [pc, #48]	; (802550c <CloseDoor+0x28c>)
 80254dc:	2200      	movs	r2, #0
 80254de:	601a      	str	r2, [r3, #0]
						pause = 0;
 80254e0:	4b0b      	ldr	r3, [pc, #44]	; (8025510 <CloseDoor+0x290>)
 80254e2:	2200      	movs	r2, #0
 80254e4:	601a      	str	r2, [r3, #0]
						result = 1;
 80254e6:	2301      	movs	r3, #1
 80254e8:	60fb      	str	r3, [r7, #12]
						tim = 0;
 80254ea:	4b07      	ldr	r3, [pc, #28]	; (8025508 <CloseDoor+0x288>)
 80254ec:	2200      	movs	r2, #0
 80254ee:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
				break;
 80254f0:	e005      	b.n	80254fe <CloseDoor+0x27e>
					result = 0;
 80254f2:	2300      	movs	r3, #0
 80254f4:	60fb      	str	r3, [r7, #12]
				break;
 80254f6:	e002      	b.n	80254fe <CloseDoor+0x27e>
			default:
				return -3; // bad case;
 80254f8:	f06f 0302 	mvn.w	r3, #2
 80254fc:	e000      	b.n	8025500 <CloseDoor+0x280>

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 80254fe:	68fb      	ldr	r3, [r7, #12]
}
 8025500:	4618      	mov	r0, r3
 8025502:	3710      	adds	r7, #16
 8025504:	46bd      	mov	sp, r7
 8025506:	bd80      	pop	{r7, pc}
 8025508:	20000740 	.word	0x20000740
 802550c:	20000744 	.word	0x20000744
 8025510:	20000748 	.word	0x20000748
 8025514:	20000600 	.word	0x20000600
 8025518:	20000770 	.word	0x20000770
 802551c:	20000628 	.word	0x20000628

08025520 <OpenDoor>:



int32_t OpenDoor (int32_t cmd)
{
 8025520:	b580      	push	{r7, lr}
 8025522:	b084      	sub	sp, #16
 8025524:	af00      	add	r7, sp, #0
 8025526:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8025528:	2300      	movs	r3, #0
 802552a:	60fb      	str	r3, [r7, #12]
	static int32_t pause = 0;
	static int32_t tim = 0;

	//static int32_t first_opening_done = 0;

	tim++;
 802552c:	4ba1      	ldr	r3, [pc, #644]	; (80257b4 <OpenDoor+0x294>)
 802552e:	681b      	ldr	r3, [r3, #0]
 8025530:	3301      	adds	r3, #1
 8025532:	4aa0      	ldr	r2, [pc, #640]	; (80257b4 <OpenDoor+0x294>)
 8025534:	6013      	str	r3, [r2, #0]


	if(tim >= 2000)
 8025536:	4b9f      	ldr	r3, [pc, #636]	; (80257b4 <OpenDoor+0x294>)
 8025538:	681b      	ldr	r3, [r3, #0]
 802553a:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 802553e:	db0d      	blt.n	802555c <OpenDoor+0x3c>
	{
		MotorStop();
 8025540:	f7fd fb80 	bl	8022c44 <MotorStop>
		state = 0;
 8025544:	4b9c      	ldr	r3, [pc, #624]	; (80257b8 <OpenDoor+0x298>)
 8025546:	2200      	movs	r2, #0
 8025548:	601a      	str	r2, [r3, #0]
		tim = 0;
 802554a:	4b9a      	ldr	r3, [pc, #616]	; (80257b4 <OpenDoor+0x294>)
 802554c:	2200      	movs	r2, #0
 802554e:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025550:	4b9a      	ldr	r3, [pc, #616]	; (80257bc <OpenDoor+0x29c>)
 8025552:	2200      	movs	r2, #0
 8025554:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 8025556:	f04f 33ff 	mov.w	r3, #4294967295
 802555a:	e206      	b.n	802596a <OpenDoor+0x44a>
	}
	if (drive.Current >= 2100)
 802555c:	4b98      	ldr	r3, [pc, #608]	; (80257c0 <OpenDoor+0x2a0>)
 802555e:	885b      	ldrh	r3, [r3, #2]
 8025560:	f640 0233 	movw	r2, #2099	; 0x833
 8025564:	4293      	cmp	r3, r2
 8025566:	d90d      	bls.n	8025584 <OpenDoor+0x64>
	{
		MotorStop();
 8025568:	f7fd fb6c 	bl	8022c44 <MotorStop>
		state = 0;
 802556c:	4b92      	ldr	r3, [pc, #584]	; (80257b8 <OpenDoor+0x298>)
 802556e:	2200      	movs	r2, #0
 8025570:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025572:	4b90      	ldr	r3, [pc, #576]	; (80257b4 <OpenDoor+0x294>)
 8025574:	2200      	movs	r2, #0
 8025576:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025578:	4b90      	ldr	r3, [pc, #576]	; (80257bc <OpenDoor+0x29c>)
 802557a:	2200      	movs	r2, #0
 802557c:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 802557e:	f06f 0301 	mvn.w	r3, #1
 8025582:	e1f2      	b.n	802596a <OpenDoor+0x44a>
	}


	if(!cmd)
 8025584:	687b      	ldr	r3, [r7, #4]
 8025586:	2b00      	cmp	r3, #0
 8025588:	d10c      	bne.n	80255a4 <OpenDoor+0x84>
	{
		MotorStop();
 802558a:	f7fd fb5b 	bl	8022c44 <MotorStop>
		state = 0;
 802558e:	4b8a      	ldr	r3, [pc, #552]	; (80257b8 <OpenDoor+0x298>)
 8025590:	2200      	movs	r2, #0
 8025592:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025594:	4b89      	ldr	r3, [pc, #548]	; (80257bc <OpenDoor+0x29c>)
 8025596:	2200      	movs	r2, #0
 8025598:	601a      	str	r2, [r3, #0]
		tim = 0;
 802559a:	4b86      	ldr	r3, [pc, #536]	; (80257b4 <OpenDoor+0x294>)
 802559c:	2200      	movs	r2, #0
 802559e:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 80255a0:	2300      	movs	r3, #0
 80255a2:	e1e2      	b.n	802596a <OpenDoor+0x44a>
	}
	else
	{
		switch (state)
 80255a4:	4b84      	ldr	r3, [pc, #528]	; (80257b8 <OpenDoor+0x298>)
 80255a6:	681b      	ldr	r3, [r3, #0]
 80255a8:	2b04      	cmp	r3, #4
 80255aa:	f200 81da 	bhi.w	8025962 <OpenDoor+0x442>
 80255ae:	a201      	add	r2, pc, #4	; (adr r2, 80255b4 <OpenDoor+0x94>)
 80255b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80255b4:	080255c9 	.word	0x080255c9
 80255b8:	0802566f 	.word	0x0802566f
 80255bc:	080258c3 	.word	0x080258c3
 80255c0:	080258eb 	.word	0x080258eb
 80255c4:	0802591f 	.word	0x0802591f
		{
			case 0:
			{
				WriteClutch(CLUTCH_UNLOCK);
 80255c8:	2001      	movs	r0, #1
 80255ca:	f7fd ff0b 	bl	80233e4 <WriteClutch>
				pause++;
 80255ce:	4b7b      	ldr	r3, [pc, #492]	; (80257bc <OpenDoor+0x29c>)
 80255d0:	681b      	ldr	r3, [r3, #0]
 80255d2:	3301      	adds	r3, #1
 80255d4:	4a79      	ldr	r2, [pc, #484]	; (80257bc <OpenDoor+0x29c>)
 80255d6:	6013      	str	r3, [r2, #0]

				if(pause <= 10)
 80255d8:	4b78      	ldr	r3, [pc, #480]	; (80257bc <OpenDoor+0x29c>)
 80255da:	681b      	ldr	r3, [r3, #0]
 80255dc:	2b0a      	cmp	r3, #10
 80255de:	dc01      	bgt.n	80255e4 <OpenDoor+0xc4>
				{
					MotorStop();
 80255e0:	f7fd fb30 	bl	8022c44 <MotorStop>
//					{
//						Motor0_BLDC_SCALAR_MotorStop();
//					}
//				}

				if((pause > 10) && (pause <= 20))
 80255e4:	4b75      	ldr	r3, [pc, #468]	; (80257bc <OpenDoor+0x29c>)
 80255e6:	681b      	ldr	r3, [r3, #0]
 80255e8:	2b0a      	cmp	r3, #10
 80255ea:	dd19      	ble.n	8025620 <OpenDoor+0x100>
 80255ec:	4b73      	ldr	r3, [pc, #460]	; (80257bc <OpenDoor+0x29c>)
 80255ee:	681b      	ldr	r3, [r3, #0]
 80255f0:	2b14      	cmp	r3, #20
 80255f2:	dc15      	bgt.n	8025620 <OpenDoor+0x100>
				{
					MotorSetPILimit(60);
 80255f4:	203c      	movs	r0, #60	; 0x3c
 80255f6:	f7fd fb50 	bl	8022c9a <MotorSetPILimit>
					MotorClearError();
 80255fa:	f7fd fb5b 	bl	8022cb4 <MotorClearError>
					MotorSetProportionalGain(1000);
 80255fe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8025602:	f7fd fb30 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025606:	200a      	movs	r0, #10
 8025608:	f7fd fb3a 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 5);
 802560c:	4b6d      	ldr	r3, [pc, #436]	; (80257c4 <OpenDoor+0x2a4>)
 802560e:	681a      	ldr	r2, [r3, #0]
 8025610:	4613      	mov	r3, r2
 8025612:	009b      	lsls	r3, r3, #2
 8025614:	4413      	add	r3, r2
 8025616:	4618      	mov	r0, r3
 8025618:	f7fd fb1a 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 802561c:	f7fd fb0c 	bl	8022c38 <MotorStart>

				}
//
				if(pause > 20)
 8025620:	4b66      	ldr	r3, [pc, #408]	; (80257bc <OpenDoor+0x29c>)
 8025622:	681b      	ldr	r3, [r3, #0]
 8025624:	2b14      	cmp	r3, #20
 8025626:	dd1f      	ble.n	8025668 <OpenDoor+0x148>
				{
					MotorSetPILimit(40);
 8025628:	2028      	movs	r0, #40	; 0x28
 802562a:	f7fd fb36 	bl	8022c9a <MotorSetPILimit>
					MotorClearError();
 802562e:	f7fd fb41 	bl	8022cb4 <MotorClearError>
					MotorSetProportionalGain(1000);
 8025632:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8025636:	f7fd fb16 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 802563a:	200a      	movs	r0, #10
 802563c:	f7fd fb20 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 300);
 8025640:	4b61      	ldr	r3, [pc, #388]	; (80257c8 <OpenDoor+0x2a8>)
 8025642:	681b      	ldr	r3, [r3, #0]
 8025644:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8025648:	fb02 f303 	mul.w	r3, r2, r3
 802564c:	4618      	mov	r0, r3
 802564e:	f7fd faff 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025652:	f7fd faf1 	bl	8022c38 <MotorStart>
					state  = 1;
 8025656:	4b58      	ldr	r3, [pc, #352]	; (80257b8 <OpenDoor+0x298>)
 8025658:	2201      	movs	r2, #1
 802565a:	601a      	str	r2, [r3, #0]
					pause = 0;
 802565c:	4b57      	ldr	r3, [pc, #348]	; (80257bc <OpenDoor+0x29c>)
 802565e:	2200      	movs	r2, #0
 8025660:	601a      	str	r2, [r3, #0]
					WriteClutch(CLUTCH_UNLOCK);
 8025662:	2001      	movs	r0, #1
 8025664:	f7fd febe 	bl	80233e4 <WriteClutch>
					state = 1;
					pause = 0;
					WriteClutch(CLUTCH_UNLOCK);
				}
*/
				result = 0;
 8025668:	2300      	movs	r3, #0
 802566a:	60fb      	str	r3, [r7, #12]
			}
				break;
 802566c:	e17c      	b.n	8025968 <OpenDoor+0x448>

			case 1:
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_R);
				if((Presets.OPEN_POSITION != 0x0))
 802566e:	4b55      	ldr	r3, [pc, #340]	; (80257c4 <OpenDoor+0x2a4>)
 8025670:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025672:	2b00      	cmp	r3, #0
 8025674:	f000 80aa 	beq.w	80257cc <OpenDoor+0x2ac>
				{
						if((drive.Position >= (100)) && (drive.Position < (Presets.OPEN_POSITION - 250)))
 8025678:	4b51      	ldr	r3, [pc, #324]	; (80257c0 <OpenDoor+0x2a0>)
 802567a:	881b      	ldrh	r3, [r3, #0]
 802567c:	2b63      	cmp	r3, #99	; 0x63
 802567e:	d921      	bls.n	80256c4 <OpenDoor+0x1a4>
 8025680:	4b4f      	ldr	r3, [pc, #316]	; (80257c0 <OpenDoor+0x2a0>)
 8025682:	881b      	ldrh	r3, [r3, #0]
 8025684:	461a      	mov	r2, r3
 8025686:	4b4f      	ldr	r3, [pc, #316]	; (80257c4 <OpenDoor+0x2a4>)
 8025688:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802568a:	3bfa      	subs	r3, #250	; 0xfa
 802568c:	429a      	cmp	r2, r3
 802568e:	d219      	bcs.n	80256c4 <OpenDoor+0x1a4>
						{
							MotorClearError();
 8025690:	f7fd fb10 	bl	8022cb4 <MotorClearError>
							WriteClutch(CLUTCH_UNLOCK);
 8025694:	2001      	movs	r0, #1
 8025696:	f7fd fea5 	bl	80233e4 <WriteClutch>
							MotorSetProportionalGain(500);
 802569a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 802569e:	f7fd fae2 	bl	8022c66 <MotorSetProportionalGain>
							MotorSetIntegralGain(20);
 80256a2:	2014      	movs	r0, #20
 80256a4:	f7fd faec 	bl	8022c80 <MotorSetIntegralGain>
							MotorSetSpeed(OPEN_DIR * 1200);
 80256a8:	4b47      	ldr	r3, [pc, #284]	; (80257c8 <OpenDoor+0x2a8>)
 80256aa:	681b      	ldr	r3, [r3, #0]
 80256ac:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80256b0:	fb02 f303 	mul.w	r3, r2, r3
 80256b4:	4618      	mov	r0, r3
 80256b6:	f7fd facb 	bl	8022c50 <MotorSetSpeed>
							MotorSetPILimit(80);
 80256ba:	2050      	movs	r0, #80	; 0x50
 80256bc:	f7fd faed 	bl	8022c9a <MotorSetPILimit>
							MotorStart();
 80256c0:	f7fd faba 	bl	8022c38 <MotorStart>
						}

						if((drive.Position >= (Presets.OPEN_POSITION - 300)) && (drive.Position < (Presets.OPEN_POSITION - 120)))
 80256c4:	4b3e      	ldr	r3, [pc, #248]	; (80257c0 <OpenDoor+0x2a0>)
 80256c6:	881b      	ldrh	r3, [r3, #0]
 80256c8:	461a      	mov	r2, r3
 80256ca:	4b3e      	ldr	r3, [pc, #248]	; (80257c4 <OpenDoor+0x2a4>)
 80256cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80256ce:	f5a3 7396 	sub.w	r3, r3, #300	; 0x12c
 80256d2:	429a      	cmp	r2, r3
 80256d4:	d31e      	bcc.n	8025714 <OpenDoor+0x1f4>
 80256d6:	4b3a      	ldr	r3, [pc, #232]	; (80257c0 <OpenDoor+0x2a0>)
 80256d8:	881b      	ldrh	r3, [r3, #0]
 80256da:	461a      	mov	r2, r3
 80256dc:	4b39      	ldr	r3, [pc, #228]	; (80257c4 <OpenDoor+0x2a4>)
 80256de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80256e0:	3b78      	subs	r3, #120	; 0x78
 80256e2:	429a      	cmp	r2, r3
 80256e4:	d216      	bcs.n	8025714 <OpenDoor+0x1f4>
						{
							MotorSetPILimit(30);
 80256e6:	201e      	movs	r0, #30
 80256e8:	f7fd fad7 	bl	8022c9a <MotorSetPILimit>
							MotorSetProportionalGain(100);
 80256ec:	2064      	movs	r0, #100	; 0x64
 80256ee:	f7fd faba 	bl	8022c66 <MotorSetProportionalGain>
							MotorSetIntegralGain(5);
 80256f2:	2005      	movs	r0, #5
 80256f4:	f7fd fac4 	bl	8022c80 <MotorSetIntegralGain>
							MotorSetSpeed(OPEN_DIR * 400);
 80256f8:	4b33      	ldr	r3, [pc, #204]	; (80257c8 <OpenDoor+0x2a8>)
 80256fa:	681b      	ldr	r3, [r3, #0]
 80256fc:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8025700:	fb02 f303 	mul.w	r3, r2, r3
 8025704:	4618      	mov	r0, r3
 8025706:	f7fd faa3 	bl	8022c50 <MotorSetSpeed>
							MotorSetPILimit(40);
 802570a:	2028      	movs	r0, #40	; 0x28
 802570c:	f7fd fac5 	bl	8022c9a <MotorSetPILimit>
							result = 0;
 8025710:	2300      	movs	r3, #0
 8025712:	60fb      	str	r3, [r7, #12]
						}


						if(((drive.Position >= 400) && (drive.Position <= (Presets.OPEN_POSITION - 200)) && (drive.Current >= 1000)) || ((drive.Position > (Presets.OPEN_POSITION - 200)) && (drive.Current >= 200)) || (drive.Current >= 2000))
 8025714:	4b2a      	ldr	r3, [pc, #168]	; (80257c0 <OpenDoor+0x2a0>)
 8025716:	881b      	ldrh	r3, [r3, #0]
 8025718:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 802571c:	d30c      	bcc.n	8025738 <OpenDoor+0x218>
 802571e:	4b28      	ldr	r3, [pc, #160]	; (80257c0 <OpenDoor+0x2a0>)
 8025720:	881b      	ldrh	r3, [r3, #0]
 8025722:	461a      	mov	r2, r3
 8025724:	4b27      	ldr	r3, [pc, #156]	; (80257c4 <OpenDoor+0x2a4>)
 8025726:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025728:	3bc8      	subs	r3, #200	; 0xc8
 802572a:	429a      	cmp	r2, r3
 802572c:	d804      	bhi.n	8025738 <OpenDoor+0x218>
 802572e:	4b24      	ldr	r3, [pc, #144]	; (80257c0 <OpenDoor+0x2a0>)
 8025730:	885b      	ldrh	r3, [r3, #2]
 8025732:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8025736:	d210      	bcs.n	802575a <OpenDoor+0x23a>
 8025738:	4b21      	ldr	r3, [pc, #132]	; (80257c0 <OpenDoor+0x2a0>)
 802573a:	881b      	ldrh	r3, [r3, #0]
 802573c:	461a      	mov	r2, r3
 802573e:	4b21      	ldr	r3, [pc, #132]	; (80257c4 <OpenDoor+0x2a4>)
 8025740:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025742:	3bc8      	subs	r3, #200	; 0xc8
 8025744:	429a      	cmp	r2, r3
 8025746:	d903      	bls.n	8025750 <OpenDoor+0x230>
 8025748:	4b1d      	ldr	r3, [pc, #116]	; (80257c0 <OpenDoor+0x2a0>)
 802574a:	885b      	ldrh	r3, [r3, #2]
 802574c:	2bc7      	cmp	r3, #199	; 0xc7
 802574e:	d804      	bhi.n	802575a <OpenDoor+0x23a>
 8025750:	4b1b      	ldr	r3, [pc, #108]	; (80257c0 <OpenDoor+0x2a0>)
 8025752:	885b      	ldrh	r3, [r3, #2]
 8025754:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8025758:	d308      	bcc.n	802576c <OpenDoor+0x24c>
						{
							WriteClutch(CLUTCH_UNLOCK);
 802575a:	2001      	movs	r0, #1
 802575c:	f7fd fe42 	bl	80233e4 <WriteClutch>
							MotorStop();
 8025760:	f7fd fa70 	bl	8022c44 <MotorStop>
							result = -4;
 8025764:	f06f 0303 	mvn.w	r3, #3
 8025768:	60fb      	str	r3, [r7, #12]
 802576a:	e001      	b.n	8025770 <OpenDoor+0x250>
						}
						else
						{
							result = 0;
 802576c:	2300      	movs	r3, #0
 802576e:	60fb      	str	r3, [r7, #12]
						}

						if(drive.Position >= (Presets.OPEN_POSITION - 120))
 8025770:	4b13      	ldr	r3, [pc, #76]	; (80257c0 <OpenDoor+0x2a0>)
 8025772:	881b      	ldrh	r3, [r3, #0]
 8025774:	461a      	mov	r2, r3
 8025776:	4b13      	ldr	r3, [pc, #76]	; (80257c4 <OpenDoor+0x2a4>)
 8025778:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802577a:	3b78      	subs	r3, #120	; 0x78
 802577c:	429a      	cmp	r2, r3
 802577e:	f0c0 809d 	bcc.w	80258bc <OpenDoor+0x39c>
						{
							MotorSetProportionalGain(200);
 8025782:	20c8      	movs	r0, #200	; 0xc8
 8025784:	f7fd fa6f 	bl	8022c66 <MotorSetProportionalGain>
							MotorSetIntegralGain(5);
 8025788:	2005      	movs	r0, #5
 802578a:	f7fd fa79 	bl	8022c80 <MotorSetIntegralGain>
							MotorSetSpeed(OPEN_DIR * 100);
 802578e:	4b0e      	ldr	r3, [pc, #56]	; (80257c8 <OpenDoor+0x2a8>)
 8025790:	681b      	ldr	r3, [r3, #0]
 8025792:	2264      	movs	r2, #100	; 0x64
 8025794:	fb02 f303 	mul.w	r3, r2, r3
 8025798:	4618      	mov	r0, r3
 802579a:	f7fd fa59 	bl	8022c50 <MotorSetSpeed>
							MotorSetPILimit(20);
 802579e:	2014      	movs	r0, #20
 80257a0:	f7fd fa7b 	bl	8022c9a <MotorSetPILimit>
							MotorStart();
 80257a4:	f7fd fa48 	bl	8022c38 <MotorStart>
							state = 2;
 80257a8:	4b03      	ldr	r3, [pc, #12]	; (80257b8 <OpenDoor+0x298>)
 80257aa:	2202      	movs	r2, #2
 80257ac:	601a      	str	r2, [r3, #0]
							result = 0;
 80257ae:	2300      	movs	r3, #0
 80257b0:	60fb      	str	r3, [r7, #12]
 80257b2:	e083      	b.n	80258bc <OpenDoor+0x39c>
 80257b4:	2000074c 	.word	0x2000074c
 80257b8:	20000750 	.word	0x20000750
 80257bc:	20000754 	.word	0x20000754
 80257c0:	20000600 	.word	0x20000600
 80257c4:	20000770 	.word	0x20000770
 80257c8:	20000250 	.word	0x20000250
						}
					}
				else // if presets. openpos is clean
				{
					WriteClutch(CLUTCH_UNLOCK);
 80257cc:	2001      	movs	r0, #1
 80257ce:	f7fd fe09 	bl	80233e4 <WriteClutch>

					if ((drive.Position >= 100) && (drive.Position < (DOOR_DEFAULT_OPEN_POSITION - 300)))
 80257d2:	4b68      	ldr	r3, [pc, #416]	; (8025974 <OpenDoor+0x454>)
 80257d4:	881b      	ldrh	r3, [r3, #0]
 80257d6:	2b63      	cmp	r3, #99	; 0x63
 80257d8:	d91e      	bls.n	8025818 <OpenDoor+0x2f8>
 80257da:	4b66      	ldr	r3, [pc, #408]	; (8025974 <OpenDoor+0x454>)
 80257dc:	881b      	ldrh	r3, [r3, #0]
 80257de:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80257e2:	d219      	bcs.n	8025818 <OpenDoor+0x2f8>
					{
						MotorClearError();
 80257e4:	f7fd fa66 	bl	8022cb4 <MotorClearError>
						WriteClutch(CLUTCH_UNLOCK);
 80257e8:	2001      	movs	r0, #1
 80257ea:	f7fd fdfb 	bl	80233e4 <WriteClutch>
						MotorSetProportionalGain(1000);
 80257ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80257f2:	f7fd fa38 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(10);
 80257f6:	200a      	movs	r0, #10
 80257f8:	f7fd fa42 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 600);
 80257fc:	4b5e      	ldr	r3, [pc, #376]	; (8025978 <OpenDoor+0x458>)
 80257fe:	681b      	ldr	r3, [r3, #0]
 8025800:	f44f 7216 	mov.w	r2, #600	; 0x258
 8025804:	fb02 f303 	mul.w	r3, r2, r3
 8025808:	4618      	mov	r0, r3
 802580a:	f7fd fa21 	bl	8022c50 <MotorSetSpeed>
						MotorSetPILimit(70);
 802580e:	2046      	movs	r0, #70	; 0x46
 8025810:	f7fd fa43 	bl	8022c9a <MotorSetPILimit>
						MotorStart();
 8025814:	f7fd fa10 	bl	8022c38 <MotorStart>
					}


					if(drive.Position >= (DOOR_DEFAULT_OPEN_POSITION - 300) && (drive.Position < DOOR_DEFAULT_OPEN_POSITION))
 8025818:	4b56      	ldr	r3, [pc, #344]	; (8025974 <OpenDoor+0x454>)
 802581a:	881b      	ldrh	r3, [r3, #0]
 802581c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8025820:	d31a      	bcc.n	8025858 <OpenDoor+0x338>
 8025822:	4b54      	ldr	r3, [pc, #336]	; (8025974 <OpenDoor+0x454>)
 8025824:	881b      	ldrh	r3, [r3, #0]
 8025826:	f240 5213 	movw	r2, #1299	; 0x513
 802582a:	4293      	cmp	r3, r2
 802582c:	d814      	bhi.n	8025858 <OpenDoor+0x338>
					{
						MotorClearError();
 802582e:	f7fd fa41 	bl	8022cb4 <MotorClearError>
						MotorSetProportionalGain(200);
 8025832:	20c8      	movs	r0, #200	; 0xc8
 8025834:	f7fd fa17 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(10);
 8025838:	200a      	movs	r0, #10
 802583a:	f7fd fa21 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 200);
 802583e:	4b4e      	ldr	r3, [pc, #312]	; (8025978 <OpenDoor+0x458>)
 8025840:	681b      	ldr	r3, [r3, #0]
 8025842:	22c8      	movs	r2, #200	; 0xc8
 8025844:	fb02 f303 	mul.w	r3, r2, r3
 8025848:	4618      	mov	r0, r3
 802584a:	f7fd fa01 	bl	8022c50 <MotorSetSpeed>
						MotorSetPILimit(40);
 802584e:	2028      	movs	r0, #40	; 0x28
 8025850:	f7fd fa23 	bl	8022c9a <MotorSetPILimit>
						MotorStart();
 8025854:	f7fd f9f0 	bl	8022c38 <MotorStart>
					}


					if((drive.Position >= DOOR_DEFAULT_OPEN_POSITION) && (drive.Current >= 100) && !ServiceMode)
 8025858:	4b46      	ldr	r3, [pc, #280]	; (8025974 <OpenDoor+0x454>)
 802585a:	881b      	ldrh	r3, [r3, #0]
 802585c:	f240 5213 	movw	r2, #1299	; 0x513
 8025860:	4293      	cmp	r3, r2
 8025862:	d916      	bls.n	8025892 <OpenDoor+0x372>
 8025864:	4b43      	ldr	r3, [pc, #268]	; (8025974 <OpenDoor+0x454>)
 8025866:	885b      	ldrh	r3, [r3, #2]
 8025868:	2b63      	cmp	r3, #99	; 0x63
 802586a:	d912      	bls.n	8025892 <OpenDoor+0x372>
 802586c:	4b43      	ldr	r3, [pc, #268]	; (802597c <OpenDoor+0x45c>)
 802586e:	681b      	ldr	r3, [r3, #0]
 8025870:	2b00      	cmp	r3, #0
 8025872:	d10e      	bne.n	8025892 <OpenDoor+0x372>
					{
						MotorStop();
 8025874:	f7fd f9e6 	bl	8022c44 <MotorStop>
						Presets.OPEN_POSITION = drive.Position;
 8025878:	4b3e      	ldr	r3, [pc, #248]	; (8025974 <OpenDoor+0x454>)
 802587a:	881b      	ldrh	r3, [r3, #0]
 802587c:	461a      	mov	r2, r3
 802587e:	4b40      	ldr	r3, [pc, #256]	; (8025980 <OpenDoor+0x460>)
 8025880:	625a      	str	r2, [r3, #36]	; 0x24
						SaveAllPresets(&Presets);
 8025882:	483f      	ldr	r0, [pc, #252]	; (8025980 <OpenDoor+0x460>)
 8025884:	f000 fb35 	bl	8025ef2 <SaveAllPresets>
						//ReadAllPresets(&Presets);

						state = 3;
 8025888:	4b3e      	ldr	r3, [pc, #248]	; (8025984 <OpenDoor+0x464>)
 802588a:	2203      	movs	r2, #3
 802588c:	601a      	str	r2, [r3, #0]
						result = 0;
 802588e:	2300      	movs	r3, #0
 8025890:	60fb      	str	r3, [r7, #12]
					}
					if((drive.Position >= DOOR_DEFAULT_OPEN_POSITION) && (drive.Current >= 50) && ServiceMode)
 8025892:	4b38      	ldr	r3, [pc, #224]	; (8025974 <OpenDoor+0x454>)
 8025894:	881b      	ldrh	r3, [r3, #0]
 8025896:	f240 5213 	movw	r2, #1299	; 0x513
 802589a:	4293      	cmp	r3, r2
 802589c:	d90e      	bls.n	80258bc <OpenDoor+0x39c>
 802589e:	4b35      	ldr	r3, [pc, #212]	; (8025974 <OpenDoor+0x454>)
 80258a0:	885b      	ldrh	r3, [r3, #2]
 80258a2:	2b31      	cmp	r3, #49	; 0x31
 80258a4:	d90a      	bls.n	80258bc <OpenDoor+0x39c>
 80258a6:	4b35      	ldr	r3, [pc, #212]	; (802597c <OpenDoor+0x45c>)
 80258a8:	681b      	ldr	r3, [r3, #0]
 80258aa:	2b00      	cmp	r3, #0
 80258ac:	d006      	beq.n	80258bc <OpenDoor+0x39c>
					{
						//Presets.OPEN_POSITION = drive.Position;
						MotorStop();
 80258ae:	f7fd f9c9 	bl	8022c44 <MotorStop>
						state = 3;
 80258b2:	4b34      	ldr	r3, [pc, #208]	; (8025984 <OpenDoor+0x464>)
 80258b4:	2203      	movs	r2, #3
 80258b6:	601a      	str	r2, [r3, #0]
						result = 0;
 80258b8:	2300      	movs	r3, #0
 80258ba:	60fb      	str	r3, [r7, #12]
					}

				}
				result = 0;
 80258bc:	2300      	movs	r3, #0
 80258be:	60fb      	str	r3, [r7, #12]
			}
				break;
 80258c0:	e052      	b.n	8025968 <OpenDoor+0x448>
//					{
//						result = 0;
//					}
//				}

				if(((drive.Position >= (Presets.OPEN_POSITION - 5)) || (drive.Current >= 100)  ))
 80258c2:	4b2c      	ldr	r3, [pc, #176]	; (8025974 <OpenDoor+0x454>)
 80258c4:	881b      	ldrh	r3, [r3, #0]
 80258c6:	461a      	mov	r2, r3
 80258c8:	4b2d      	ldr	r3, [pc, #180]	; (8025980 <OpenDoor+0x460>)
 80258ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80258cc:	3b05      	subs	r3, #5
 80258ce:	429a      	cmp	r2, r3
 80258d0:	d203      	bcs.n	80258da <OpenDoor+0x3ba>
 80258d2:	4b28      	ldr	r3, [pc, #160]	; (8025974 <OpenDoor+0x454>)
 80258d4:	885b      	ldrh	r3, [r3, #2]
 80258d6:	2b63      	cmp	r3, #99	; 0x63
 80258d8:	d904      	bls.n	80258e4 <OpenDoor+0x3c4>
//					MotorSetProportionalGain(400);
//					MotorSetIntegralGain(10);
//					MotorSetSpeed(Presets.CLOSE_DIR * 5);
//					MotorSetPILimit(10);
//					MotorStart();
					MotorStop();
 80258da:	f7fd f9b3 	bl	8022c44 <MotorStop>

					state = 3;
 80258de:	4b29      	ldr	r3, [pc, #164]	; (8025984 <OpenDoor+0x464>)
 80258e0:	2203      	movs	r2, #3
 80258e2:	601a      	str	r2, [r3, #0]
				}
				result = 0;
 80258e4:	2300      	movs	r3, #0
 80258e6:	60fb      	str	r3, [r7, #12]
			}
				break;
 80258e8:	e03e      	b.n	8025968 <OpenDoor+0x448>

			case 3:
			{
				pause++;
 80258ea:	4b27      	ldr	r3, [pc, #156]	; (8025988 <OpenDoor+0x468>)
 80258ec:	681b      	ldr	r3, [r3, #0]
 80258ee:	3301      	adds	r3, #1
 80258f0:	4a25      	ldr	r2, [pc, #148]	; (8025988 <OpenDoor+0x468>)
 80258f2:	6013      	str	r3, [r2, #0]
				if (pause >= 10)
 80258f4:	4b24      	ldr	r3, [pc, #144]	; (8025988 <OpenDoor+0x468>)
 80258f6:	681b      	ldr	r3, [r3, #0]
 80258f8:	2b09      	cmp	r3, #9
 80258fa:	dd0d      	ble.n	8025918 <OpenDoor+0x3f8>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 80258fc:	2000      	movs	r0, #0
 80258fe:	f7fd fd71 	bl	80233e4 <WriteClutch>
						MotorStop();
 8025902:	f7fd f99f 	bl	8022c44 <MotorStop>
						state = 4;
 8025906:	4b1f      	ldr	r3, [pc, #124]	; (8025984 <OpenDoor+0x464>)
 8025908:	2204      	movs	r2, #4
 802590a:	601a      	str	r2, [r3, #0]
						pause = 0;
 802590c:	4b1e      	ldr	r3, [pc, #120]	; (8025988 <OpenDoor+0x468>)
 802590e:	2200      	movs	r2, #0
 8025910:	601a      	str	r2, [r3, #0]
						result = 0;
 8025912:	2300      	movs	r3, #0
 8025914:	60fb      	str	r3, [r7, #12]
				else
				{
					result = 0;
				}
			}
				break;
 8025916:	e027      	b.n	8025968 <OpenDoor+0x448>
					result = 0;
 8025918:	2300      	movs	r3, #0
 802591a:	60fb      	str	r3, [r7, #12]
				break;
 802591c:	e024      	b.n	8025968 <OpenDoor+0x448>

			case 4:
			{
				pause++;
 802591e:	4b1a      	ldr	r3, [pc, #104]	; (8025988 <OpenDoor+0x468>)
 8025920:	681b      	ldr	r3, [r3, #0]
 8025922:	3301      	adds	r3, #1
 8025924:	4a18      	ldr	r2, [pc, #96]	; (8025988 <OpenDoor+0x468>)
 8025926:	6013      	str	r3, [r2, #0]
				if (pause >= 1)
 8025928:	4b17      	ldr	r3, [pc, #92]	; (8025988 <OpenDoor+0x468>)
 802592a:	681b      	ldr	r3, [r3, #0]
 802592c:	2b00      	cmp	r3, #0
 802592e:	dd15      	ble.n	802595c <OpenDoor+0x43c>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025930:	2000      	movs	r0, #0
 8025932:	f7fd fd57 	bl	80233e4 <WriteClutch>
						MotorStop();
 8025936:	f7fd f985 	bl	8022c44 <MotorStop>
						state = 0;
 802593a:	4b12      	ldr	r3, [pc, #72]	; (8025984 <OpenDoor+0x464>)
 802593c:	2200      	movs	r2, #0
 802593e:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025940:	4b11      	ldr	r3, [pc, #68]	; (8025988 <OpenDoor+0x468>)
 8025942:	2200      	movs	r2, #0
 8025944:	601a      	str	r2, [r3, #0]
						result = 1;
 8025946:	2301      	movs	r3, #1
 8025948:	60fb      	str	r3, [r7, #12]
						tim = 0;
 802594a:	4b10      	ldr	r3, [pc, #64]	; (802598c <OpenDoor+0x46c>)
 802594c:	2200      	movs	r2, #0
 802594e:	601a      	str	r2, [r3, #0]
						Presets.CYCLES_COUNTER++;
 8025950:	4b0b      	ldr	r3, [pc, #44]	; (8025980 <OpenDoor+0x460>)
 8025952:	699b      	ldr	r3, [r3, #24]
 8025954:	3301      	adds	r3, #1
 8025956:	4a0a      	ldr	r2, [pc, #40]	; (8025980 <OpenDoor+0x460>)
 8025958:	6193      	str	r3, [r2, #24]
				else
				{
					result = 0;
				}
			}
				break;
 802595a:	e005      	b.n	8025968 <OpenDoor+0x448>
					result = 0;
 802595c:	2300      	movs	r3, #0
 802595e:	60fb      	str	r3, [r7, #12]
				break;
 8025960:	e002      	b.n	8025968 <OpenDoor+0x448>
			default:
				return -3; // bad case;
 8025962:	f06f 0302 	mvn.w	r3, #2
 8025966:	e000      	b.n	802596a <OpenDoor+0x44a>

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025968:	68fb      	ldr	r3, [r7, #12]
}
 802596a:	4618      	mov	r0, r3
 802596c:	3710      	adds	r7, #16
 802596e:	46bd      	mov	sp, r7
 8025970:	bd80      	pop	{r7, pc}
 8025972:	bf00      	nop
 8025974:	20000600 	.word	0x20000600
 8025978:	20000250 	.word	0x20000250
 802597c:	20000fd0 	.word	0x20000fd0
 8025980:	20000770 	.word	0x20000770
 8025984:	20000750 	.word	0x20000750
 8025988:	20000754 	.word	0x20000754
 802598c:	2000074c 	.word	0x2000074c

08025990 <OpenAfterBlockage>:

int32_t OpenAfterBlockage (int32_t cmd)
{
 8025990:	b580      	push	{r7, lr}
 8025992:	b084      	sub	sp, #16
 8025994:	af00      	add	r7, sp, #0
 8025996:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8025998:	2300      	movs	r3, #0
 802599a:	60fb      	str	r3, [r7, #12]
	static int32_t pause = 0;
	static int32_t tim = 0;

	//static int32_t first_opening_done = 0;

	tim++;
 802599c:	4b9f      	ldr	r3, [pc, #636]	; (8025c1c <OpenAfterBlockage+0x28c>)
 802599e:	681b      	ldr	r3, [r3, #0]
 80259a0:	3301      	adds	r3, #1
 80259a2:	4a9e      	ldr	r2, [pc, #632]	; (8025c1c <OpenAfterBlockage+0x28c>)
 80259a4:	6013      	str	r3, [r2, #0]


	if(tim >= 1000)
 80259a6:	4b9d      	ldr	r3, [pc, #628]	; (8025c1c <OpenAfterBlockage+0x28c>)
 80259a8:	681b      	ldr	r3, [r3, #0]
 80259aa:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80259ae:	db0d      	blt.n	80259cc <OpenAfterBlockage+0x3c>
	{
		MotorStop();
 80259b0:	f7fd f948 	bl	8022c44 <MotorStop>
		state = 0;
 80259b4:	4b9a      	ldr	r3, [pc, #616]	; (8025c20 <OpenAfterBlockage+0x290>)
 80259b6:	2200      	movs	r2, #0
 80259b8:	601a      	str	r2, [r3, #0]
		tim = 0;
 80259ba:	4b98      	ldr	r3, [pc, #608]	; (8025c1c <OpenAfterBlockage+0x28c>)
 80259bc:	2200      	movs	r2, #0
 80259be:	601a      	str	r2, [r3, #0]
		pause = 0;
 80259c0:	4b98      	ldr	r3, [pc, #608]	; (8025c24 <OpenAfterBlockage+0x294>)
 80259c2:	2200      	movs	r2, #0
 80259c4:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 80259c6:	f04f 33ff 	mov.w	r3, #4294967295
 80259ca:	e15a      	b.n	8025c82 <OpenAfterBlockage+0x2f2>
	}
	if (drive.Current >= 1200)
 80259cc:	4b96      	ldr	r3, [pc, #600]	; (8025c28 <OpenAfterBlockage+0x298>)
 80259ce:	885b      	ldrh	r3, [r3, #2]
 80259d0:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 80259d4:	d30d      	bcc.n	80259f2 <OpenAfterBlockage+0x62>
	{
		MotorStop();
 80259d6:	f7fd f935 	bl	8022c44 <MotorStop>
		state = 0;
 80259da:	4b91      	ldr	r3, [pc, #580]	; (8025c20 <OpenAfterBlockage+0x290>)
 80259dc:	2200      	movs	r2, #0
 80259de:	601a      	str	r2, [r3, #0]
		tim = 0;
 80259e0:	4b8e      	ldr	r3, [pc, #568]	; (8025c1c <OpenAfterBlockage+0x28c>)
 80259e2:	2200      	movs	r2, #0
 80259e4:	601a      	str	r2, [r3, #0]
		pause = 0;
 80259e6:	4b8f      	ldr	r3, [pc, #572]	; (8025c24 <OpenAfterBlockage+0x294>)
 80259e8:	2200      	movs	r2, #0
 80259ea:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 80259ec:	f06f 0301 	mvn.w	r3, #1
 80259f0:	e147      	b.n	8025c82 <OpenAfterBlockage+0x2f2>
	}


	if(!cmd)
 80259f2:	687b      	ldr	r3, [r7, #4]
 80259f4:	2b00      	cmp	r3, #0
 80259f6:	d10c      	bne.n	8025a12 <OpenAfterBlockage+0x82>
	{
		MotorStop();
 80259f8:	f7fd f924 	bl	8022c44 <MotorStop>
		state = 0;
 80259fc:	4b88      	ldr	r3, [pc, #544]	; (8025c20 <OpenAfterBlockage+0x290>)
 80259fe:	2200      	movs	r2, #0
 8025a00:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025a02:	4b88      	ldr	r3, [pc, #544]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025a04:	2200      	movs	r2, #0
 8025a06:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025a08:	4b84      	ldr	r3, [pc, #528]	; (8025c1c <OpenAfterBlockage+0x28c>)
 8025a0a:	2200      	movs	r2, #0
 8025a0c:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8025a0e:	2300      	movs	r3, #0
 8025a10:	e137      	b.n	8025c82 <OpenAfterBlockage+0x2f2>
	}
	else
	{
		switch (state)
 8025a12:	4b83      	ldr	r3, [pc, #524]	; (8025c20 <OpenAfterBlockage+0x290>)
 8025a14:	681b      	ldr	r3, [r3, #0]
 8025a16:	2b04      	cmp	r3, #4
 8025a18:	f200 812e 	bhi.w	8025c78 <OpenAfterBlockage+0x2e8>
 8025a1c:	a201      	add	r2, pc, #4	; (adr r2, 8025a24 <OpenAfterBlockage+0x94>)
 8025a1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025a22:	bf00      	nop
 8025a24:	08025a39 	.word	0x08025a39
 8025a28:	08025a8f 	.word	0x08025a8f
 8025a2c:	08025ba9 	.word	0x08025ba9
 8025a30:	08025be7 	.word	0x08025be7
 8025a34:	08025c35 	.word	0x08025c35
		{
			case 0:
			{
				WriteClutch(CLUTCH_UNLOCK);
 8025a38:	2001      	movs	r0, #1
 8025a3a:	f7fd fcd3 	bl	80233e4 <WriteClutch>

//				DIGITAL_IO_SetOutputHigh(&HS_SW_1);
//				DIGITAL_IO_SetOutputHigh(&HS_SW_2);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
				pause++;
 8025a3e:	4b79      	ldr	r3, [pc, #484]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025a40:	681b      	ldr	r3, [r3, #0]
 8025a42:	3301      	adds	r3, #1
 8025a44:	4a77      	ldr	r2, [pc, #476]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025a46:	6013      	str	r3, [r2, #0]
//					Motor0_BLDC_SCALAR_SetSpeedIntegralGain(10);
//					Motor0_BLDC_SCALAR_SetSpeedVal(OPEN_DIR * 250);
//					Motor0_BLDC_SCALAR_MotorStart();
//				}
//
				if(pause > 50)
 8025a48:	4b76      	ldr	r3, [pc, #472]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025a4a:	681b      	ldr	r3, [r3, #0]
 8025a4c:	2b32      	cmp	r3, #50	; 0x32
 8025a4e:	dd1b      	ble.n	8025a88 <OpenAfterBlockage+0xf8>
				{
					MotorClearError();
 8025a50:	f7fd f930 	bl	8022cb4 <MotorClearError>
					MotorSetProportionalGain(2000);
 8025a54:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8025a58:	f7fd f905 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(20);
 8025a5c:	2014      	movs	r0, #20
 8025a5e:	f7fd f90f 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 200);
 8025a62:	4b72      	ldr	r3, [pc, #456]	; (8025c2c <OpenAfterBlockage+0x29c>)
 8025a64:	681b      	ldr	r3, [r3, #0]
 8025a66:	22c8      	movs	r2, #200	; 0xc8
 8025a68:	fb02 f303 	mul.w	r3, r2, r3
 8025a6c:	4618      	mov	r0, r3
 8025a6e:	f7fd f8ef 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025a72:	f7fd f8e1 	bl	8022c38 <MotorStart>
					state  = 1;
 8025a76:	4b6a      	ldr	r3, [pc, #424]	; (8025c20 <OpenAfterBlockage+0x290>)
 8025a78:	2201      	movs	r2, #1
 8025a7a:	601a      	str	r2, [r3, #0]
					pause = 0;
 8025a7c:	4b69      	ldr	r3, [pc, #420]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025a7e:	2200      	movs	r2, #0
 8025a80:	601a      	str	r2, [r3, #0]
					WriteClutch(CLUTCH_UNLOCK);
 8025a82:	2001      	movs	r0, #1
 8025a84:	f7fd fcae 	bl	80233e4 <WriteClutch>
					state = 1;
					pause = 0;
					WriteClutch(CLUTCH_UNLOCK);
				}
*/
				result = 0;
 8025a88:	2300      	movs	r3, #0
 8025a8a:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025a8c:	e0f8      	b.n	8025c80 <OpenAfterBlockage+0x2f0>
			case 1:
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_R);
//				if((Presets.OPEN_POSITION != 0x0))
	//			{
				if ((drive.Position >= 40) && (drive.Position < (Presets.OPEN_POSITION - 500)))
 8025a8e:	4b66      	ldr	r3, [pc, #408]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025a90:	881b      	ldrh	r3, [r3, #0]
 8025a92:	2b27      	cmp	r3, #39	; 0x27
 8025a94:	d91f      	bls.n	8025ad6 <OpenAfterBlockage+0x146>
 8025a96:	4b64      	ldr	r3, [pc, #400]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025a98:	881b      	ldrh	r3, [r3, #0]
 8025a9a:	461a      	mov	r2, r3
 8025a9c:	4b64      	ldr	r3, [pc, #400]	; (8025c30 <OpenAfterBlockage+0x2a0>)
 8025a9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025aa0:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8025aa4:	429a      	cmp	r2, r3
 8025aa6:	d216      	bcs.n	8025ad6 <OpenAfterBlockage+0x146>
				{
					MotorClearError();
 8025aa8:	f7fd f904 	bl	8022cb4 <MotorClearError>
				    WriteClutch(CLUTCH_UNLOCK);
 8025aac:	2001      	movs	r0, #1
 8025aae:	f7fd fc99 	bl	80233e4 <WriteClutch>
					MotorSetProportionalGain(1000);
 8025ab2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8025ab6:	f7fd f8d6 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025aba:	200a      	movs	r0, #10
 8025abc:	f7fd f8e0 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 1000);
 8025ac0:	4b5a      	ldr	r3, [pc, #360]	; (8025c2c <OpenAfterBlockage+0x29c>)
 8025ac2:	681b      	ldr	r3, [r3, #0]
 8025ac4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8025ac8:	fb02 f303 	mul.w	r3, r2, r3
 8025acc:	4618      	mov	r0, r3
 8025ace:	f7fd f8bf 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025ad2:	f7fd f8b1 	bl	8022c38 <MotorStart>
				}

				if((drive.Position >= (Presets.OPEN_POSITION - 500)) && (drive.Position < (Presets.OPEN_POSITION - 200)))
 8025ad6:	4b54      	ldr	r3, [pc, #336]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025ad8:	881b      	ldrh	r3, [r3, #0]
 8025ada:	461a      	mov	r2, r3
 8025adc:	4b54      	ldr	r3, [pc, #336]	; (8025c30 <OpenAfterBlockage+0x2a0>)
 8025ade:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025ae0:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8025ae4:	429a      	cmp	r2, r3
 8025ae6:	d315      	bcc.n	8025b14 <OpenAfterBlockage+0x184>
 8025ae8:	4b4f      	ldr	r3, [pc, #316]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025aea:	881b      	ldrh	r3, [r3, #0]
 8025aec:	461a      	mov	r2, r3
 8025aee:	4b50      	ldr	r3, [pc, #320]	; (8025c30 <OpenAfterBlockage+0x2a0>)
 8025af0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025af2:	3bc8      	subs	r3, #200	; 0xc8
 8025af4:	429a      	cmp	r2, r3
 8025af6:	d20d      	bcs.n	8025b14 <OpenAfterBlockage+0x184>
				{
					MotorSetSpeed(OPEN_DIR * 400);
 8025af8:	4b4c      	ldr	r3, [pc, #304]	; (8025c2c <OpenAfterBlockage+0x29c>)
 8025afa:	681b      	ldr	r3, [r3, #0]
 8025afc:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8025b00:	fb02 f303 	mul.w	r3, r2, r3
 8025b04:	4618      	mov	r0, r3
 8025b06:	f7fd f8a3 	bl	8022c50 <MotorSetSpeed>
					result = 0;
 8025b0a:	2300      	movs	r3, #0
 8025b0c:	60fb      	str	r3, [r7, #12]
					WriteClutch(CLUTCH_UNLOCK);
 8025b0e:	2001      	movs	r0, #1
 8025b10:	f7fd fc68 	bl	80233e4 <WriteClutch>
				}


				if(((drive.Current >= 1500) && (drive.Position < 1300) && (drive.Position >= 500)) || ((drive.Position > 1300) && (drive.Current >= 300)))
 8025b14:	4b44      	ldr	r3, [pc, #272]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025b16:	885b      	ldrh	r3, [r3, #2]
 8025b18:	f240 52db 	movw	r2, #1499	; 0x5db
 8025b1c:	4293      	cmp	r3, r2
 8025b1e:	d90a      	bls.n	8025b36 <OpenAfterBlockage+0x1a6>
 8025b20:	4b41      	ldr	r3, [pc, #260]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025b22:	881b      	ldrh	r3, [r3, #0]
 8025b24:	f240 5213 	movw	r2, #1299	; 0x513
 8025b28:	4293      	cmp	r3, r2
 8025b2a:	d804      	bhi.n	8025b36 <OpenAfterBlockage+0x1a6>
 8025b2c:	4b3e      	ldr	r3, [pc, #248]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025b2e:	881b      	ldrh	r3, [r3, #0]
 8025b30:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8025b34:	d20a      	bcs.n	8025b4c <OpenAfterBlockage+0x1bc>
 8025b36:	4b3c      	ldr	r3, [pc, #240]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025b38:	881b      	ldrh	r3, [r3, #0]
 8025b3a:	f240 5214 	movw	r2, #1300	; 0x514
 8025b3e:	4293      	cmp	r3, r2
 8025b40:	d90d      	bls.n	8025b5e <OpenAfterBlockage+0x1ce>
 8025b42:	4b39      	ldr	r3, [pc, #228]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025b44:	885b      	ldrh	r3, [r3, #2]
 8025b46:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8025b4a:	d308      	bcc.n	8025b5e <OpenAfterBlockage+0x1ce>
				{
					WriteClutch(CLUTCH_UNLOCK);
 8025b4c:	2001      	movs	r0, #1
 8025b4e:	f7fd fc49 	bl	80233e4 <WriteClutch>
					MotorStop();
 8025b52:	f7fd f877 	bl	8022c44 <MotorStop>
					result = -4;
 8025b56:	f06f 0303 	mvn.w	r3, #3
 8025b5a:	60fb      	str	r3, [r7, #12]
 8025b5c:	e001      	b.n	8025b62 <OpenAfterBlockage+0x1d2>
				}
				else
				{
					result = 0;
 8025b5e:	2300      	movs	r3, #0
 8025b60:	60fb      	str	r3, [r7, #12]
				}

				if(drive.Position >= (Presets.OPEN_POSITION - 150))
 8025b62:	4b31      	ldr	r3, [pc, #196]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025b64:	881b      	ldrh	r3, [r3, #0]
 8025b66:	461a      	mov	r2, r3
 8025b68:	4b31      	ldr	r3, [pc, #196]	; (8025c30 <OpenAfterBlockage+0x2a0>)
 8025b6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025b6c:	3b96      	subs	r3, #150	; 0x96
 8025b6e:	429a      	cmp	r2, r3
 8025b70:	f0c0 8085 	bcc.w	8025c7e <OpenAfterBlockage+0x2ee>
				{
					MotorSetProportionalGain(2000);
 8025b74:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8025b78:	f7fd f875 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025b7c:	200a      	movs	r0, #10
 8025b7e:	f7fd f87f 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 100);
 8025b82:	4b2a      	ldr	r3, [pc, #168]	; (8025c2c <OpenAfterBlockage+0x29c>)
 8025b84:	681b      	ldr	r3, [r3, #0]
 8025b86:	2264      	movs	r2, #100	; 0x64
 8025b88:	fb02 f303 	mul.w	r3, r2, r3
 8025b8c:	4618      	mov	r0, r3
 8025b8e:	f7fd f85f 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025b92:	f7fd f851 	bl	8022c38 <MotorStart>
					state = 2;
 8025b96:	4b22      	ldr	r3, [pc, #136]	; (8025c20 <OpenAfterBlockage+0x290>)
 8025b98:	2202      	movs	r2, #2
 8025b9a:	601a      	str	r2, [r3, #0]
					result = 0;
 8025b9c:	2300      	movs	r3, #0
 8025b9e:	60fb      	str	r3, [r7, #12]
					WriteClutch(CLUTCH_UNLOCK);
 8025ba0:	2001      	movs	r0, #1
 8025ba2:	f7fd fc1f 	bl	80233e4 <WriteClutch>
//					}
//
//				}
				//result = 0;
			}
				break;
 8025ba6:	e06a      	b.n	8025c7e <OpenAfterBlockage+0x2ee>
//					{
//						result = 0;
//					}
//				}

				if(((drive.Position >= (Presets.OPEN_POSITION - 10))))
 8025ba8:	4b1f      	ldr	r3, [pc, #124]	; (8025c28 <OpenAfterBlockage+0x298>)
 8025baa:	881b      	ldrh	r3, [r3, #0]
 8025bac:	461a      	mov	r2, r3
 8025bae:	4b20      	ldr	r3, [pc, #128]	; (8025c30 <OpenAfterBlockage+0x2a0>)
 8025bb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025bb2:	3b0a      	subs	r3, #10
 8025bb4:	429a      	cmp	r2, r3
 8025bb6:	d313      	bcc.n	8025be0 <OpenAfterBlockage+0x250>
				{
					MotorSetProportionalGain(400);
 8025bb8:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8025bbc:	f7fd f853 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025bc0:	200a      	movs	r0, #10
 8025bc2:	f7fd f85d 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 5);
 8025bc6:	4b19      	ldr	r3, [pc, #100]	; (8025c2c <OpenAfterBlockage+0x29c>)
 8025bc8:	681a      	ldr	r2, [r3, #0]
 8025bca:	4613      	mov	r3, r2
 8025bcc:	009b      	lsls	r3, r3, #2
 8025bce:	4413      	add	r3, r2
 8025bd0:	4618      	mov	r0, r3
 8025bd2:	f7fd f83d 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025bd6:	f7fd f82f 	bl	8022c38 <MotorStart>
					//Motor0_BLDC_SCALAR_MotorStop();

					state = 3;
 8025bda:	4b11      	ldr	r3, [pc, #68]	; (8025c20 <OpenAfterBlockage+0x290>)
 8025bdc:	2203      	movs	r2, #3
 8025bde:	601a      	str	r2, [r3, #0]
				}
				result = 0;
 8025be0:	2300      	movs	r3, #0
 8025be2:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025be4:	e04c      	b.n	8025c80 <OpenAfterBlockage+0x2f0>

			case 3:
			{
				pause++;
 8025be6:	4b0f      	ldr	r3, [pc, #60]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025be8:	681b      	ldr	r3, [r3, #0]
 8025bea:	3301      	adds	r3, #1
 8025bec:	4a0d      	ldr	r2, [pc, #52]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025bee:	6013      	str	r3, [r2, #0]
				if (pause >= 1)
 8025bf0:	4b0c      	ldr	r3, [pc, #48]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025bf2:	681b      	ldr	r3, [r3, #0]
 8025bf4:	2b00      	cmp	r3, #0
 8025bf6:	dd0d      	ble.n	8025c14 <OpenAfterBlockage+0x284>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025bf8:	2000      	movs	r0, #0
 8025bfa:	f7fd fbf3 	bl	80233e4 <WriteClutch>
						MotorStop();
 8025bfe:	f7fd f821 	bl	8022c44 <MotorStop>
						state = 4;
 8025c02:	4b07      	ldr	r3, [pc, #28]	; (8025c20 <OpenAfterBlockage+0x290>)
 8025c04:	2204      	movs	r2, #4
 8025c06:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025c08:	4b06      	ldr	r3, [pc, #24]	; (8025c24 <OpenAfterBlockage+0x294>)
 8025c0a:	2200      	movs	r2, #0
 8025c0c:	601a      	str	r2, [r3, #0]
						result = 0;
 8025c0e:	2300      	movs	r3, #0
 8025c10:	60fb      	str	r3, [r7, #12]
				else
				{
					result = 0;
				}
			}
				break;
 8025c12:	e035      	b.n	8025c80 <OpenAfterBlockage+0x2f0>
					result = 0;
 8025c14:	2300      	movs	r3, #0
 8025c16:	60fb      	str	r3, [r7, #12]
				break;
 8025c18:	e032      	b.n	8025c80 <OpenAfterBlockage+0x2f0>
 8025c1a:	bf00      	nop
 8025c1c:	20000758 	.word	0x20000758
 8025c20:	2000075c 	.word	0x2000075c
 8025c24:	20000760 	.word	0x20000760
 8025c28:	20000600 	.word	0x20000600
 8025c2c:	20000250 	.word	0x20000250
 8025c30:	20000770 	.word	0x20000770

			case 4:
			{
				pause++;
 8025c34:	4b15      	ldr	r3, [pc, #84]	; (8025c8c <OpenAfterBlockage+0x2fc>)
 8025c36:	681b      	ldr	r3, [r3, #0]
 8025c38:	3301      	adds	r3, #1
 8025c3a:	4a14      	ldr	r2, [pc, #80]	; (8025c8c <OpenAfterBlockage+0x2fc>)
 8025c3c:	6013      	str	r3, [r2, #0]
				if (pause >= 10)
 8025c3e:	4b13      	ldr	r3, [pc, #76]	; (8025c8c <OpenAfterBlockage+0x2fc>)
 8025c40:	681b      	ldr	r3, [r3, #0]
 8025c42:	2b09      	cmp	r3, #9
 8025c44:	dd15      	ble.n	8025c72 <OpenAfterBlockage+0x2e2>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025c46:	2000      	movs	r0, #0
 8025c48:	f7fd fbcc 	bl	80233e4 <WriteClutch>
						MotorStop();
 8025c4c:	f7fc fffa 	bl	8022c44 <MotorStop>
						state = 0;
 8025c50:	4b0f      	ldr	r3, [pc, #60]	; (8025c90 <OpenAfterBlockage+0x300>)
 8025c52:	2200      	movs	r2, #0
 8025c54:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025c56:	4b0d      	ldr	r3, [pc, #52]	; (8025c8c <OpenAfterBlockage+0x2fc>)
 8025c58:	2200      	movs	r2, #0
 8025c5a:	601a      	str	r2, [r3, #0]
						result = 1;
 8025c5c:	2301      	movs	r3, #1
 8025c5e:	60fb      	str	r3, [r7, #12]
						tim = 0;
 8025c60:	4b0c      	ldr	r3, [pc, #48]	; (8025c94 <OpenAfterBlockage+0x304>)
 8025c62:	2200      	movs	r2, #0
 8025c64:	601a      	str	r2, [r3, #0]
						Presets.CYCLES_COUNTER++;
 8025c66:	4b0c      	ldr	r3, [pc, #48]	; (8025c98 <OpenAfterBlockage+0x308>)
 8025c68:	699b      	ldr	r3, [r3, #24]
 8025c6a:	3301      	adds	r3, #1
 8025c6c:	4a0a      	ldr	r2, [pc, #40]	; (8025c98 <OpenAfterBlockage+0x308>)
 8025c6e:	6193      	str	r3, [r2, #24]
				else
				{
					result = 0;
				}
			}
				break;
 8025c70:	e006      	b.n	8025c80 <OpenAfterBlockage+0x2f0>
					result = 0;
 8025c72:	2300      	movs	r3, #0
 8025c74:	60fb      	str	r3, [r7, #12]
				break;
 8025c76:	e003      	b.n	8025c80 <OpenAfterBlockage+0x2f0>
			default:
				return -3; // bad case;
 8025c78:	f06f 0302 	mvn.w	r3, #2
 8025c7c:	e001      	b.n	8025c82 <OpenAfterBlockage+0x2f2>
				break;
 8025c7e:	bf00      	nop

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025c80:	68fb      	ldr	r3, [r7, #12]
}
 8025c82:	4618      	mov	r0, r3
 8025c84:	3710      	adds	r7, #16
 8025c86:	46bd      	mov	sp, r7
 8025c88:	bd80      	pop	{r7, pc}
 8025c8a:	bf00      	nop
 8025c8c:	20000760 	.word	0x20000760
 8025c90:	2000075c 	.word	0x2000075c
 8025c94:	20000758 	.word	0x20000758
 8025c98:	20000770 	.word	0x20000770

08025c9c <ForceHold>:

int32_t ForceHold(int32_t cmd)
{
 8025c9c:	b580      	push	{r7, lr}
 8025c9e:	b082      	sub	sp, #8
 8025ca0:	af00      	add	r7, sp, #0
 8025ca2:	6078      	str	r0, [r7, #4]
	if(!cmd)
 8025ca4:	687b      	ldr	r3, [r7, #4]
 8025ca6:	2b00      	cmp	r3, #0
 8025ca8:	d103      	bne.n	8025cb2 <ForceHold+0x16>
		{
			MotorStop();
 8025caa:	f7fc ffcb 	bl	8022c44 <MotorStop>
			return 0;
 8025cae:	2300      	movs	r3, #0
 8025cb0:	e011      	b.n	8025cd6 <ForceHold+0x3a>
		}
		else
		{
			//drive.RAWPosition = 0;
			MotorSetPILimit(5);
 8025cb2:	2005      	movs	r0, #5
 8025cb4:	f7fc fff1 	bl	8022c9a <MotorSetPILimit>
			MotorSetProportionalGain(100);
 8025cb8:	2064      	movs	r0, #100	; 0x64
 8025cba:	f7fc ffd4 	bl	8022c66 <MotorSetProportionalGain>
			MotorSetIntegralGain(1);
 8025cbe:	2001      	movs	r0, #1
 8025cc0:	f7fc ffde 	bl	8022c80 <MotorSetIntegralGain>
			MotorSetSpeed(Presets.CLOSE_DIR * 5);
 8025cc4:	4b06      	ldr	r3, [pc, #24]	; (8025ce0 <ForceHold+0x44>)
 8025cc6:	681a      	ldr	r2, [r3, #0]
 8025cc8:	4613      	mov	r3, r2
 8025cca:	009b      	lsls	r3, r3, #2
 8025ccc:	4413      	add	r3, r2
 8025cce:	4618      	mov	r0, r3
 8025cd0:	f7fc ffbe 	bl	8022c50 <MotorSetSpeed>
			return 0;
 8025cd4:	2300      	movs	r3, #0
		}
}
 8025cd6:	4618      	mov	r0, r3
 8025cd8:	3708      	adds	r7, #8
 8025cda:	46bd      	mov	sp, r7
 8025cdc:	bd80      	pop	{r7, pc}
 8025cde:	bf00      	nop
 8025ce0:	20000770 	.word	0x20000770

08025ce4 <ForceClose>:
int32_t ForceClose(int32_t cmd)
{
 8025ce4:	b580      	push	{r7, lr}
 8025ce6:	b084      	sub	sp, #16
 8025ce8:	af00      	add	r7, sp, #0
 8025cea:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8025cec:	2300      	movs	r3, #0
 8025cee:	60fb      	str	r3, [r7, #12]
	static int32_t state = 0;
	static int32_t pause = 0;
	static int32_t tim = 0;

	if(!cmd)
 8025cf0:	687b      	ldr	r3, [r7, #4]
 8025cf2:	2b00      	cmp	r3, #0
 8025cf4:	d10c      	bne.n	8025d10 <ForceClose+0x2c>
	{
		MotorStop();
 8025cf6:	f7fc ffa5 	bl	8022c44 <MotorStop>
		state = 0;
 8025cfa:	4b6f      	ldr	r3, [pc, #444]	; (8025eb8 <ForceClose+0x1d4>)
 8025cfc:	2200      	movs	r2, #0
 8025cfe:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025d00:	4b6e      	ldr	r3, [pc, #440]	; (8025ebc <ForceClose+0x1d8>)
 8025d02:	2200      	movs	r2, #0
 8025d04:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025d06:	4b6e      	ldr	r3, [pc, #440]	; (8025ec0 <ForceClose+0x1dc>)
 8025d08:	2200      	movs	r2, #0
 8025d0a:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8025d0c:	2300      	movs	r3, #0
 8025d0e:	e0ce      	b.n	8025eae <ForceClose+0x1ca>
	}
	else
	{
		switch (state)
 8025d10:	4b69      	ldr	r3, [pc, #420]	; (8025eb8 <ForceClose+0x1d4>)
 8025d12:	681b      	ldr	r3, [r3, #0]
 8025d14:	2b03      	cmp	r3, #3
 8025d16:	f200 80c6 	bhi.w	8025ea6 <ForceClose+0x1c2>
 8025d1a:	a201      	add	r2, pc, #4	; (adr r2, 8025d20 <ForceClose+0x3c>)
 8025d1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025d20:	08025d31 	.word	0x08025d31
 8025d24:	08025d91 	.word	0x08025d91
 8025d28:	08025e19 	.word	0x08025e19
 8025d2c:	08025e77 	.word	0x08025e77
		{
			case 0:
			{
				WriteClutch(CLUTCH_LOCK);
 8025d30:	2000      	movs	r0, #0
 8025d32:	f7fd fb57 	bl	80233e4 <WriteClutch>
				pause++;
 8025d36:	4b62      	ldr	r3, [pc, #392]	; (8025ec0 <ForceClose+0x1dc>)
 8025d38:	681b      	ldr	r3, [r3, #0]
 8025d3a:	3301      	adds	r3, #1
 8025d3c:	4a60      	ldr	r2, [pc, #384]	; (8025ec0 <ForceClose+0x1dc>)
 8025d3e:	6013      	str	r3, [r2, #0]
				if(pause >= 10)
 8025d40:	4b5f      	ldr	r3, [pc, #380]	; (8025ec0 <ForceClose+0x1dc>)
 8025d42:	681b      	ldr	r3, [r3, #0]
 8025d44:	2b09      	cmp	r3, #9
 8025d46:	dd16      	ble.n	8025d76 <ForceClose+0x92>
				{
					//pause = 0;
					//state = 1;
					MotorClearError();
 8025d48:	f7fc ffb4 	bl	8022cb4 <MotorClearError>
					MotorSetPILimit(60);
 8025d4c:	203c      	movs	r0, #60	; 0x3c
 8025d4e:	f7fc ffa4 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(500);
 8025d52:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8025d56:	f7fc ff86 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025d5a:	200a      	movs	r0, #10
 8025d5c:	f7fc ff90 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 300); //(Presets.CLOSE_DIR));
 8025d60:	4b58      	ldr	r3, [pc, #352]	; (8025ec4 <ForceClose+0x1e0>)
 8025d62:	681b      	ldr	r3, [r3, #0]
 8025d64:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8025d68:	fb02 f303 	mul.w	r3, r2, r3
 8025d6c:	4618      	mov	r0, r3
 8025d6e:	f7fc ff6f 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025d72:	f7fc ff61 	bl	8022c38 <MotorStart>
				}
				if(pause >= 13) // to eat start stable
 8025d76:	4b52      	ldr	r3, [pc, #328]	; (8025ec0 <ForceClose+0x1dc>)
 8025d78:	681b      	ldr	r3, [r3, #0]
 8025d7a:	2b0c      	cmp	r3, #12
 8025d7c:	dd05      	ble.n	8025d8a <ForceClose+0xa6>
				{
					pause = 0;
 8025d7e:	4b50      	ldr	r3, [pc, #320]	; (8025ec0 <ForceClose+0x1dc>)
 8025d80:	2200      	movs	r2, #0
 8025d82:	601a      	str	r2, [r3, #0]
					state = 1;
 8025d84:	4b4c      	ldr	r3, [pc, #304]	; (8025eb8 <ForceClose+0x1d4>)
 8025d86:	2201      	movs	r2, #1
 8025d88:	601a      	str	r2, [r3, #0]
				}
				result = 0;
 8025d8a:	2300      	movs	r3, #0
 8025d8c:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025d8e:	e08d      	b.n	8025eac <ForceClose+0x1c8>

			case 1:
			{
				if((!ServiceMode && CloseSensor && (drive.Current >= 300)) || (ServiceMode && (drive.Current >= 300)) || (ServiceMode && (drive.Current >= 300) && serv_from_but))//
 8025d90:	4b4d      	ldr	r3, [pc, #308]	; (8025ec8 <ForceClose+0x1e4>)
 8025d92:	681b      	ldr	r3, [r3, #0]
 8025d94:	2b00      	cmp	r3, #0
 8025d96:	d108      	bne.n	8025daa <ForceClose+0xc6>
 8025d98:	4b4c      	ldr	r3, [pc, #304]	; (8025ecc <ForceClose+0x1e8>)
 8025d9a:	681b      	ldr	r3, [r3, #0]
 8025d9c:	2b00      	cmp	r3, #0
 8025d9e:	d004      	beq.n	8025daa <ForceClose+0xc6>
 8025da0:	4b4b      	ldr	r3, [pc, #300]	; (8025ed0 <ForceClose+0x1ec>)
 8025da2:	885b      	ldrh	r3, [r3, #2]
 8025da4:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8025da8:	d215      	bcs.n	8025dd6 <ForceClose+0xf2>
 8025daa:	4b47      	ldr	r3, [pc, #284]	; (8025ec8 <ForceClose+0x1e4>)
 8025dac:	681b      	ldr	r3, [r3, #0]
 8025dae:	2b00      	cmp	r3, #0
 8025db0:	d004      	beq.n	8025dbc <ForceClose+0xd8>
 8025db2:	4b47      	ldr	r3, [pc, #284]	; (8025ed0 <ForceClose+0x1ec>)
 8025db4:	885b      	ldrh	r3, [r3, #2]
 8025db6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8025dba:	d20c      	bcs.n	8025dd6 <ForceClose+0xf2>
 8025dbc:	4b42      	ldr	r3, [pc, #264]	; (8025ec8 <ForceClose+0x1e4>)
 8025dbe:	681b      	ldr	r3, [r3, #0]
 8025dc0:	2b00      	cmp	r3, #0
 8025dc2:	d025      	beq.n	8025e10 <ForceClose+0x12c>
 8025dc4:	4b42      	ldr	r3, [pc, #264]	; (8025ed0 <ForceClose+0x1ec>)
 8025dc6:	885b      	ldrh	r3, [r3, #2]
 8025dc8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 8025dcc:	d320      	bcc.n	8025e10 <ForceClose+0x12c>
 8025dce:	4b41      	ldr	r3, [pc, #260]	; (8025ed4 <ForceClose+0x1f0>)
 8025dd0:	681b      	ldr	r3, [r3, #0]
 8025dd2:	2b00      	cmp	r3, #0
 8025dd4:	d01c      	beq.n	8025e10 <ForceClose+0x12c>
				{
					WriteClutch(CLUTCH_LOCK);
 8025dd6:	2000      	movs	r0, #0
 8025dd8:	f7fd fb04 	bl	80233e4 <WriteClutch>
					MotorSetProportionalGain(200);
 8025ddc:	20c8      	movs	r0, #200	; 0xc8
 8025dde:	f7fc ff42 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025de2:	200a      	movs	r0, #10
 8025de4:	f7fc ff4c 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetPILimit(20);
 8025de8:	2014      	movs	r0, #20
 8025dea:	f7fc ff56 	bl	8022c9a <MotorSetPILimit>
					MotorSetSpeed(Presets.CLOSE_DIR * 50);
 8025dee:	4b35      	ldr	r3, [pc, #212]	; (8025ec4 <ForceClose+0x1e0>)
 8025df0:	681b      	ldr	r3, [r3, #0]
 8025df2:	2232      	movs	r2, #50	; 0x32
 8025df4:	fb02 f303 	mul.w	r3, r2, r3
 8025df8:	4618      	mov	r0, r3
 8025dfa:	f7fc ff29 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025dfe:	f7fc ff1b 	bl	8022c38 <MotorStart>
					state = 2;
 8025e02:	4b2d      	ldr	r3, [pc, #180]	; (8025eb8 <ForceClose+0x1d4>)
 8025e04:	2202      	movs	r2, #2
 8025e06:	601a      	str	r2, [r3, #0]
					pause = 0;
 8025e08:	4b2d      	ldr	r3, [pc, #180]	; (8025ec0 <ForceClose+0x1dc>)
 8025e0a:	2200      	movs	r2, #0
 8025e0c:	601a      	str	r2, [r3, #0]
				else
				{
					WriteClutch(CLUTCH_LOCK);
				}
			}
				break;
 8025e0e:	e04d      	b.n	8025eac <ForceClose+0x1c8>
					WriteClutch(CLUTCH_LOCK);
 8025e10:	2000      	movs	r0, #0
 8025e12:	f7fd fae7 	bl	80233e4 <WriteClutch>
				break;
 8025e16:	e049      	b.n	8025eac <ForceClose+0x1c8>

			case 2:
			{
				WriteClutch(CLUTCH_LOCK);
 8025e18:	2000      	movs	r0, #0
 8025e1a:	f7fd fae3 	bl	80233e4 <WriteClutch>
				pause++;
 8025e1e:	4b28      	ldr	r3, [pc, #160]	; (8025ec0 <ForceClose+0x1dc>)
 8025e20:	681b      	ldr	r3, [r3, #0]
 8025e22:	3301      	adds	r3, #1
 8025e24:	4a26      	ldr	r2, [pc, #152]	; (8025ec0 <ForceClose+0x1dc>)
 8025e26:	6013      	str	r3, [r2, #0]

				if (pause >= 50)//Presets.HOMING_CLUTCH_LOCK_PAUSE)
 8025e28:	4b25      	ldr	r3, [pc, #148]	; (8025ec0 <ForceClose+0x1dc>)
 8025e2a:	681b      	ldr	r3, [r3, #0]
 8025e2c:	2b31      	cmp	r3, #49	; 0x31
 8025e2e:	dd1f      	ble.n	8025e70 <ForceClose+0x18c>
				{
					//MotorStop();
					drive.RAWPosition = 0;
 8025e30:	4b27      	ldr	r3, [pc, #156]	; (8025ed0 <ForceClose+0x1ec>)
 8025e32:	2200      	movs	r2, #0
 8025e34:	609a      	str	r2, [r3, #8]
					MotorSetPILimit(5);
 8025e36:	2005      	movs	r0, #5
 8025e38:	f7fc ff2f 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(100);
 8025e3c:	2064      	movs	r0, #100	; 0x64
 8025e3e:	f7fc ff12 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(1);
 8025e42:	2001      	movs	r0, #1
 8025e44:	f7fc ff1c 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 5);
 8025e48:	4b1e      	ldr	r3, [pc, #120]	; (8025ec4 <ForceClose+0x1e0>)
 8025e4a:	681a      	ldr	r2, [r3, #0]
 8025e4c:	4613      	mov	r3, r2
 8025e4e:	009b      	lsls	r3, r3, #2
 8025e50:	4413      	add	r3, r2
 8025e52:	4618      	mov	r0, r3
 8025e54:	f7fc fefc 	bl	8022c50 <MotorSetSpeed>
					result = 0; // success
 8025e58:	2300      	movs	r3, #0
 8025e5a:	60fb      	str	r3, [r7, #12]
					pause = 0;
 8025e5c:	4b18      	ldr	r3, [pc, #96]	; (8025ec0 <ForceClose+0x1dc>)
 8025e5e:	2200      	movs	r2, #0
 8025e60:	601a      	str	r2, [r3, #0]
					tim = 0;
 8025e62:	4b16      	ldr	r3, [pc, #88]	; (8025ebc <ForceClose+0x1d8>)
 8025e64:	2200      	movs	r2, #0
 8025e66:	601a      	str	r2, [r3, #0]
					state = 3;
 8025e68:	4b13      	ldr	r3, [pc, #76]	; (8025eb8 <ForceClose+0x1d4>)
 8025e6a:	2203      	movs	r2, #3
 8025e6c:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
				break;
 8025e6e:	e01d      	b.n	8025eac <ForceClose+0x1c8>
					result = 0;
 8025e70:	2300      	movs	r3, #0
 8025e72:	60fb      	str	r3, [r7, #12]
				break;
 8025e74:	e01a      	b.n	8025eac <ForceClose+0x1c8>
			case 3:
			{
				pause ++;
 8025e76:	4b12      	ldr	r3, [pc, #72]	; (8025ec0 <ForceClose+0x1dc>)
 8025e78:	681b      	ldr	r3, [r3, #0]
 8025e7a:	3301      	adds	r3, #1
 8025e7c:	4a10      	ldr	r2, [pc, #64]	; (8025ec0 <ForceClose+0x1dc>)
 8025e7e:	6013      	str	r3, [r2, #0]
				if (5 <= pause)
 8025e80:	4b0f      	ldr	r3, [pc, #60]	; (8025ec0 <ForceClose+0x1dc>)
 8025e82:	681b      	ldr	r3, [r3, #0]
 8025e84:	2b04      	cmp	r3, #4
 8025e86:	dd0b      	ble.n	8025ea0 <ForceClose+0x1bc>
				{
					pause = 0;
 8025e88:	4b0d      	ldr	r3, [pc, #52]	; (8025ec0 <ForceClose+0x1dc>)
 8025e8a:	2200      	movs	r2, #0
 8025e8c:	601a      	str	r2, [r3, #0]
					result = 1;
 8025e8e:	2301      	movs	r3, #1
 8025e90:	60fb      	str	r3, [r7, #12]
					//drive.RAWPosition = 0;
					tim = 0;
 8025e92:	4b0a      	ldr	r3, [pc, #40]	; (8025ebc <ForceClose+0x1d8>)
 8025e94:	2200      	movs	r2, #0
 8025e96:	601a      	str	r2, [r3, #0]
					state = 0;
 8025e98:	4b07      	ldr	r3, [pc, #28]	; (8025eb8 <ForceClose+0x1d4>)
 8025e9a:	2200      	movs	r2, #0
 8025e9c:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
			break;
 8025e9e:	e005      	b.n	8025eac <ForceClose+0x1c8>
					result = 0;
 8025ea0:	2300      	movs	r3, #0
 8025ea2:	60fb      	str	r3, [r7, #12]
			break;
 8025ea4:	e002      	b.n	8025eac <ForceClose+0x1c8>
			default:
				return -3; // bad case;
 8025ea6:	f06f 0302 	mvn.w	r3, #2
 8025eaa:	e000      	b.n	8025eae <ForceClose+0x1ca>

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025eac:	68fb      	ldr	r3, [r7, #12]
}
 8025eae:	4618      	mov	r0, r3
 8025eb0:	3710      	adds	r7, #16
 8025eb2:	46bd      	mov	sp, r7
 8025eb4:	bd80      	pop	{r7, pc}
 8025eb6:	bf00      	nop
 8025eb8:	20000764 	.word	0x20000764
 8025ebc:	20000768 	.word	0x20000768
 8025ec0:	2000076c 	.word	0x2000076c
 8025ec4:	20000770 	.word	0x20000770
 8025ec8:	20000fd0 	.word	0x20000fd0
 8025ecc:	2000062c 	.word	0x2000062c
 8025ed0:	20000600 	.word	0x20000600
 8025ed4:	20000704 	.word	0x20000704

08025ed8 <ReadAllPresets>:
/* ---------------------------------------------------------------------------*/

/* ---------------------------------------------------------------------------*/
/* Public Functions ----------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
void ReadAllPresets( const PresetsTypeDef *const pntrPresets ) {
 8025ed8:	b580      	push	{r7, lr}
 8025eda:	b082      	sub	sp, #8
 8025edc:	af00      	add	r7, sp, #0
 8025ede:	6078      	str	r0, [r7, #4]
	E_EEPROM_XMC4_ReadArray( 0, (uint8_t*)pntrPresets, sizeof(*pntrPresets) );
 8025ee0:	224c      	movs	r2, #76	; 0x4c
 8025ee2:	6879      	ldr	r1, [r7, #4]
 8025ee4:	2000      	movs	r0, #0
 8025ee6:	f000 f903 	bl	80260f0 <E_EEPROM_XMC4_ReadArray>
}
 8025eea:	bf00      	nop
 8025eec:	3708      	adds	r7, #8
 8025eee:	46bd      	mov	sp, r7
 8025ef0:	bd80      	pop	{r7, pc}

08025ef2 <SaveAllPresets>:
	E_EEPROM_XMC4_ReadArray( (uint16_t)offset, pntrParam, 4 ); // read 4 bytes (one parameter)
}



E_EEPROM_XMC4_STATUS_t SaveAllPresets( const PresetsTypeDef *const pntrPresets ) {
 8025ef2:	b580      	push	{r7, lr}
 8025ef4:	b082      	sub	sp, #8
 8025ef6:	af00      	add	r7, sp, #0
 8025ef8:	6078      	str	r0, [r7, #4]
	E_EEPROM_XMC4_WriteArray( 0, (uint8_t*)pntrPresets, sizeof(*pntrPresets) );
 8025efa:	224c      	movs	r2, #76	; 0x4c
 8025efc:	6879      	ldr	r1, [r7, #4]
 8025efe:	2000      	movs	r0, #0
 8025f00:	f000 f8c4 	bl	802608c <E_EEPROM_XMC4_WriteArray>
	return E_EEPROM_XMC4_UpdateFlashContents();
 8025f04:	f000 f91c 	bl	8026140 <E_EEPROM_XMC4_UpdateFlashContents>
 8025f08:	4603      	mov	r3, r0
}
 8025f0a:	4618      	mov	r0, r3
 8025f0c:	3708      	adds	r7, #8
 8025f0e:	46bd      	mov	sp, r7
 8025f10:	bd80      	pop	{r7, pc}
	...

08025f14 <XMC_FLASH_SetMargin>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
 8025f14:	b480      	push	{r7}
 8025f16:	b083      	sub	sp, #12
 8025f18:	af00      	add	r7, sp, #0
 8025f1a:	4603      	mov	r3, r0
 8025f1c:	71fb      	strb	r3, [r7, #7]
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 8025f1e:	4b09      	ldr	r3, [pc, #36]	; (8025f44 <XMC_FLASH_SetMargin+0x30>)
 8025f20:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8025f24:	699b      	ldr	r3, [r3, #24]
 8025f26:	f023 020f 	bic.w	r2, r3, #15
 8025f2a:	79fb      	ldrb	r3, [r7, #7]
 8025f2c:	4905      	ldr	r1, [pc, #20]	; (8025f44 <XMC_FLASH_SetMargin+0x30>)
 8025f2e:	4313      	orrs	r3, r2
 8025f30:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
 8025f34:	6193      	str	r3, [r2, #24]
}
 8025f36:	bf00      	nop
 8025f38:	370c      	adds	r7, #12
 8025f3a:	46bd      	mov	sp, r7
 8025f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025f40:	4770      	bx	lr
 8025f42:	bf00      	nop
 8025f44:	58001000 	.word	0x58001000

08025f48 <XMC_FLASH_EnableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_EnableDoubleBitErrorTrap(void)
{
 8025f48:	b480      	push	{r7}
 8025f4a:	af00      	add	r7, sp, #0
  FLASH0->MARP &= (uint32_t)~FLASH_MARP_TRAPDIS_Msk;
 8025f4c:	4b07      	ldr	r3, [pc, #28]	; (8025f6c <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 8025f4e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8025f52:	699b      	ldr	r3, [r3, #24]
 8025f54:	4a05      	ldr	r2, [pc, #20]	; (8025f6c <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 8025f56:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8025f5a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8025f5e:	6193      	str	r3, [r2, #24]
}
 8025f60:	bf00      	nop
 8025f62:	46bd      	mov	sp, r7
 8025f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025f68:	4770      	bx	lr
 8025f6a:	bf00      	nop
 8025f6c:	58001000 	.word	0x58001000

08025f70 <XMC_FLASH_DisableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_DisableDoubleBitErrorTrap(void)
{
 8025f70:	b480      	push	{r7}
 8025f72:	af00      	add	r7, sp, #0
  FLASH0->MARP |= FLASH_MARP_TRAPDIS_Msk;
 8025f74:	4b07      	ldr	r3, [pc, #28]	; (8025f94 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 8025f76:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8025f7a:	699b      	ldr	r3, [r3, #24]
 8025f7c:	4a05      	ldr	r2, [pc, #20]	; (8025f94 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 8025f7e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8025f82:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8025f86:	6193      	str	r3, [r2, #24]
}
 8025f88:	bf00      	nop
 8025f8a:	46bd      	mov	sp, r7
 8025f8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025f90:	4770      	bx	lr
 8025f92:	bf00      	nop
 8025f94:	58001000 	.word	0x58001000

08025f98 <XMC_FCE_InitializeSeedValue>:
 *
 * \par
 * The function sets the initial CRC (seed) value in the CRC register.
 */
__STATIC_INLINE void XMC_FCE_InitializeSeedValue(const XMC_FCE_t *const engine, uint32_t seedvalue)
{
 8025f98:	b480      	push	{r7}
 8025f9a:	b083      	sub	sp, #12
 8025f9c:	af00      	add	r7, sp, #0
 8025f9e:	6078      	str	r0, [r7, #4]
 8025fa0:	6039      	str	r1, [r7, #0]
  engine->kernel_ptr->CRC = seedvalue;
 8025fa2:	687b      	ldr	r3, [r7, #4]
 8025fa4:	681b      	ldr	r3, [r3, #0]
 8025fa6:	683a      	ldr	r2, [r7, #0]
 8025fa8:	619a      	str	r2, [r3, #24]
}
 8025faa:	bf00      	nop
 8025fac:	370c      	adds	r7, #12
 8025fae:	46bd      	mov	sp, r7
 8025fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025fb4:	4770      	bx	lr
	...

08025fb8 <E_EEPROM_XMC4_Init>:

/* ---------------------------------------------------------------------------*/
/* Public Functions ----------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 8025fb8:	b580      	push	{r7, lr}
 8025fba:	b084      	sub	sp, #16
 8025fbc:	af00      	add	r7, sp, #0
 8025fbe:	6078      	str	r0, [r7, #4]
  uint32_t sector_count;
  E_EEPROM_XMC4_STATUS_t status ;

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL));

  status = E_EEPROM_XMC4_STATUS_OK;
 8025fc0:	2300      	movs	r3, #0
 8025fc2:	72fb      	strb	r3, [r7, #11]

  if (handle->initialized == (bool)false)
 8025fc4:	687b      	ldr	r3, [r7, #4]
 8025fc6:	781b      	ldrb	r3, [r3, #0]
 8025fc8:	f083 0301 	eor.w	r3, r3, #1
 8025fcc:	b2db      	uxtb	r3, r3
 8025fce:	2b00      	cmp	r3, #0
 8025fd0:	d04c      	beq.n	802606c <E_EEPROM_XMC4_Init+0xb4>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 8025fd2:	4b29      	ldr	r3, [pc, #164]	; (8026078 <E_EEPROM_XMC4_Init+0xc0>)
 8025fd4:	2200      	movs	r2, #0
 8025fd6:	605a      	str	r2, [r3, #4]
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8025fd8:	4b28      	ldr	r3, [pc, #160]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 8025fda:	2200      	movs	r2, #0
 8025fdc:	605a      	str	r2, [r3, #4]

    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_TIGHT0);
 8025fde:	2001      	movs	r0, #1
 8025fe0:	f7ff ff98 	bl	8025f14 <XMC_FLASH_SetMargin>
    XMC_FLASH_DisableDoubleBitErrorTrap();
 8025fe4:	f7ff ffc4 	bl	8025f70 <XMC_FLASH_DisableDoubleBitErrorTrap>

    XMC_FCE_Enable();
 8025fe8:	f002 f996 	bl	8028318 <XMC_FCE_Enable>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8025fec:	4824      	ldr	r0, [pc, #144]	; (8026080 <E_EEPROM_XMC4_Init+0xc8>)
 8025fee:	f002 f97e 	bl	80282ee <XMC_FCE_Init>

    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8025ff2:	2300      	movs	r3, #0
 8025ff4:	60fb      	str	r3, [r7, #12]
 8025ff6:	e005      	b.n	8026004 <E_EEPROM_XMC4_Init+0x4c>
    {
      E_EEPROM_XMC4_lInitReadSectorInfo(sector_count);
 8025ff8:	68f8      	ldr	r0, [r7, #12]
 8025ffa:	f000 f945 	bl	8026288 <E_EEPROM_XMC4_lInitReadSectorInfo>
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8025ffe:	68fb      	ldr	r3, [r7, #12]
 8026000:	3301      	adds	r3, #1
 8026002:	60fb      	str	r3, [r7, #12]
 8026004:	68fb      	ldr	r3, [r7, #12]
 8026006:	2b03      	cmp	r3, #3
 8026008:	d9f6      	bls.n	8025ff8 <E_EEPROM_XMC4_Init+0x40>
    }

    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_DEFAULT);
 802600a:	2000      	movs	r0, #0
 802600c:	f7ff ff82 	bl	8025f14 <XMC_FLASH_SetMargin>

    /* Implement the OVER ERASE CHECK code here and return the status*/

    /* If Read was successful*/
    if (status == E_EEPROM_XMC4_STATUS_OK)
 8026010:	7afb      	ldrb	r3, [r7, #11]
 8026012:	2b00      	cmp	r3, #0
 8026014:	d125      	bne.n	8026062 <E_EEPROM_XMC4_Init+0xaa>
    {
      /* Execute erase state machine to free up the unwanted sectors and keep
       * only the sector which has latest valid block. If no valid block found then all sectors are emptied.
       */
      status = E_EEPROM_XMC4_lInitEraseStateMachine();
 8026016:	f000 f98f 	bl	8026338 <E_EEPROM_XMC4_lInitEraseStateMachine>
 802601a:	4603      	mov	r3, r0
 802601c:	72fb      	strb	r3, [r7, #11]

      /* If erase operations were successful, continue block data updates to RAM buffer */
      if (status == E_EEPROM_XMC4_STATUS_OK)
 802601e:	7afb      	ldrb	r3, [r7, #11]
 8026020:	2b00      	cmp	r3, #0
 8026022:	d11e      	bne.n	8026062 <E_EEPROM_XMC4_Init+0xaa>
      {

        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
 8026024:	4b15      	ldr	r3, [pc, #84]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 8026026:	685b      	ldr	r3, [r3, #4]
 8026028:	2b00      	cmp	r3, #0
 802602a:	d106      	bne.n	802603a <E_EEPROM_XMC4_Init+0x82>
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
 802602c:	4b13      	ldr	r3, [pc, #76]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 802602e:	2200      	movs	r2, #0
 8026030:	609a      	str	r2, [r3, #8]
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8026032:	4b12      	ldr	r3, [pc, #72]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 8026034:	4a13      	ldr	r2, [pc, #76]	; (8026084 <E_EEPROM_XMC4_Init+0xcc>)
 8026036:	601a      	str	r2, [r3, #0]
 8026038:	e013      	b.n	8026062 <E_EEPROM_XMC4_Init+0xaa>
        }
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
 802603a:	f000 f9d5 	bl	80263e8 <E_EEPROM_XMC4_lCopyFlashToRam>

          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 802603e:	4b0f      	ldr	r3, [pc, #60]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 8026040:	681a      	ldr	r2, [r3, #0]
 8026042:	4b0e      	ldr	r3, [pc, #56]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 8026044:	685b      	ldr	r3, [r3, #4]
 8026046:	1ad3      	subs	r3, r2, r3
 8026048:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 802604c:	d001      	beq.n	8026052 <E_EEPROM_XMC4_Init+0x9a>
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
 802604e:	2301      	movs	r3, #1
 8026050:	72fb      	strb	r3, [r7, #11]
          }

          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8026052:	4b0a      	ldr	r3, [pc, #40]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 8026054:	681b      	ldr	r3, [r3, #0]
 8026056:	4a0c      	ldr	r2, [pc, #48]	; (8026088 <E_EEPROM_XMC4_Init+0xd0>)
 8026058:	4293      	cmp	r3, r2
 802605a:	d902      	bls.n	8026062 <E_EEPROM_XMC4_Init+0xaa>
          {
            e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 802605c:	4b07      	ldr	r3, [pc, #28]	; (802607c <E_EEPROM_XMC4_Init+0xc4>)
 802605e:	4a09      	ldr	r2, [pc, #36]	; (8026084 <E_EEPROM_XMC4_Init+0xcc>)
 8026060:	601a      	str	r2, [r3, #0]

        }
      }
    }

    XMC_FLASH_EnableDoubleBitErrorTrap();
 8026062:	f7ff ff71 	bl	8025f48 <XMC_FLASH_EnableDoubleBitErrorTrap>

    handle->initialized = (bool)true;
 8026066:	687b      	ldr	r3, [r7, #4]
 8026068:	2201      	movs	r2, #1
 802606a:	701a      	strb	r2, [r3, #0]
  }

  return (status);
 802606c:	7afb      	ldrb	r3, [r7, #11]
}
 802606e:	4618      	mov	r0, r3
 8026070:	3710      	adds	r7, #16
 8026072:	46bd      	mov	sp, r7
 8026074:	bd80      	pop	{r7, pc}
 8026076:	bf00      	nop
 8026078:	200007bc 	.word	0x200007bc
 802607c:	20000258 	.word	0x20000258
 8026080:	0802b268 	.word	0x0802b268
 8026084:	0c010000 	.word	0x0c010000
 8026088:	0c01ffff 	.word	0x0c01ffff

0802608c <E_EEPROM_XMC4_WriteArray>:



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 802608c:	b580      	push	{r7, lr}
 802608e:	b086      	sub	sp, #24
 8026090:	af00      	add	r7, sp, #0
 8026092:	4603      	mov	r3, r0
 8026094:	6039      	str	r1, [r7, #0]
 8026096:	80fb      	strh	r3, [r7, #6]
 8026098:	4613      	mov	r3, r2
 802609a:	80bb      	strh	r3, [r7, #4]
  bool status;

  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length", ((offset_address + length) <= E_EEPROM_XMC4_DATA_BLOCK_SIZE));

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 802609c:	88fb      	ldrh	r3, [r7, #6]
 802609e:	4a13      	ldr	r2, [pc, #76]	; (80260ec <E_EEPROM_XMC4_WriteArray+0x60>)
 80260a0:	4413      	add	r3, r2
 80260a2:	613b      	str	r3, [r7, #16]
  status = (memcmp(address_ptr, data, length) != 0);
 80260a4:	88bb      	ldrh	r3, [r7, #4]
 80260a6:	461a      	mov	r2, r3
 80260a8:	6839      	ldr	r1, [r7, #0]
 80260aa:	6938      	ldr	r0, [r7, #16]
 80260ac:	f005 f832 	bl	802b114 <memcmp>
 80260b0:	4603      	mov	r3, r0
 80260b2:	2b00      	cmp	r3, #0
 80260b4:	bf14      	ite	ne
 80260b6:	2301      	movne	r3, #1
 80260b8:	2300      	moveq	r3, #0
 80260ba:	73fb      	strb	r3, [r7, #15]

  for (i = 0U; i < length; i++)
 80260bc:	2300      	movs	r3, #0
 80260be:	82fb      	strh	r3, [r7, #22]
 80260c0:	e00a      	b.n	80260d8 <E_EEPROM_XMC4_WriteArray+0x4c>
  {
      *(address_ptr + i) = *(data + i);
 80260c2:	8afb      	ldrh	r3, [r7, #22]
 80260c4:	683a      	ldr	r2, [r7, #0]
 80260c6:	441a      	add	r2, r3
 80260c8:	8afb      	ldrh	r3, [r7, #22]
 80260ca:	6939      	ldr	r1, [r7, #16]
 80260cc:	440b      	add	r3, r1
 80260ce:	7812      	ldrb	r2, [r2, #0]
 80260d0:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < length; i++)
 80260d2:	8afb      	ldrh	r3, [r7, #22]
 80260d4:	3301      	adds	r3, #1
 80260d6:	82fb      	strh	r3, [r7, #22]
 80260d8:	8afa      	ldrh	r2, [r7, #22]
 80260da:	88bb      	ldrh	r3, [r7, #4]
 80260dc:	429a      	cmp	r2, r3
 80260de:	d3f0      	bcc.n	80260c2 <E_EEPROM_XMC4_WriteArray+0x36>
  }

  return status;
 80260e0:	7bfb      	ldrb	r3, [r7, #15]
}
 80260e2:	4618      	mov	r0, r3
 80260e4:	3718      	adds	r7, #24
 80260e6:	46bd      	mov	sp, r7
 80260e8:	bd80      	pop	{r7, pc}
 80260ea:	bf00      	nop
 80260ec:	200007c4 	.word	0x200007c4

080260f0 <E_EEPROM_XMC4_ReadArray>:



/* Read a set of bytes from RAM Buffer */
void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length)
{
 80260f0:	b480      	push	{r7}
 80260f2:	b085      	sub	sp, #20
 80260f4:	af00      	add	r7, sp, #0
 80260f6:	4603      	mov	r3, r0
 80260f8:	6039      	str	r1, [r7, #0]
 80260fa:	80fb      	strh	r3, [r7, #6]
 80260fc:	4613      	mov	r3, r2
 80260fe:	80bb      	strh	r3, [r7, #4]
  uint16_t i;
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length", ((offset_address + length) <= E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8026100:	88fb      	ldrh	r3, [r7, #6]
 8026102:	4a0e      	ldr	r2, [pc, #56]	; (802613c <E_EEPROM_XMC4_ReadArray+0x4c>)
 8026104:	4413      	add	r3, r2
 8026106:	60bb      	str	r3, [r7, #8]

  for (i=0U; i<length; i++)
 8026108:	2300      	movs	r3, #0
 802610a:	81fb      	strh	r3, [r7, #14]
 802610c:	e00a      	b.n	8026124 <E_EEPROM_XMC4_ReadArray+0x34>
  {
    *(data + i) = *(address_ptr + i);
 802610e:	89fb      	ldrh	r3, [r7, #14]
 8026110:	68ba      	ldr	r2, [r7, #8]
 8026112:	441a      	add	r2, r3
 8026114:	89fb      	ldrh	r3, [r7, #14]
 8026116:	6839      	ldr	r1, [r7, #0]
 8026118:	440b      	add	r3, r1
 802611a:	7812      	ldrb	r2, [r2, #0]
 802611c:	701a      	strb	r2, [r3, #0]
  for (i=0U; i<length; i++)
 802611e:	89fb      	ldrh	r3, [r7, #14]
 8026120:	3301      	adds	r3, #1
 8026122:	81fb      	strh	r3, [r7, #14]
 8026124:	89fa      	ldrh	r2, [r7, #14]
 8026126:	88bb      	ldrh	r3, [r7, #4]
 8026128:	429a      	cmp	r2, r3
 802612a:	d3f0      	bcc.n	802610e <E_EEPROM_XMC4_ReadArray+0x1e>
  }
}
 802612c:	bf00      	nop
 802612e:	bf00      	nop
 8026130:	3714      	adds	r7, #20
 8026132:	46bd      	mov	sp, r7
 8026134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026138:	4770      	bx	lr
 802613a:	bf00      	nop
 802613c:	200007c4 	.word	0x200007c4

08026140 <E_EEPROM_XMC4_UpdateFlashContents>:



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 8026140:	b580      	push	{r7, lr}
 8026142:	b082      	sub	sp, #8
 8026144:	af00      	add	r7, sp, #0
  E_EEPROM_XMC4_STATUS_t status;
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;
 8026146:	2300      	movs	r3, #0
 8026148:	71fb      	strb	r3, [r7, #7]

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);
 802614a:	4b22      	ldr	r3, [pc, #136]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802614c:	689b      	ldr	r3, [r3, #8]
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 802614e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8026152:	3304      	adds	r3, #4
 8026154:	039b      	lsls	r3, r3, #14
 8026156:	603b      	str	r3, [r7, #0]

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026158:	4b1e      	ldr	r3, [pc, #120]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802615a:	681b      	ldr	r3, [r3, #0]
 802615c:	683a      	ldr	r2, [r7, #0]
 802615e:	429a      	cmp	r2, r3
 8026160:	d111      	bne.n	8026186 <E_EEPROM_XMC4_UpdateFlashContents+0x46>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 8026162:	4b1d      	ldr	r3, [pc, #116]	; (80261d8 <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8026164:	685b      	ldr	r3, [r3, #4]
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026166:	2b00      	cmp	r3, #0
 8026168:	d00d      	beq.n	8026186 <E_EEPROM_XMC4_UpdateFlashContents+0x46>
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 802616a:	4b1a      	ldr	r3, [pc, #104]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802616c:	685b      	ldr	r3, [r3, #4]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
 802616e:	0b9b      	lsrs	r3, r3, #14
 8026170:	f003 0303 	and.w	r3, r3, #3
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 8026174:	4a17      	ldr	r2, [pc, #92]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8026176:	6093      	str	r3, [r2, #8]
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 8026178:	4b16      	ldr	r3, [pc, #88]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802617a:	220f      	movs	r2, #15
 802617c:	60da      	str	r2, [r3, #12]

    /* Execute erase state machine to free up the unwanted sectors and keep only the sector which has latest block*/
    status = E_EEPROM_XMC4_lInitEraseStateMachine();
 802617e:	f000 f8db 	bl	8026338 <E_EEPROM_XMC4_lInitEraseStateMachine>
 8026182:	4603      	mov	r3, r0
 8026184:	71fb      	strb	r3, [r7, #7]
  }

  if (status ==  E_EEPROM_XMC4_STATUS_OK)
 8026186:	79fb      	ldrb	r3, [r7, #7]
 8026188:	2b00      	cmp	r3, #0
 802618a:	d11d      	bne.n	80261c8 <E_EEPROM_XMC4_UpdateFlashContents+0x88>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count++;
 802618c:	4b12      	ldr	r3, [pc, #72]	; (80261d8 <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 802618e:	685b      	ldr	r3, [r3, #4]
 8026190:	3301      	adds	r3, #1
 8026192:	4a11      	ldr	r2, [pc, #68]	; (80261d8 <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8026194:	6053      	str	r3, [r2, #4]

    status = E_EEPROM_XMC4_lWriteToFlash();
 8026196:	f000 f839 	bl	802620c <E_EEPROM_XMC4_lWriteToFlash>
 802619a:	4603      	mov	r3, r0
 802619c:	71fb      	strb	r3, [r7, #7]

    /* If the flash write succeeds, update the latest flash data location in RAM for reference */
    if (status == E_EEPROM_XMC4_STATUS_OK)
 802619e:	79fb      	ldrb	r3, [r7, #7]
 80261a0:	2b00      	cmp	r3, #0
 80261a2:	d103      	bne.n	80261ac <E_EEPROM_XMC4_UpdateFlashContents+0x6c>
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
 80261a4:	4b0b      	ldr	r3, [pc, #44]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80261a6:	681b      	ldr	r3, [r3, #0]
 80261a8:	4a0a      	ldr	r2, [pc, #40]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80261aa:	6053      	str	r3, [r2, #4]
    }

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 80261ac:	4b09      	ldr	r3, [pc, #36]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80261ae:	681b      	ldr	r3, [r3, #0]
 80261b0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80261b4:	4a07      	ldr	r2, [pc, #28]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80261b6:	6013      	str	r3, [r2, #0]

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 80261b8:	4b06      	ldr	r3, [pc, #24]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80261ba:	681b      	ldr	r3, [r3, #0]
 80261bc:	4a07      	ldr	r2, [pc, #28]	; (80261dc <E_EEPROM_XMC4_UpdateFlashContents+0x9c>)
 80261be:	4293      	cmp	r3, r2
 80261c0:	d902      	bls.n	80261c8 <E_EEPROM_XMC4_UpdateFlashContents+0x88>
    {
      e_eeprom_xmc4_sector_info.next_free_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR;
 80261c2:	4b04      	ldr	r3, [pc, #16]	; (80261d4 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80261c4:	4a06      	ldr	r2, [pc, #24]	; (80261e0 <E_EEPROM_XMC4_UpdateFlashContents+0xa0>)
 80261c6:	601a      	str	r2, [r3, #0]
    }
  }

  return (status);
 80261c8:	79fb      	ldrb	r3, [r7, #7]
}
 80261ca:	4618      	mov	r0, r3
 80261cc:	3708      	adds	r7, #8
 80261ce:	46bd      	mov	sp, r7
 80261d0:	bd80      	pop	{r7, pc}
 80261d2:	bf00      	nop
 80261d4:	20000258 	.word	0x20000258
 80261d8:	200007bc 	.word	0x200007bc
 80261dc:	0c01ffff 	.word	0x0c01ffff
 80261e0:	0c010000 	.word	0x0c010000

080261e4 <E_EEPROM_XMC4_IsFlashEmpty>:


/* Check the availability data in the flash emulated EEPROM area */
bool E_EEPROM_XMC4_IsFlashEmpty(void)
{
 80261e4:	b480      	push	{r7}
 80261e6:	b083      	sub	sp, #12
 80261e8:	af00      	add	r7, sp, #0
  bool status = false;
 80261ea:	2300      	movs	r3, #0
 80261ec:	71fb      	strb	r3, [r7, #7]

  /* If data available flash_data_addr will have a valid address*/
  if (e_eeprom_xmc4_sector_info.flash_data_addr == 0U)
 80261ee:	4b06      	ldr	r3, [pc, #24]	; (8026208 <E_EEPROM_XMC4_IsFlashEmpty+0x24>)
 80261f0:	685b      	ldr	r3, [r3, #4]
 80261f2:	2b00      	cmp	r3, #0
 80261f4:	d101      	bne.n	80261fa <E_EEPROM_XMC4_IsFlashEmpty+0x16>
  {
    status = true;
 80261f6:	2301      	movs	r3, #1
 80261f8:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 80261fa:	79fb      	ldrb	r3, [r7, #7]
}
 80261fc:	4618      	mov	r0, r3
 80261fe:	370c      	adds	r7, #12
 8026200:	46bd      	mov	sp, r7
 8026202:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026206:	4770      	bx	lr
 8026208:	20000258 	.word	0x20000258

0802620c <E_EEPROM_XMC4_lWriteToFlash>:
/* Private Functions ---------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/

/* Local function to program data blocks from RAM into FLASH */
static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lWriteToFlash(void)
{
 802620c:	b580      	push	{r7, lr}
 802620e:	b084      	sub	sp, #16
 8026210:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
 8026212:	2300      	movs	r3, #0
 8026214:	70fb      	strb	r3, [r7, #3]
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
 8026216:	4b18      	ldr	r3, [pc, #96]	; (8026278 <E_EEPROM_XMC4_lWriteToFlash+0x6c>)
 8026218:	681b      	ldr	r3, [r3, #0]
 802621a:	60fb      	str	r3, [r7, #12]
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 802621c:	4b17      	ldr	r3, [pc, #92]	; (802627c <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 802621e:	60bb      	str	r3, [r7, #8]

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
 8026220:	4817      	ldr	r0, [pc, #92]	; (8026280 <E_EEPROM_XMC4_lWriteToFlash+0x74>)
 8026222:	f000 f8c9 	bl	80263b8 <E_EEPROM_XMC4_lCalculateCRC>
 8026226:	4603      	mov	r3, r0
 8026228:	4a14      	ldr	r2, [pc, #80]	; (802627c <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 802622a:	6013      	str	r3, [r2, #0]
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 802622c:	2300      	movs	r3, #0
 802622e:	607b      	str	r3, [r7, #4]
 8026230:	e01a      	b.n	8026268 <E_EEPROM_XMC4_lWriteToFlash+0x5c>
  {
    XMC_FLASH_ClearStatus();
 8026232:	f000 f989 	bl	8026548 <XMC_FLASH_ClearStatus>

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);
 8026236:	68b9      	ldr	r1, [r7, #8]
 8026238:	68f8      	ldr	r0, [r7, #12]
 802623a:	f000 f999 	bl	8026570 <XMC_FLASH_ProgramPage>

    if ((XMC_FLASH_GetStatus() & (uint32_t)(XMC_FLASH_STATUS_VERIFY_ERROR | XMC_FLASH_STATUS_OPERATION_ERROR)) != 0)
 802623e:	f000 f989 	bl	8026554 <XMC_FLASH_GetStatus>
 8026242:	4602      	mov	r2, r0
 8026244:	4b0f      	ldr	r3, [pc, #60]	; (8026284 <E_EEPROM_XMC4_lWriteToFlash+0x78>)
 8026246:	4013      	ands	r3, r2
 8026248:	2b00      	cmp	r3, #0
 802624a:	d002      	beq.n	8026252 <E_EEPROM_XMC4_lWriteToFlash+0x46>
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
 802624c:	2303      	movs	r3, #3
 802624e:	70fb      	strb	r3, [r7, #3]
      break;
 8026250:	e00d      	b.n	802626e <E_EEPROM_XMC4_lWriteToFlash+0x62>
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 8026252:	68bb      	ldr	r3, [r7, #8]
 8026254:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8026258:	60bb      	str	r3, [r7, #8]
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 802625a:	68fb      	ldr	r3, [r7, #12]
 802625c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8026260:	60fb      	str	r3, [r7, #12]
  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 8026262:	687b      	ldr	r3, [r7, #4]
 8026264:	3301      	adds	r3, #1
 8026266:	607b      	str	r3, [r7, #4]
 8026268:	687b      	ldr	r3, [r7, #4]
 802626a:	2b07      	cmp	r3, #7
 802626c:	d9e1      	bls.n	8026232 <E_EEPROM_XMC4_lWriteToFlash+0x26>
  }

  return (status);
 802626e:	78fb      	ldrb	r3, [r7, #3]
}
 8026270:	4618      	mov	r0, r3
 8026272:	3710      	adds	r7, #16
 8026274:	46bd      	mov	sp, r7
 8026276:	bd80      	pop	{r7, pc}
 8026278:	20000258 	.word	0x20000258
 802627c:	200007bc 	.word	0x200007bc
 8026280:	200007c0 	.word	0x200007c0
 8026284:	80000100 	.word	0x80000100

08026288 <E_EEPROM_XMC4_lInitReadSectorInfo>:



static void E_EEPROM_XMC4_lInitReadSectorInfo(const uint32_t sector)
{
 8026288:	b580      	push	{r7, lr}
 802628a:	b08a      	sub	sp, #40	; 0x28
 802628c:	af00      	add	r7, sp, #0
 802628e:	6078      	str	r0, [r7, #4]
  uint32_t block_cycle_count;
  uint32_t written_crc;
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
 8026290:	687b      	ldr	r3, [r7, #4]
 8026292:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8026296:	3304      	adds	r3, #4
 8026298:	039b      	lsls	r3, r3, #14
 802629a:	61fb      	str	r3, [r7, #28]
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 802629c:	69fb      	ldr	r3, [r7, #28]
 802629e:	f503 5360 	add.w	r3, r3, #14336	; 0x3800
 80262a2:	627b      	str	r3, [r7, #36]	; 0x24
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 80262a4:	2300      	movs	r3, #0
 80262a6:	623b      	str	r3, [r7, #32]

  do
  {
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
 80262a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80262aa:	61bb      	str	r3, [r7, #24]
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 80262ac:	69bb      	ldr	r3, [r7, #24]
 80262ae:	685b      	ldr	r3, [r3, #4]
 80262b0:	617b      	str	r3, [r7, #20]

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
 80262b2:	697b      	ldr	r3, [r7, #20]
 80262b4:	2b00      	cmp	r3, #0
 80262b6:	d02e      	beq.n	8026316 <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 80262b8:	4b1d      	ldr	r3, [pc, #116]	; (8026330 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 80262ba:	68da      	ldr	r2, [r3, #12]
 80262bc:	2101      	movs	r1, #1
 80262be:	687b      	ldr	r3, [r7, #4]
 80262c0:	fa01 f303 	lsl.w	r3, r1, r3
 80262c4:	4313      	orrs	r3, r2
 80262c6:	4a1a      	ldr	r2, [pc, #104]	; (8026330 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 80262c8:	60d3      	str	r3, [r2, #12]

      /* If this is the first non empty block identified, then store the address as next free address */
      if (free_block_addr == E_EEPROM_XMC4_EMPTY)
 80262ca:	6a3b      	ldr	r3, [r7, #32]
 80262cc:	2b00      	cmp	r3, #0
 80262ce:	d103      	bne.n	80262d8 <E_EEPROM_XMC4_lInitReadSectorInfo+0x50>
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 80262d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80262d2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80262d6:	623b      	str	r3, [r7, #32]
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 80262d8:	69bb      	ldr	r3, [r7, #24]
 80262da:	681b      	ldr	r3, [r3, #0]
 80262dc:	613b      	str	r3, [r7, #16]
      /* Calculate the CRC for the written data in flash (3rd word to the last word)*/
      calculated_crc = E_EEPROM_XMC4_lCalculateCRC(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 80262de:	69bb      	ldr	r3, [r7, #24]
 80262e0:	3304      	adds	r3, #4
 80262e2:	4618      	mov	r0, r3
 80262e4:	f000 f868 	bl	80263b8 <E_EEPROM_XMC4_lCalculateCRC>
 80262e8:	60f8      	str	r0, [r7, #12]

      if (calculated_crc == written_crc)
 80262ea:	68fa      	ldr	r2, [r7, #12]
 80262ec:	693b      	ldr	r3, [r7, #16]
 80262ee:	429a      	cmp	r2, r3
 80262f0:	d111      	bne.n	8026316 <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
      {
        /* If both CRC matches and the current block cycle counter is greater than the previous recorded value,
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
 80262f2:	4b10      	ldr	r3, [pc, #64]	; (8026334 <E_EEPROM_XMC4_lInitReadSectorInfo+0xac>)
 80262f4:	685b      	ldr	r3, [r3, #4]
 80262f6:	697a      	ldr	r2, [r7, #20]
 80262f8:	429a      	cmp	r2, r3
 80262fa:	d90c      	bls.n	8026316 <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 80262fc:	4a0d      	ldr	r2, [pc, #52]	; (8026334 <E_EEPROM_XMC4_lInitReadSectorInfo+0xac>)
 80262fe:	697b      	ldr	r3, [r7, #20]
 8026300:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.current_sector = sector;
 8026302:	4a0b      	ldr	r2, [pc, #44]	; (8026330 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8026304:	687b      	ldr	r3, [r7, #4]
 8026306:	6093      	str	r3, [r2, #8]
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
 8026308:	4a09      	ldr	r2, [pc, #36]	; (8026330 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 802630a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802630c:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.next_free_start_addr = free_block_addr;
 802630e:	4a08      	ldr	r2, [pc, #32]	; (8026330 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8026310:	6a3b      	ldr	r3, [r7, #32]
 8026312:	6013      	str	r3, [r2, #0]
          break;
 8026314:	e008      	b.n	8026328 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa0>
        }
      }
    }
    /* Move the block read address to one block size up starting from the bottom of sector */
    block_read_addr -= E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026316:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026318:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 802631c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Iterate the read process until the block read address crosses sector start address or a
   * latest valid block is identified.
   */
  } while ( block_read_addr >= sector_start_addr );
 802631e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8026320:	69fb      	ldr	r3, [r7, #28]
 8026322:	429a      	cmp	r2, r3
 8026324:	d2c0      	bcs.n	80262a8 <E_EEPROM_XMC4_lInitReadSectorInfo+0x20>

}
 8026326:	bf00      	nop
 8026328:	bf00      	nop
 802632a:	3728      	adds	r7, #40	; 0x28
 802632c:	46bd      	mov	sp, r7
 802632e:	bd80      	pop	{r7, pc}
 8026330:	20000258 	.word	0x20000258
 8026334:	200007bc 	.word	0x200007bc

08026338 <E_EEPROM_XMC4_lInitEraseStateMachine>:



static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lInitEraseStateMachine(void)
{
 8026338:	b580      	push	{r7, lr}
 802633a:	b084      	sub	sp, #16
 802633c:	af00      	add	r7, sp, #0
  uint32_t sector_count;
  uint32_t sector_start_addr;
  E_EEPROM_XMC4_STATUS_t status ;

  status = E_EEPROM_XMC4_STATUS_OK;
 802633e:	2300      	movs	r3, #0
 8026340:	72fb      	strb	r3, [r7, #11]
  sector_count = 0U;
 8026342:	2300      	movs	r3, #0
 8026344:	60fb      	str	r3, [r7, #12]

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026346:	4b1b      	ldr	r3, [pc, #108]	; (80263b4 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 8026348:	689b      	ldr	r3, [r3, #8]
 802634a:	68fa      	ldr	r2, [r7, #12]
 802634c:	429a      	cmp	r2, r3
 802634e:	d026      	beq.n	802639e <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026350:	4b18      	ldr	r3, [pc, #96]	; (80263b4 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 8026352:	68da      	ldr	r2, [r3, #12]
 8026354:	68fb      	ldr	r3, [r7, #12]
 8026356:	fa22 f303 	lsr.w	r3, r2, r3
 802635a:	f003 0301 	and.w	r3, r3, #1
 802635e:	2b00      	cmp	r3, #0
 8026360:	d01d      	beq.n	802639e <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);
 8026362:	68fb      	ldr	r3, [r7, #12]
 8026364:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8026368:	3304      	adds	r3, #4
 802636a:	039b      	lsls	r3, r3, #14
 802636c:	607b      	str	r3, [r7, #4]

        XMC_FLASH_ClearStatus();
 802636e:	f000 f8eb 	bl	8026548 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026372:	687b      	ldr	r3, [r7, #4]
 8026374:	4618      	mov	r0, r3
 8026376:	f000 f92f 	bl	80265d8 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 802637a:	f000 f8eb 	bl	8026554 <XMC_FLASH_GetStatus>
 802637e:	4603      	mov	r3, r0
 8026380:	2b20      	cmp	r3, #32
 8026382:	d002      	beq.n	802638a <E_EEPROM_XMC4_lInitEraseStateMachine+0x52>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8026384:	2304      	movs	r3, #4
 8026386:	72fb      	strb	r3, [r7, #11]
          break;
 8026388:	e00f      	b.n	80263aa <E_EEPROM_XMC4_lInitEraseStateMachine+0x72>
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 802638a:	4b0a      	ldr	r3, [pc, #40]	; (80263b4 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 802638c:	68da      	ldr	r2, [r3, #12]
 802638e:	2101      	movs	r1, #1
 8026390:	68fb      	ldr	r3, [r7, #12]
 8026392:	fa01 f303 	lsl.w	r3, r1, r3
 8026396:	43db      	mvns	r3, r3
 8026398:	4013      	ands	r3, r2
 802639a:	4a06      	ldr	r2, [pc, #24]	; (80263b4 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 802639c:	60d3      	str	r3, [r2, #12]
      }
    }
    sector_count++;
 802639e:	68fb      	ldr	r3, [r7, #12]
 80263a0:	3301      	adds	r3, #1
 80263a2:	60fb      	str	r3, [r7, #12]
    /* Iterate the erase loop until all 4 sectors are checked. Break and return failure on any sector erase errors.*/
  } while ( sector_count < E_EEPROM_XMC4_MAX_SECTORS );
 80263a4:	68fb      	ldr	r3, [r7, #12]
 80263a6:	2b03      	cmp	r3, #3
 80263a8:	d9cd      	bls.n	8026346 <E_EEPROM_XMC4_lInitEraseStateMachine+0xe>

  return (status);
 80263aa:	7afb      	ldrb	r3, [r7, #11]
}
 80263ac:	4618      	mov	r0, r3
 80263ae:	3710      	adds	r7, #16
 80263b0:	46bd      	mov	sp, r7
 80263b2:	bd80      	pop	{r7, pc}
 80263b4:	20000258 	.word	0x20000258

080263b8 <E_EEPROM_XMC4_lCalculateCRC>:

/* Local function to CRC */
static uint32_t E_EEPROM_XMC4_lCalculateCRC(const uint32_t *data_start_addr)
{
 80263b8:	b580      	push	{r7, lr}
 80263ba:	b084      	sub	sp, #16
 80263bc:	af00      	add	r7, sp, #0
 80263be:	6078      	str	r0, [r7, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);
 80263c0:	2100      	movs	r1, #0
 80263c2:	4808      	ldr	r0, [pc, #32]	; (80263e4 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 80263c4:	f7ff fde8 	bl	8025f98 <XMC_FCE_InitializeSeedValue>

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 80263c8:	f107 030c 	add.w	r3, r7, #12
 80263cc:	f240 72fc 	movw	r2, #2044	; 0x7fc
 80263d0:	6879      	ldr	r1, [r7, #4]
 80263d2:	4804      	ldr	r0, [pc, #16]	; (80263e4 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 80263d4:	f001 ffb2 	bl	802833c <XMC_FCE_CalculateCRC32>

  return (result);
 80263d8:	68fb      	ldr	r3, [r7, #12]
}
 80263da:	4618      	mov	r0, r3
 80263dc:	3710      	adds	r7, #16
 80263de:	46bd      	mov	sp, r7
 80263e0:	bd80      	pop	{r7, pc}
 80263e2:	bf00      	nop
 80263e4:	0802b268 	.word	0x0802b268

080263e8 <E_EEPROM_XMC4_lCopyFlashToRam>:



/* Local function to copy data blocks from FLASH to RAM */
static void E_EEPROM_XMC4_lCopyFlashToRam(void)
{
 80263e8:	b480      	push	{r7}
 80263ea:	b085      	sub	sp, #20
 80263ec:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
 80263ee:	4b10      	ldr	r3, [pc, #64]	; (8026430 <E_EEPROM_XMC4_lCopyFlashToRam+0x48>)
 80263f0:	685b      	ldr	r3, [r3, #4]
 80263f2:	60bb      	str	r3, [r7, #8]
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 80263f4:	4b0f      	ldr	r3, [pc, #60]	; (8026434 <E_EEPROM_XMC4_lCopyFlashToRam+0x4c>)
 80263f6:	607b      	str	r3, [r7, #4]

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 80263f8:	2300      	movs	r3, #0
 80263fa:	60fb      	str	r3, [r7, #12]
 80263fc:	e00c      	b.n	8026418 <E_EEPROM_XMC4_lCopyFlashToRam+0x30>
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
 80263fe:	68fb      	ldr	r3, [r7, #12]
 8026400:	009b      	lsls	r3, r3, #2
 8026402:	68ba      	ldr	r2, [r7, #8]
 8026404:	441a      	add	r2, r3
 8026406:	68fb      	ldr	r3, [r7, #12]
 8026408:	009b      	lsls	r3, r3, #2
 802640a:	6879      	ldr	r1, [r7, #4]
 802640c:	440b      	add	r3, r1
 802640e:	6812      	ldr	r2, [r2, #0]
 8026410:	601a      	str	r2, [r3, #0]
  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 8026412:	68fb      	ldr	r3, [r7, #12]
 8026414:	3301      	adds	r3, #1
 8026416:	60fb      	str	r3, [r7, #12]
 8026418:	68fb      	ldr	r3, [r7, #12]
 802641a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802641e:	d3ee      	bcc.n	80263fe <E_EEPROM_XMC4_lCopyFlashToRam+0x16>
  }
}
 8026420:	bf00      	nop
 8026422:	bf00      	nop
 8026424:	3714      	adds	r7, #20
 8026426:	46bd      	mov	sp, r7
 8026428:	f85d 7b04 	ldr.w	r7, [sp], #4
 802642c:	4770      	bx	lr
 802642e:	bf00      	nop
 8026430:	20000258 	.word	0x20000258
 8026434:	200007bc 	.word	0x200007bc

08026438 <XMC_FLASH_lEnterPageModeCommand>:

/*
 * Command to program the PFLASH in to page mode, so that assembly buffer is used
 */
void XMC_FLASH_lEnterPageModeCommand(void)
{
 8026438:	b480      	push	{r7}
 802643a:	b083      	sub	sp, #12
 802643c:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 802643e:	4b05      	ldr	r3, [pc, #20]	; (8026454 <XMC_FLASH_lEnterPageModeCommand+0x1c>)
 8026440:	607b      	str	r3, [r7, #4]
  *address = (uint32_t)0x50U;
 8026442:	687b      	ldr	r3, [r7, #4]
 8026444:	2250      	movs	r2, #80	; 0x50
 8026446:	601a      	str	r2, [r3, #0]
}
 8026448:	bf00      	nop
 802644a:	370c      	adds	r7, #12
 802644c:	46bd      	mov	sp, r7
 802644e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026452:	4770      	bx	lr
 8026454:	0c005554 	.word	0x0c005554

08026458 <XMC_FLASH_lLoadPageCommand>:

/*
 * Command to load the data into the page assembly buffer
 */
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
 8026458:	b480      	push	{r7}
 802645a:	b085      	sub	sp, #20
 802645c:	af00      	add	r7, sp, #0
 802645e:	6078      	str	r0, [r7, #4]
 8026460:	6039      	str	r1, [r7, #0]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
 8026462:	4b08      	ldr	r3, [pc, #32]	; (8026484 <XMC_FLASH_lLoadPageCommand+0x2c>)
 8026464:	60fb      	str	r3, [r7, #12]
  *address = low_word;
 8026466:	68fb      	ldr	r3, [r7, #12]
 8026468:	687a      	ldr	r2, [r7, #4]
 802646a:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
 802646c:	4b06      	ldr	r3, [pc, #24]	; (8026488 <XMC_FLASH_lLoadPageCommand+0x30>)
 802646e:	60fb      	str	r3, [r7, #12]
  *address = high_word;
 8026470:	68fb      	ldr	r3, [r7, #12]
 8026472:	683a      	ldr	r2, [r7, #0]
 8026474:	601a      	str	r2, [r3, #0]
}
 8026476:	bf00      	nop
 8026478:	3714      	adds	r7, #20
 802647a:	46bd      	mov	sp, r7
 802647c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026480:	4770      	bx	lr
 8026482:	bf00      	nop
 8026484:	0c0055f0 	.word	0x0c0055f0
 8026488:	0c0055f4 	.word	0x0c0055f4

0802648c <XMC_FLASH_lWritePageCommand>:

/*
 * Command to start the programming of one page with data from the assembly buffer
 */
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
 802648c:	b480      	push	{r7}
 802648e:	b085      	sub	sp, #20
 8026490:	af00      	add	r7, sp, #0
 8026492:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8026494:	4b0c      	ldr	r3, [pc, #48]	; (80264c8 <XMC_FLASH_lWritePageCommand+0x3c>)
 8026496:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 8026498:	68fb      	ldr	r3, [r7, #12]
 802649a:	22aa      	movs	r2, #170	; 0xaa
 802649c:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 802649e:	4b0b      	ldr	r3, [pc, #44]	; (80264cc <XMC_FLASH_lWritePageCommand+0x40>)
 80264a0:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 80264a2:	68fb      	ldr	r3, [r7, #12]
 80264a4:	2255      	movs	r2, #85	; 0x55
 80264a6:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80264a8:	4b07      	ldr	r3, [pc, #28]	; (80264c8 <XMC_FLASH_lWritePageCommand+0x3c>)
 80264aa:	60fb      	str	r3, [r7, #12]
  *address = 0xa0U;
 80264ac:	68fb      	ldr	r3, [r7, #12]
 80264ae:	22a0      	movs	r2, #160	; 0xa0
 80264b0:	601a      	str	r2, [r3, #0]
  address = page_start_address;
 80264b2:	687b      	ldr	r3, [r7, #4]
 80264b4:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80264b6:	68fb      	ldr	r3, [r7, #12]
 80264b8:	22aa      	movs	r2, #170	; 0xaa
 80264ba:	601a      	str	r2, [r3, #0]
}
 80264bc:	bf00      	nop
 80264be:	3714      	adds	r7, #20
 80264c0:	46bd      	mov	sp, r7
 80264c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80264c6:	4770      	bx	lr
 80264c8:	0c005554 	.word	0x0c005554
 80264cc:	0c00aaa8 	.word	0x0c00aaa8

080264d0 <XMC_FLASH_lEraseSectorCommand>:

/*
 * Command to erase sector which is starting with the specified address
 */
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
 80264d0:	b480      	push	{r7}
 80264d2:	b085      	sub	sp, #20
 80264d4:	af00      	add	r7, sp, #0
 80264d6:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80264d8:	4b11      	ldr	r3, [pc, #68]	; (8026520 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80264da:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80264dc:	68fb      	ldr	r3, [r7, #12]
 80264de:	22aa      	movs	r2, #170	; 0xaa
 80264e0:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 80264e2:	4b10      	ldr	r3, [pc, #64]	; (8026524 <XMC_FLASH_lEraseSectorCommand+0x54>)
 80264e4:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 80264e6:	68fb      	ldr	r3, [r7, #12]
 80264e8:	2255      	movs	r2, #85	; 0x55
 80264ea:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80264ec:	4b0c      	ldr	r3, [pc, #48]	; (8026520 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80264ee:	60fb      	str	r3, [r7, #12]
  *address = 0x80U;
 80264f0:	68fb      	ldr	r3, [r7, #12]
 80264f2:	2280      	movs	r2, #128	; 0x80
 80264f4:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80264f6:	4b0a      	ldr	r3, [pc, #40]	; (8026520 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80264f8:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80264fa:	68fb      	ldr	r3, [r7, #12]
 80264fc:	22aa      	movs	r2, #170	; 0xaa
 80264fe:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 8026500:	4b08      	ldr	r3, [pc, #32]	; (8026524 <XMC_FLASH_lEraseSectorCommand+0x54>)
 8026502:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 8026504:	68fb      	ldr	r3, [r7, #12]
 8026506:	2255      	movs	r2, #85	; 0x55
 8026508:	601a      	str	r2, [r3, #0]
  address = sector_start_address;
 802650a:	687b      	ldr	r3, [r7, #4]
 802650c:	60fb      	str	r3, [r7, #12]
  *address = 0x30U;
 802650e:	68fb      	ldr	r3, [r7, #12]
 8026510:	2230      	movs	r2, #48	; 0x30
 8026512:	601a      	str	r2, [r3, #0]
}
 8026514:	bf00      	nop
 8026516:	3714      	adds	r7, #20
 8026518:	46bd      	mov	sp, r7
 802651a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802651e:	4770      	bx	lr
 8026520:	0c005554 	.word	0x0c005554
 8026524:	0c00aaa8 	.word	0x0c00aaa8

08026528 <XMC_FLASH_lClearStatusCommand>:

/*
 * Command to clear FSR.PROG and FSR.ERASE and the error flags in FSR such as PFOPER, SQER, PROER, PFDBER, ORIER, VER
 */
void XMC_FLASH_lClearStatusCommand(void)
{
 8026528:	b480      	push	{r7}
 802652a:	b083      	sub	sp, #12
 802652c:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 802652e:	4b05      	ldr	r3, [pc, #20]	; (8026544 <XMC_FLASH_lClearStatusCommand+0x1c>)
 8026530:	607b      	str	r3, [r7, #4]
  *address = 0xf5U;
 8026532:	687b      	ldr	r3, [r7, #4]
 8026534:	22f5      	movs	r2, #245	; 0xf5
 8026536:	601a      	str	r2, [r3, #0]
}
 8026538:	bf00      	nop
 802653a:	370c      	adds	r7, #12
 802653c:	46bd      	mov	sp, r7
 802653e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026542:	4770      	bx	lr
 8026544:	0c005554 	.word	0x0c005554

08026548 <XMC_FLASH_ClearStatus>:

/*
* This API shall clear Program, erase and error flags(PFOPER, SQER, PROER, PFDBER, ORIER, VER) of FSR register.
*/
void XMC_FLASH_ClearStatus(void)
{
 8026548:	b580      	push	{r7, lr}
 802654a:	af00      	add	r7, sp, #0
  XMC_FLASH_lClearStatusCommand();
 802654c:	f7ff ffec 	bl	8026528 <XMC_FLASH_lClearStatusCommand>
}
 8026550:	bf00      	nop
 8026552:	bd80      	pop	{r7, pc}

08026554 <XMC_FLASH_GetStatus>:

/*
 * This API returns the FSR register value
 */
uint32_t XMC_FLASH_GetStatus(void)
{
 8026554:	b480      	push	{r7}
 8026556:	af00      	add	r7, sp, #0
  return FLASH0->FSR;
 8026558:	4b04      	ldr	r3, [pc, #16]	; (802656c <XMC_FLASH_GetStatus+0x18>)
 802655a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 802655e:	691b      	ldr	r3, [r3, #16]
}
 8026560:	4618      	mov	r0, r3
 8026562:	46bd      	mov	sp, r7
 8026564:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026568:	4770      	bx	lr
 802656a:	bf00      	nop
 802656c:	58001000 	.word	0x58001000

08026570 <XMC_FLASH_ProgramPage>:

/*
 * This API write the PFLASH page
 */
void XMC_FLASH_ProgramPage(uint32_t *address, const uint32_t *data)
{
 8026570:	b580      	push	{r7, lr}
 8026572:	b084      	sub	sp, #16
 8026574:	af00      	add	r7, sp, #0
 8026576:	6078      	str	r0, [r7, #4]
 8026578:	6039      	str	r1, [r7, #0]
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();
 802657a:	f7ff ffd5 	bl	8026528 <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEnterPageModeCommand();
 802657e:	f7ff ff5b 	bl	8026438 <XMC_FLASH_lEnterPageModeCommand>

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8026582:	2300      	movs	r3, #0
 8026584:	60fb      	str	r3, [r7, #12]
 8026586:	e010      	b.n	80265aa <XMC_FLASH_ProgramPage+0x3a>
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
 8026588:	68fb      	ldr	r3, [r7, #12]
 802658a:	009b      	lsls	r3, r3, #2
 802658c:	683a      	ldr	r2, [r7, #0]
 802658e:	4413      	add	r3, r2
 8026590:	6818      	ldr	r0, [r3, #0]
 8026592:	68fb      	ldr	r3, [r7, #12]
 8026594:	3301      	adds	r3, #1
 8026596:	009b      	lsls	r3, r3, #2
 8026598:	683a      	ldr	r2, [r7, #0]
 802659a:	4413      	add	r3, r2
 802659c:	681b      	ldr	r3, [r3, #0]
 802659e:	4619      	mov	r1, r3
 80265a0:	f7ff ff5a 	bl	8026458 <XMC_FLASH_lLoadPageCommand>
  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 80265a4:	68fb      	ldr	r3, [r7, #12]
 80265a6:	3302      	adds	r3, #2
 80265a8:	60fb      	str	r3, [r7, #12]
 80265aa:	68fb      	ldr	r3, [r7, #12]
 80265ac:	2b3f      	cmp	r3, #63	; 0x3f
 80265ae:	d9eb      	bls.n	8026588 <XMC_FLASH_ProgramPage+0x18>
  }

  XMC_FLASH_lWritePageCommand(address);
 80265b0:	6878      	ldr	r0, [r7, #4]
 80265b2:	f7ff ff6b 	bl	802648c <XMC_FLASH_lWritePageCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 80265b6:	bf00      	nop
 80265b8:	4b06      	ldr	r3, [pc, #24]	; (80265d4 <XMC_FLASH_ProgramPage+0x64>)
 80265ba:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80265be:	691b      	ldr	r3, [r3, #16]
 80265c0:	f003 0301 	and.w	r3, r3, #1
 80265c4:	2b00      	cmp	r3, #0
 80265c6:	d1f7      	bne.n	80265b8 <XMC_FLASH_ProgramPage+0x48>
}
 80265c8:	bf00      	nop
 80265ca:	bf00      	nop
 80265cc:	3710      	adds	r7, #16
 80265ce:	46bd      	mov	sp, r7
 80265d0:	bd80      	pop	{r7, pc}
 80265d2:	bf00      	nop
 80265d4:	58001000 	.word	0x58001000

080265d8 <XMC_FLASH_EraseSector>:

/*
 * This API erase the logical sector
 */
void XMC_FLASH_EraseSector(uint32_t *address)
{
 80265d8:	b580      	push	{r7, lr}
 80265da:	b082      	sub	sp, #8
 80265dc:	af00      	add	r7, sp, #0
 80265de:	6078      	str	r0, [r7, #4]
  XMC_FLASH_lClearStatusCommand();
 80265e0:	f7ff ffa2 	bl	8026528 <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEraseSectorCommand(address);
 80265e4:	6878      	ldr	r0, [r7, #4]
 80265e6:	f7ff ff73 	bl	80264d0 <XMC_FLASH_lEraseSectorCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 80265ea:	bf00      	nop
 80265ec:	4b06      	ldr	r3, [pc, #24]	; (8026608 <XMC_FLASH_EraseSector+0x30>)
 80265ee:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80265f2:	691b      	ldr	r3, [r3, #16]
 80265f4:	f003 0301 	and.w	r3, r3, #1
 80265f8:	2b00      	cmp	r3, #0
 80265fa:	d1f7      	bne.n	80265ec <XMC_FLASH_EraseSector+0x14>
}
 80265fc:	bf00      	nop
 80265fe:	bf00      	nop
 8026600:	3708      	adds	r7, #8
 8026602:	46bd      	mov	sp, r7
 8026604:	bd80      	pop	{r7, pc}
 8026606:	bf00      	nop
 8026608:	58001000 	.word	0x58001000

0802660c <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 802660c:	b480      	push	{r7}
 802660e:	b085      	sub	sp, #20
 8026610:	af00      	add	r7, sp, #0
 8026612:	60f8      	str	r0, [r7, #12]
 8026614:	460b      	mov	r3, r1
 8026616:	607a      	str	r2, [r7, #4]
 8026618:	72fb      	strb	r3, [r7, #11]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 802661a:	7afb      	ldrb	r3, [r7, #11]
 802661c:	089b      	lsrs	r3, r3, #2
 802661e:	b2db      	uxtb	r3, r3
 8026620:	461a      	mov	r2, r3
 8026622:	68fb      	ldr	r3, [r7, #12]
 8026624:	3204      	adds	r2, #4
 8026626:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802662a:	7afb      	ldrb	r3, [r7, #11]
 802662c:	f003 0303 	and.w	r3, r3, #3
 8026630:	00db      	lsls	r3, r3, #3
 8026632:	21f8      	movs	r1, #248	; 0xf8
 8026634:	fa01 f303 	lsl.w	r3, r1, r3
 8026638:	43db      	mvns	r3, r3
 802663a:	7af9      	ldrb	r1, [r7, #11]
 802663c:	0889      	lsrs	r1, r1, #2
 802663e:	b2c9      	uxtb	r1, r1
 8026640:	4608      	mov	r0, r1
 8026642:	ea02 0103 	and.w	r1, r2, r3
 8026646:	68fb      	ldr	r3, [r7, #12]
 8026648:	1d02      	adds	r2, r0, #4
 802664a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 802664e:	68fb      	ldr	r3, [r7, #12]
 8026650:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8026652:	7afb      	ldrb	r3, [r7, #11]
 8026654:	005b      	lsls	r3, r3, #1
 8026656:	2103      	movs	r1, #3
 8026658:	fa01 f303 	lsl.w	r3, r1, r3
 802665c:	43db      	mvns	r3, r3
 802665e:	401a      	ands	r2, r3
 8026660:	68fb      	ldr	r3, [r7, #12]
 8026662:	675a      	str	r2, [r3, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8026664:	68fb      	ldr	r3, [r7, #12]
 8026666:	4a3a      	ldr	r2, [pc, #232]	; (8026750 <XMC_GPIO_Init+0x144>)
 8026668:	4293      	cmp	r3, r2
 802666a:	d003      	beq.n	8026674 <XMC_GPIO_Init+0x68>
 802666c:	68fb      	ldr	r3, [r7, #12]
 802666e:	4a39      	ldr	r2, [pc, #228]	; (8026754 <XMC_GPIO_Init+0x148>)
 8026670:	4293      	cmp	r3, r2
 8026672:	d10a      	bne.n	802668a <XMC_GPIO_Init+0x7e>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 8026674:	68fb      	ldr	r3, [r7, #12]
 8026676:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8026678:	7afb      	ldrb	r3, [r7, #11]
 802667a:	2101      	movs	r1, #1
 802667c:	fa01 f303 	lsl.w	r3, r1, r3
 8026680:	43db      	mvns	r3, r3
 8026682:	401a      	ands	r2, r3
 8026684:	68fb      	ldr	r3, [r7, #12]
 8026686:	661a      	str	r2, [r3, #96]	; 0x60
 8026688:	e041      	b.n	802670e <XMC_GPIO_Init+0x102>
  }
  else
  {
    if ((config->mode & XMC_GPIO_MODE_OE) != 0)
 802668a:	687b      	ldr	r3, [r7, #4]
 802668c:	781b      	ldrb	r3, [r3, #0]
 802668e:	b25b      	sxtb	r3, r3
 8026690:	2b00      	cmp	r3, #0
 8026692:	da3c      	bge.n	802670e <XMC_GPIO_Init+0x102>
    {
      /* If output is enabled */

      /* Set output level */
      port->OMR = (uint32_t)config->output_level << pin;
 8026694:	687b      	ldr	r3, [r7, #4]
 8026696:	685a      	ldr	r2, [r3, #4]
 8026698:	7afb      	ldrb	r3, [r7, #11]
 802669a:	409a      	lsls	r2, r3
 802669c:	68fb      	ldr	r3, [r7, #12]
 802669e:	605a      	str	r2, [r3, #4]

      /* Set output driver strength */
      port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 80266a0:	7afb      	ldrb	r3, [r7, #11]
 80266a2:	08db      	lsrs	r3, r3, #3
 80266a4:	b2db      	uxtb	r3, r3
 80266a6:	461a      	mov	r2, r3
 80266a8:	68fb      	ldr	r3, [r7, #12]
 80266aa:	3210      	adds	r2, #16
 80266ac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80266b0:	7afb      	ldrb	r3, [r7, #11]
 80266b2:	f003 0307 	and.w	r3, r3, #7
 80266b6:	009b      	lsls	r3, r3, #2
 80266b8:	2107      	movs	r1, #7
 80266ba:	fa01 f303 	lsl.w	r3, r1, r3
 80266be:	43db      	mvns	r3, r3
 80266c0:	7af9      	ldrb	r1, [r7, #11]
 80266c2:	08c9      	lsrs	r1, r1, #3
 80266c4:	b2c9      	uxtb	r1, r1
 80266c6:	4608      	mov	r0, r1
 80266c8:	ea02 0103 	and.w	r1, r2, r3
 80266cc:	68fb      	ldr	r3, [r7, #12]
 80266ce:	f100 0210 	add.w	r2, r0, #16
 80266d2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 80266d6:	7afb      	ldrb	r3, [r7, #11]
 80266d8:	08db      	lsrs	r3, r3, #3
 80266da:	b2db      	uxtb	r3, r3
 80266dc:	461a      	mov	r2, r3
 80266de:	68fb      	ldr	r3, [r7, #12]
 80266e0:	3210      	adds	r2, #16
 80266e2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80266e6:	687b      	ldr	r3, [r7, #4]
 80266e8:	7a1b      	ldrb	r3, [r3, #8]
 80266ea:	4619      	mov	r1, r3
 80266ec:	7afb      	ldrb	r3, [r7, #11]
 80266ee:	f003 0307 	and.w	r3, r3, #7
 80266f2:	009b      	lsls	r3, r3, #2
 80266f4:	fa01 f303 	lsl.w	r3, r1, r3
 80266f8:	7af9      	ldrb	r1, [r7, #11]
 80266fa:	08c9      	lsrs	r1, r1, #3
 80266fc:	b2c9      	uxtb	r1, r1
 80266fe:	4608      	mov	r0, r1
 8026700:	ea42 0103 	orr.w	r1, r2, r3
 8026704:	68fb      	ldr	r3, [r7, #12]
 8026706:	f100 0210 	add.w	r2, r0, #16
 802670a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 802670e:	7afb      	ldrb	r3, [r7, #11]
 8026710:	089b      	lsrs	r3, r3, #2
 8026712:	b2db      	uxtb	r3, r3
 8026714:	461a      	mov	r2, r3
 8026716:	68fb      	ldr	r3, [r7, #12]
 8026718:	3204      	adds	r2, #4
 802671a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802671e:	687b      	ldr	r3, [r7, #4]
 8026720:	781b      	ldrb	r3, [r3, #0]
 8026722:	4619      	mov	r1, r3
 8026724:	7afb      	ldrb	r3, [r7, #11]
 8026726:	f003 0303 	and.w	r3, r3, #3
 802672a:	00db      	lsls	r3, r3, #3
 802672c:	fa01 f303 	lsl.w	r3, r1, r3
 8026730:	7af9      	ldrb	r1, [r7, #11]
 8026732:	0889      	lsrs	r1, r1, #2
 8026734:	b2c9      	uxtb	r1, r1
 8026736:	4608      	mov	r0, r1
 8026738:	ea42 0103 	orr.w	r1, r2, r3
 802673c:	68fb      	ldr	r3, [r7, #12]
 802673e:	1d02      	adds	r2, r0, #4
 8026740:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8026744:	bf00      	nop
 8026746:	3714      	adds	r7, #20
 8026748:	46bd      	mov	sp, r7
 802674a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802674e:	4770      	bx	lr
 8026750:	48028e00 	.word	0x48028e00
 8026754:	48028f00 	.word	0x48028f00

08026758 <XMC_SCU_CLOCK_GetCpuClockFrequency>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
{
 8026758:	b480      	push	{r7}
 802675a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 802675c:	4b03      	ldr	r3, [pc, #12]	; (802676c <XMC_SCU_CLOCK_GetCpuClockFrequency+0x14>)
 802675e:	681b      	ldr	r3, [r3, #0]
}
 8026760:	4618      	mov	r0, r3
 8026762:	46bd      	mov	sp, r7
 8026764:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026768:	4770      	bx	lr
 802676a:	bf00      	nop
 802676c:	2000ffc0 	.word	0x2000ffc0

08026770 <XMC_SCU_lDelay>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
 8026770:	b580      	push	{r7, lr}
 8026772:	b084      	sub	sp, #16
 8026774:	af00      	add	r7, sp, #0
 8026776:	6078      	str	r0, [r7, #4]
  uint32_t i;

  SystemCoreClockUpdate();
 8026778:	f7f9 ffae 	bl	80206d8 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802677c:	4b0c      	ldr	r3, [pc, #48]	; (80267b0 <XMC_SCU_lDelay+0x40>)
 802677e:	681b      	ldr	r3, [r3, #0]
 8026780:	4a0c      	ldr	r2, [pc, #48]	; (80267b4 <XMC_SCU_lDelay+0x44>)
 8026782:	fba2 2303 	umull	r2, r3, r2, r3
 8026786:	0c9a      	lsrs	r2, r3, #18
 8026788:	687b      	ldr	r3, [r7, #4]
 802678a:	fb02 f303 	mul.w	r3, r2, r3
 802678e:	607b      	str	r3, [r7, #4]

  for (i = 0U; i < delay; ++i)
 8026790:	2300      	movs	r3, #0
 8026792:	60fb      	str	r3, [r7, #12]
 8026794:	e003      	b.n	802679e <XMC_SCU_lDelay+0x2e>
  {
    __NOP();
 8026796:	bf00      	nop
  for (i = 0U; i < delay; ++i)
 8026798:	68fb      	ldr	r3, [r7, #12]
 802679a:	3301      	adds	r3, #1
 802679c:	60fb      	str	r3, [r7, #12]
 802679e:	68fa      	ldr	r2, [r7, #12]
 80267a0:	687b      	ldr	r3, [r7, #4]
 80267a2:	429a      	cmp	r2, r3
 80267a4:	d3f7      	bcc.n	8026796 <XMC_SCU_lDelay+0x26>
  }
}
 80267a6:	bf00      	nop
 80267a8:	bf00      	nop
 80267aa:	3710      	adds	r7, #16
 80267ac:	46bd      	mov	sp, r7
 80267ae:	bd80      	pop	{r7, pc}
 80267b0:	2000ffc0 	.word	0x2000ffc0
 80267b4:	431bde83 	.word	0x431bde83

080267b8 <XMC_SCU_INTERUPT_GetEventStatus>:
  SCU_INTERRUPT->SRSET |= (uint32_t)event;
}

/* API to retrieve the SCU event status */
XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
{
 80267b8:	b480      	push	{r7}
 80267ba:	af00      	add	r7, sp, #0
  return (SCU_INTERRUPT->SRRAW);
 80267bc:	4b03      	ldr	r3, [pc, #12]	; (80267cc <XMC_SCU_INTERUPT_GetEventStatus+0x14>)
 80267be:	685b      	ldr	r3, [r3, #4]
}
 80267c0:	4618      	mov	r0, r3
 80267c2:	46bd      	mov	sp, r7
 80267c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267c8:	4770      	bx	lr
 80267ca:	bf00      	nop
 80267cc:	50004074 	.word	0x50004074

080267d0 <XMC_SCU_INTERRUPT_ClearEventStatus>:

/* API to clear the SCU event status */
void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
{
 80267d0:	b480      	push	{r7}
 80267d2:	b083      	sub	sp, #12
 80267d4:	af00      	add	r7, sp, #0
 80267d6:	6078      	str	r0, [r7, #4]
  SCU_INTERRUPT->SRCLR = (uint32_t)event;
 80267d8:	4a04      	ldr	r2, [pc, #16]	; (80267ec <XMC_SCU_INTERRUPT_ClearEventStatus+0x1c>)
 80267da:	687b      	ldr	r3, [r7, #4]
 80267dc:	60d3      	str	r3, [r2, #12]
}
 80267de:	bf00      	nop
 80267e0:	370c      	adds	r7, #12
 80267e2:	46bd      	mov	sp, r7
 80267e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267e8:	4770      	bx	lr
 80267ea:	bf00      	nop
 80267ec:	50004074 	.word	0x50004074

080267f0 <XMC_SCU_SetBootMode>:
  return (uint32_t)(SCU_GENERAL->STCON & SCU_GENERAL_STCON_SWCON_Msk);
}

/* API to program a new device bootmode */
void XMC_SCU_SetBootMode(const XMC_SCU_BOOTMODE_t bootmode)
{
 80267f0:	b480      	push	{r7}
 80267f2:	b083      	sub	sp, #12
 80267f4:	af00      	add	r7, sp, #0
 80267f6:	4603      	mov	r3, r0
 80267f8:	80fb      	strh	r3, [r7, #6]
  SCU_GENERAL->STCON = (uint32_t)bootmode;
 80267fa:	4a04      	ldr	r2, [pc, #16]	; (802680c <XMC_SCU_SetBootMode+0x1c>)
 80267fc:	88fb      	ldrh	r3, [r7, #6]
 80267fe:	6113      	str	r3, [r2, #16]
}
 8026800:	bf00      	nop
 8026802:	370c      	adds	r7, #12
 8026804:	46bd      	mov	sp, r7
 8026806:	f85d 7b04 	ldr.w	r7, [sp], #4
 802680a:	4770      	bx	lr
 802680c:	50004000 	.word	0x50004000

08026810 <XMC_SCU_CLOCK_Init>:
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8026810:	b590      	push	{r4, r7, lr}
 8026812:	b085      	sub	sp, #20
 8026814:	af02      	add	r7, sp, #8
 8026816:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("", ((config->fstdby_clksrc == XMC_SCU_HIB_STDBYCLKSRC_OSCULP) && (config->enable_osculp == true)) ||
                 (config->fstdby_clksrc != XMC_SCU_HIB_STDBYCLKSRC_OSCULP));
  XMC_ASSERT("", ((config->syspll_config.clksrc == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) &&
                 (config->enable_oschp == true)) || (config->syspll_config.clksrc != XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP));

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);
 8026818:	2000      	movs	r0, #0
 802681a:	f000 f895 	bl	8026948 <XMC_SCU_CLOCK_SetSystemClockSource>

  XMC_SCU_HIB_EnableHibernateDomain();
 802681e:	f000 fa25 	bl	8026c6c <XMC_SCU_HIB_EnableHibernateDomain>

  if (config->enable_osculp == true)
 8026822:	687b      	ldr	r3, [r7, #4]
 8026824:	79db      	ldrb	r3, [r3, #7]
 8026826:	2b00      	cmp	r3, #0
 8026828:	d00a      	beq.n	8026840 <XMC_SCU_CLOCK_Init+0x30>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
 802682a:	f000 fa5d 	bl	8026ce8 <XMC_SCU_CLOCK_EnableLowPowerOscillator>
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 802682e:	bf00      	nop
 8026830:	f000 fa48 	bl	8026cc4 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>
 8026834:	4603      	mov	r3, r0
 8026836:	f083 0301 	eor.w	r3, r3, #1
 802683a:	b2db      	uxtb	r3, r3
 802683c:	2b00      	cmp	r3, #0
 802683e:	d1f7      	bne.n	8026830 <XMC_SCU_CLOCK_Init+0x20>
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
 8026840:	687b      	ldr	r3, [r7, #4]
 8026842:	7a5b      	ldrb	r3, [r3, #9]
 8026844:	4618      	mov	r0, r3
 8026846:	f000 f8e8 	bl	8026a1a <XMC_SCU_HIB_SetStandbyClockSource>
  //while (XMC_SCU_GetMirrorStatus() != 0)
 // {
    /* Wait until update of the stanby clock source is done in the HIB domain */    
 // }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 802684a:	687b      	ldr	r3, [r7, #4]
 802684c:	7a1b      	ldrb	r3, [r3, #8]
 802684e:	4618      	mov	r0, r3
 8026850:	f000 f9e6 	bl	8026c20 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 8026854:	687b      	ldr	r3, [r7, #4]
 8026856:	7c1b      	ldrb	r3, [r3, #16]
 8026858:	4618      	mov	r0, r3
 802685a:	f000 f8e9 	bl	8026a30 <XMC_SCU_CLOCK_SetSystemClockDivider>
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 802685e:	687b      	ldr	r3, [r7, #4]
 8026860:	7c5b      	ldrb	r3, [r3, #17]
 8026862:	4618      	mov	r0, r3
 8026864:	f000 f910 	bl	8026a88 <XMC_SCU_CLOCK_SetCpuClockDivider>
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 8026868:	687b      	ldr	r3, [r7, #4]
 802686a:	7c9b      	ldrb	r3, [r3, #18]
 802686c:	4618      	mov	r0, r3
 802686e:	f000 f8f5 	bl	8026a5c <XMC_SCU_CLOCK_SetCcuClockDivider>
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 8026872:	687b      	ldr	r3, [r7, #4]
 8026874:	7cdb      	ldrb	r3, [r3, #19]
 8026876:	4618      	mov	r0, r3
 8026878:	f000 f91c 	bl	8026ab4 <XMC_SCU_CLOCK_SetPeripheralClockDivider>

  if (config->enable_oschp == true)
 802687c:	687b      	ldr	r3, [r7, #4]
 802687e:	799b      	ldrb	r3, [r3, #6]
 8026880:	2b00      	cmp	r3, #0
 8026882:	d00a      	beq.n	802689a <XMC_SCU_CLOCK_Init+0x8a>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
 8026884:	f000 fa6a 	bl	8026d5c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 8026888:	bf00      	nop
 802688a:	f000 fa8f 	bl	8026dac <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>
 802688e:	4603      	mov	r3, r0
 8026890:	f083 0301 	eor.w	r3, r3, #1
 8026894:	b2db      	uxtb	r3, r3
 8026896:	2b00      	cmp	r3, #0
 8026898:	d1f7      	bne.n	802688a <XMC_SCU_CLOCK_Init+0x7a>
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 802689a:	687b      	ldr	r3, [r7, #4]
 802689c:	78db      	ldrb	r3, [r3, #3]
 802689e:	2b00      	cmp	r3, #0
 80268a0:	d102      	bne.n	80268a8 <XMC_SCU_CLOCK_Init+0x98>
  {
    XMC_SCU_CLOCK_DisableSystemPll();
 80268a2:	f000 faa9 	bl	8026df8 <XMC_SCU_CLOCK_DisableSystemPll>
 80268a6:	e011      	b.n	80268cc <XMC_SCU_CLOCK_Init+0xbc>
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
 80268a8:	f000 fa94 	bl	8026dd4 <XMC_SCU_CLOCK_EnableSystemPll>
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80268ac:	687b      	ldr	r3, [r7, #4]
 80268ae:	8898      	ldrh	r0, [r3, #4]
 80268b0:	687b      	ldr	r3, [r7, #4]
 80268b2:	78d9      	ldrb	r1, [r3, #3]
                                 config->syspll_config.mode,
                                 (uint32_t)config->syspll_config.p_div,
 80268b4:	687b      	ldr	r3, [r7, #4]
 80268b6:	785b      	ldrb	r3, [r3, #1]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80268b8:	461a      	mov	r2, r3
                                 (uint32_t)config->syspll_config.n_div,
 80268ba:	687b      	ldr	r3, [r7, #4]
 80268bc:	781b      	ldrb	r3, [r3, #0]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80268be:	461c      	mov	r4, r3
                                 (uint32_t)config->syspll_config.k_div);
 80268c0:	687b      	ldr	r3, [r7, #4]
 80268c2:	789b      	ldrb	r3, [r3, #2]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80268c4:	9300      	str	r3, [sp, #0]
 80268c6:	4623      	mov	r3, r4
 80268c8:	f000 faa8 	bl	8026e1c <XMC_SCU_CLOCK_StartSystemPll>
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 80268cc:	687b      	ldr	r3, [r7, #4]
 80268ce:	68db      	ldr	r3, [r3, #12]
 80268d0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80268d4:	d103      	bne.n	80268de <XMC_SCU_CLOCK_Init+0xce>
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
 80268d6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80268da:	f000 f835 	bl	8026948 <XMC_SCU_CLOCK_SetSystemClockSource>
  }
  SystemCoreClockUpdate();
 80268de:	f7f9 fefb 	bl	80206d8 <SystemCoreClockUpdate>
}
 80268e2:	bf00      	nop
 80268e4:	370c      	adds	r7, #12
 80268e6:	46bd      	mov	sp, r7
 80268e8:	bd90      	pop	{r4, r7, pc}
	...

080268ec <XMC_SCU_RESET_DeassertPeripheralReset>:
  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 80268ec:	b480      	push	{r7}
 80268ee:	b085      	sub	sp, #20
 80268f0:	af00      	add	r7, sp, #0
 80268f2:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 80268f4:	687b      	ldr	r3, [r7, #4]
 80268f6:	0f1b      	lsrs	r3, r3, #28
 80268f8:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 80268fa:	687b      	ldr	r3, [r7, #4]
 80268fc:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8026900:	60bb      	str	r3, [r7, #8]

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8026902:	68fa      	ldr	r2, [r7, #12]
 8026904:	4613      	mov	r3, r2
 8026906:	005b      	lsls	r3, r3, #1
 8026908:	4413      	add	r3, r2
 802690a:	009b      	lsls	r3, r3, #2
 802690c:	461a      	mov	r2, r3
 802690e:	4b05      	ldr	r3, [pc, #20]	; (8026924 <XMC_SCU_RESET_DeassertPeripheralReset+0x38>)
 8026910:	4413      	add	r3, r2
 8026912:	68ba      	ldr	r2, [r7, #8]
 8026914:	601a      	str	r2, [r3, #0]
}
 8026916:	bf00      	nop
 8026918:	3714      	adds	r7, #20
 802691a:	46bd      	mov	sp, r7
 802691c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026920:	4770      	bx	lr
 8026922:	bf00      	nop
 8026924:	50004414 	.word	0x50004414

08026928 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
 8026928:	b580      	push	{r7, lr}
 802692a:	af00      	add	r7, sp, #0
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 802692c:	f7ff ff14 	bl	8026758 <XMC_SCU_CLOCK_GetCpuClockFrequency>
 8026930:	4602      	mov	r2, r0
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
 8026932:	4b04      	ldr	r3, [pc, #16]	; (8026944 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x1c>)
 8026934:	695b      	ldr	r3, [r3, #20]
 8026936:	f003 0301 	and.w	r3, r3, #1
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 802693a:	fa22 f303 	lsr.w	r3, r2, r3
}
 802693e:	4618      	mov	r0, r3
 8026940:	bd80      	pop	{r7, pc}
 8026942:	bf00      	nop
 8026944:	50004600 	.word	0x50004600

08026948 <XMC_SCU_CLOCK_SetSystemClockSource>:

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
 8026948:	b480      	push	{r7}
 802694a:	b083      	sub	sp, #12
 802694c:	af00      	add	r7, sp, #0
 802694e:	6078      	str	r0, [r7, #4]
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8026950:	4b06      	ldr	r3, [pc, #24]	; (802696c <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 8026952:	68db      	ldr	r3, [r3, #12]
 8026954:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8026958:	4904      	ldr	r1, [pc, #16]	; (802696c <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 802695a:	687b      	ldr	r3, [r7, #4]
 802695c:	4313      	orrs	r3, r2
 802695e:	60cb      	str	r3, [r1, #12]
                      ((uint32_t)source);
}
 8026960:	bf00      	nop
 8026962:	370c      	adds	r7, #12
 8026964:	46bd      	mov	sp, r7
 8026966:	f85d 7b04 	ldr.w	r7, [sp], #4
 802696a:	4770      	bx	lr
 802696c:	50004600 	.word	0x50004600

08026970 <XMC_SCU_CLOCK_SetUsbClockSource>:

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
 8026970:	b480      	push	{r7}
 8026972:	b083      	sub	sp, #12
 8026974:	af00      	add	r7, sp, #0
 8026976:	6078      	str	r0, [r7, #4]
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 8026978:	4b06      	ldr	r3, [pc, #24]	; (8026994 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 802697a:	699b      	ldr	r3, [r3, #24]
 802697c:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8026980:	4904      	ldr	r1, [pc, #16]	; (8026994 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 8026982:	687b      	ldr	r3, [r7, #4]
 8026984:	4313      	orrs	r3, r2
 8026986:	618b      	str	r3, [r1, #24]
                      ((uint32_t)source);
}
 8026988:	bf00      	nop
 802698a:	370c      	adds	r7, #12
 802698c:	46bd      	mov	sp, r7
 802698e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026992:	4770      	bx	lr
 8026994:	50004600 	.word	0x50004600

08026998 <XMC_SCU_CLOCK_SetWdtClockSource>:

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
 8026998:	b480      	push	{r7}
 802699a:	b083      	sub	sp, #12
 802699c:	af00      	add	r7, sp, #0
 802699e:	6078      	str	r0, [r7, #4]
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 80269a0:	4b06      	ldr	r3, [pc, #24]	; (80269bc <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 80269a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80269a4:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 80269a8:	4904      	ldr	r1, [pc, #16]	; (80269bc <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 80269aa:	687b      	ldr	r3, [r7, #4]
 80269ac:	4313      	orrs	r3, r2
 80269ae:	624b      	str	r3, [r1, #36]	; 0x24
                      ((uint32_t)source);
}
 80269b0:	bf00      	nop
 80269b2:	370c      	adds	r7, #12
 80269b4:	46bd      	mov	sp, r7
 80269b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80269ba:	4770      	bx	lr
 80269bc:	50004600 	.word	0x50004600

080269c0 <XMC_SCU_CLOCK_SetSystemPllClockSource>:
                      ((uint32_t)source);
}

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
 80269c0:	b480      	push	{r7}
 80269c2:	b083      	sub	sp, #12
 80269c4:	af00      	add	r7, sp, #0
 80269c6:	4603      	mov	r3, r0
 80269c8:	80fb      	strh	r3, [r7, #6]
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 80269ca:	88fb      	ldrh	r3, [r7, #6]
 80269cc:	2b00      	cmp	r3, #0
 80269ce:	d108      	bne.n	80269e2 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x22>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80269d0:	4b0b      	ldr	r3, [pc, #44]	; (8026a00 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 80269d2:	68db      	ldr	r3, [r3, #12]
 80269d4:	4a0a      	ldr	r2, [pc, #40]	; (8026a00 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 80269d6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80269da:	f023 0301 	bic.w	r3, r3, #1
 80269de:	60d3      	str	r3, [r2, #12]
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
}
 80269e0:	e007      	b.n	80269f2 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x32>
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80269e2:	4b07      	ldr	r3, [pc, #28]	; (8026a00 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 80269e4:	68db      	ldr	r3, [r3, #12]
 80269e6:	4a06      	ldr	r2, [pc, #24]	; (8026a00 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 80269e8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80269ec:	f043 0301 	orr.w	r3, r3, #1
 80269f0:	60d3      	str	r3, [r2, #12]
}
 80269f2:	bf00      	nop
 80269f4:	370c      	adds	r7, #12
 80269f6:	46bd      	mov	sp, r7
 80269f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80269fc:	4770      	bx	lr
 80269fe:	bf00      	nop
 8026a00:	50004710 	.word	0x50004710

08026a04 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
 8026a04:	b480      	push	{r7}
 8026a06:	b083      	sub	sp, #12
 8026a08:	af00      	add	r7, sp, #0
 8026a0a:	4603      	mov	r3, r0
 8026a0c:	71fb      	strb	r3, [r7, #7]
 // {
 // }

 // SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 //                       ((uint32_t)source);
}
 8026a0e:	bf00      	nop
 8026a10:	370c      	adds	r7, #12
 8026a12:	46bd      	mov	sp, r7
 8026a14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a18:	4770      	bx	lr

08026a1a <XMC_SCU_HIB_SetStandbyClockSource>:

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
 8026a1a:	b480      	push	{r7}
 8026a1c:	b083      	sub	sp, #12
 8026a1e:	af00      	add	r7, sp, #0
 8026a20:	4603      	mov	r3, r0
 8026a22:	71fb      	strb	r3, [r7, #7]
 // {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
 // }
//  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 //                       ((uint32_t)source);
}
 8026a24:	bf00      	nop
 8026a26:	370c      	adds	r7, #12
 8026a28:	46bd      	mov	sp, r7
 8026a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a2e:	4770      	bx	lr

08026a30 <XMC_SCU_CLOCK_SetSystemClockDivider>:

/* API to program the divider placed between fsys and its parent */
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
 8026a30:	b480      	push	{r7}
 8026a32:	b083      	sub	sp, #12
 8026a34:	af00      	add	r7, sp, #0
 8026a36:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8026a38:	4b07      	ldr	r3, [pc, #28]	; (8026a58 <XMC_SCU_CLOCK_SetSystemClockDivider+0x28>)
 8026a3a:	68db      	ldr	r3, [r3, #12]
 8026a3c:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 8026a40:	687b      	ldr	r3, [r7, #4]
 8026a42:	3b01      	subs	r3, #1
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8026a44:	4904      	ldr	r1, [pc, #16]	; (8026a58 <XMC_SCU_CLOCK_SetSystemClockDivider+0x28>)
 8026a46:	4313      	orrs	r3, r2
 8026a48:	60cb      	str	r3, [r1, #12]
}
 8026a4a:	bf00      	nop
 8026a4c:	370c      	adds	r7, #12
 8026a4e:	46bd      	mov	sp, r7
 8026a50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a54:	4770      	bx	lr
 8026a56:	bf00      	nop
 8026a58:	50004600 	.word	0x50004600

08026a5c <XMC_SCU_CLOCK_SetCcuClockDivider>:

/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
 8026a5c:	b480      	push	{r7}
 8026a5e:	b083      	sub	sp, #12
 8026a60:	af00      	add	r7, sp, #0
 8026a62:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8026a64:	4b07      	ldr	r3, [pc, #28]	; (8026a84 <XMC_SCU_CLOCK_SetCcuClockDivider+0x28>)
 8026a66:	6a1b      	ldr	r3, [r3, #32]
 8026a68:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 8026a6c:	687b      	ldr	r3, [r7, #4]
 8026a6e:	3b01      	subs	r3, #1
  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8026a70:	4904      	ldr	r1, [pc, #16]	; (8026a84 <XMC_SCU_CLOCK_SetCcuClockDivider+0x28>)
 8026a72:	4313      	orrs	r3, r2
 8026a74:	620b      	str	r3, [r1, #32]
}
 8026a76:	bf00      	nop
 8026a78:	370c      	adds	r7, #12
 8026a7a:	46bd      	mov	sp, r7
 8026a7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a80:	4770      	bx	lr
 8026a82:	bf00      	nop
 8026a84:	50004600 	.word	0x50004600

08026a88 <XMC_SCU_CLOCK_SetCpuClockDivider>:

/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
 8026a88:	b480      	push	{r7}
 8026a8a:	b083      	sub	sp, #12
 8026a8c:	af00      	add	r7, sp, #0
 8026a8e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8026a90:	4b07      	ldr	r3, [pc, #28]	; (8026ab0 <XMC_SCU_CLOCK_SetCpuClockDivider+0x28>)
 8026a92:	691b      	ldr	r3, [r3, #16]
 8026a94:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 8026a98:	687b      	ldr	r3, [r7, #4]
 8026a9a:	3b01      	subs	r3, #1
  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8026a9c:	4904      	ldr	r1, [pc, #16]	; (8026ab0 <XMC_SCU_CLOCK_SetCpuClockDivider+0x28>)
 8026a9e:	4313      	orrs	r3, r2
 8026aa0:	610b      	str	r3, [r1, #16]
}
 8026aa2:	bf00      	nop
 8026aa4:	370c      	adds	r7, #12
 8026aa6:	46bd      	mov	sp, r7
 8026aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026aac:	4770      	bx	lr
 8026aae:	bf00      	nop
 8026ab0:	50004600 	.word	0x50004600

08026ab4 <XMC_SCU_CLOCK_SetPeripheralClockDivider>:

/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
 8026ab4:	b480      	push	{r7}
 8026ab6:	b083      	sub	sp, #12
 8026ab8:	af00      	add	r7, sp, #0
 8026aba:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8026abc:	4b07      	ldr	r3, [pc, #28]	; (8026adc <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x28>)
 8026abe:	695b      	ldr	r3, [r3, #20]
 8026ac0:	f023 0201 	bic.w	r2, r3, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 8026ac4:	687b      	ldr	r3, [r7, #4]
 8026ac6:	3b01      	subs	r3, #1
  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8026ac8:	4904      	ldr	r1, [pc, #16]	; (8026adc <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x28>)
 8026aca:	4313      	orrs	r3, r2
 8026acc:	614b      	str	r3, [r1, #20]
}
 8026ace:	bf00      	nop
 8026ad0:	370c      	adds	r7, #12
 8026ad2:	46bd      	mov	sp, r7
 8026ad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ad8:	4770      	bx	lr
 8026ada:	bf00      	nop
 8026adc:	50004600 	.word	0x50004600

08026ae0 <XMC_SCU_CLOCK_SetUsbClockDivider>:

/* API to program the divider placed between fsdmmc and its parent */
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
 8026ae0:	b480      	push	{r7}
 8026ae2:	b083      	sub	sp, #12
 8026ae4:	af00      	add	r7, sp, #0
 8026ae6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8026ae8:	4b07      	ldr	r3, [pc, #28]	; (8026b08 <XMC_SCU_CLOCK_SetUsbClockDivider+0x28>)
 8026aea:	699b      	ldr	r3, [r3, #24]
 8026aec:	f023 0207 	bic.w	r2, r3, #7
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 8026af0:	687b      	ldr	r3, [r7, #4]
 8026af2:	3b01      	subs	r3, #1
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8026af4:	4904      	ldr	r1, [pc, #16]	; (8026b08 <XMC_SCU_CLOCK_SetUsbClockDivider+0x28>)
 8026af6:	4313      	orrs	r3, r2
 8026af8:	618b      	str	r3, [r1, #24]
}
 8026afa:	bf00      	nop
 8026afc:	370c      	adds	r7, #12
 8026afe:	46bd      	mov	sp, r7
 8026b00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b04:	4770      	bx	lr
 8026b06:	bf00      	nop
 8026b08:	50004600 	.word	0x50004600

08026b0c <XMC_SCU_CLOCK_SetEbuClockDivider>:

#if defined(EBU)
/* API to program the divider placed between febu and its parent */
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
 8026b0c:	b480      	push	{r7}
 8026b0e:	b083      	sub	sp, #12
 8026b10:	af00      	add	r7, sp, #0
 8026b12:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 8026b14:	4b07      	ldr	r3, [pc, #28]	; (8026b34 <XMC_SCU_CLOCK_SetEbuClockDivider+0x28>)
 8026b16:	69db      	ldr	r3, [r3, #28]
 8026b18:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 8026b1c:	687b      	ldr	r3, [r7, #4]
 8026b1e:	3b01      	subs	r3, #1
  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 8026b20:	4904      	ldr	r1, [pc, #16]	; (8026b34 <XMC_SCU_CLOCK_SetEbuClockDivider+0x28>)
 8026b22:	4313      	orrs	r3, r2
 8026b24:	61cb      	str	r3, [r1, #28]
}
 8026b26:	bf00      	nop
 8026b28:	370c      	adds	r7, #12
 8026b2a:	46bd      	mov	sp, r7
 8026b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b30:	4770      	bx	lr
 8026b32:	bf00      	nop
 8026b34:	50004600 	.word	0x50004600

08026b38 <XMC_SCU_CLOCK_SetWdtClockDivider>:
#endif

/* API to program the divider placed between fwdt and its parent */
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
 8026b38:	b480      	push	{r7}
 8026b3a:	b083      	sub	sp, #12
 8026b3c:	af00      	add	r7, sp, #0
 8026b3e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8026b40:	4b07      	ldr	r3, [pc, #28]	; (8026b60 <XMC_SCU_CLOCK_SetWdtClockDivider+0x28>)
 8026b42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8026b44:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 8026b48:	687b      	ldr	r3, [r7, #4]
 8026b4a:	3b01      	subs	r3, #1
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8026b4c:	4904      	ldr	r1, [pc, #16]	; (8026b60 <XMC_SCU_CLOCK_SetWdtClockDivider+0x28>)
 8026b4e:	4313      	orrs	r3, r2
 8026b50:	624b      	str	r3, [r1, #36]	; 0x24
}
 8026b52:	bf00      	nop
 8026b54:	370c      	adds	r7, #12
 8026b56:	46bd      	mov	sp, r7
 8026b58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b5c:	4770      	bx	lr
 8026b5e:	bf00      	nop
 8026b60:	50004600 	.word	0x50004600

08026b64 <XMC_SCU_CLOCK_EnableClock>:
}
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
 8026b64:	b480      	push	{r7}
 8026b66:	b083      	sub	sp, #12
 8026b68:	af00      	add	r7, sp, #0
 8026b6a:	4603      	mov	r3, r0
 8026b6c:	71fb      	strb	r3, [r7, #7]
  SCU_CLK->CLKSET = ((uint32_t)clock);
 8026b6e:	4a04      	ldr	r2, [pc, #16]	; (8026b80 <XMC_SCU_CLOCK_EnableClock+0x1c>)
 8026b70:	79fb      	ldrb	r3, [r7, #7]
 8026b72:	6053      	str	r3, [r2, #4]
}
 8026b74:	bf00      	nop
 8026b76:	370c      	adds	r7, #12
 8026b78:	46bd      	mov	sp, r7
 8026b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b7e:	4770      	bx	lr
 8026b80:	50004600 	.word	0x50004600

08026b84 <XMC_SCU_CLOCK_EnableUsbPll>:
  return ((SCU_POWER->EVRVADCSTAT & SCU_POWER_EVRVADCSTAT_VADC33V_Msk) >> SCU_POWER_EVRVADCSTAT_VADC33V_Pos) * XMC_SCU_POWER_LSB33V;
}

/* API to enable USB PLL for USB clock */
void XMC_SCU_CLOCK_EnableUsbPll(void)
{
 8026b84:	b480      	push	{r7}
 8026b86:	af00      	add	r7, sp, #0
  SCU_PLL->USBPLLCON &= (uint32_t)~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 8026b88:	4b06      	ldr	r3, [pc, #24]	; (8026ba4 <XMC_SCU_CLOCK_EnableUsbPll+0x20>)
 8026b8a:	695b      	ldr	r3, [r3, #20]
 8026b8c:	4a05      	ldr	r2, [pc, #20]	; (8026ba4 <XMC_SCU_CLOCK_EnableUsbPll+0x20>)
 8026b8e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8026b92:	f023 0302 	bic.w	r3, r3, #2
 8026b96:	6153      	str	r3, [r2, #20]
}
 8026b98:	bf00      	nop
 8026b9a:	46bd      	mov	sp, r7
 8026b9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ba0:	4770      	bx	lr
 8026ba2:	bf00      	nop
 8026ba4:	50004710 	.word	0x50004710

08026ba8 <XMC_SCU_CLOCK_StartUsbPll>:
  SCU_PLL->USBPLLCON |= (uint32_t)(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
}

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
 8026ba8:	b480      	push	{r7}
 8026baa:	b083      	sub	sp, #12
 8026bac:	af00      	add	r7, sp, #0
 8026bae:	6078      	str	r0, [r7, #4]
 8026bb0:	6039      	str	r1, [r7, #0]
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8026bb2:	4b1a      	ldr	r3, [pc, #104]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bb4:	695b      	ldr	r3, [r3, #20]
 8026bb6:	4a19      	ldr	r2, [pc, #100]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bb8:	f043 0301 	orr.w	r3, r3, #1
 8026bbc:	6153      	str	r3, [r2, #20]

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8026bbe:	4b17      	ldr	r3, [pc, #92]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bc0:	695b      	ldr	r3, [r3, #20]
 8026bc2:	4a16      	ldr	r2, [pc, #88]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bc4:	f043 0310 	orr.w	r3, r3, #16
 8026bc8:	6153      	str	r3, [r2, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8026bca:	683b      	ldr	r3, [r7, #0]
 8026bcc:	3b01      	subs	r3, #1
 8026bce:	021a      	lsls	r2, r3, #8
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8026bd0:	687b      	ldr	r3, [r7, #4]
 8026bd2:	3b01      	subs	r3, #1
 8026bd4:	061b      	lsls	r3, r3, #24
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8026bd6:	4911      	ldr	r1, [pc, #68]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bd8:	4313      	orrs	r3, r2
 8026bda:	614b      	str	r3, [r1, #20]

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8026bdc:	4b0f      	ldr	r3, [pc, #60]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bde:	695b      	ldr	r3, [r3, #20]
 8026be0:	4a0e      	ldr	r2, [pc, #56]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026be2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8026be6:	6153      	str	r3, [r2, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 8026be8:	4b0c      	ldr	r3, [pc, #48]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bea:	695b      	ldr	r3, [r3, #20]
 8026bec:	4a0b      	ldr	r2, [pc, #44]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bee:	f023 0310 	bic.w	r3, r3, #16
 8026bf2:	6153      	str	r3, [r2, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8026bf4:	4b09      	ldr	r3, [pc, #36]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bf6:	695b      	ldr	r3, [r3, #20]
 8026bf8:	4a08      	ldr	r2, [pc, #32]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026bfa:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8026bfe:	6153      	str	r3, [r2, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 8026c00:	bf00      	nop
 8026c02:	4b06      	ldr	r3, [pc, #24]	; (8026c1c <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026c04:	691b      	ldr	r3, [r3, #16]
 8026c06:	f003 0304 	and.w	r3, r3, #4
 8026c0a:	2b00      	cmp	r3, #0
 8026c0c:	d0f9      	beq.n	8026c02 <XMC_SCU_CLOCK_StartUsbPll+0x5a>
  {
    /* wait for PLL Lock */
  }

}
 8026c0e:	bf00      	nop
 8026c10:	bf00      	nop
 8026c12:	370c      	adds	r7, #12
 8026c14:	46bd      	mov	sp, r7
 8026c16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026c1a:	4770      	bx	lr
 8026c1c:	50004710 	.word	0x50004710

08026c20 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>:
                                  SCU_PLL_USBPLLCON_VCOBYP_Msk);
}

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
 8026c20:	b580      	push	{r7, lr}
 8026c22:	b082      	sub	sp, #8
 8026c24:	af00      	add	r7, sp, #0
 8026c26:	4603      	mov	r3, r0
 8026c28:	71fb      	strb	r3, [r7, #7]
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8026c2a:	4b0f      	ldr	r3, [pc, #60]	; (8026c68 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026c2c:	685b      	ldr	r3, [r3, #4]
 8026c2e:	4a0e      	ldr	r2, [pc, #56]	; (8026c68 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026c30:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8026c34:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8026c36:	79fb      	ldrb	r3, [r7, #7]
 8026c38:	2b01      	cmp	r3, #1
 8026c3a:	d10e      	bne.n	8026c5a <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x3a>
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8026c3c:	4b0a      	ldr	r3, [pc, #40]	; (8026c68 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026c3e:	685b      	ldr	r3, [r3, #4]
 8026c40:	4a09      	ldr	r2, [pc, #36]	; (8026c68 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026c42:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8026c46:	6053      	str	r3, [r2, #4]
    XMC_SCU_lDelay(100UL);
 8026c48:	2064      	movs	r0, #100	; 0x64
 8026c4a:	f7ff fd91 	bl	8026770 <XMC_SCU_lDelay>

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 8026c4e:	4b06      	ldr	r3, [pc, #24]	; (8026c68 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026c50:	685b      	ldr	r3, [r3, #4]
 8026c52:	4a05      	ldr	r2, [pc, #20]	; (8026c68 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026c54:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8026c58:	6053      	str	r3, [r2, #4]
  }

  XMC_SCU_lDelay(100UL);
 8026c5a:	2064      	movs	r0, #100	; 0x64
 8026c5c:	f7ff fd88 	bl	8026770 <XMC_SCU_lDelay>
}
 8026c60:	bf00      	nop
 8026c62:	3708      	adds	r7, #8
 8026c64:	46bd      	mov	sp, r7
 8026c66:	bd80      	pop	{r7, pc}
 8026c68:	50004710 	.word	0x50004710

08026c6c <XMC_SCU_HIB_EnableHibernateDomain>:
  return (bool)((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) != 0UL);
}

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
 8026c6c:	b480      	push	{r7}
 8026c6e:	af00      	add	r7, sp, #0
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8026c70:	4b12      	ldr	r3, [pc, #72]	; (8026cbc <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8026c72:	681b      	ldr	r3, [r3, #0]
 8026c74:	f003 0301 	and.w	r3, r3, #1
 8026c78:	2b00      	cmp	r3, #0
 8026c7a:	d109      	bne.n	8026c90 <XMC_SCU_HIB_EnableHibernateDomain+0x24>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8026c7c:	4b0f      	ldr	r3, [pc, #60]	; (8026cbc <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8026c7e:	2201      	movs	r2, #1
 8026c80:	605a      	str	r2, [r3, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8026c82:	bf00      	nop
 8026c84:	4b0d      	ldr	r3, [pc, #52]	; (8026cbc <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8026c86:	681b      	ldr	r3, [r3, #0]
 8026c88:	f003 0301 	and.w	r3, r3, #1
 8026c8c:	2b00      	cmp	r3, #0
 8026c8e:	d0f9      	beq.n	8026c84 <XMC_SCU_HIB_EnableHibernateDomain+0x18>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 8026c90:	4b0b      	ldr	r3, [pc, #44]	; (8026cc0 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8026c92:	681b      	ldr	r3, [r3, #0]
 8026c94:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8026c98:	2b00      	cmp	r3, #0
 8026c9a:	d00a      	beq.n	8026cb2 <XMC_SCU_HIB_EnableHibernateDomain+0x46>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 8026c9c:	4b08      	ldr	r3, [pc, #32]	; (8026cc0 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8026c9e:	f44f 7200 	mov.w	r2, #512	; 0x200
 8026ca2:	609a      	str	r2, [r3, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8026ca4:	bf00      	nop
 8026ca6:	4b06      	ldr	r3, [pc, #24]	; (8026cc0 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8026ca8:	681b      	ldr	r3, [r3, #0]
 8026caa:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8026cae:	2b00      	cmp	r3, #0
 8026cb0:	d1f9      	bne.n	8026ca6 <XMC_SCU_HIB_EnableHibernateDomain+0x3a>
    {
      /* wait until HIB domain is enabled */
    }
  }
}
 8026cb2:	bf00      	nop
 8026cb4:	46bd      	mov	sp, r7
 8026cb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026cba:	4770      	bx	lr
 8026cbc:	50004200 	.word	0x50004200
 8026cc0:	50004400 	.word	0x50004400

08026cc4 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>:
}

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
 8026cc4:	b480      	push	{r7}
 8026cc6:	af00      	add	r7, sp, #0
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 8026cc8:	4b06      	ldr	r3, [pc, #24]	; (8026ce4 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable+0x20>)
 8026cca:	681b      	ldr	r3, [r3, #0]
 8026ccc:	f003 0308 	and.w	r3, r3, #8
 8026cd0:	2b00      	cmp	r3, #0
 8026cd2:	bf0c      	ite	eq
 8026cd4:	2301      	moveq	r3, #1
 8026cd6:	2300      	movne	r3, #0
 8026cd8:	b2db      	uxtb	r3, r3
}
 8026cda:	4618      	mov	r0, r3
 8026cdc:	46bd      	mov	sp, r7
 8026cde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ce2:	4770      	bx	lr
 8026ce4:	50004300 	.word	0x50004300

08026ce8 <XMC_SCU_CLOCK_EnableLowPowerOscillator>:

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
 8026ce8:	b580      	push	{r7, lr}
 8026cea:	af00      	add	r7, sp, #0
  /* Enable OSC_ULP */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED);
 8026cec:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8026cf0:	f7ff fd6e 	bl	80267d0 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8026cf4:	4b18      	ldr	r3, [pc, #96]	; (8026d58 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026cf6:	69db      	ldr	r3, [r3, #28]
 8026cf8:	4a17      	ldr	r2, [pc, #92]	; (8026d58 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026cfa:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8026cfe:	61d3      	str	r3, [r2, #28]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED) == 0);
 8026d00:	bf00      	nop
 8026d02:	f7ff fd59 	bl	80267b8 <XMC_SCU_INTERUPT_GetEventStatus>
 8026d06:	4603      	mov	r3, r0
 8026d08:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8026d0c:	2b00      	cmp	r3, #0
 8026d0e:	d0f8      	beq.n	8026d02 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x1a>

  /* Clear ULP WDG status */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED);
 8026d10:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8026d14:	f7ff fd5c 	bl	80267d0 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCLR = (uint32_t)SCU_HIBERNATE_HDCLR_ULPWDG_Msk;
 8026d18:	4b0f      	ldr	r3, [pc, #60]	; (8026d58 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026d1a:	2208      	movs	r2, #8
 8026d1c:	605a      	str	r2, [r3, #4]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED) == 0);
 8026d1e:	bf00      	nop
 8026d20:	f7ff fd4a 	bl	80267b8 <XMC_SCU_INTERUPT_GetEventStatus>
 8026d24:	4603      	mov	r3, r0
 8026d26:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8026d2a:	2b00      	cmp	r3, #0
 8026d2c:	d0f8      	beq.n	8026d20 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x38>

  /* Enable ULP WDG */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED);
 8026d2e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8026d32:	f7ff fd4d 	bl	80267d0 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 8026d36:	4b08      	ldr	r3, [pc, #32]	; (8026d58 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026d38:	68db      	ldr	r3, [r3, #12]
 8026d3a:	4a07      	ldr	r2, [pc, #28]	; (8026d58 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026d3c:	f043 0308 	orr.w	r3, r3, #8
 8026d40:	60d3      	str	r3, [r2, #12]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED) == 0);
 8026d42:	bf00      	nop
 8026d44:	f7ff fd38 	bl	80267b8 <XMC_SCU_INTERUPT_GetEventStatus>
 8026d48:	4603      	mov	r3, r0
 8026d4a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8026d4e:	2b00      	cmp	r3, #0
 8026d50:	d0f8      	beq.n	8026d44 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x5c>
}
 8026d52:	bf00      	nop
 8026d54:	bf00      	nop
 8026d56:	bd80      	pop	{r7, pc}
 8026d58:	50004300 	.word	0x50004300

08026d5c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>:
  return (SCU_HIBERNATE->OSCULSTAT & SCU_HIBERNATE_OSCULSTAT_X1D_Msk);
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
 8026d5c:	b598      	push	{r3, r4, r7, lr}
 8026d5e:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8026d60:	4b0f      	ldr	r3, [pc, #60]	; (8026da0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026d62:	685b      	ldr	r3, [r3, #4]
 8026d64:	4a0e      	ldr	r2, [pc, #56]	; (8026da0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026d66:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8026d6a:	6053      	str	r3, [r2, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8026d6c:	4b0d      	ldr	r3, [pc, #52]	; (8026da4 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 8026d6e:	685b      	ldr	r3, [r3, #4]
 8026d70:	f423 2470 	bic.w	r4, r3, #983040	; 0xf0000
 8026d74:	f024 0430 	bic.w	r4, r4, #48	; 0x30
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8026d78:	f003 f834 	bl	8029de4 <OSCHP_GetFrequency>
 8026d7c:	4603      	mov	r3, r0
 8026d7e:	4a0a      	ldr	r2, [pc, #40]	; (8026da8 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x4c>)
 8026d80:	fba2 2303 	umull	r2, r3, r2, r3
 8026d84:	0d1b      	lsrs	r3, r3, #20
 8026d86:	3b01      	subs	r3, #1
 8026d88:	041b      	lsls	r3, r3, #16
  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8026d8a:	4a06      	ldr	r2, [pc, #24]	; (8026da4 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 8026d8c:	4323      	orrs	r3, r4
 8026d8e:	6053      	str	r3, [r2, #4]

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 8026d90:	4b03      	ldr	r3, [pc, #12]	; (8026da0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026d92:	685b      	ldr	r3, [r3, #4]
 8026d94:	4a02      	ldr	r2, [pc, #8]	; (8026da0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026d96:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8026d9a:	6053      	str	r3, [r2, #4]
}
 8026d9c:	bf00      	nop
 8026d9e:	bd98      	pop	{r3, r4, r7, pc}
 8026da0:	50004710 	.word	0x50004710
 8026da4:	50004700 	.word	0x50004700
 8026da8:	6b5fca6b 	.word	0x6b5fca6b

08026dac <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>:

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
 8026dac:	b480      	push	{r7}
 8026dae:	af00      	add	r7, sp, #0
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 8026db0:	4b07      	ldr	r3, [pc, #28]	; (8026dd0 <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable+0x24>)
 8026db2:	681b      	ldr	r3, [r3, #0]
 8026db4:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8026db8:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8026dbc:	bf0c      	ite	eq
 8026dbe:	2301      	moveq	r3, #1
 8026dc0:	2300      	movne	r3, #0
 8026dc2:	b2db      	uxtb	r3, r3
}
 8026dc4:	4618      	mov	r0, r3
 8026dc6:	46bd      	mov	sp, r7
 8026dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026dcc:	4770      	bx	lr
 8026dce:	bf00      	nop
 8026dd0:	50004710 	.word	0x50004710

08026dd4 <XMC_SCU_CLOCK_EnableSystemPll>:
  return (SCU_OSC->OSCHPSTAT & SCU_OSC_OSCHPSTAT_X1D_Msk);
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
 8026dd4:	b480      	push	{r7}
 8026dd6:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8026dd8:	4b06      	ldr	r3, [pc, #24]	; (8026df4 <XMC_SCU_CLOCK_EnableSystemPll+0x20>)
 8026dda:	685b      	ldr	r3, [r3, #4]
 8026ddc:	4a05      	ldr	r2, [pc, #20]	; (8026df4 <XMC_SCU_CLOCK_EnableSystemPll+0x20>)
 8026dde:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8026de2:	f023 0302 	bic.w	r3, r3, #2
 8026de6:	6053      	str	r3, [r2, #4]
}
 8026de8:	bf00      	nop
 8026dea:	46bd      	mov	sp, r7
 8026dec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026df0:	4770      	bx	lr
 8026df2:	bf00      	nop
 8026df4:	50004710 	.word	0x50004710

08026df8 <XMC_SCU_CLOCK_DisableSystemPll>:

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
 8026df8:	b480      	push	{r7}
 8026dfa:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8026dfc:	4b06      	ldr	r3, [pc, #24]	; (8026e18 <XMC_SCU_CLOCK_DisableSystemPll+0x20>)
 8026dfe:	685b      	ldr	r3, [r3, #4]
 8026e00:	4a05      	ldr	r2, [pc, #20]	; (8026e18 <XMC_SCU_CLOCK_DisableSystemPll+0x20>)
 8026e02:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8026e06:	f043 0302 	orr.w	r3, r3, #2
 8026e0a:	6053      	str	r3, [r2, #4]
}
 8026e0c:	bf00      	nop
 8026e0e:	46bd      	mov	sp, r7
 8026e10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026e14:	4770      	bx	lr
 8026e16:	bf00      	nop
 8026e18:	50004710 	.word	0x50004710

08026e1c <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 8026e1c:	b580      	push	{r7, lr}
 8026e1e:	b086      	sub	sp, #24
 8026e20:	af00      	add	r7, sp, #0
 8026e22:	60ba      	str	r2, [r7, #8]
 8026e24:	607b      	str	r3, [r7, #4]
 8026e26:	4603      	mov	r3, r0
 8026e28:	81fb      	strh	r3, [r7, #14]
 8026e2a:	460b      	mov	r3, r1
 8026e2c:	737b      	strb	r3, [r7, #13]

  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);
 8026e2e:	89fb      	ldrh	r3, [r7, #14]
 8026e30:	4618      	mov	r0, r3
 8026e32:	f7ff fdc5 	bl	80269c0 <XMC_SCU_CLOCK_SetSystemPllClockSource>

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8026e36:	7b7b      	ldrb	r3, [r7, #13]
 8026e38:	2b01      	cmp	r3, #1
 8026e3a:	f040 8084 	bne.w	8026f46 <XMC_SCU_CLOCK_StartSystemPll+0x12a>
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
 8026e3e:	89fb      	ldrh	r3, [r7, #14]
 8026e40:	2b00      	cmp	r3, #0
 8026e42:	d109      	bne.n	8026e58 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 8026e44:	f002 ffce 	bl	8029de4 <OSCHP_GetFrequency>
 8026e48:	4603      	mov	r3, r0
 8026e4a:	4a4c      	ldr	r2, [pc, #304]	; (8026f7c <XMC_SCU_CLOCK_StartSystemPll+0x160>)
 8026e4c:	fba2 2303 	umull	r2, r3, r2, r3
 8026e50:	0c9b      	lsrs	r3, r3, #18
 8026e52:	059b      	lsls	r3, r3, #22
 8026e54:	617b      	str	r3, [r7, #20]
 8026e56:	e002      	b.n	8026e5e <XMC_SCU_CLOCK_StartSystemPll+0x42>
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 8026e58:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 8026e5c:	617b      	str	r3, [r7, #20]
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 8026e5e:	697b      	ldr	r3, [r7, #20]
 8026e60:	687a      	ldr	r2, [r7, #4]
 8026e62:	fb03 f202 	mul.w	r2, r3, r2
 8026e66:	68bb      	ldr	r3, [r7, #8]
 8026e68:	fbb2 f3f3 	udiv	r3, r2, r3
 8026e6c:	617b      	str	r3, [r7, #20]
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8026e6e:	697b      	ldr	r3, [r7, #20]
 8026e70:	4a43      	ldr	r2, [pc, #268]	; (8026f80 <XMC_SCU_CLOCK_StartSystemPll+0x164>)
 8026e72:	fba2 2303 	umull	r2, r3, r2, r3
 8026e76:	091b      	lsrs	r3, r3, #4
 8026e78:	0d9b      	lsrs	r3, r3, #22
 8026e7a:	613b      	str	r3, [r7, #16]

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8026e7c:	4b41      	ldr	r3, [pc, #260]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e7e:	685b      	ldr	r3, [r3, #4]
 8026e80:	4a40      	ldr	r2, [pc, #256]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e82:	f043 0301 	orr.w	r3, r3, #1
 8026e86:	6053      	str	r3, [r2, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 8026e88:	4b3e      	ldr	r3, [pc, #248]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e8a:	685b      	ldr	r3, [r3, #4]
 8026e8c:	4a3d      	ldr	r2, [pc, #244]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e8e:	f043 0310 	orr.w	r3, r3, #16
 8026e92:	6053      	str	r3, [r2, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8026e94:	4b3b      	ldr	r3, [pc, #236]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e96:	689a      	ldr	r2, [r3, #8]
 8026e98:	4b3b      	ldr	r3, [pc, #236]	; (8026f88 <XMC_SCU_CLOCK_StartSystemPll+0x16c>)
 8026e9a:	4013      	ands	r3, r2
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8026e9c:	687a      	ldr	r2, [r7, #4]
 8026e9e:	3a01      	subs	r2, #1
 8026ea0:	0212      	lsls	r2, r2, #8
 8026ea2:	431a      	orrs	r2, r3
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 8026ea4:	693b      	ldr	r3, [r7, #16]
 8026ea6:	3b01      	subs	r3, #1
 8026ea8:	041b      	lsls	r3, r3, #16
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8026eaa:	431a      	orrs	r2, r3
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 8026eac:	68bb      	ldr	r3, [r7, #8]
 8026eae:	3b01      	subs	r3, #1
 8026eb0:	061b      	lsls	r3, r3, #24
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8026eb2:	4934      	ldr	r1, [pc, #208]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026eb4:	4313      	orrs	r3, r2
 8026eb6:	608b      	str	r3, [r1, #8]

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8026eb8:	4b32      	ldr	r3, [pc, #200]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026eba:	685b      	ldr	r3, [r3, #4]
 8026ebc:	4a31      	ldr	r2, [pc, #196]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026ebe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8026ec2:	6053      	str	r3, [r2, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 8026ec4:	4b2f      	ldr	r3, [pc, #188]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026ec6:	685b      	ldr	r3, [r3, #4]
 8026ec8:	4a2e      	ldr	r2, [pc, #184]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026eca:	f023 0310 	bic.w	r3, r3, #16
 8026ece:	6053      	str	r3, [r2, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 8026ed0:	4b2c      	ldr	r3, [pc, #176]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026ed2:	685b      	ldr	r3, [r3, #4]
 8026ed4:	4a2b      	ldr	r2, [pc, #172]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026ed6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8026eda:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 8026edc:	bf00      	nop
 8026ede:	4b29      	ldr	r3, [pc, #164]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026ee0:	681b      	ldr	r3, [r3, #0]
 8026ee2:	f003 0304 	and.w	r3, r3, #4
 8026ee6:	2b00      	cmp	r3, #0
 8026ee8:	d0f9      	beq.n	8026ede <XMC_SCU_CLOCK_StartSystemPll+0xc2>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8026eea:	4b26      	ldr	r3, [pc, #152]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026eec:	685b      	ldr	r3, [r3, #4]
 8026eee:	4a25      	ldr	r2, [pc, #148]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026ef0:	f023 0301 	bic.w	r3, r3, #1
 8026ef4:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8026ef6:	bf00      	nop
 8026ef8:	4b22      	ldr	r3, [pc, #136]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026efa:	681b      	ldr	r3, [r3, #0]
 8026efc:	f003 0301 	and.w	r3, r3, #1
 8026f00:	2b00      	cmp	r3, #0
 8026f02:	d1f9      	bne.n	8026ef8 <XMC_SCU_CLOCK_StartSystemPll+0xdc>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 8026f04:	697b      	ldr	r3, [r7, #20]
 8026f06:	4a21      	ldr	r2, [pc, #132]	; (8026f8c <XMC_SCU_CLOCK_StartSystemPll+0x170>)
 8026f08:	fba2 2303 	umull	r2, r3, r2, r3
 8026f0c:	095b      	lsrs	r3, r3, #5
 8026f0e:	0d9b      	lsrs	r3, r3, #22
 8026f10:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8026f12:	6a3a      	ldr	r2, [r7, #32]
 8026f14:	693b      	ldr	r3, [r7, #16]
 8026f16:	429a      	cmp	r2, r3
 8026f18:	d202      	bcs.n	8026f20 <XMC_SCU_CLOCK_StartSystemPll+0x104>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8026f1a:	6938      	ldr	r0, [r7, #16]
 8026f1c:	f000 f83a 	bl	8026f94 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 8026f20:	697b      	ldr	r3, [r7, #20]
 8026f22:	085b      	lsrs	r3, r3, #1
 8026f24:	4a1a      	ldr	r2, [pc, #104]	; (8026f90 <XMC_SCU_CLOCK_StartSystemPll+0x174>)
 8026f26:	fba2 2303 	umull	r2, r3, r2, r3
 8026f2a:	095b      	lsrs	r3, r3, #5
 8026f2c:	0d9b      	lsrs	r3, r3, #22
 8026f2e:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8026f30:	6a3a      	ldr	r2, [r7, #32]
 8026f32:	693b      	ldr	r3, [r7, #16]
 8026f34:	429a      	cmp	r2, r3
 8026f36:	d202      	bcs.n	8026f3e <XMC_SCU_CLOCK_StartSystemPll+0x122>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8026f38:	6938      	ldr	r0, [r7, #16]
 8026f3a:	f000 f82b 	bl	8026f94 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
 8026f3e:	6a38      	ldr	r0, [r7, #32]
 8026f40:	f000 f828 	bl	8026f94 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
    {
      /* wait for prescaler mode */
    }
  }
}
 8026f44:	e015      	b.n	8026f72 <XMC_SCU_CLOCK_StartSystemPll+0x156>
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8026f46:	4b0f      	ldr	r3, [pc, #60]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026f48:	689b      	ldr	r3, [r3, #8]
 8026f4a:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 8026f4e:	6a3b      	ldr	r3, [r7, #32]
 8026f50:	3b01      	subs	r3, #1
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8026f52:	490c      	ldr	r1, [pc, #48]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026f54:	4313      	orrs	r3, r2
 8026f56:	608b      	str	r3, [r1, #8]
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8026f58:	4b0a      	ldr	r3, [pc, #40]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026f5a:	685b      	ldr	r3, [r3, #4]
 8026f5c:	4a09      	ldr	r2, [pc, #36]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026f5e:	f043 0301 	orr.w	r3, r3, #1
 8026f62:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 8026f64:	bf00      	nop
 8026f66:	4b07      	ldr	r3, [pc, #28]	; (8026f84 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026f68:	681b      	ldr	r3, [r3, #0]
 8026f6a:	f003 0301 	and.w	r3, r3, #1
 8026f6e:	2b00      	cmp	r3, #0
 8026f70:	d0f9      	beq.n	8026f66 <XMC_SCU_CLOCK_StartSystemPll+0x14a>
}
 8026f72:	bf00      	nop
 8026f74:	3718      	adds	r7, #24
 8026f76:	46bd      	mov	sp, r7
 8026f78:	bd80      	pop	{r7, pc}
 8026f7a:	bf00      	nop
 8026f7c:	431bde83 	.word	0x431bde83
 8026f80:	aaaaaaab 	.word	0xaaaaaaab
 8026f84:	50004710 	.word	0x50004710
 8026f88:	f08080ff 	.word	0xf08080ff
 8026f8c:	88888889 	.word	0x88888889
 8026f90:	b60b60b7 	.word	0xb60b60b7

08026f94 <XMC_SCU_CLOCK_StepSystemPllFrequency>:
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_PLLPWD_Msk;
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
 8026f94:	b580      	push	{r7, lr}
 8026f96:	b082      	sub	sp, #8
 8026f98:	af00      	add	r7, sp, #0
 8026f9a:	6078      	str	r0, [r7, #4]
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8026f9c:	4b08      	ldr	r3, [pc, #32]	; (8026fc0 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x2c>)
 8026f9e:	689b      	ldr	r3, [r3, #8]
 8026fa0:	f423 02fe 	bic.w	r2, r3, #8323072	; 0x7f0000
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 8026fa4:	687b      	ldr	r3, [r7, #4]
 8026fa6:	3b01      	subs	r3, #1
 8026fa8:	041b      	lsls	r3, r3, #16
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8026faa:	4905      	ldr	r1, [pc, #20]	; (8026fc0 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x2c>)
 8026fac:	4313      	orrs	r3, r2
 8026fae:	608b      	str	r3, [r1, #8]

  XMC_SCU_lDelay(50U);
 8026fb0:	2032      	movs	r0, #50	; 0x32
 8026fb2:	f7ff fbdd 	bl	8026770 <XMC_SCU_lDelay>
}
 8026fb6:	bf00      	nop
 8026fb8:	3708      	adds	r7, #8
 8026fba:	46bd      	mov	sp, r7
 8026fbc:	bd80      	pop	{r7, pc}
 8026fbe:	bf00      	nop
 8026fc0:	50004710 	.word	0x50004710

08026fc4 <XMC_CAN_IsPanelControlReady>:
 * \par<b>Related APIs:</b><BR>
 *  XMC_CAN_PanelControl()
 *
 */
__STATIC_INLINE bool XMC_CAN_IsPanelControlReady(XMC_CAN_t *const obj)
{
 8026fc4:	b480      	push	{r7}
 8026fc6:	b083      	sub	sp, #12
 8026fc8:	af00      	add	r7, sp, #0
 8026fca:	6078      	str	r0, [r7, #4]
  return (bool)((obj->PANCTR & (CAN_PANCTR_BUSY_Msk | CAN_PANCTR_RBUSY_Msk)) == 0);
 8026fcc:	687b      	ldr	r3, [r7, #4]
 8026fce:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8026fd2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8026fd6:	2b00      	cmp	r3, #0
 8026fd8:	bf0c      	ite	eq
 8026fda:	2301      	moveq	r3, #1
 8026fdc:	2300      	movne	r3, #0
 8026fde:	b2db      	uxtb	r3, r3
}
 8026fe0:	4618      	mov	r0, r3
 8026fe2:	370c      	adds	r7, #12
 8026fe4:	46bd      	mov	sp, r7
 8026fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026fea:	4770      	bx	lr

08026fec <XMC_CAN_PanelControl>:

__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
 8026fec:	b480      	push	{r7}
 8026fee:	b083      	sub	sp, #12
 8026ff0:	af00      	add	r7, sp, #0
 8026ff2:	6078      	str	r0, [r7, #4]
 8026ff4:	4608      	mov	r0, r1
 8026ff6:	4611      	mov	r1, r2
 8026ff8:	461a      	mov	r2, r3
 8026ffa:	4603      	mov	r3, r0
 8026ffc:	70fb      	strb	r3, [r7, #3]
 8026ffe:	460b      	mov	r3, r1
 8027000:	70bb      	strb	r3, [r7, #2]
 8027002:	4613      	mov	r3, r2
 8027004:	707b      	strb	r3, [r7, #1]
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8027006:	78fa      	ldrb	r2, [r7, #3]
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 8027008:	78bb      	ldrb	r3, [r7, #2]
 802700a:	041b      	lsls	r3, r3, #16
 802700c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8027010:	431a      	orrs	r2, r3
                (((uint32_t)arg2 << CAN_PANCTR_PANAR2_Pos) & (uint32_t)CAN_PANCTR_PANAR2_Msk);
 8027012:	787b      	ldrb	r3, [r7, #1]
 8027014:	061b      	lsls	r3, r3, #24
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 8027016:	431a      	orrs	r2, r3
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8027018:	687b      	ldr	r3, [r7, #4]
 802701a:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
}
 802701e:	bf00      	nop
 8027020:	370c      	adds	r7, #12
 8027022:	46bd      	mov	sp, r7
 8027024:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027028:	4770      	bx	lr

0802702a <XMC_CAN_NODE_EnableConfigurationChange>:
 * XMC_CAN_NODE_DisableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
 802702a:	b480      	push	{r7}
 802702c:	b083      	sub	sp, #12
 802702e:	af00      	add	r7, sp, #0
 8027030:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8027032:	687b      	ldr	r3, [r7, #4]
 8027034:	681b      	ldr	r3, [r3, #0]
 8027036:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 802703a:	687b      	ldr	r3, [r7, #4]
 802703c:	601a      	str	r2, [r3, #0]
}
 802703e:	bf00      	nop
 8027040:	370c      	adds	r7, #12
 8027042:	46bd      	mov	sp, r7
 8027044:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027048:	4770      	bx	lr

0802704a <XMC_CAN_NODE_DisableConfigurationChange>:
 * XMC_CAN_NODE_EnableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
 802704a:	b480      	push	{r7}
 802704c:	b083      	sub	sp, #12
 802704e:	af00      	add	r7, sp, #0
 8027050:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 8027052:	687b      	ldr	r3, [r7, #4]
 8027054:	681b      	ldr	r3, [r3, #0]
 8027056:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 802705a:	687b      	ldr	r3, [r7, #4]
 802705c:	601a      	str	r2, [r3, #0]
}
 802705e:	bf00      	nop
 8027060:	370c      	adds	r7, #12
 8027062:	46bd      	mov	sp, r7
 8027064:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027068:	4770      	bx	lr

0802706a <max>:

#if defined(CAN)
#include "xmc_scu.h"

__STATIC_INLINE uint32_t max(uint32_t a, uint32_t b)
{
 802706a:	b480      	push	{r7}
 802706c:	b083      	sub	sp, #12
 802706e:	af00      	add	r7, sp, #0
 8027070:	6078      	str	r0, [r7, #4]
 8027072:	6039      	str	r1, [r7, #0]
  return (a > b) ? a : b;
 8027074:	683a      	ldr	r2, [r7, #0]
 8027076:	687b      	ldr	r3, [r7, #4]
 8027078:	4293      	cmp	r3, r2
 802707a:	bf38      	it	cc
 802707c:	4613      	movcc	r3, r2
}
 802707e:	4618      	mov	r0, r3
 8027080:	370c      	adds	r7, #12
 8027082:	46bd      	mov	sp, r7
 8027084:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027088:	4770      	bx	lr

0802708a <min>:

__STATIC_INLINE uint32_t min(uint32_t a, uint32_t b)
{
 802708a:	b480      	push	{r7}
 802708c:	b083      	sub	sp, #12
 802708e:	af00      	add	r7, sp, #0
 8027090:	6078      	str	r0, [r7, #4]
 8027092:	6039      	str	r1, [r7, #0]
  return (a < b) ? a : b;
 8027094:	683a      	ldr	r2, [r7, #0]
 8027096:	687b      	ldr	r3, [r7, #4]
 8027098:	4293      	cmp	r3, r2
 802709a:	bf28      	it	cs
 802709c:	4613      	movcs	r3, r2
}
 802709e:	4618      	mov	r0, r3
 80270a0:	370c      	adds	r7, #12
 80270a2:	46bd      	mov	sp, r7
 80270a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80270a8:	4770      	bx	lr
	...

080270ac <XMC_CAN_NODE_NominalBitTimeConfigureEx>:
#define XMC_CAN_NODE_MAX_TSEG2 7


int32_t XMC_CAN_NODE_NominalBitTimeConfigureEx(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const bit_time_config)
{
 80270ac:	b580      	push	{r7, lr}
 80270ae:	b088      	sub	sp, #32
 80270b0:	af00      	add	r7, sp, #0
 80270b2:	6078      	str	r0, [r7, #4]
 80270b4:	6039      	str	r1, [r7, #0]
  /* Check that the CAN frequency is a multiple of the required baudrate */
  if ((bit_time_config->can_frequency % bit_time_config->baudrate) == 0)
 80270b6:	683b      	ldr	r3, [r7, #0]
 80270b8:	681b      	ldr	r3, [r3, #0]
 80270ba:	683a      	ldr	r2, [r7, #0]
 80270bc:	6852      	ldr	r2, [r2, #4]
 80270be:	fbb3 f1f2 	udiv	r1, r3, r2
 80270c2:	fb01 f202 	mul.w	r2, r1, r2
 80270c6:	1a9b      	subs	r3, r3, r2
 80270c8:	2b00      	cmp	r3, #0
 80270ca:	f040 8091 	bne.w	80271f0 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x144>
  {
    uint32_t prescaler = 0;
 80270ce:	2300      	movs	r3, #0
 80270d0:	61fb      	str	r3, [r7, #28]
    uint32_t div8 = 0;
 80270d2:	2300      	movs	r3, #0
 80270d4:	61bb      	str	r3, [r7, #24]

    /* Calculate the factor between can frequency and required baudrate, this is equal to (prescaler x ntq) */
    uint32_t fcan_div = bit_time_config->can_frequency / bit_time_config->baudrate;
 80270d6:	683b      	ldr	r3, [r7, #0]
 80270d8:	681a      	ldr	r2, [r3, #0]
 80270da:	683b      	ldr	r3, [r7, #0]
 80270dc:	685b      	ldr	r3, [r3, #4]
 80270de:	fbb2 f3f3 	udiv	r3, r2, r3
 80270e2:	60bb      	str	r3, [r7, #8]

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
 80270e4:	2319      	movs	r3, #25
 80270e6:	617b      	str	r3, [r7, #20]
    uint32_t tseg1 = 0;
 80270e8:	2300      	movs	r3, #0
 80270ea:	613b      	str	r3, [r7, #16]
    uint32_t tseg2 = 0;
 80270ec:	2300      	movs	r3, #0
 80270ee:	60fb      	str	r3, [r7, #12]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 80270f0:	e04a      	b.n	8027188 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xdc>
    {
      /* consider this ntq, only if fcan_div is multiple of ntq */
      if ((fcan_div % ntq) == 0)
 80270f2:	68bb      	ldr	r3, [r7, #8]
 80270f4:	697a      	ldr	r2, [r7, #20]
 80270f6:	fbb3 f2f2 	udiv	r2, r3, r2
 80270fa:	6979      	ldr	r1, [r7, #20]
 80270fc:	fb01 f202 	mul.w	r2, r1, r2
 8027100:	1a9b      	subs	r3, r3, r2
 8027102:	2b00      	cmp	r3, #0
 8027104:	d13d      	bne.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
      {
        div8 = 0;
 8027106:	2300      	movs	r3, #0
 8027108:	61bb      	str	r3, [r7, #24]
        prescaler = fcan_div / ntq;
 802710a:	68ba      	ldr	r2, [r7, #8]
 802710c:	697b      	ldr	r3, [r7, #20]
 802710e:	fbb2 f3f3 	udiv	r3, r2, r3
 8027112:	61fb      	str	r3, [r7, #28]
        if ((prescaler > 0) && (prescaler <= XMC_CAN_NODE_MAX_PRESCALER))
 8027114:	69fb      	ldr	r3, [r7, #28]
 8027116:	2b00      	cmp	r3, #0
 8027118:	d033      	beq.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 802711a:	69fb      	ldr	r3, [r7, #28]
 802711c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8027120:	d82f      	bhi.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
        {
          if (prescaler >= 64)
 8027122:	69fb      	ldr	r3, [r7, #28]
 8027124:	2b3f      	cmp	r3, #63	; 0x3f
 8027126:	d90a      	bls.n	802713e <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x92>
          {
            /* consider prescaler >=64, if it is integer divisible by 8*/
            if ((prescaler & 0x7U) != 0)
 8027128:	69fb      	ldr	r3, [r7, #28]
 802712a:	f003 0307 	and.w	r3, r3, #7
 802712e:	2b00      	cmp	r3, #0
 8027130:	d003      	beq.n	802713a <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x8e>
            {
              --ntq;
 8027132:	697b      	ldr	r3, [r7, #20]
 8027134:	3b01      	subs	r3, #1
 8027136:	617b      	str	r3, [r7, #20]
              continue;
 8027138:	e026      	b.n	8027188 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xdc>
            }
            else
            {
              div8 = 1;
 802713a:	2301      	movs	r3, #1
 802713c:	61bb      	str	r3, [r7, #24]
            }
          }

          tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 10000;
 802713e:	697b      	ldr	r3, [r7, #20]
 8027140:	3b01      	subs	r3, #1
 8027142:	683a      	ldr	r2, [r7, #0]
 8027144:	8912      	ldrh	r2, [r2, #8]
 8027146:	fb02 f303 	mul.w	r3, r2, r3
 802714a:	4a2c      	ldr	r2, [pc, #176]	; (80271fc <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x150>)
 802714c:	fba2 2303 	umull	r2, r3, r2, r3
 8027150:	0b5b      	lsrs	r3, r3, #13
 8027152:	613b      	str	r3, [r7, #16]
          tseg2 = ntq - tseg1 - 1;
 8027154:	697a      	ldr	r2, [r7, #20]
 8027156:	693b      	ldr	r3, [r7, #16]
 8027158:	1ad3      	subs	r3, r2, r3
 802715a:	3b01      	subs	r3, #1
 802715c:	60fb      	str	r3, [r7, #12]

          if ((XMC_CAN_NODE_MIN_TSEG1 <= tseg1) && (tseg1 <= XMC_CAN_NODE_MAX_TSEG1) &&
 802715e:	693b      	ldr	r3, [r7, #16]
 8027160:	2b02      	cmp	r3, #2
 8027162:	d90e      	bls.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 8027164:	693b      	ldr	r3, [r7, #16]
 8027166:	2b0f      	cmp	r3, #15
 8027168:	d80b      	bhi.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 802716a:	68fb      	ldr	r3, [r7, #12]
 802716c:	2b01      	cmp	r3, #1
 802716e:	d908      	bls.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
              (XMC_CAN_NODE_MIN_TSEG2 <= tseg2) && (tseg2 < XMC_CAN_NODE_MAX_TSEG2) && (tseg2 >= bit_time_config->sjw))
 8027170:	68fb      	ldr	r3, [r7, #12]
 8027172:	2b06      	cmp	r3, #6
 8027174:	d805      	bhi.n	8027182 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 8027176:	683b      	ldr	r3, [r7, #0]
 8027178:	895b      	ldrh	r3, [r3, #10]
 802717a:	461a      	mov	r2, r3
 802717c:	68fb      	ldr	r3, [r7, #12]
 802717e:	4293      	cmp	r3, r2
 8027180:	d206      	bcs.n	8027190 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe4>
          }


        }
      }
      --ntq;
 8027182:	697b      	ldr	r3, [r7, #20]
 8027184:	3b01      	subs	r3, #1
 8027186:	617b      	str	r3, [r7, #20]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8027188:	697b      	ldr	r3, [r7, #20]
 802718a:	2b07      	cmp	r3, #7
 802718c:	d8b1      	bhi.n	80270f2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x46>
 802718e:	e000      	b.n	8027192 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe6>
            break;
 8027190:	bf00      	nop
    }

    if (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8027192:	697b      	ldr	r3, [r7, #20]
 8027194:	2b07      	cmp	r3, #7
 8027196:	d92b      	bls.n	80271f0 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x144>

      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: prescaler", (prescaler != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg1", (tseg1 != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg2", (tseg2 != 0));

      XMC_CAN_NODE_EnableConfigurationChange(can_node);
 8027198:	6878      	ldr	r0, [r7, #4]
 802719a:	f7ff ff46 	bl	802702a <XMC_CAN_NODE_EnableConfigurationChange>

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 802719e:	68fb      	ldr	r3, [r7, #12]
 80271a0:	3b01      	subs	r3, #1
 80271a2:	031b      	lsls	r3, r3, #12
 80271a4:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 80271a8:	683b      	ldr	r3, [r7, #0]
 80271aa:	895b      	ldrh	r3, [r3, #10]
 80271ac:	3b01      	subs	r3, #1
 80271ae:	019b      	lsls	r3, r3, #6
 80271b0:	b2db      	uxtb	r3, r3
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 80271b2:	431a      	orrs	r2, r3
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 80271b4:	693b      	ldr	r3, [r7, #16]
 80271b6:	3b01      	subs	r3, #1
 80271b8:	021b      	lsls	r3, r3, #8
 80271ba:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 80271be:	ea42 0103 	orr.w	r1, r2, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 80271c2:	69ba      	ldr	r2, [r7, #24]
 80271c4:	4613      	mov	r3, r2
 80271c6:	005b      	lsls	r3, r3, #1
 80271c8:	4413      	add	r3, r2
 80271ca:	69fa      	ldr	r2, [r7, #28]
 80271cc:	fa22 f303 	lsr.w	r3, r2, r3
 80271d0:	3b01      	subs	r3, #1
 80271d2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 80271d6:	ea41 0203 	orr.w	r2, r1, r3
                       ((div8 << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
 80271da:	69bb      	ldr	r3, [r7, #24]
 80271dc:	03db      	lsls	r3, r3, #15
 80271de:	b29b      	uxth	r3, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 80271e0:	431a      	orrs	r2, r3
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 80271e2:	687b      	ldr	r3, [r7, #4]
 80271e4:	611a      	str	r2, [r3, #16]

      XMC_CAN_NODE_DisableConfigurationChange(can_node);
 80271e6:	6878      	ldr	r0, [r7, #4]
 80271e8:	f7ff ff2f 	bl	802704a <XMC_CAN_NODE_DisableConfigurationChange>

      return XMC_CAN_STATUS_SUCCESS;
 80271ec:	2300      	movs	r3, #0
 80271ee:	e000      	b.n	80271f2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x146>
    }
  }

  return XMC_CAN_STATUS_ERROR;
 80271f0:	2301      	movs	r3, #1
}
 80271f2:	4618      	mov	r0, r3
 80271f4:	3720      	adds	r7, #32
 80271f6:	46bd      	mov	sp, r7
 80271f8:	bd80      	pop	{r7, pc}
 80271fa:	bf00      	nop
 80271fc:	d1b71759 	.word	0xd1b71759

08027200 <XMC_CAN_AllocateMOtoNodeList>:
                   (((uint32_t)0U << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
  XMC_CAN_NODE_DisableConfigurationChange(can_node);
}
/* Function to allocate message object from free list to node list */
void XMC_CAN_AllocateMOtoNodeList(XMC_CAN_t *const obj, const uint8_t node_num, const uint8_t mo_num)
{
 8027200:	b580      	push	{r7, lr}
 8027202:	b082      	sub	sp, #8
 8027204:	af00      	add	r7, sp, #0
 8027206:	6078      	str	r0, [r7, #4]
 8027208:	460b      	mov	r3, r1
 802720a:	70fb      	strb	r3, [r7, #3]
 802720c:	4613      	mov	r3, r2
 802720e:	70bb      	strb	r3, [r7, #2]
  /* wait while panel operation is in progress. */
  while (XMC_CAN_IsPanelControlReady(obj) == false)
 8027210:	bf00      	nop
 8027212:	6878      	ldr	r0, [r7, #4]
 8027214:	f7ff fed6 	bl	8026fc4 <XMC_CAN_IsPanelControlReady>
 8027218:	4603      	mov	r3, r0
 802721a:	f083 0301 	eor.w	r3, r3, #1
 802721e:	b2db      	uxtb	r3, r3
 8027220:	2b00      	cmp	r3, #0
 8027222:	d1f6      	bne.n	8027212 <XMC_CAN_AllocateMOtoNodeList+0x12>
  {
    /*Do nothing*/
  };

  /* Panel Command for  allocation of MO to node list */
  XMC_CAN_PanelControl(obj, XMC_CAN_PANCMD_STATIC_ALLOCATE, mo_num, (node_num + 1U));
 8027224:	78fb      	ldrb	r3, [r7, #3]
 8027226:	3301      	adds	r3, #1
 8027228:	b2db      	uxtb	r3, r3
 802722a:	78ba      	ldrb	r2, [r7, #2]
 802722c:	2102      	movs	r1, #2
 802722e:	6878      	ldr	r0, [r7, #4]
 8027230:	f7ff fedc 	bl	8026fec <XMC_CAN_PanelControl>
}
 8027234:	bf00      	nop
 8027236:	3708      	adds	r7, #8
 8027238:	46bd      	mov	sp, r7
 802723a:	bd80      	pop	{r7, pc}

0802723c <XMC_CAN_Enable>:
#endif
}

/* Enable XMC_CAN Peripheral */
void XMC_CAN_Enable(XMC_CAN_t *const obj)
{
 802723c:	b580      	push	{r7, lr}
 802723e:	b082      	sub	sp, #8
 8027240:	af00      	add	r7, sp, #0
 8027242:	6078      	str	r0, [r7, #4]
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MCAN);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_MCAN);
 8027244:	480a      	ldr	r0, [pc, #40]	; (8027270 <XMC_CAN_Enable+0x34>)
 8027246:	f7ff fb51 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  /* Enable CAN Module */
  obj->CLC &= ~(uint32_t)CAN_CLC_DISR_Msk;
 802724a:	687b      	ldr	r3, [r7, #4]
 802724c:	681b      	ldr	r3, [r3, #0]
 802724e:	f023 0201 	bic.w	r2, r3, #1
 8027252:	687b      	ldr	r3, [r7, #4]
 8027254:	601a      	str	r2, [r3, #0]
  while (obj->CLC & CAN_CLC_DISS_Msk)
 8027256:	bf00      	nop
 8027258:	687b      	ldr	r3, [r7, #4]
 802725a:	681b      	ldr	r3, [r3, #0]
 802725c:	f003 0302 	and.w	r3, r3, #2
 8027260:	2b00      	cmp	r3, #0
 8027262:	d1f9      	bne.n	8027258 <XMC_CAN_Enable+0x1c>
  {
    /*Do nothing*/
  };
}
 8027264:	bf00      	nop
 8027266:	bf00      	nop
 8027268:	3708      	adds	r7, #8
 802726a:	46bd      	mov	sp, r7
 802726c:	bd80      	pop	{r7, pc}
 802726e:	bf00      	nop
 8027270:	10000010 	.word	0x10000010

08027274 <XMC_CAN_SetBaudrateClockSource>:
  obj->FDR |= ((uint32_t)can_divider_mode << CAN_FDR_DM_Pos) | ((uint32_t)step << CAN_FDR_STEP_Pos);
}
#endif

void XMC_CAN_SetBaudrateClockSource(XMC_CAN_t *const obj, const XMC_CAN_CANCLKSRC_t source)
{
 8027274:	b480      	push	{r7}
 8027276:	b083      	sub	sp, #12
 8027278:	af00      	add	r7, sp, #0
 802727a:	6078      	str	r0, [r7, #4]
 802727c:	460b      	mov	r3, r1
 802727e:	70fb      	strb	r3, [r7, #3]
  obj->MCR = (obj->MCR & ~CAN_MCR_CLKSEL_Msk) | source ;
#else
  XMC_UNUSED_ARG(obj);
  XMC_UNUSED_ARG(source);
#endif
}
 8027280:	bf00      	nop
 8027282:	370c      	adds	r7, #12
 8027284:	46bd      	mov	sp, r7
 8027286:	f85d 7b04 	ldr.w	r7, [sp], #4
 802728a:	4770      	bx	lr

0802728c <XMC_CAN_GetBaudrateClockFrequency>:
  return XMC_CAN_CANCLKSRC_FPERI;
#endif
}

uint32_t XMC_CAN_GetBaudrateClockFrequency(XMC_CAN_t *const obj)
{
 802728c:	b580      	push	{r7, lr}
 802728e:	b084      	sub	sp, #16
 8027290:	af00      	add	r7, sp, #0
 8027292:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0;
 8027294:	2300      	movs	r3, #0
 8027296:	60fb      	str	r3, [r7, #12]
      frequency = OSCHP_GetFrequency();
      break;
  }
#else
  XMC_UNUSED_ARG(obj);
  frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 8027298:	f7ff fb46 	bl	8026928 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 802729c:	60f8      	str	r0, [r7, #12]
#endif

  return frequency;
 802729e:	68fb      	ldr	r3, [r7, #12]
}
 80272a0:	4618      	mov	r0, r3
 80272a2:	3710      	adds	r7, #16
 80272a4:	46bd      	mov	sp, r7
 80272a6:	bd80      	pop	{r7, pc}

080272a8 <XMC_CAN_InitEx>:

uint32_t XMC_CAN_InitEx(XMC_CAN_t *const obj, XMC_CAN_CANCLKSRC_t clksrc, uint32_t can_frequency)
{
 80272a8:	b580      	push	{r7, lr}
 80272aa:	b088      	sub	sp, #32
 80272ac:	af00      	add	r7, sp, #0
 80272ae:	60f8      	str	r0, [r7, #12]
 80272b0:	460b      	mov	r3, r1
 80272b2:	607a      	str	r2, [r7, #4]
 80272b4:	72fb      	strb	r3, [r7, #11]
  uint32_t step_n;
  uint32_t freq_n;
  uint32_t peripheral_frequency;

  /*Enabling the module*/
  XMC_CAN_Enable(obj);
 80272b6:	68f8      	ldr	r0, [r7, #12]
 80272b8:	f7ff ffc0 	bl	802723c <XMC_CAN_Enable>

  XMC_CAN_SetBaudrateClockSource(obj, clksrc);
 80272bc:	7afb      	ldrb	r3, [r7, #11]
 80272be:	4619      	mov	r1, r3
 80272c0:	68f8      	ldr	r0, [r7, #12]
 80272c2:	f7ff ffd7 	bl	8027274 <XMC_CAN_SetBaudrateClockSource>
  peripheral_frequency = XMC_CAN_GetBaudrateClockFrequency(obj);
 80272c6:	68f8      	ldr	r0, [r7, #12]
 80272c8:	f7ff ffe0 	bl	802728c <XMC_CAN_GetBaudrateClockFrequency>
 80272cc:	61f8      	str	r0, [r7, #28]
  XMC_ASSERT("XMC_CAN_Init: frequency not supported", can_frequency <= peripheral_frequency);

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
 80272ce:	69fa      	ldr	r2, [r7, #28]
 80272d0:	687b      	ldr	r3, [r7, #4]
 80272d2:	fbb2 f3f3 	udiv	r3, r2, r3
 80272d6:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 80272da:	4619      	mov	r1, r3
 80272dc:	2000      	movs	r0, #0
 80272de:	f7ff fec4 	bl	802706a <max>
 80272e2:	4603      	mov	r3, r0
 80272e4:	f240 31ff 	movw	r1, #1023	; 0x3ff
 80272e8:	4618      	mov	r0, r3
 80272ea:	f7ff fece 	bl	802708a <min>
 80272ee:	61b8      	str	r0, [r7, #24]
  freq_n = (uint32_t)(peripheral_frequency / (1024U - step_n));
 80272f0:	69bb      	ldr	r3, [r7, #24]
 80272f2:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 80272f6:	69fa      	ldr	r2, [r7, #28]
 80272f8:	fbb2 f3f3 	udiv	r3, r2, r3
 80272fc:	617b      	str	r3, [r7, #20]

  obj->FDR &= (uint32_t) ~(CAN_FDR_DM_Msk | CAN_FDR_STEP_Msk);
 80272fe:	68fb      	ldr	r3, [r7, #12]
 8027300:	68db      	ldr	r3, [r3, #12]
 8027302:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 8027306:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 802730a:	68fa      	ldr	r2, [r7, #12]
 802730c:	60d3      	str	r3, [r2, #12]
  obj->FDR |= ((uint32_t)XMC_CAN_DM_NORMAL << CAN_FDR_DM_Pos) | ((uint32_t)step_n << CAN_FDR_STEP_Pos);
 802730e:	68fb      	ldr	r3, [r7, #12]
 8027310:	68da      	ldr	r2, [r3, #12]
 8027312:	69bb      	ldr	r3, [r7, #24]
 8027314:	4313      	orrs	r3, r2
 8027316:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 802731a:	68fb      	ldr	r3, [r7, #12]
 802731c:	60da      	str	r2, [r3, #12]

  return freq_n;
 802731e:	697b      	ldr	r3, [r7, #20]
}
 8027320:	4618      	mov	r0, r3
 8027322:	3720      	adds	r7, #32
 8027324:	46bd      	mov	sp, r7
 8027326:	bd80      	pop	{r7, pc}

08027328 <XMC_CAN_MO_SetIdentifier>:
  return (XMC_CAN_GetBaudrateClockFrequency(obj) * (1024U - step_n));
}

/* Sets the Identifier of the MO */
void XMC_CAN_MO_SetIdentifier(XMC_CAN_MO_t *const can_mo, const uint32_t can_identifier)
{
 8027328:	b480      	push	{r7}
 802732a:	b083      	sub	sp, #12
 802732c:	af00      	add	r7, sp, #0
 802732e:	6078      	str	r0, [r7, #4]
 8027330:	6039      	str	r1, [r7, #0]
  if ((can_mo->can_mo_ptr->MOAR & CAN_MO_MOAR_IDE_Msk) != (uint32_t)CAN_MO_MOAR_IDE_Msk)
 8027332:	687b      	ldr	r3, [r7, #4]
 8027334:	681b      	ldr	r3, [r3, #0]
 8027336:	699b      	ldr	r3, [r3, #24]
 8027338:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 802733c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8027340:	d00d      	beq.n	802735e <XMC_CAN_MO_SetIdentifier+0x36>
  {
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 8027342:	687b      	ldr	r3, [r7, #4]
 8027344:	681b      	ldr	r3, [r3, #0]
 8027346:	699b      	ldr	r3, [r3, #24]
 8027348:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
                               ((can_identifier << XMC_CAN_MO_MOAR_STDID_Pos) & (uint32_t)CAN_MO_MOAR_ID_Msk);
 802734c:	683b      	ldr	r3, [r7, #0]
 802734e:	049b      	lsls	r3, r3, #18
 8027350:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 8027354:	687b      	ldr	r3, [r7, #4]
 8027356:	681b      	ldr	r3, [r3, #0]
 8027358:	430a      	orrs	r2, r1
 802735a:	619a      	str	r2, [r3, #24]
 802735c:	e00b      	b.n	8027376 <XMC_CAN_MO_SetIdentifier+0x4e>
  }
  else
  {
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 802735e:	687b      	ldr	r3, [r7, #4]
 8027360:	681b      	ldr	r3, [r3, #0]
 8027362:	699b      	ldr	r3, [r3, #24]
 8027364:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
                               (can_identifier & (uint32_t)CAN_MO_MOAR_ID_Msk);
 8027368:	683b      	ldr	r3, [r7, #0]
 802736a:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 802736e:	687b      	ldr	r3, [r7, #4]
 8027370:	681b      	ldr	r3, [r3, #0]
 8027372:	430a      	orrs	r2, r1
 8027374:	619a      	str	r2, [r3, #24]
  }
  can_mo->can_identifier = can_identifier;
 8027376:	683b      	ldr	r3, [r7, #0]
 8027378:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 802737c:	687a      	ldr	r2, [r7, #4]
 802737e:	6853      	ldr	r3, [r2, #4]
 8027380:	f361 031c 	bfi	r3, r1, #0, #29
 8027384:	6053      	str	r3, [r2, #4]
}
 8027386:	bf00      	nop
 8027388:	370c      	adds	r7, #12
 802738a:	46bd      	mov	sp, r7
 802738c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027390:	4770      	bx	lr
	...

08027394 <XMC_CAN_MO_Config>:
  can_mo->can_id_mask = can_id_mask;
}

/* Initialization of XMC_CAN MO Object */
void XMC_CAN_MO_Config(const XMC_CAN_MO_t *const can_mo)
{
 8027394:	b580      	push	{r7, lr}
 8027396:	b086      	sub	sp, #24
 8027398:	af00      	add	r7, sp, #0
 802739a:	6078      	str	r0, [r7, #4]
  uint32_t reg;

  /* Configure MPN */
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U) / 0x0020U;
 802739c:	687b      	ldr	r3, [r7, #4]
 802739e:	681b      	ldr	r3, [r3, #0]
 80273a0:	f103 4338 	add.w	r3, r3, #3087007744	; 0xb8000000
 80273a4:	f5a3 33a8 	sub.w	r3, r3, #86016	; 0x15000
 80273a8:	095b      	lsrs	r3, r3, #5
 80273aa:	617b      	str	r3, [r7, #20]
  uint32_t set = (((uint32_t)(num / 32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num % 32) << CAN_MO_MOIPR_MPN_Pos));
 80273ac:	697b      	ldr	r3, [r7, #20]
 80273ae:	095b      	lsrs	r3, r3, #5
 80273b0:	035a      	lsls	r2, r3, #13
 80273b2:	697b      	ldr	r3, [r7, #20]
 80273b4:	021b      	lsls	r3, r3, #8
 80273b6:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 80273ba:	4313      	orrs	r3, r2
 80273bc:	613b      	str	r3, [r7, #16]
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
 80273be:	687b      	ldr	r3, [r7, #4]
 80273c0:	681b      	ldr	r3, [r3, #0]
 80273c2:	689a      	ldr	r2, [r3, #8]
 80273c4:	687b      	ldr	r3, [r7, #4]
 80273c6:	681b      	ldr	r3, [r3, #0]
 80273c8:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80273cc:	609a      	str	r2, [r3, #8]
  can_mo->can_mo_ptr->MOIPR |= set;
 80273ce:	687b      	ldr	r3, [r7, #4]
 80273d0:	681b      	ldr	r3, [r3, #0]
 80273d2:	6899      	ldr	r1, [r3, #8]
 80273d4:	687b      	ldr	r3, [r7, #4]
 80273d6:	681b      	ldr	r3, [r3, #0]
 80273d8:	693a      	ldr	r2, [r7, #16]
 80273da:	430a      	orrs	r2, r1
 80273dc:	609a      	str	r2, [r3, #8]

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 80273de:	687b      	ldr	r3, [r7, #4]
 80273e0:	79db      	ldrb	r3, [r3, #7]
 80273e2:	f003 0320 	and.w	r3, r3, #32
 80273e6:	b2db      	uxtb	r3, r3
 80273e8:	2b00      	cmp	r3, #0
 80273ea:	d006      	beq.n	80273fa <XMC_CAN_MO_Config+0x66>
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
 80273ec:	687b      	ldr	r3, [r7, #4]
 80273ee:	79db      	ldrb	r3, [r3, #7]
 80273f0:	f003 0320 	and.w	r3, r3, #32
 80273f4:	b2db      	uxtb	r3, r3
  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 80273f6:	2b00      	cmp	r3, #0
 80273f8:	d060      	beq.n	80274bc <XMC_CAN_MO_Config+0x128>
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
 80273fa:	687b      	ldr	r3, [r7, #4]
 80273fc:	7e1b      	ldrb	r3, [r3, #24]
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
 80273fe:	2b00      	cmp	r3, #0
 8027400:	d003      	beq.n	802740a <XMC_CAN_MO_Config+0x76>
       (can_mo->can_mo_type != XMC_CAN_MO_TYPE_TRANSMSGOBJ)))
 8027402:	687b      	ldr	r3, [r7, #4]
 8027404:	7e1b      	ldrb	r3, [r3, #24]
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
 8027406:	2b01      	cmp	r3, #1
 8027408:	d158      	bne.n	80274bc <XMC_CAN_MO_Config+0x128>
  }
  else
  {

    /* Disable Message object */
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 802740a:	687b      	ldr	r3, [r7, #4]
 802740c:	681b      	ldr	r3, [r3, #0]
 802740e:	2220      	movs	r2, #32
 8027410:	61da      	str	r2, [r3, #28]
    if (can_mo->can_id_mode == (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS)
 8027412:	687b      	ldr	r3, [r7, #4]
 8027414:	79db      	ldrb	r3, [r3, #7]
 8027416:	f003 0320 	and.w	r3, r3, #32
 802741a:	b2db      	uxtb	r3, r3
 802741c:	2b00      	cmp	r3, #0
 802741e:	d128      	bne.n	8027472 <XMC_CAN_MO_Config+0xde>
    {
      reg = can_mo->mo_ar;
 8027420:	687b      	ldr	r3, [r7, #4]
 8027422:	685b      	ldr	r3, [r3, #4]
 8027424:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAR_ID_Msk);
 8027426:	68fb      	ldr	r3, [r7, #12]
 8027428:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 802742c:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_identifier << XMC_CAN_MO_MOAR_STDID_Pos);
 802742e:	687b      	ldr	r3, [r7, #4]
 8027430:	685b      	ldr	r3, [r3, #4]
 8027432:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8027436:	049b      	lsls	r3, r3, #18
 8027438:	461a      	mov	r2, r3
 802743a:	68fb      	ldr	r3, [r7, #12]
 802743c:	4313      	orrs	r3, r2
 802743e:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAR = reg;
 8027440:	687b      	ldr	r3, [r7, #4]
 8027442:	681b      	ldr	r3, [r3, #0]
 8027444:	68fa      	ldr	r2, [r7, #12]
 8027446:	619a      	str	r2, [r3, #24]

      reg = can_mo->mo_amr;
 8027448:	687b      	ldr	r3, [r7, #4]
 802744a:	689b      	ldr	r3, [r3, #8]
 802744c:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAMR_AM_Msk);
 802744e:	68fb      	ldr	r3, [r7, #12]
 8027450:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 8027454:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_id_mask << XMC_CAN_MO_MOAR_STDID_Pos);
 8027456:	687b      	ldr	r3, [r7, #4]
 8027458:	689b      	ldr	r3, [r3, #8]
 802745a:	f3c3 031c 	ubfx	r3, r3, #0, #29
 802745e:	049b      	lsls	r3, r3, #18
 8027460:	461a      	mov	r2, r3
 8027462:	68fb      	ldr	r3, [r7, #12]
 8027464:	4313      	orrs	r3, r2
 8027466:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAMR = reg;
 8027468:	687b      	ldr	r3, [r7, #4]
 802746a:	681b      	ldr	r3, [r3, #0]
 802746c:	68fa      	ldr	r2, [r7, #12]
 802746e:	60da      	str	r2, [r3, #12]
 8027470:	e009      	b.n	8027486 <XMC_CAN_MO_Config+0xf2>
    }
    else
    {
      can_mo->can_mo_ptr->MOAR = can_mo->mo_ar;
 8027472:	687b      	ldr	r3, [r7, #4]
 8027474:	681b      	ldr	r3, [r3, #0]
 8027476:	687a      	ldr	r2, [r7, #4]
 8027478:	6852      	ldr	r2, [r2, #4]
 802747a:	619a      	str	r2, [r3, #24]
      can_mo->can_mo_ptr->MOAMR = can_mo->mo_amr;
 802747c:	687b      	ldr	r3, [r7, #4]
 802747e:	681b      	ldr	r3, [r3, #0]
 8027480:	687a      	ldr	r2, [r7, #4]
 8027482:	6892      	ldr	r2, [r2, #8]
 8027484:	60da      	str	r2, [r3, #12]
    }
    /* Check whether message object is transmit message object */
    if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 8027486:	687b      	ldr	r3, [r7, #4]
 8027488:	7e1b      	ldrb	r3, [r3, #24]
 802748a:	2b01      	cmp	r3, #1
 802748c:	d10c      	bne.n	80274a8 <XMC_CAN_MO_Config+0x114>
    {
      /* Set MO as Transmit message object  */
      XMC_CAN_MO_UpdateData(can_mo);
 802748e:	6878      	ldr	r0, [r7, #4]
 8027490:	f000 f81c 	bl	80274cc <XMC_CAN_MO_UpdateData>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_SETDIR_Msk;
 8027494:	687b      	ldr	r3, [r7, #4]
 8027496:	681b      	ldr	r3, [r3, #0]
 8027498:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802749c:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL and Set MSGVAL, TXEN0 and TXEN1 bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 802749e:	687b      	ldr	r3, [r7, #4]
 80274a0:	681b      	ldr	r3, [r3, #0]
 80274a2:	4a08      	ldr	r2, [pc, #32]	; (80274c4 <XMC_CAN_MO_Config+0x130>)
 80274a4:	61da      	str	r2, [r3, #28]
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
                                   CAN_MO_MOCTR_SETRXEN_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
    }

  }
}
 80274a6:	e009      	b.n	80274bc <XMC_CAN_MO_Config+0x128>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESDIR_Msk;
 80274a8:	687b      	ldr	r3, [r7, #4]
 80274aa:	681b      	ldr	r3, [r3, #0]
 80274ac:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80274b0:	61da      	str	r2, [r3, #28]
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 80274b2:	687b      	ldr	r3, [r7, #4]
 80274b4:	681b      	ldr	r3, [r3, #0]
 80274b6:	4a04      	ldr	r2, [pc, #16]	; (80274c8 <XMC_CAN_MO_Config+0x134>)
 80274b8:	61da      	str	r2, [r3, #28]
}
 80274ba:	e7ff      	b.n	80274bc <XMC_CAN_MO_Config+0x128>
 80274bc:	bf00      	nop
 80274be:	3718      	adds	r7, #24
 80274c0:	46bd      	mov	sp, r7
 80274c2:	bd80      	pop	{r7, pc}
 80274c4:	062000c0 	.word	0x062000c0
 80274c8:	00a00640 	.word	0x00a00640

080274cc <XMC_CAN_MO_UpdateData>:

/* Update of XMC_CAN Object */
XMC_CAN_STATUS_t XMC_CAN_MO_UpdateData(const XMC_CAN_MO_t *const can_mo)
{
 80274cc:	b480      	push	{r7}
 80274ce:	b085      	sub	sp, #20
 80274d0:	af00      	add	r7, sp, #0
 80274d2:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 80274d4:	2303      	movs	r3, #3
 80274d6:	73fb      	strb	r3, [r7, #15]
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 80274d8:	687b      	ldr	r3, [r7, #4]
 80274da:	7e1b      	ldrb	r3, [r3, #24]
 80274dc:	2b01      	cmp	r3, #1
 80274de:	d122      	bne.n	8027526 <XMC_CAN_MO_UpdateData+0x5a>
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 80274e0:	687b      	ldr	r3, [r7, #4]
 80274e2:	681b      	ldr	r3, [r3, #0]
 80274e4:	2220      	movs	r2, #32
 80274e6:	61da      	str	r2, [r3, #28]
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 80274e8:	687b      	ldr	r3, [r7, #4]
 80274ea:	681b      	ldr	r3, [r3, #0]
 80274ec:	681b      	ldr	r3, [r3, #0]
 80274ee:	f023 6170 	bic.w	r1, r3, #251658240	; 0xf000000
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
 80274f2:	687b      	ldr	r3, [r7, #4]
 80274f4:	7b1b      	ldrb	r3, [r3, #12]
 80274f6:	061b      	lsls	r3, r3, #24
 80274f8:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 80274fc:	687b      	ldr	r3, [r7, #4]
 80274fe:	681b      	ldr	r3, [r3, #0]
 8027500:	430a      	orrs	r2, r1
 8027502:	601a      	str	r2, [r3, #0]
    /* Configure Data registers*/
    can_mo->can_mo_ptr->MODATAL = can_mo->can_data[0];
 8027504:	687b      	ldr	r3, [r7, #4]
 8027506:	681b      	ldr	r3, [r3, #0]
 8027508:	687a      	ldr	r2, [r7, #4]
 802750a:	6912      	ldr	r2, [r2, #16]
 802750c:	611a      	str	r2, [r3, #16]
    can_mo->can_mo_ptr->MODATAH = can_mo->can_data[1];
 802750e:	687b      	ldr	r3, [r7, #4]
 8027510:	681b      	ldr	r3, [r3, #0]
 8027512:	687a      	ldr	r2, [r7, #4]
 8027514:	6952      	ldr	r2, [r2, #20]
 8027516:	615a      	str	r2, [r3, #20]
    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1 bits */
    can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETNEWDAT_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
 8027518:	687b      	ldr	r3, [r7, #4]
 802751a:	681b      	ldr	r3, [r3, #0]
 802751c:	4a06      	ldr	r2, [pc, #24]	; (8027538 <XMC_CAN_MO_UpdateData+0x6c>)
 802751e:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
 8027520:	2300      	movs	r3, #0
 8027522:	73fb      	strb	r3, [r7, #15]
 8027524:	e001      	b.n	802752a <XMC_CAN_MO_UpdateData+0x5e>
  }
  else
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 8027526:	2303      	movs	r3, #3
 8027528:	73fb      	strb	r3, [r7, #15]
  }
  return error;
 802752a:	7bfb      	ldrb	r3, [r7, #15]
}
 802752c:	4618      	mov	r0, r3
 802752e:	3714      	adds	r7, #20
 8027530:	46bd      	mov	sp, r7
 8027532:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027536:	4770      	bx	lr
 8027538:	00280040 	.word	0x00280040

0802753c <XMC_CAN_MO_Transmit>:

/* This function is will put a transmit request to transmit message object */
XMC_CAN_STATUS_t XMC_CAN_MO_Transmit(const XMC_CAN_MO_t *const can_mo)
{
 802753c:	b480      	push	{r7}
 802753e:	b087      	sub	sp, #28
 8027540:	af00      	add	r7, sp, #0
 8027542:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
 8027544:	2301      	movs	r3, #1
 8027546:	75fb      	strb	r3, [r7, #23]
  uint32_t mo_type = (uint32_t)(((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_MSGVAL_Msk) >> CAN_MO_MOSTAT_MSGVAL_Pos);
 8027548:	687b      	ldr	r3, [r7, #4]
 802754a:	681b      	ldr	r3, [r3, #0]
 802754c:	69db      	ldr	r3, [r3, #28]
 802754e:	095b      	lsrs	r3, r3, #5
 8027550:	f003 0301 	and.w	r3, r3, #1
 8027554:	613b      	str	r3, [r7, #16]
  uint32_t mo_transmission_ongoing = (uint32_t) ((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_TXRQ_Msk) >> CAN_MO_MOSTAT_TXRQ_Pos;
 8027556:	687b      	ldr	r3, [r7, #4]
 8027558:	681b      	ldr	r3, [r3, #0]
 802755a:	69db      	ldr	r3, [r3, #28]
 802755c:	0a1b      	lsrs	r3, r3, #8
 802755e:	f003 0301 	and.w	r3, r3, #1
 8027562:	60fb      	str	r3, [r7, #12]
  /* check if message is disabled */
  if (mo_type == 0U)
 8027564:	693b      	ldr	r3, [r7, #16]
 8027566:	2b00      	cmp	r3, #0
 8027568:	d102      	bne.n	8027570 <XMC_CAN_MO_Transmit+0x34>
  {
    error = XMC_CAN_STATUS_MO_DISABLED;
 802756a:	2304      	movs	r3, #4
 802756c:	75fb      	strb	r3, [r7, #23]
 802756e:	e00c      	b.n	802758a <XMC_CAN_MO_Transmit+0x4e>
  }
  /* check if transmission is ongoing on message object */
  else if (mo_transmission_ongoing == 1U)
 8027570:	68fb      	ldr	r3, [r7, #12]
 8027572:	2b01      	cmp	r3, #1
 8027574:	d102      	bne.n	802757c <XMC_CAN_MO_Transmit+0x40>
  {
    error = XMC_CAN_STATUS_BUSY;
 8027576:	2302      	movs	r3, #2
 8027578:	75fb      	strb	r3, [r7, #23]
 802757a:	e006      	b.n	802758a <XMC_CAN_MO_Transmit+0x4e>
  }
  else
  {
    /* set TXRQ bit */
    can_mo->can_mo_ptr-> MOCTR = CAN_MO_MOCTR_SETTXRQ_Msk | CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk;
 802757c:	687b      	ldr	r3, [r7, #4]
 802757e:	681b      	ldr	r3, [r3, #0]
 8027580:	f04f 62e0 	mov.w	r2, #117440512	; 0x7000000
 8027584:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
 8027586:	2300      	movs	r3, #0
 8027588:	75fb      	strb	r3, [r7, #23]
  }
  return error;
 802758a:	7dfb      	ldrb	r3, [r7, #23]
}
 802758c:	4618      	mov	r0, r3
 802758e:	371c      	adds	r7, #28
 8027590:	46bd      	mov	sp, r7
 8027592:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027596:	4770      	bx	lr

08027598 <XMC_CAN_MO_Receive>:
}


/* This function is will read the message object data bytes */
XMC_CAN_STATUS_t XMC_CAN_MO_Receive (XMC_CAN_MO_t *can_mo)
{
 8027598:	b480      	push	{r7}
 802759a:	b087      	sub	sp, #28
 802759c:	af00      	add	r7, sp, #0
 802759e:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
 80275a0:	2301      	movs	r3, #1
 80275a2:	75fb      	strb	r3, [r7, #23]
  uint8_t rx_pnd = 0U;
 80275a4:	2300      	movs	r3, #0
 80275a6:	75bb      	strb	r3, [r7, #22]
  uint8_t new_data = 0U;
 80275a8:	2300      	movs	r3, #0
 80275aa:	757b      	strb	r3, [r7, #21]
  uint32_t mo_type = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_DIR_Msk) >> CAN_MO_MOSTAT_DIR_Pos;
 80275ac:	687b      	ldr	r3, [r7, #4]
 80275ae:	681b      	ldr	r3, [r3, #0]
 80275b0:	69db      	ldr	r3, [r3, #28]
 80275b2:	0adb      	lsrs	r3, r3, #11
 80275b4:	f003 0301 	and.w	r3, r3, #1
 80275b8:	613b      	str	r3, [r7, #16]
  uint32_t mo_recepcion_ongoing = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos;
 80275ba:	687b      	ldr	r3, [r7, #4]
 80275bc:	681b      	ldr	r3, [r3, #0]
 80275be:	69db      	ldr	r3, [r3, #28]
 80275c0:	089b      	lsrs	r3, r3, #2
 80275c2:	f003 0301 	and.w	r3, r3, #1
 80275c6:	60fb      	str	r3, [r7, #12]
  /* check if message object is a receive message object */
  if (mo_type != (uint32_t)XMC_CAN_MO_TYPE_RECMSGOBJ)
 80275c8:	693b      	ldr	r3, [r7, #16]
 80275ca:	2b00      	cmp	r3, #0
 80275cc:	d002      	beq.n	80275d4 <XMC_CAN_MO_Receive+0x3c>
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 80275ce:	2303      	movs	r3, #3
 80275d0:	75fb      	strb	r3, [r7, #23]
 80275d2:	e0a3      	b.n	802771c <XMC_CAN_MO_Receive+0x184>
  }
  /* check if reception is ongoing on message object */
  else if (mo_recepcion_ongoing == 1U)
 80275d4:	68fb      	ldr	r3, [r7, #12]
 80275d6:	2b01      	cmp	r3, #1
 80275d8:	d102      	bne.n	80275e0 <XMC_CAN_MO_Receive+0x48>
  {
    error = XMC_CAN_STATUS_BUSY;
 80275da:	2302      	movs	r3, #2
 80275dc:	75fb      	strb	r3, [r7, #23]
 80275de:	e09d      	b.n	802771c <XMC_CAN_MO_Receive+0x184>
  else
  {
    /* read message parameters */
    do
    {
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESNEWDAT_Msk;
 80275e0:	687b      	ldr	r3, [r7, #4]
 80275e2:	681b      	ldr	r3, [r3, #0]
 80275e4:	2208      	movs	r2, #8
 80275e6:	61da      	str	r2, [r3, #28]
      if ((((can_mo->can_mo_ptr->MOAR) & CAN_MO_MOAR_IDE_Msk) >> CAN_MO_MOAR_IDE_Pos) == 0U)
 80275e8:	687b      	ldr	r3, [r7, #4]
 80275ea:	681b      	ldr	r3, [r3, #0]
 80275ec:	699b      	ldr	r3, [r3, #24]
 80275ee:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80275f2:	2b00      	cmp	r3, #0
 80275f4:	d13d      	bne.n	8027672 <XMC_CAN_MO_Receive+0xda>
      {
        can_mo->can_id_mode = (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS;
 80275f6:	687a      	ldr	r2, [r7, #4]
 80275f8:	79d3      	ldrb	r3, [r2, #7]
 80275fa:	f36f 1345 	bfc	r3, #5, #1
 80275fe:	71d3      	strb	r3, [r2, #7]
        can_mo->can_identifier = (can_mo->can_mo_ptr->MOAR & XMC_CAN_MO_MOAR_STDID_Msk) >> XMC_CAN_MO_MOAR_STDID_Pos;
 8027600:	687b      	ldr	r3, [r7, #4]
 8027602:	681b      	ldr	r3, [r3, #0]
 8027604:	699b      	ldr	r3, [r3, #24]
 8027606:	0c9b      	lsrs	r3, r3, #18
 8027608:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802760c:	f3c3 010a 	ubfx	r1, r3, #0, #11
 8027610:	687a      	ldr	r2, [r7, #4]
 8027612:	6853      	ldr	r3, [r2, #4]
 8027614:	f361 031c 	bfi	r3, r1, #0, #29
 8027618:	6053      	str	r3, [r2, #4]
        can_mo->can_ide_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_MIDE_Msk) >> CAN_MO_MOAMR_MIDE_Pos;
 802761a:	687b      	ldr	r3, [r7, #4]
 802761c:	681b      	ldr	r3, [r3, #0]
 802761e:	68db      	ldr	r3, [r3, #12]
 8027620:	0f5b      	lsrs	r3, r3, #29
 8027622:	f003 0301 	and.w	r3, r3, #1
 8027626:	b2d9      	uxtb	r1, r3
 8027628:	687a      	ldr	r2, [r7, #4]
 802762a:	7ad3      	ldrb	r3, [r2, #11]
 802762c:	f361 1345 	bfi	r3, r1, #5, #1
 8027630:	72d3      	strb	r3, [r2, #11]
        if (can_mo->can_ide_mask == 1U)
 8027632:	687b      	ldr	r3, [r7, #4]
 8027634:	7adb      	ldrb	r3, [r3, #11]
 8027636:	f003 0320 	and.w	r3, r3, #32
 802763a:	b2db      	uxtb	r3, r3
 802763c:	2b00      	cmp	r3, #0
 802763e:	d00d      	beq.n	802765c <XMC_CAN_MO_Receive+0xc4>
        {
          can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & XMC_CAN_MO_MOAR_STDID_Msk) >> XMC_CAN_MO_MOAR_STDID_Pos;
 8027640:	687b      	ldr	r3, [r7, #4]
 8027642:	681b      	ldr	r3, [r3, #0]
 8027644:	68db      	ldr	r3, [r3, #12]
 8027646:	0c9b      	lsrs	r3, r3, #18
 8027648:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802764c:	f3c3 010a 	ubfx	r1, r3, #0, #11
 8027650:	687a      	ldr	r2, [r7, #4]
 8027652:	6893      	ldr	r3, [r2, #8]
 8027654:	f361 031c 	bfi	r3, r1, #0, #29
 8027658:	6093      	str	r3, [r2, #8]
 802765a:	e02f      	b.n	80276bc <XMC_CAN_MO_Receive+0x124>
        }
        else
        {
          can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_AM_Msk);
 802765c:	687b      	ldr	r3, [r7, #4]
 802765e:	681b      	ldr	r3, [r3, #0]
 8027660:	68db      	ldr	r3, [r3, #12]
 8027662:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8027666:	687a      	ldr	r2, [r7, #4]
 8027668:	6893      	ldr	r3, [r2, #8]
 802766a:	f361 031c 	bfi	r3, r1, #0, #29
 802766e:	6093      	str	r3, [r2, #8]
 8027670:	e024      	b.n	80276bc <XMC_CAN_MO_Receive+0x124>
        }
      }
      else
      {
        can_mo->can_id_mode = (uint32_t)XMC_CAN_FRAME_TYPE_EXTENDED_29BITS;
 8027672:	687a      	ldr	r2, [r7, #4]
 8027674:	79d3      	ldrb	r3, [r2, #7]
 8027676:	f043 0320 	orr.w	r3, r3, #32
 802767a:	71d3      	strb	r3, [r2, #7]
        can_mo->can_identifier = (can_mo->can_mo_ptr->MOAR & CAN_MO_MOAR_ID_Msk);
 802767c:	687b      	ldr	r3, [r7, #4]
 802767e:	681b      	ldr	r3, [r3, #0]
 8027680:	699b      	ldr	r3, [r3, #24]
 8027682:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8027686:	687a      	ldr	r2, [r7, #4]
 8027688:	6853      	ldr	r3, [r2, #4]
 802768a:	f361 031c 	bfi	r3, r1, #0, #29
 802768e:	6053      	str	r3, [r2, #4]
        can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_AM_Msk);
 8027690:	687b      	ldr	r3, [r7, #4]
 8027692:	681b      	ldr	r3, [r3, #0]
 8027694:	68db      	ldr	r3, [r3, #12]
 8027696:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 802769a:	687a      	ldr	r2, [r7, #4]
 802769c:	6893      	ldr	r3, [r2, #8]
 802769e:	f361 031c 	bfi	r3, r1, #0, #29
 80276a2:	6093      	str	r3, [r2, #8]
        can_mo->can_ide_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_MIDE_Msk) >> CAN_MO_MOAMR_MIDE_Pos;
 80276a4:	687b      	ldr	r3, [r7, #4]
 80276a6:	681b      	ldr	r3, [r3, #0]
 80276a8:	68db      	ldr	r3, [r3, #12]
 80276aa:	0f5b      	lsrs	r3, r3, #29
 80276ac:	f003 0301 	and.w	r3, r3, #1
 80276b0:	b2d9      	uxtb	r1, r3
 80276b2:	687a      	ldr	r2, [r7, #4]
 80276b4:	7ad3      	ldrb	r3, [r2, #11]
 80276b6:	f361 1345 	bfi	r3, r1, #5, #1
 80276ba:	72d3      	strb	r3, [r2, #11]
      }
      can_mo->can_data_length = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOFCR) & CAN_MO_MOFCR_DLC_Msk) >> CAN_MO_MOFCR_DLC_Pos);
 80276bc:	687b      	ldr	r3, [r7, #4]
 80276be:	681b      	ldr	r3, [r3, #0]
 80276c0:	681b      	ldr	r3, [r3, #0]
 80276c2:	0e1b      	lsrs	r3, r3, #24
 80276c4:	b2db      	uxtb	r3, r3
 80276c6:	f003 030f 	and.w	r3, r3, #15
 80276ca:	b2da      	uxtb	r2, r3
 80276cc:	687b      	ldr	r3, [r7, #4]
 80276ce:	731a      	strb	r2, [r3, #12]

      can_mo->can_data[0] = can_mo->can_mo_ptr->MODATAL;
 80276d0:	687b      	ldr	r3, [r7, #4]
 80276d2:	681b      	ldr	r3, [r3, #0]
 80276d4:	691a      	ldr	r2, [r3, #16]
 80276d6:	687b      	ldr	r3, [r7, #4]
 80276d8:	611a      	str	r2, [r3, #16]
      can_mo->can_data[1] = can_mo->can_mo_ptr->MODATAH;
 80276da:	687b      	ldr	r3, [r7, #4]
 80276dc:	681b      	ldr	r3, [r3, #0]
 80276de:	695a      	ldr	r2, [r3, #20]
 80276e0:	687b      	ldr	r3, [r7, #4]
 80276e2:	615a      	str	r2, [r3, #20]

      rx_pnd = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos);
 80276e4:	687b      	ldr	r3, [r7, #4]
 80276e6:	681b      	ldr	r3, [r3, #0]
 80276e8:	69db      	ldr	r3, [r3, #28]
 80276ea:	089b      	lsrs	r3, r3, #2
 80276ec:	b2db      	uxtb	r3, r3
 80276ee:	f003 0301 	and.w	r3, r3, #1
 80276f2:	75bb      	strb	r3, [r7, #22]
      new_data = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_NEWDAT_Msk) >> CAN_MO_MOSTAT_NEWDAT_Pos);
 80276f4:	687b      	ldr	r3, [r7, #4]
 80276f6:	681b      	ldr	r3, [r3, #0]
 80276f8:	69db      	ldr	r3, [r3, #28]
 80276fa:	08db      	lsrs	r3, r3, #3
 80276fc:	b2db      	uxtb	r3, r3
 80276fe:	f003 0301 	and.w	r3, r3, #1
 8027702:	757b      	strb	r3, [r7, #21]
    }
    while ((rx_pnd != 0U) && (new_data != 0U));
 8027704:	7dbb      	ldrb	r3, [r7, #22]
 8027706:	2b00      	cmp	r3, #0
 8027708:	d003      	beq.n	8027712 <XMC_CAN_MO_Receive+0x17a>
 802770a:	7d7b      	ldrb	r3, [r7, #21]
 802770c:	2b00      	cmp	r3, #0
 802770e:	f47f af67 	bne.w	80275e0 <XMC_CAN_MO_Receive+0x48>

    can_mo->can_mo_type = XMC_CAN_MO_TYPE_RECMSGOBJ;
 8027712:	687b      	ldr	r3, [r7, #4]
 8027714:	2200      	movs	r2, #0
 8027716:	761a      	strb	r2, [r3, #24]
    error = XMC_CAN_STATUS_SUCCESS;
 8027718:	2300      	movs	r3, #0
 802771a:	75fb      	strb	r3, [r7, #23]
  }
  return error;
 802771c:	7dfb      	ldrb	r3, [r7, #23]
}
 802771e:	4618      	mov	r0, r3
 8027720:	371c      	adds	r7, #28
 8027722:	46bd      	mov	sp, r7
 8027724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027728:	4770      	bx	lr

0802772a <XMC_CAN_NODE_EnableEvent>:

/* Function to enable node event */
void XMC_CAN_NODE_EnableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event)
{
 802772a:	b480      	push	{r7}
 802772c:	b083      	sub	sp, #12
 802772e:	af00      	add	r7, sp, #0
 8027730:	6078      	str	r0, [r7, #4]
 8027732:	6039      	str	r1, [r7, #0]
  if (event != XMC_CAN_NODE_EVENT_CFCIE)
 8027734:	683b      	ldr	r3, [r7, #0]
 8027736:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 802773a:	d006      	beq.n	802774a <XMC_CAN_NODE_EnableEvent+0x20>
  {
    can_node->NCR |= (uint32_t)event;
 802773c:	687b      	ldr	r3, [r7, #4]
 802773e:	681a      	ldr	r2, [r3, #0]
 8027740:	683b      	ldr	r3, [r7, #0]
 8027742:	431a      	orrs	r2, r3
 8027744:	687b      	ldr	r3, [r7, #4]
 8027746:	601a      	str	r2, [r3, #0]
  }
  else
  {
    can_node->NFCR |= (uint32_t)event;
  }
}
 8027748:	e005      	b.n	8027756 <XMC_CAN_NODE_EnableEvent+0x2c>
    can_node->NFCR |= (uint32_t)event;
 802774a:	687b      	ldr	r3, [r7, #4]
 802774c:	699a      	ldr	r2, [r3, #24]
 802774e:	683b      	ldr	r3, [r7, #0]
 8027750:	431a      	orrs	r2, r3
 8027752:	687b      	ldr	r3, [r7, #4]
 8027754:	619a      	str	r2, [r3, #24]
}
 8027756:	bf00      	nop
 8027758:	370c      	adds	r7, #12
 802775a:	46bd      	mov	sp, r7
 802775c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027760:	4770      	bx	lr

08027762 <XMC_CCU4_StartPrescaler>:
{
 8027762:	b480      	push	{r7}
 8027764:	b083      	sub	sp, #12
 8027766:	af00      	add	r7, sp, #0
 8027768:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 802776a:	687b      	ldr	r3, [r7, #4]
 802776c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8027770:	60da      	str	r2, [r3, #12]
}
 8027772:	bf00      	nop
 8027774:	370c      	adds	r7, #12
 8027776:	46bd      	mov	sp, r7
 8027778:	f85d 7b04 	ldr.w	r7, [sp], #4
 802777c:	4770      	bx	lr
	...

08027780 <XMC_CCU4_lDeassertReset>:
    XMC_ASSERT("XMC_CCU4_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
 8027780:	b580      	push	{r7, lr}
 8027782:	b082      	sub	sp, #8
 8027784:	af00      	add	r7, sp, #0
 8027786:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
 8027788:	687b      	ldr	r3, [r7, #4]
 802778a:	4a11      	ldr	r2, [pc, #68]	; (80277d0 <XMC_CCU4_lDeassertReset+0x50>)
 802778c:	4293      	cmp	r3, r2
 802778e:	d103      	bne.n	8027798 <XMC_CCU4_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 8027790:	2004      	movs	r0, #4
 8027792:	f7ff f8ab 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 8027796:	e016      	b.n	80277c6 <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU41)
 8027798:	687b      	ldr	r3, [r7, #4]
 802779a:	4a0e      	ldr	r2, [pc, #56]	; (80277d4 <XMC_CCU4_lDeassertReset+0x54>)
 802779c:	4293      	cmp	r3, r2
 802779e:	d103      	bne.n	80277a8 <XMC_CCU4_lDeassertReset+0x28>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 80277a0:	2008      	movs	r0, #8
 80277a2:	f7ff f8a3 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
}
 80277a6:	e00e      	b.n	80277c6 <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU42)
 80277a8:	687b      	ldr	r3, [r7, #4]
 80277aa:	4a0b      	ldr	r2, [pc, #44]	; (80277d8 <XMC_CCU4_lDeassertReset+0x58>)
 80277ac:	4293      	cmp	r3, r2
 80277ae:	d103      	bne.n	80277b8 <XMC_CCU4_lDeassertReset+0x38>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 80277b0:	2010      	movs	r0, #16
 80277b2:	f7ff f89b 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
}
 80277b6:	e006      	b.n	80277c6 <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU43)
 80277b8:	687b      	ldr	r3, [r7, #4]
 80277ba:	4a08      	ldr	r2, [pc, #32]	; (80277dc <XMC_CCU4_lDeassertReset+0x5c>)
 80277bc:	4293      	cmp	r3, r2
 80277be:	d102      	bne.n	80277c6 <XMC_CCU4_lDeassertReset+0x46>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 80277c0:	4807      	ldr	r0, [pc, #28]	; (80277e0 <XMC_CCU4_lDeassertReset+0x60>)
 80277c2:	f7ff f893 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
}
 80277c6:	bf00      	nop
 80277c8:	3708      	adds	r7, #8
 80277ca:	46bd      	mov	sp, r7
 80277cc:	bd80      	pop	{r7, pc}
 80277ce:	bf00      	nop
 80277d0:	4000c000 	.word	0x4000c000
 80277d4:	40010000 	.word	0x40010000
 80277d8:	40014000 	.word	0x40014000
 80277dc:	48004000 	.word	0x48004000
 80277e0:	10000001 	.word	0x10000001

080277e4 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
 80277e4:	b580      	push	{r7, lr}
 80277e6:	b082      	sub	sp, #8
 80277e8:	af00      	add	r7, sp, #0
 80277ea:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 80277ec:	2010      	movs	r0, #16
 80277ee:	f7ff f9b9 	bl	8026b64 <XMC_SCU_CLOCK_EnableClock>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
 80277f2:	6878      	ldr	r0, [r7, #4]
 80277f4:	f7ff ffc4 	bl	8027780 <XMC_CCU4_lDeassertReset>
#endif
}
 80277f8:	bf00      	nop
 80277fa:	3708      	adds	r7, #8
 80277fc:	46bd      	mov	sp, r7
 80277fe:	bd80      	pop	{r7, pc}

08027800 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8027800:	b580      	push	{r7, lr}
 8027802:	b084      	sub	sp, #16
 8027804:	af00      	add	r7, sp, #0
 8027806:	6078      	str	r0, [r7, #4]
 8027808:	460b      	mov	r3, r1
 802780a:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
 802780c:	6878      	ldr	r0, [r7, #4]
 802780e:	f7ff ffe9 	bl	80277e4 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
 8027812:	6878      	ldr	r0, [r7, #4]
 8027814:	f7ff ffa5 	bl	8027762 <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
 8027818:	687b      	ldr	r3, [r7, #4]
 802781a:	681b      	ldr	r3, [r3, #0]
 802781c:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 802781e:	68fb      	ldr	r3, [r7, #12]
 8027820:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8027824:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 8027826:	78fb      	ldrb	r3, [r7, #3]
 8027828:	039b      	lsls	r3, r3, #14
 802782a:	68fa      	ldr	r2, [r7, #12]
 802782c:	4313      	orrs	r3, r2
 802782e:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 8027830:	687b      	ldr	r3, [r7, #4]
 8027832:	68fa      	ldr	r2, [r7, #12]
 8027834:	601a      	str	r2, [r3, #0]
}
 8027836:	bf00      	nop
 8027838:	3710      	adds	r7, #16
 802783a:	46bd      	mov	sp, r7
 802783c:	bd80      	pop	{r7, pc}

0802783e <XMC_CCU4_SetMultiChannelShadowTransferMode>:
  module->GCTRL = gctrl;
}

/* API to configure the multichannel shadow transfer request via SW and via the CCU4x.MCSS input. */
void XMC_CCU4_SetMultiChannelShadowTransferMode(XMC_CCU4_MODULE_t *const module, const uint32_t slice_mode_msk)
{
 802783e:	b480      	push	{r7}
 8027840:	b085      	sub	sp, #20
 8027842:	af00      	add	r7, sp, #0
 8027844:	6078      	str	r0, [r7, #4]
 8027846:	6039      	str	r1, [r7, #0]
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));

  gctrl = module->GCTRL;
 8027848:	687b      	ldr	r3, [r7, #4]
 802784a:	681b      	ldr	r3, [r3, #0]
 802784c:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 802784e:	683b      	ldr	r3, [r7, #0]
 8027850:	0c1b      	lsrs	r3, r3, #16
 8027852:	43db      	mvns	r3, r3
 8027854:	68fa      	ldr	r2, [r7, #12]
 8027856:	4013      	ands	r3, r2
 8027858:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 802785a:	683b      	ldr	r3, [r7, #0]
 802785c:	b29b      	uxth	r3, r3
 802785e:	68fa      	ldr	r2, [r7, #12]
 8027860:	4313      	orrs	r3, r2
 8027862:	60fb      	str	r3, [r7, #12]
  module->GCTRL = gctrl;
 8027864:	687b      	ldr	r3, [r7, #4]
 8027866:	68fa      	ldr	r2, [r7, #12]
 8027868:	601a      	str	r2, [r3, #0]
}
 802786a:	bf00      	nop
 802786c:	3714      	adds	r7, #20
 802786e:	46bd      	mov	sp, r7
 8027870:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027874:	4770      	bx	lr

08027876 <XMC_CCU4_SLICE_CompareInit>:

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8027876:	b480      	push	{r7}
 8027878:	b083      	sub	sp, #12
 802787a:	af00      	add	r7, sp, #0
 802787c:	6078      	str	r0, [r7, #4]
 802787e:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8027880:	683b      	ldr	r3, [r7, #0]
 8027882:	681a      	ldr	r2, [r3, #0]
 8027884:	687b      	ldr	r3, [r7, #4]
 8027886:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8027888:	683b      	ldr	r3, [r7, #0]
 802788a:	795b      	ldrb	r3, [r3, #5]
 802788c:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8027890:	b2db      	uxtb	r3, r3
 8027892:	051a      	lsls	r2, r3, #20
 8027894:	687b      	ldr	r3, [r7, #4]
 8027896:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8027898:	683b      	ldr	r3, [r7, #0]
 802789a:	791b      	ldrb	r3, [r3, #4]
 802789c:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80278a0:	b2db      	uxtb	r3, r3
 80278a2:	461a      	mov	r2, r3
 80278a4:	687b      	ldr	r3, [r7, #4]
 80278a6:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80278a8:	683b      	ldr	r3, [r7, #0]
 80278aa:	795b      	ldrb	r3, [r3, #5]
 80278ac:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80278b0:	b2db      	uxtb	r3, r3
 80278b2:	461a      	mov	r2, r3
 80278b4:	687b      	ldr	r3, [r7, #4]
 80278b6:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 80278b8:	683b      	ldr	r3, [r7, #0]
 80278ba:	795b      	ldrb	r3, [r3, #5]
 80278bc:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80278c0:	b2db      	uxtb	r3, r3
 80278c2:	461a      	mov	r2, r3
 80278c4:	687b      	ldr	r3, [r7, #4]
 80278c6:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80278c8:	683b      	ldr	r3, [r7, #0]
 80278ca:	791b      	ldrb	r3, [r3, #4]
 80278cc:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80278d0:	b2db      	uxtb	r3, r3
 80278d2:	461a      	mov	r2, r3
 80278d4:	687b      	ldr	r3, [r7, #4]
 80278d6:	62da      	str	r2, [r3, #44]	; 0x2c
}
 80278d8:	bf00      	nop
 80278da:	370c      	adds	r7, #12
 80278dc:	46bd      	mov	sp, r7
 80278de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278e2:	4770      	bx	lr

080278e4 <XMC_CCU4_SLICE_CaptureInit>:

/* API to configure CC4 Slice for Capture */
void XMC_CCU4_SLICE_CaptureInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_CAPTURE_CONFIG_t *const capture_init)
{
 80278e4:	b480      	push	{r7}
 80278e6:	b083      	sub	sp, #12
 80278e8:	af00      	add	r7, sp, #0
 80278ea:	6078      	str	r0, [r7, #4]
 80278ec:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CaptureInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CaptureInit:Capture Init Pointer is NULL",
             (XMC_CCU4_SLICE_CAPTURE_CONFIG_t *) NULL != capture_init);

  /* Program the capture mode */
  slice->TC = capture_init->tc;
 80278ee:	683b      	ldr	r3, [r7, #0]
 80278f0:	681a      	ldr	r2, [r3, #0]
 80278f2:	687b      	ldr	r3, [r7, #4]
 80278f4:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t)capture_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80278f6:	683b      	ldr	r3, [r7, #0]
 80278f8:	795b      	ldrb	r3, [r3, #5]
 80278fa:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80278fe:	b2db      	uxtb	r3, r3
 8027900:	051a      	lsls	r2, r3, #20
 8027902:	687b      	ldr	r3, [r7, #4]
 8027904:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) capture_init->prescaler_initval;
 8027906:	683b      	ldr	r3, [r7, #0]
 8027908:	791b      	ldrb	r3, [r3, #4]
 802790a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802790e:	b2db      	uxtb	r3, r3
 8027910:	461a      	mov	r2, r3
 8027912:	687b      	ldr	r3, [r7, #4]
 8027914:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program initial floating prescaler compare value */
  slice->FPCS = (uint32_t) capture_init->float_limit;
 8027916:	683b      	ldr	r3, [r7, #0]
 8027918:	791b      	ldrb	r3, [r3, #4]
 802791a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802791e:	b2db      	uxtb	r3, r3
 8027920:	461a      	mov	r2, r3
 8027922:	687b      	ldr	r3, [r7, #4]
 8027924:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8027926:	bf00      	nop
 8027928:	370c      	adds	r7, #12
 802792a:	46bd      	mov	sp, r7
 802792c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027930:	4770      	bx	lr

08027932 <XMC_CCU4_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice */
void XMC_CCU4_SLICE_StartConfig(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_EVENT_t event,
                                const XMC_CCU4_SLICE_START_MODE_t start_mode)
{
 8027932:	b480      	push	{r7}
 8027934:	b085      	sub	sp, #20
 8027936:	af00      	add	r7, sp, #0
 8027938:	6078      	str	r0, [r7, #4]
 802793a:	460b      	mov	r3, r1
 802793c:	70fb      	strb	r3, [r7, #3]
 802793e:	4613      	mov	r3, r2
 8027940:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Start Mode",
             ((start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR) || \
              (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START)));
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8027942:	687b      	ldr	r3, [r7, #4]
 8027944:	685b      	ldr	r3, [r3, #4]
 8027946:	60bb      	str	r3, [r7, #8]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_STRTS_Msk);
 8027948:	68bb      	ldr	r3, [r7, #8]
 802794a:	f023 0303 	bic.w	r3, r3, #3
 802794e:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_STRTS_Pos;
 8027950:	78fb      	ldrb	r3, [r7, #3]
 8027952:	68ba      	ldr	r2, [r7, #8]
 8027954:	4313      	orrs	r3, r2
 8027956:	60bb      	str	r3, [r7, #8]

  slice->CMC = cmc;
 8027958:	687b      	ldr	r3, [r7, #4]
 802795a:	68ba      	ldr	r2, [r7, #8]
 802795c:	605a      	str	r2, [r3, #4]

  tc  = slice->TC;
 802795e:	687b      	ldr	r3, [r7, #4]
 8027960:	695b      	ldr	r3, [r3, #20]
 8027962:	60fb      	str	r3, [r7, #12]
  /* Next, Configure the start mode */
  if (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR)
 8027964:	78bb      	ldrb	r3, [r7, #2]
 8027966:	2b01      	cmp	r3, #1
 8027968:	d104      	bne.n	8027974 <XMC_CCU4_SLICE_StartConfig+0x42>
  {
    tc |= (uint32_t)CCU4_CC4_TC_STRM_Msk;
 802796a:	68fb      	ldr	r3, [r7, #12]
 802796c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8027970:	60fb      	str	r3, [r7, #12]
 8027972:	e003      	b.n	802797c <XMC_CCU4_SLICE_StartConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t)CCU4_CC4_TC_STRM_Msk);
 8027974:	68fb      	ldr	r3, [r7, #12]
 8027976:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802797a:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 802797c:	687b      	ldr	r3, [r7, #4]
 802797e:	68fa      	ldr	r2, [r7, #12]
 8027980:	615a      	str	r2, [r3, #20]
}
 8027982:	bf00      	nop
 8027984:	3714      	adds	r7, #20
 8027986:	46bd      	mov	sp, r7
 8027988:	f85d 7b04 	ldr.w	r7, [sp], #4
 802798c:	4770      	bx	lr

0802798e <XMC_CCU4_SLICE_StopConfig>:

/* API to configure the Stop trigger function of a slice */
void XMC_CCU4_SLICE_StopConfig(XMC_CCU4_SLICE_t *const slice,
                               const XMC_CCU4_SLICE_EVENT_t event,
                               const XMC_CCU4_SLICE_END_MODE_t end_mode)
{
 802798e:	b480      	push	{r7}
 8027990:	b085      	sub	sp, #20
 8027992:	af00      	add	r7, sp, #0
 8027994:	6078      	str	r0, [r7, #4]
 8027996:	460b      	mov	r3, r1
 8027998:	70fb      	strb	r3, [r7, #3]
 802799a:	4613      	mov	r3, r2
 802799c:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Start Mode", XMC_CCU4_CHECK_END_MODE(end_mode));

  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 802799e:	687b      	ldr	r3, [r7, #4]
 80279a0:	685b      	ldr	r3, [r3, #4]
 80279a2:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_ENDS_Msk);
 80279a4:	68fb      	ldr	r3, [r7, #12]
 80279a6:	f023 030c 	bic.w	r3, r3, #12
 80279aa:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_ENDS_Pos;
 80279ac:	78fb      	ldrb	r3, [r7, #3]
 80279ae:	009b      	lsls	r3, r3, #2
 80279b0:	68fa      	ldr	r2, [r7, #12]
 80279b2:	4313      	orrs	r3, r2
 80279b4:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 80279b6:	687b      	ldr	r3, [r7, #4]
 80279b8:	68fa      	ldr	r2, [r7, #12]
 80279ba:	605a      	str	r2, [r3, #4]

  /* Next, Configure the stop mode */
  tc = slice->TC;
 80279bc:	687b      	ldr	r3, [r7, #4]
 80279be:	695b      	ldr	r3, [r3, #20]
 80279c0:	60bb      	str	r3, [r7, #8]
  tc &= ~((uint32_t) CCU4_CC4_TC_ENDM_Msk);
 80279c2:	68bb      	ldr	r3, [r7, #8]
 80279c4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80279c8:	60bb      	str	r3, [r7, #8]
  tc |= ((uint32_t) end_mode) << CCU4_CC4_TC_ENDM_Pos;
 80279ca:	78bb      	ldrb	r3, [r7, #2]
 80279cc:	021b      	lsls	r3, r3, #8
 80279ce:	68ba      	ldr	r2, [r7, #8]
 80279d0:	4313      	orrs	r3, r2
 80279d2:	60bb      	str	r3, [r7, #8]

  slice->TC = tc;
 80279d4:	687b      	ldr	r3, [r7, #4]
 80279d6:	68ba      	ldr	r2, [r7, #8]
 80279d8:	615a      	str	r2, [r3, #20]
}
 80279da:	bf00      	nop
 80279dc:	3714      	adds	r7, #20
 80279de:	46bd      	mov	sp, r7
 80279e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279e4:	4770      	bx	lr

080279e6 <XMC_CCU4_SLICE_LoadConfig>:

/* API to configure the Load trigger function of a slice */
void XMC_CCU4_SLICE_LoadConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 80279e6:	b480      	push	{r7}
 80279e8:	b085      	sub	sp, #20
 80279ea:	af00      	add	r7, sp, #0
 80279ec:	6078      	str	r0, [r7, #4]
 80279ee:	460b      	mov	r3, r1
 80279f0:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_LoadConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_LoadConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the load function */
  cmc = slice->CMC;
 80279f2:	687b      	ldr	r3, [r7, #4]
 80279f4:	685b      	ldr	r3, [r3, #4]
 80279f6:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_LDS_Msk);
 80279f8:	68fb      	ldr	r3, [r7, #12]
 80279fa:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80279fe:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_LDS_Pos;
 8027a00:	78fb      	ldrb	r3, [r7, #3]
 8027a02:	031b      	lsls	r3, r3, #12
 8027a04:	68fa      	ldr	r2, [r7, #12]
 8027a06:	4313      	orrs	r3, r2
 8027a08:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027a0a:	687b      	ldr	r3, [r7, #4]
 8027a0c:	68fa      	ldr	r2, [r7, #12]
 8027a0e:	605a      	str	r2, [r3, #4]
}
 8027a10:	bf00      	nop
 8027a12:	3714      	adds	r7, #20
 8027a14:	46bd      	mov	sp, r7
 8027a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027a1a:	4770      	bx	lr

08027a1c <XMC_CCU4_SLICE_ModulationConfig>:
/* API to configure the slice modulation function */
void XMC_CCU4_SLICE_ModulationConfig(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_EVENT_t event,
                                     const XMC_CCU4_SLICE_MODULATION_MODE_t mod_mode,
                                     const bool synch_with_pwm)
{
 8027a1c:	b480      	push	{r7}
 8027a1e:	b085      	sub	sp, #20
 8027a20:	af00      	add	r7, sp, #0
 8027a22:	6078      	str	r0, [r7, #4]
 8027a24:	4608      	mov	r0, r1
 8027a26:	4611      	mov	r1, r2
 8027a28:	461a      	mov	r2, r3
 8027a2a:	4603      	mov	r3, r0
 8027a2c:	70fb      	strb	r3, [r7, #3]
 8027a2e:	460b      	mov	r3, r1
 8027a30:	70bb      	strb	r3, [r7, #2]
 8027a32:	4613      	mov	r3, r2
 8027a34:	707b      	strb	r3, [r7, #1]
  XMC_ASSERT("XMC_CCU4_SLICE_ModulationConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_ModulationConfig:Invalid Modulation Mode",
             ((mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT) || \
              (mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_ST_OUT)));

  tc  = slice->TC;
 8027a36:	687b      	ldr	r3, [r7, #4]
 8027a38:	695b      	ldr	r3, [r3, #20]
 8027a3a:	60fb      	str	r3, [r7, #12]
  cmc = slice->CMC;
 8027a3c:	687b      	ldr	r3, [r7, #4]
 8027a3e:	685b      	ldr	r3, [r3, #4]
 8027a40:	60bb      	str	r3, [r7, #8]

  /* First, Bind the event with the modulation function */
  cmc &= ~((uint32_t) CCU4_CC4_CMC_MOS_Msk);
 8027a42:	68bb      	ldr	r3, [r7, #8]
 8027a44:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8027a48:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_MOS_Pos;
 8027a4a:	78fb      	ldrb	r3, [r7, #3]
 8027a4c:	049b      	lsls	r3, r3, #18
 8027a4e:	68ba      	ldr	r2, [r7, #8]
 8027a50:	4313      	orrs	r3, r2
 8027a52:	60bb      	str	r3, [r7, #8]
  slice->CMC = cmc;
 8027a54:	687b      	ldr	r3, [r7, #4]
 8027a56:	68ba      	ldr	r2, [r7, #8]
 8027a58:	605a      	str	r2, [r3, #4]

  /* Next, Modulation mode */
  if (mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT)
 8027a5a:	78bb      	ldrb	r3, [r7, #2]
 8027a5c:	2b01      	cmp	r3, #1
 8027a5e:	d104      	bne.n	8027a6a <XMC_CCU4_SLICE_ModulationConfig+0x4e>
  {
    tc |= (uint32_t) CCU4_CC4_TC_EMT_Msk;
 8027a60:	68fb      	ldr	r3, [r7, #12]
 8027a62:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8027a66:	60fb      	str	r3, [r7, #12]
 8027a68:	e003      	b.n	8027a72 <XMC_CCU4_SLICE_ModulationConfig+0x56>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_EMT_Msk);
 8027a6a:	68fb      	ldr	r3, [r7, #12]
 8027a6c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8027a70:	60fb      	str	r3, [r7, #12]
  }

  /* Synchronization of modulation effect with PWM cycle */
  if (synch_with_pwm == (bool) true)
 8027a72:	787b      	ldrb	r3, [r7, #1]
 8027a74:	2b00      	cmp	r3, #0
 8027a76:	d004      	beq.n	8027a82 <XMC_CCU4_SLICE_ModulationConfig+0x66>
  {
    tc |= (uint32_t) CCU4_CC4_TC_EMS_Msk;
 8027a78:	68fb      	ldr	r3, [r7, #12]
 8027a7a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8027a7e:	60fb      	str	r3, [r7, #12]
 8027a80:	e003      	b.n	8027a8a <XMC_CCU4_SLICE_ModulationConfig+0x6e>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_EMS_Msk);
 8027a82:	68fb      	ldr	r3, [r7, #12]
 8027a84:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8027a88:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8027a8a:	687b      	ldr	r3, [r7, #4]
 8027a8c:	68fa      	ldr	r2, [r7, #12]
 8027a8e:	615a      	str	r2, [r3, #20]
}
 8027a90:	bf00      	nop
 8027a92:	3714      	adds	r7, #20
 8027a94:	46bd      	mov	sp, r7
 8027a96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027a9a:	4770      	bx	lr

08027a9c <XMC_CCU4_SLICE_CountConfig>:

/* API to configure the slice count function */
void XMC_CCU4_SLICE_CountConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8027a9c:	b480      	push	{r7}
 8027a9e:	b085      	sub	sp, #20
 8027aa0:	af00      	add	r7, sp, #0
 8027aa2:	6078      	str	r0, [r7, #4]
 8027aa4:	460b      	mov	r3, r1
 8027aa6:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_CountConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CountConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the count function */
  cmc = slice->CMC;
 8027aa8:	687b      	ldr	r3, [r7, #4]
 8027aaa:	685b      	ldr	r3, [r3, #4]
 8027aac:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_CNTS_Msk);
 8027aae:	68fb      	ldr	r3, [r7, #12]
 8027ab0:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8027ab4:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_CNTS_Pos;
 8027ab6:	78fb      	ldrb	r3, [r7, #3]
 8027ab8:	039b      	lsls	r3, r3, #14
 8027aba:	68fa      	ldr	r2, [r7, #12]
 8027abc:	4313      	orrs	r3, r2
 8027abe:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027ac0:	687b      	ldr	r3, [r7, #4]
 8027ac2:	68fa      	ldr	r2, [r7, #12]
 8027ac4:	605a      	str	r2, [r3, #4]
}
 8027ac6:	bf00      	nop
 8027ac8:	3714      	adds	r7, #20
 8027aca:	46bd      	mov	sp, r7
 8027acc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027ad0:	4770      	bx	lr

08027ad2 <XMC_CCU4_SLICE_GateConfig>:

/* API to configure slice gate function */
void XMC_CCU4_SLICE_GateConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8027ad2:	b480      	push	{r7}
 8027ad4:	b085      	sub	sp, #20
 8027ad6:	af00      	add	r7, sp, #0
 8027ad8:	6078      	str	r0, [r7, #4]
 8027ada:	460b      	mov	r3, r1
 8027adc:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_GateConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GateConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the gate function */
  cmc = slice->CMC;
 8027ade:	687b      	ldr	r3, [r7, #4]
 8027ae0:	685b      	ldr	r3, [r3, #4]
 8027ae2:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_GATES_Msk);
 8027ae4:	68fb      	ldr	r3, [r7, #12]
 8027ae6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8027aea:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_GATES_Pos;
 8027aec:	78fb      	ldrb	r3, [r7, #3]
 8027aee:	021b      	lsls	r3, r3, #8
 8027af0:	68fa      	ldr	r2, [r7, #12]
 8027af2:	4313      	orrs	r3, r2
 8027af4:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027af6:	687b      	ldr	r3, [r7, #4]
 8027af8:	68fa      	ldr	r2, [r7, #12]
 8027afa:	605a      	str	r2, [r3, #4]
}
 8027afc:	bf00      	nop
 8027afe:	3714      	adds	r7, #20
 8027b00:	46bd      	mov	sp, r7
 8027b02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027b06:	4770      	bx	lr

08027b08 <XMC_CCU4_SLICE_Capture1Config>:
  slice->CMC = cmc;
}

/* API to configure Capture-1 function */
void XMC_CCU4_SLICE_Capture1Config(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8027b08:	b480      	push	{r7}
 8027b0a:	b085      	sub	sp, #20
 8027b0c:	af00      	add	r7, sp, #0
 8027b0e:	6078      	str	r0, [r7, #4]
 8027b10:	460b      	mov	r3, r1
 8027b12:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_Capture1Config:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_Capture1Config:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the gate function */
  cmc = slice->CMC;
 8027b14:	687b      	ldr	r3, [r7, #4]
 8027b16:	685b      	ldr	r3, [r3, #4]
 8027b18:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_CAP1S_Msk);
 8027b1a:	68fb      	ldr	r3, [r7, #12]
 8027b1c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8027b20:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_CAP1S_Pos;
 8027b22:	78fb      	ldrb	r3, [r7, #3]
 8027b24:	019b      	lsls	r3, r3, #6
 8027b26:	68fa      	ldr	r2, [r7, #12]
 8027b28:	4313      	orrs	r3, r2
 8027b2a:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027b2c:	687b      	ldr	r3, [r7, #4]
 8027b2e:	68fa      	ldr	r2, [r7, #12]
 8027b30:	605a      	str	r2, [r3, #4]
}
 8027b32:	bf00      	nop
 8027b34:	3714      	adds	r7, #20
 8027b36:	46bd      	mov	sp, r7
 8027b38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027b3c:	4770      	bx	lr

08027b3e <XMC_CCU4_SLICE_DirectionConfig>:

/* API to configure direction function */
void XMC_CCU4_SLICE_DirectionConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8027b3e:	b480      	push	{r7}
 8027b40:	b085      	sub	sp, #20
 8027b42:	af00      	add	r7, sp, #0
 8027b44:	6078      	str	r0, [r7, #4]
 8027b46:	460b      	mov	r3, r1
 8027b48:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_DirectionConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_DirectionConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the direction function */
  cmc = slice->CMC;
 8027b4a:	687b      	ldr	r3, [r7, #4]
 8027b4c:	685b      	ldr	r3, [r3, #4]
 8027b4e:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_UDS_Msk);
 8027b50:	68fb      	ldr	r3, [r7, #12]
 8027b52:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8027b56:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_UDS_Pos;
 8027b58:	78fb      	ldrb	r3, [r7, #3]
 8027b5a:	029b      	lsls	r3, r3, #10
 8027b5c:	68fa      	ldr	r2, [r7, #12]
 8027b5e:	4313      	orrs	r3, r2
 8027b60:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027b62:	687b      	ldr	r3, [r7, #4]
 8027b64:	68fa      	ldr	r2, [r7, #12]
 8027b66:	605a      	str	r2, [r3, #4]
}
 8027b68:	bf00      	nop
 8027b6a:	3714      	adds	r7, #20
 8027b6c:	46bd      	mov	sp, r7
 8027b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027b72:	4770      	bx	lr

08027b74 <XMC_CCU4_SLICE_StatusBitOverrideConfig>:

/* API to configure slice status bit override function */
void XMC_CCU4_SLICE_StatusBitOverrideConfig(XMC_CCU4_SLICE_t *const slice)
{
 8027b74:	b480      	push	{r7}
 8027b76:	b085      	sub	sp, #20
 8027b78:	af00      	add	r7, sp, #0
 8027b7a:	6078      	str	r0, [r7, #4]
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU4_SLICE_StatusBitOverrideConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  /* Bind the event with the override function */
  cmc = slice->CMC;
 8027b7c:	687b      	ldr	r3, [r7, #4]
 8027b7e:	685b      	ldr	r3, [r3, #4]
 8027b80:	60fb      	str	r3, [r7, #12]
  /* Map status bit trigger override to Event 1 &
         status bit value override to Event 2 */
  cmc &= ~((uint32_t) CCU4_CC4_CMC_OFS_Msk);
 8027b82:	68fb      	ldr	r3, [r7, #12]
 8027b84:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8027b88:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) 1) << CCU4_CC4_CMC_OFS_Pos;
 8027b8a:	68fb      	ldr	r3, [r7, #12]
 8027b8c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8027b90:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027b92:	687b      	ldr	r3, [r7, #4]
 8027b94:	68fa      	ldr	r2, [r7, #12]
 8027b96:	605a      	str	r2, [r3, #4]
}
 8027b98:	bf00      	nop
 8027b9a:	3714      	adds	r7, #20
 8027b9c:	46bd      	mov	sp, r7
 8027b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027ba2:	4770      	bx	lr

08027ba4 <XMC_CCU4_SLICE_TrapConfig>:

/* API to configure trap function */
void XMC_CCU4_SLICE_TrapConfig(XMC_CCU4_SLICE_t *const slice,
                               const XMC_CCU4_SLICE_TRAP_EXIT_MODE_t exit_mode,
                               const bool synch_with_pwm)
{
 8027ba4:	b480      	push	{r7}
 8027ba6:	b085      	sub	sp, #20
 8027ba8:	af00      	add	r7, sp, #0
 8027baa:	6078      	str	r0, [r7, #4]
 8027bac:	460b      	mov	r3, r1
 8027bae:	70fb      	strb	r3, [r7, #3]
 8027bb0:	4613      	mov	r3, r2
 8027bb2:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_TrapConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_TrapConfig:Invalid Exit Mode", ((exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC) || \
             (exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW)));

  /* First, Map trap function to Event 2 */
  cmc = slice->CMC;
 8027bb4:	687b      	ldr	r3, [r7, #4]
 8027bb6:	685b      	ldr	r3, [r3, #4]
 8027bb8:	60bb      	str	r3, [r7, #8]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_TS_Msk);
 8027bba:	68bb      	ldr	r3, [r7, #8]
 8027bbc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8027bc0:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) 1) << CCU4_CC4_CMC_TS_Pos;
 8027bc2:	68bb      	ldr	r3, [r7, #8]
 8027bc4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8027bc8:	60bb      	str	r3, [r7, #8]
  slice->CMC = cmc;
 8027bca:	687b      	ldr	r3, [r7, #4]
 8027bcc:	68ba      	ldr	r2, [r7, #8]
 8027bce:	605a      	str	r2, [r3, #4]

  /* Next, Configure synchronization option */
  tc = slice->TC;
 8027bd0:	687b      	ldr	r3, [r7, #4]
 8027bd2:	695b      	ldr	r3, [r3, #20]
 8027bd4:	60fb      	str	r3, [r7, #12]

  if (synch_with_pwm == (bool) true)
 8027bd6:	78bb      	ldrb	r3, [r7, #2]
 8027bd8:	2b00      	cmp	r3, #0
 8027bda:	d004      	beq.n	8027be6 <XMC_CCU4_SLICE_TrapConfig+0x42>
  {
    tc |= (uint32_t) CCU4_CC4_TC_TRPSE_Msk;
 8027bdc:	68fb      	ldr	r3, [r7, #12]
 8027bde:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8027be2:	60fb      	str	r3, [r7, #12]
 8027be4:	e003      	b.n	8027bee <XMC_CCU4_SLICE_TrapConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_TRPSE_Msk);
 8027be6:	68fb      	ldr	r3, [r7, #12]
 8027be8:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8027bec:	60fb      	str	r3, [r7, #12]
  }

  /* Configure exit mode */
  if (exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW)
 8027bee:	78fb      	ldrb	r3, [r7, #3]
 8027bf0:	2b01      	cmp	r3, #1
 8027bf2:	d104      	bne.n	8027bfe <XMC_CCU4_SLICE_TrapConfig+0x5a>
  {
    tc |= (uint32_t) CCU4_CC4_TC_TRPSW_Msk;
 8027bf4:	68fb      	ldr	r3, [r7, #12]
 8027bf6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8027bfa:	60fb      	str	r3, [r7, #12]
 8027bfc:	e003      	b.n	8027c06 <XMC_CCU4_SLICE_TrapConfig+0x62>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_TRPSW_Msk);
 8027bfe:	68fb      	ldr	r3, [r7, #12]
 8027c00:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8027c04:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8027c06:	687b      	ldr	r3, [r7, #4]
 8027c08:	68fa      	ldr	r2, [r7, #12]
 8027c0a:	615a      	str	r2, [r3, #20]
}
 8027c0c:	bf00      	nop
 8027c0e:	3714      	adds	r7, #20
 8027c10:	46bd      	mov	sp, r7
 8027c12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027c16:	4770      	bx	lr

08027c18 <XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent>:

/* API to configure a slice Status Bit Override event */
void XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev1_config,
    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev2_config)
{
 8027c18:	b480      	push	{r7}
 8027c1a:	b087      	sub	sp, #28
 8027c1c:	af00      	add	r7, sp, #0
 8027c1e:	60f8      	str	r0, [r7, #12]
 8027c20:	60b9      	str	r1, [r7, #8]
 8027c22:	607a      	str	r2, [r7, #4]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS1_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU4_CC4_INS1_EV2IS_Pos;

  slice->INS1 = ins;
#else
  ins = slice->INS;
 8027c24:	68fb      	ldr	r3, [r7, #12]
 8027c26:	681b      	ldr	r3, [r3, #0]
 8027c28:	617b      	str	r3, [r7, #20]

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU4_CC4_INS_EV1EM_Pos);
 8027c2a:	697b      	ldr	r3, [r7, #20]
 8027c2c:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8027c30:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->edge) << CCU4_CC4_INS_EV1EM_Pos;
 8027c32:	68bb      	ldr	r3, [r7, #8]
 8027c34:	785b      	ldrb	r3, [r3, #1]
 8027c36:	049b      	lsls	r3, r3, #18
 8027c38:	697a      	ldr	r2, [r7, #20]
 8027c3a:	4313      	orrs	r3, r2
 8027c3c:	617b      	str	r3, [r7, #20]

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU4_CC4_INS_EV2EM_Pos);
 8027c3e:	697b      	ldr	r3, [r7, #20]
 8027c40:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8027c44:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->edge) << CCU4_CC4_INS_EV2EM_Pos;
 8027c46:	687b      	ldr	r3, [r7, #4]
 8027c48:	785b      	ldrb	r3, [r3, #1]
 8027c4a:	051b      	lsls	r3, r3, #20
 8027c4c:	697a      	ldr	r2, [r7, #20]
 8027c4e:	4313      	orrs	r3, r2
 8027c50:	617b      	str	r3, [r7, #20]

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU4_CC4_INS_EV1LM_Pos);
 8027c52:	697b      	ldr	r3, [r7, #20]
 8027c54:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8027c58:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->level) << CCU4_CC4_INS_EV1LM_Pos;
 8027c5a:	68bb      	ldr	r3, [r7, #8]
 8027c5c:	789b      	ldrb	r3, [r3, #2]
 8027c5e:	05db      	lsls	r3, r3, #23
 8027c60:	697a      	ldr	r2, [r7, #20]
 8027c62:	4313      	orrs	r3, r2
 8027c64:	617b      	str	r3, [r7, #20]

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU4_CC4_INS_EV2LM_Pos);
 8027c66:	697b      	ldr	r3, [r7, #20]
 8027c68:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8027c6c:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->level) << CCU4_CC4_INS_EV2LM_Pos;
 8027c6e:	687b      	ldr	r3, [r7, #4]
 8027c70:	789b      	ldrb	r3, [r3, #2]
 8027c72:	061b      	lsls	r3, r3, #24
 8027c74:	697a      	ldr	r2, [r7, #20]
 8027c76:	4313      	orrs	r3, r2
 8027c78:	617b      	str	r3, [r7, #20]

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU4_CC4_INS_LPF1M_Pos);
 8027c7a:	697b      	ldr	r3, [r7, #20]
 8027c7c:	f023 53c0 	bic.w	r3, r3, #402653184	; 0x18000000
 8027c80:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->duration) << CCU4_CC4_INS_LPF1M_Pos;
 8027c82:	68bb      	ldr	r3, [r7, #8]
 8027c84:	78db      	ldrb	r3, [r3, #3]
 8027c86:	06db      	lsls	r3, r3, #27
 8027c88:	697a      	ldr	r2, [r7, #20]
 8027c8a:	4313      	orrs	r3, r2
 8027c8c:	617b      	str	r3, [r7, #20]

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU4_CC4_INS_LPF2M_Pos);
 8027c8e:	697b      	ldr	r3, [r7, #20]
 8027c90:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8027c94:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->duration) << CCU4_CC4_INS_LPF2M_Pos;
 8027c96:	687b      	ldr	r3, [r7, #4]
 8027c98:	78db      	ldrb	r3, [r3, #3]
 8027c9a:	075b      	lsls	r3, r3, #29
 8027c9c:	697a      	ldr	r2, [r7, #20]
 8027c9e:	4313      	orrs	r3, r2
 8027ca0:	617b      	str	r3, [r7, #20]

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS_EV1IS_Pos);
 8027ca2:	697b      	ldr	r3, [r7, #20]
 8027ca4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8027ca8:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU4_CC4_INS_EV1IS_Pos;
 8027caa:	68bb      	ldr	r3, [r7, #8]
 8027cac:	781b      	ldrb	r3, [r3, #0]
 8027cae:	011b      	lsls	r3, r3, #4
 8027cb0:	697a      	ldr	r2, [r7, #20]
 8027cb2:	4313      	orrs	r3, r2
 8027cb4:	617b      	str	r3, [r7, #20]

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS_EV2IS_Pos);
 8027cb6:	697b      	ldr	r3, [r7, #20]
 8027cb8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8027cbc:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU4_CC4_INS_EV2IS_Pos;
 8027cbe:	687b      	ldr	r3, [r7, #4]
 8027cc0:	781b      	ldrb	r3, [r3, #0]
 8027cc2:	021b      	lsls	r3, r3, #8
 8027cc4:	697a      	ldr	r2, [r7, #20]
 8027cc6:	4313      	orrs	r3, r2
 8027cc8:	617b      	str	r3, [r7, #20]

  slice->INS = ins;
 8027cca:	68fb      	ldr	r3, [r7, #12]
 8027ccc:	697a      	ldr	r2, [r7, #20]
 8027cce:	601a      	str	r2, [r3, #0]
#endif
}
 8027cd0:	bf00      	nop
 8027cd2:	371c      	adds	r7, #28
 8027cd4:	46bd      	mov	sp, r7
 8027cd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027cda:	4770      	bx	lr

08027cdc <XMC_CCU4_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU4_SLICE_ConfigureEvent(XMC_CCU4_SLICE_t *const slice,
                                   const XMC_CCU4_SLICE_EVENT_t event,
                                   const XMC_CCU4_SLICE_EVENT_CONFIG_t *const config)
{
 8027cdc:	b480      	push	{r7}
 8027cde:	b089      	sub	sp, #36	; 0x24
 8027ce0:	af00      	add	r7, sp, #0
 8027ce2:	60f8      	str	r0, [r7, #12]
 8027ce4:	460b      	mov	r3, r1
 8027ce6:	607a      	str	r2, [r7, #4]
 8027ce8:	72fb      	strb	r3, [r7, #11]
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) || \
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8027cea:	7afb      	ldrb	r3, [r7, #11]
 8027cec:	3b01      	subs	r3, #1
 8027cee:	77fb      	strb	r3, [r7, #31]
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8027cf0:	68fb      	ldr	r3, [r7, #12]
 8027cf2:	681b      	ldr	r3, [r3, #0]
 8027cf4:	61bb      	str	r3, [r7, #24]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8027cf6:	7ffb      	ldrb	r3, [r7, #31]
 8027cf8:	005b      	lsls	r3, r3, #1
 8027cfa:	b2db      	uxtb	r3, r3
 8027cfc:	3310      	adds	r3, #16
 8027cfe:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8027d00:	7dfb      	ldrb	r3, [r7, #23]
 8027d02:	2203      	movs	r2, #3
 8027d04:	fa02 f303 	lsl.w	r3, r2, r3
 8027d08:	43db      	mvns	r3, r3
 8027d0a:	69ba      	ldr	r2, [r7, #24]
 8027d0c:	4013      	ands	r3, r2
 8027d0e:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->edge) << pos;
 8027d10:	687b      	ldr	r3, [r7, #4]
 8027d12:	785b      	ldrb	r3, [r3, #1]
 8027d14:	461a      	mov	r2, r3
 8027d16:	7dfb      	ldrb	r3, [r7, #23]
 8027d18:	fa02 f303 	lsl.w	r3, r2, r3
 8027d1c:	69ba      	ldr	r2, [r7, #24]
 8027d1e:	4313      	orrs	r3, r2
 8027d20:	61bb      	str	r3, [r7, #24]

  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
 8027d22:	7ffb      	ldrb	r3, [r7, #31]
 8027d24:	3316      	adds	r3, #22
 8027d26:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8027d28:	7dfb      	ldrb	r3, [r7, #23]
 8027d2a:	2201      	movs	r2, #1
 8027d2c:	fa02 f303 	lsl.w	r3, r2, r3
 8027d30:	43db      	mvns	r3, r3
 8027d32:	69ba      	ldr	r2, [r7, #24]
 8027d34:	4013      	ands	r3, r2
 8027d36:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->level) << pos;
 8027d38:	687b      	ldr	r3, [r7, #4]
 8027d3a:	789b      	ldrb	r3, [r3, #2]
 8027d3c:	461a      	mov	r2, r3
 8027d3e:	7dfb      	ldrb	r3, [r7, #23]
 8027d40:	fa02 f303 	lsl.w	r3, r2, r3
 8027d44:	69ba      	ldr	r2, [r7, #24]
 8027d46:	4313      	orrs	r3, r2
 8027d48:	61bb      	str	r3, [r7, #24]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8027d4a:	7ffb      	ldrb	r3, [r7, #31]
 8027d4c:	005b      	lsls	r3, r3, #1
 8027d4e:	b2db      	uxtb	r3, r3
 8027d50:	3319      	adds	r3, #25
 8027d52:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8027d54:	7dfb      	ldrb	r3, [r7, #23]
 8027d56:	2203      	movs	r2, #3
 8027d58:	fa02 f303 	lsl.w	r3, r2, r3
 8027d5c:	43db      	mvns	r3, r3
 8027d5e:	69ba      	ldr	r2, [r7, #24]
 8027d60:	4013      	ands	r3, r2
 8027d62:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->duration) << pos;
 8027d64:	687b      	ldr	r3, [r7, #4]
 8027d66:	78db      	ldrb	r3, [r3, #3]
 8027d68:	461a      	mov	r2, r3
 8027d6a:	7dfb      	ldrb	r3, [r7, #23]
 8027d6c:	fa02 f303 	lsl.w	r3, r2, r3
 8027d70:	69ba      	ldr	r2, [r7, #24]
 8027d72:	4313      	orrs	r3, r2
 8027d74:	61bb      	str	r3, [r7, #24]

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 8027d76:	7ffb      	ldrb	r3, [r7, #31]
 8027d78:	009b      	lsls	r3, r3, #2
 8027d7a:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8027d7c:	7dfb      	ldrb	r3, [r7, #23]
 8027d7e:	220f      	movs	r2, #15
 8027d80:	fa02 f303 	lsl.w	r3, r2, r3
 8027d84:	43db      	mvns	r3, r3
 8027d86:	69ba      	ldr	r2, [r7, #24]
 8027d88:	4013      	ands	r3, r2
 8027d8a:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->mapped_input) << pos;
 8027d8c:	687b      	ldr	r3, [r7, #4]
 8027d8e:	781b      	ldrb	r3, [r3, #0]
 8027d90:	461a      	mov	r2, r3
 8027d92:	7dfb      	ldrb	r3, [r7, #23]
 8027d94:	fa02 f303 	lsl.w	r3, r2, r3
 8027d98:	69ba      	ldr	r2, [r7, #24]
 8027d9a:	4313      	orrs	r3, r2
 8027d9c:	61bb      	str	r3, [r7, #24]

  slice->INS = ins;
 8027d9e:	68fb      	ldr	r3, [r7, #12]
 8027da0:	69ba      	ldr	r2, [r7, #24]
 8027da2:	601a      	str	r2, [r3, #0]
#endif
}
 8027da4:	bf00      	nop
 8027da6:	3724      	adds	r7, #36	; 0x24
 8027da8:	46bd      	mov	sp, r7
 8027daa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027dae:	4770      	bx	lr

08027db0 <XMC_CCU4_SLICE_GetCaptureRegisterValue>:
  }
}

/* Retrieves desired capture register value */
uint32_t XMC_CCU4_SLICE_GetCaptureRegisterValue(const XMC_CCU4_SLICE_t *const slice, const uint8_t reg_num)
{
 8027db0:	b480      	push	{r7}
 8027db2:	b083      	sub	sp, #12
 8027db4:	af00      	add	r7, sp, #0
 8027db6:	6078      	str	r0, [r7, #4]
 8027db8:	460b      	mov	r3, r1
 8027dba:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_GetCaptureRegisterValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetCaptureRegisterValue:Invalid register number", (reg_num < 4U));
  return (slice->CV[reg_num]);
 8027dbc:	78fb      	ldrb	r3, [r7, #3]
 8027dbe:	687a      	ldr	r2, [r7, #4]
 8027dc0:	331c      	adds	r3, #28
 8027dc2:	009b      	lsls	r3, r3, #2
 8027dc4:	4413      	add	r3, r2
 8027dc6:	685b      	ldr	r3, [r3, #4]
}
 8027dc8:	4618      	mov	r0, r3
 8027dca:	370c      	adds	r7, #12
 8027dcc:	46bd      	mov	sp, r7
 8027dce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027dd2:	4770      	bx	lr

08027dd4 <XMC_CCU4_SLICE_SetPrescaler>:
  XMC_CCU4_SLICE_SetDitherCompareValue((XMC_CCU4_SLICE_t *)slice, (uint8_t)spread);
}

/* Programs Pre-scalar divider  */
void XMC_CCU4_SLICE_SetPrescaler(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_PRESCALER_t div_val)
{
 8027dd4:	b480      	push	{r7}
 8027dd6:	b085      	sub	sp, #20
 8027dd8:	af00      	add	r7, sp, #0
 8027dda:	6078      	str	r0, [r7, #4]
 8027ddc:	460b      	mov	r3, r1
 8027dde:	70fb      	strb	r3, [r7, #3]
  uint32_t fpc;

  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 8027de0:	687b      	ldr	r3, [r7, #4]
 8027de2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8027de4:	60fb      	str	r3, [r7, #12]
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 8027de6:	68fb      	ldr	r3, [r7, #12]
 8027de8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8027dec:	60fb      	str	r3, [r7, #12]
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 8027dee:	78fb      	ldrb	r3, [r7, #3]
 8027df0:	021b      	lsls	r3, r3, #8
 8027df2:	68fa      	ldr	r2, [r7, #12]
 8027df4:	4313      	orrs	r3, r2
 8027df6:	60fb      	str	r3, [r7, #12]
  slice->FPC = fpc;
 8027df8:	687b      	ldr	r3, [r7, #4]
 8027dfa:	68fa      	ldr	r2, [r7, #12]
 8027dfc:	629a      	str	r2, [r3, #40]	; 0x28
  /*
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8027dfe:	78fa      	ldrb	r2, [r7, #3]
 8027e00:	687b      	ldr	r3, [r7, #4]
 8027e02:	625a      	str	r2, [r3, #36]	; 0x24
}
 8027e04:	bf00      	nop
 8027e06:	3714      	adds	r7, #20
 8027e08:	46bd      	mov	sp, r7
 8027e0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027e0e:	4770      	bx	lr

08027e10 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 8027e10:	b480      	push	{r7}
 8027e12:	b087      	sub	sp, #28
 8027e14:	af00      	add	r7, sp, #0
 8027e16:	6078      	str	r0, [r7, #4]
 8027e18:	460b      	mov	r3, r1
 8027e1a:	70fb      	strb	r3, [r7, #3]
 8027e1c:	4613      	mov	r3, r2
 8027e1e:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 8027e20:	78fb      	ldrb	r3, [r7, #3]
 8027e22:	2b0b      	cmp	r3, #11
 8027e24:	d836      	bhi.n	8027e94 <XMC_CCU4_SLICE_SetInterruptNode+0x84>
 8027e26:	a201      	add	r2, pc, #4	; (adr r2, 8027e2c <XMC_CCU4_SLICE_SetInterruptNode+0x1c>)
 8027e28:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027e2c:	08027e5d 	.word	0x08027e5d
 8027e30:	08027e5d 	.word	0x08027e5d
 8027e34:	08027e67 	.word	0x08027e67
 8027e38:	08027e67 	.word	0x08027e67
 8027e3c:	08027e95 	.word	0x08027e95
 8027e40:	08027e95 	.word	0x08027e95
 8027e44:	08027e95 	.word	0x08027e95
 8027e48:	08027e95 	.word	0x08027e95
 8027e4c:	08027e71 	.word	0x08027e71
 8027e50:	08027e7d 	.word	0x08027e7d
 8027e54:	08027e89 	.word	0x08027e89
 8027e58:	08027e89 	.word	0x08027e89
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
 8027e5c:	2303      	movs	r3, #3
 8027e5e:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
 8027e60:	2300      	movs	r3, #0
 8027e62:	617b      	str	r3, [r7, #20]
      break;
 8027e64:	e01b      	b.n	8027e9e <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
 8027e66:	230c      	movs	r3, #12
 8027e68:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
 8027e6a:	2302      	movs	r3, #2
 8027e6c:	617b      	str	r3, [r7, #20]
      break;
 8027e6e:	e016      	b.n	8027e9e <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
 8027e70:	f44f 7340 	mov.w	r3, #768	; 0x300
 8027e74:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
 8027e76:	2308      	movs	r3, #8
 8027e78:	617b      	str	r3, [r7, #20]
      break;
 8027e7a:	e010      	b.n	8027e9e <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
 8027e7c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8027e80:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
 8027e82:	230a      	movs	r3, #10
 8027e84:	617b      	str	r3, [r7, #20]
      break;
 8027e86:	e00a      	b.n	8027e9e <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU4_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
 8027e88:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8027e8c:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
 8027e8e:	230c      	movs	r3, #12
 8027e90:	617b      	str	r3, [r7, #20]
      break;
 8027e92:	e004      	b.n	8027e9e <XMC_CCU4_SLICE_SetInterruptNode+0x8e>
	  
	default:
	  mask = 0;
 8027e94:	2300      	movs	r3, #0
 8027e96:	613b      	str	r3, [r7, #16]
	  pos = 0;
 8027e98:	2300      	movs	r3, #0
 8027e9a:	617b      	str	r3, [r7, #20]
	  break;
 8027e9c:	bf00      	nop
  }

  if (mask != 0)
 8027e9e:	693b      	ldr	r3, [r7, #16]
 8027ea0:	2b00      	cmp	r3, #0
 8027ea2:	d013      	beq.n	8027ecc <XMC_CCU4_SLICE_SetInterruptNode+0xbc>
  {
    srs = slice->SRS;
 8027ea4:	687b      	ldr	r3, [r7, #4]
 8027ea6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8027eaa:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 8027eac:	693b      	ldr	r3, [r7, #16]
 8027eae:	43db      	mvns	r3, r3
 8027eb0:	68fa      	ldr	r2, [r7, #12]
 8027eb2:	4013      	ands	r3, r2
 8027eb4:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 8027eb6:	78ba      	ldrb	r2, [r7, #2]
 8027eb8:	697b      	ldr	r3, [r7, #20]
 8027eba:	fa02 f303 	lsl.w	r3, r2, r3
 8027ebe:	68fa      	ldr	r2, [r7, #12]
 8027ec0:	4313      	orrs	r3, r2
 8027ec2:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 8027ec4:	687b      	ldr	r3, [r7, #4]
 8027ec6:	68fa      	ldr	r2, [r7, #12]
 8027ec8:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 8027ecc:	bf00      	nop
 8027ece:	371c      	adds	r7, #28
 8027ed0:	46bd      	mov	sp, r7
 8027ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027ed6:	4770      	bx	lr

08027ed8 <XMC_CCU8_StartPrescaler>:
{
 8027ed8:	b480      	push	{r7}
 8027eda:	b083      	sub	sp, #12
 8027edc:	af00      	add	r7, sp, #0
 8027ede:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8027ee0:	687b      	ldr	r3, [r7, #4]
 8027ee2:	f44f 7280 	mov.w	r2, #256	; 0x100
 8027ee6:	60da      	str	r2, [r3, #12]
}
 8027ee8:	bf00      	nop
 8027eea:	370c      	adds	r7, #12
 8027eec:	46bd      	mov	sp, r7
 8027eee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027ef2:	4770      	bx	lr

08027ef4 <XMC_CCU8_SLICE_StopTimer>:
{
 8027ef4:	b480      	push	{r7}
 8027ef6:	b083      	sub	sp, #12
 8027ef8:	af00      	add	r7, sp, #0
 8027efa:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8027efc:	687b      	ldr	r3, [r7, #4]
 8027efe:	2201      	movs	r2, #1
 8027f00:	611a      	str	r2, [r3, #16]
}
 8027f02:	bf00      	nop
 8027f04:	370c      	adds	r7, #12
 8027f06:	46bd      	mov	sp, r7
 8027f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027f0c:	4770      	bx	lr
	...

08027f10 <XMC_CCU8_lDeassertReset>:
    XMC_ASSERT("XMC_CCU8_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
 8027f10:	b580      	push	{r7, lr}
 8027f12:	b082      	sub	sp, #8
 8027f14:	af00      	add	r7, sp, #0
 8027f16:	6078      	str	r0, [r7, #4]
  if (module == CCU80)
 8027f18:	687b      	ldr	r3, [r7, #4]
 8027f1a:	4a09      	ldr	r2, [pc, #36]	; (8027f40 <XMC_CCU8_lDeassertReset+0x30>)
 8027f1c:	4293      	cmp	r3, r2
 8027f1e:	d103      	bne.n	8027f28 <XMC_CCU8_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 8027f20:	2080      	movs	r0, #128	; 0x80
 8027f22:	f7fe fce3 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU8_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 8027f26:	e007      	b.n	8027f38 <XMC_CCU8_lDeassertReset+0x28>
  else if (module == CCU81)
 8027f28:	687b      	ldr	r3, [r7, #4]
 8027f2a:	4a06      	ldr	r2, [pc, #24]	; (8027f44 <XMC_CCU8_lDeassertReset+0x34>)
 8027f2c:	4293      	cmp	r3, r2
 8027f2e:	d103      	bne.n	8027f38 <XMC_CCU8_lDeassertReset+0x28>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 8027f30:	f44f 7080 	mov.w	r0, #256	; 0x100
 8027f34:	f7fe fcda 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8027f38:	bf00      	nop
 8027f3a:	3708      	adds	r7, #8
 8027f3c:	46bd      	mov	sp, r7
 8027f3e:	bd80      	pop	{r7, pc}
 8027f40:	40020000 	.word	0x40020000
 8027f44:	40024000 	.word	0x40024000

08027f48 <XMC_CCU8_EnableModule>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to set the CCU8 module as active and enable the clock  */
void XMC_CCU8_EnableModule(XMC_CCU8_MODULE_t *const module)
{
 8027f48:	b580      	push	{r7, lr}
 8027f4a:	b082      	sub	sp, #8
 8027f4c:	af00      	add	r7, sp, #0
 8027f4e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8027f50:	2010      	movs	r0, #16
 8027f52:	f7fe fe07 	bl	8026b64 <XMC_SCU_CLOCK_EnableClock>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU8_lUngateClock(module);
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU8_lDeassertReset(module);
 8027f56:	6878      	ldr	r0, [r7, #4]
 8027f58:	f7ff ffda 	bl	8027f10 <XMC_CCU8_lDeassertReset>
#endif
}
 8027f5c:	bf00      	nop
 8027f5e:	3708      	adds	r7, #8
 8027f60:	46bd      	mov	sp, r7
 8027f62:	bd80      	pop	{r7, pc}

08027f64 <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8027f64:	b580      	push	{r7, lr}
 8027f66:	b084      	sub	sp, #16
 8027f68:	af00      	add	r7, sp, #0
 8027f6a:	6078      	str	r0, [r7, #4]
 8027f6c:	460b      	mov	r3, r1
 8027f6e:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU8_Init:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_Init:Invalid mcs action", XMC_CCU8_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
 8027f70:	6878      	ldr	r0, [r7, #4]
 8027f72:	f7ff ffe9 	bl	8027f48 <XMC_CCU8_EnableModule>
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
 8027f76:	6878      	ldr	r0, [r7, #4]
 8027f78:	f7ff ffae 	bl	8027ed8 <XMC_CCU8_StartPrescaler>

  gctrl = module->GCTRL;
 8027f7c:	687b      	ldr	r3, [r7, #4]
 8027f7e:	681b      	ldr	r3, [r3, #0]
 8027f80:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 8027f82:	68fb      	ldr	r3, [r7, #12]
 8027f84:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8027f88:	60fb      	str	r3, [r7, #12]
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 8027f8a:	78fb      	ldrb	r3, [r7, #3]
 8027f8c:	039b      	lsls	r3, r3, #14
 8027f8e:	68fa      	ldr	r2, [r7, #12]
 8027f90:	4313      	orrs	r3, r2
 8027f92:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 8027f94:	687b      	ldr	r3, [r7, #4]
 8027f96:	68fa      	ldr	r2, [r7, #12]
 8027f98:	601a      	str	r2, [r3, #0]
}
 8027f9a:	bf00      	nop
 8027f9c:	3710      	adds	r7, #16
 8027f9e:	46bd      	mov	sp, r7
 8027fa0:	bd80      	pop	{r7, pc}

08027fa2 <XMC_CCU8_SLICE_CompareInit>:
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8027fa2:	b580      	push	{r7, lr}
 8027fa4:	b082      	sub	sp, #8
 8027fa6:	af00      	add	r7, sp, #0
 8027fa8:	6078      	str	r0, [r7, #4]
 8027faa:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
 8027fac:	6878      	ldr	r0, [r7, #4]
 8027fae:	f7ff ffa1 	bl	8027ef4 <XMC_CCU8_SLICE_StopTimer>
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8027fb2:	683b      	ldr	r3, [r7, #0]
 8027fb4:	681a      	ldr	r2, [r3, #0]
 8027fb6:	687b      	ldr	r3, [r7, #4]
 8027fb8:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8027fba:	683b      	ldr	r3, [r7, #0]
 8027fbc:	7b5b      	ldrb	r3, [r3, #13]
 8027fbe:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8027fc2:	b2db      	uxtb	r3, r3
 8027fc4:	051a      	lsls	r2, r3, #20
 8027fc6:	687b      	ldr	r3, [r7, #4]
 8027fc8:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8027fca:	683b      	ldr	r3, [r7, #0]
 8027fcc:	7b1b      	ldrb	r3, [r3, #12]
 8027fce:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027fd2:	b2db      	uxtb	r3, r3
 8027fd4:	461a      	mov	r2, r3
 8027fd6:	687b      	ldr	r3, [r7, #4]
 8027fd8:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8027fda:	683b      	ldr	r3, [r7, #0]
 8027fdc:	7b1b      	ldrb	r3, [r3, #12]
 8027fde:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8027fe2:	b2db      	uxtb	r3, r3
 8027fe4:	461a      	mov	r2, r3
 8027fe6:	687b      	ldr	r3, [r7, #4]
 8027fe8:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8027fea:	683b      	ldr	r3, [r7, #0]
 8027fec:	7b5b      	ldrb	r3, [r3, #13]
 8027fee:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027ff2:	b2db      	uxtb	r3, r3
 8027ff4:	461a      	mov	r2, r3
 8027ff6:	687b      	ldr	r3, [r7, #4]
 8027ff8:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 8027ffa:	683b      	ldr	r3, [r7, #0]
 8027ffc:	685a      	ldr	r2, [r3, #4]
 8027ffe:	687b      	ldr	r3, [r7, #4]
 8028000:	619a      	str	r2, [r3, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 8028002:	683b      	ldr	r3, [r7, #0]
 8028004:	689b      	ldr	r3, [r3, #8]
 8028006:	f083 0214 	eor.w	r2, r3, #20
 802800a:	687b      	ldr	r3, [r7, #4]
 802800c:	649a      	str	r2, [r3, #72]	; 0x48
#endif
}
 802800e:	bf00      	nop
 8028010:	3708      	adds	r7, #8
 8028012:	46bd      	mov	sp, r7
 8028014:	bd80      	pop	{r7, pc}

08028016 <XMC_CCU8_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice*/
void XMC_CCU8_SLICE_StartConfig(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_EVENT_t event,
                                const XMC_CCU8_SLICE_START_MODE_t start_mode)
{
 8028016:	b480      	push	{r7}
 8028018:	b085      	sub	sp, #20
 802801a:	af00      	add	r7, sp, #0
 802801c:	6078      	str	r0, [r7, #4]
 802801e:	460b      	mov	r3, r1
 8028020:	70fb      	strb	r3, [r7, #3]
 8028022:	4613      	mov	r3, r2
 8028024:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode",
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) || \
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;
 8028026:	687b      	ldr	r3, [r7, #4]
 8028028:	685b      	ldr	r3, [r3, #4]
 802802a:	60bb      	str	r3, [r7, #8]

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
 802802c:	68bb      	ldr	r3, [r7, #8]
 802802e:	f023 0303 	bic.w	r3, r3, #3
 8028032:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_STRTS_Pos;
 8028034:	78fb      	ldrb	r3, [r7, #3]
 8028036:	68ba      	ldr	r2, [r7, #8]
 8028038:	4313      	orrs	r3, r2
 802803a:	60bb      	str	r3, [r7, #8]

  slice->CMC = cmc;
 802803c:	687b      	ldr	r3, [r7, #4]
 802803e:	68ba      	ldr	r2, [r7, #8]
 8028040:	605a      	str	r2, [r3, #4]

  tc  = slice->TC;
 8028042:	687b      	ldr	r3, [r7, #4]
 8028044:	695b      	ldr	r3, [r3, #20]
 8028046:	60fb      	str	r3, [r7, #12]

  if (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
 8028048:	78bb      	ldrb	r3, [r7, #2]
 802804a:	2b01      	cmp	r3, #1
 802804c:	d104      	bne.n	8028058 <XMC_CCU8_SLICE_StartConfig+0x42>
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
 802804e:	68fb      	ldr	r3, [r7, #12]
 8028050:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8028054:	60fb      	str	r3, [r7, #12]
 8028056:	e003      	b.n	8028060 <XMC_CCU8_SLICE_StartConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_STRM_Msk);
 8028058:	68fb      	ldr	r3, [r7, #12]
 802805a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802805e:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8028060:	687b      	ldr	r3, [r7, #4]
 8028062:	68fa      	ldr	r2, [r7, #12]
 8028064:	615a      	str	r2, [r3, #20]
}
 8028066:	bf00      	nop
 8028068:	3714      	adds	r7, #20
 802806a:	46bd      	mov	sp, r7
 802806c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028070:	4770      	bx	lr

08028072 <XMC_CCU8_SLICE_StopConfig>:

/* API to configure the Stop trigger function of a slice */
void XMC_CCU8_SLICE_StopConfig(XMC_CCU8_SLICE_t *const slice,
                               const XMC_CCU8_SLICE_EVENT_t event,
                               const XMC_CCU8_SLICE_END_MODE_t end_mode)
{
 8028072:	b480      	push	{r7}
 8028074:	b085      	sub	sp, #20
 8028076:	af00      	add	r7, sp, #0
 8028078:	6078      	str	r0, [r7, #4]
 802807a:	460b      	mov	r3, r1
 802807c:	70fb      	strb	r3, [r7, #3]
 802807e:	4613      	mov	r3, r2
 8028080:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid End Mode", XMC_CCU8_SLICE_CHECK_END_MODE(end_mode));

  cmc = slice->CMC;
 8028082:	687b      	ldr	r3, [r7, #4]
 8028084:	685b      	ldr	r3, [r3, #4]
 8028086:	60fb      	str	r3, [r7, #12]
  /* First, Bind the event with the stop function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_ENDS_Msk);
 8028088:	68fb      	ldr	r3, [r7, #12]
 802808a:	f023 030c 	bic.w	r3, r3, #12
 802808e:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_ENDS_Pos;
 8028090:	78fb      	ldrb	r3, [r7, #3]
 8028092:	009b      	lsls	r3, r3, #2
 8028094:	68fa      	ldr	r2, [r7, #12]
 8028096:	4313      	orrs	r3, r2
 8028098:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 802809a:	687b      	ldr	r3, [r7, #4]
 802809c:	68fa      	ldr	r2, [r7, #12]
 802809e:	605a      	str	r2, [r3, #4]

  /* Configure the stop mode */
  tc = slice->TC;
 80280a0:	687b      	ldr	r3, [r7, #4]
 80280a2:	695b      	ldr	r3, [r3, #20]
 80280a4:	60bb      	str	r3, [r7, #8]
  tc &= ~((uint32_t) CCU8_CC8_TC_ENDM_Msk);
 80280a6:	68bb      	ldr	r3, [r7, #8]
 80280a8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80280ac:	60bb      	str	r3, [r7, #8]
  tc |= ((uint32_t) end_mode) << CCU8_CC8_TC_ENDM_Pos;
 80280ae:	78bb      	ldrb	r3, [r7, #2]
 80280b0:	021b      	lsls	r3, r3, #8
 80280b2:	68ba      	ldr	r2, [r7, #8]
 80280b4:	4313      	orrs	r3, r2
 80280b6:	60bb      	str	r3, [r7, #8]

  slice->TC = tc;
 80280b8:	687b      	ldr	r3, [r7, #4]
 80280ba:	68ba      	ldr	r2, [r7, #8]
 80280bc:	615a      	str	r2, [r3, #20]
}
 80280be:	bf00      	nop
 80280c0:	3714      	adds	r7, #20
 80280c2:	46bd      	mov	sp, r7
 80280c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80280c8:	4770      	bx	lr

080280ca <XMC_CCU8_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
 80280ca:	b480      	push	{r7}
 80280cc:	b089      	sub	sp, #36	; 0x24
 80280ce:	af00      	add	r7, sp, #0
 80280d0:	60f8      	str	r0, [r7, #12]
 80280d2:	460b      	mov	r3, r1
 80280d4:	607a      	str	r2, [r7, #4]
 80280d6:	72fb      	strb	r3, [r7, #11]
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 80280d8:	7afb      	ldrb	r3, [r7, #11]
 80280da:	3b01      	subs	r3, #1
 80280dc:	77fb      	strb	r3, [r7, #31]
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 80280de:	68fb      	ldr	r3, [r7, #12]
 80280e0:	681b      	ldr	r3, [r3, #0]
 80280e2:	61bb      	str	r3, [r7, #24]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 80280e4:	7ffb      	ldrb	r3, [r7, #31]
 80280e6:	005b      	lsls	r3, r3, #1
 80280e8:	b2db      	uxtb	r3, r3
 80280ea:	3310      	adds	r3, #16
 80280ec:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 80280ee:	7dfb      	ldrb	r3, [r7, #23]
 80280f0:	2203      	movs	r2, #3
 80280f2:	fa02 f303 	lsl.w	r3, r2, r3
 80280f6:	43db      	mvns	r3, r3
 80280f8:	69ba      	ldr	r2, [r7, #24]
 80280fa:	4013      	ands	r3, r2
 80280fc:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->edge) << pos;
 80280fe:	687b      	ldr	r3, [r7, #4]
 8028100:	785b      	ldrb	r3, [r3, #1]
 8028102:	461a      	mov	r2, r3
 8028104:	7dfb      	ldrb	r3, [r7, #23]
 8028106:	fa02 f303 	lsl.w	r3, r2, r3
 802810a:	69ba      	ldr	r2, [r7, #24]
 802810c:	4313      	orrs	r3, r2
 802810e:	61bb      	str	r3, [r7, #24]

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
 8028110:	7ffb      	ldrb	r3, [r7, #31]
 8028112:	3316      	adds	r3, #22
 8028114:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8028116:	7dfb      	ldrb	r3, [r7, #23]
 8028118:	2201      	movs	r2, #1
 802811a:	fa02 f303 	lsl.w	r3, r2, r3
 802811e:	43db      	mvns	r3, r3
 8028120:	69ba      	ldr	r2, [r7, #24]
 8028122:	4013      	ands	r3, r2
 8028124:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) (config->level)) << pos;
 8028126:	687b      	ldr	r3, [r7, #4]
 8028128:	789b      	ldrb	r3, [r3, #2]
 802812a:	461a      	mov	r2, r3
 802812c:	7dfb      	ldrb	r3, [r7, #23]
 802812e:	fa02 f303 	lsl.w	r3, r2, r3
 8028132:	69ba      	ldr	r2, [r7, #24]
 8028134:	4313      	orrs	r3, r2
 8028136:	61bb      	str	r3, [r7, #24]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8028138:	7ffb      	ldrb	r3, [r7, #31]
 802813a:	005b      	lsls	r3, r3, #1
 802813c:	b2db      	uxtb	r3, r3
 802813e:	3319      	adds	r3, #25
 8028140:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8028142:	7dfb      	ldrb	r3, [r7, #23]
 8028144:	2203      	movs	r2, #3
 8028146:	fa02 f303 	lsl.w	r3, r2, r3
 802814a:	43db      	mvns	r3, r3
 802814c:	69ba      	ldr	r2, [r7, #24]
 802814e:	4013      	ands	r3, r2
 8028150:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->duration) << pos;
 8028152:	687b      	ldr	r3, [r7, #4]
 8028154:	78db      	ldrb	r3, [r3, #3]
 8028156:	461a      	mov	r2, r3
 8028158:	7dfb      	ldrb	r3, [r7, #23]
 802815a:	fa02 f303 	lsl.w	r3, r2, r3
 802815e:	69ba      	ldr	r2, [r7, #24]
 8028160:	4313      	orrs	r3, r2
 8028162:	61bb      	str	r3, [r7, #24]

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 8028164:	7ffb      	ldrb	r3, [r7, #31]
 8028166:	009b      	lsls	r3, r3, #2
 8028168:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 802816a:	7dfb      	ldrb	r3, [r7, #23]
 802816c:	220f      	movs	r2, #15
 802816e:	fa02 f303 	lsl.w	r3, r2, r3
 8028172:	43db      	mvns	r3, r3
 8028174:	69ba      	ldr	r2, [r7, #24]
 8028176:	4013      	ands	r3, r2
 8028178:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->mapped_input) << pos;
 802817a:	687b      	ldr	r3, [r7, #4]
 802817c:	781b      	ldrb	r3, [r3, #0]
 802817e:	461a      	mov	r2, r3
 8028180:	7dfb      	ldrb	r3, [r7, #23]
 8028182:	fa02 f303 	lsl.w	r3, r2, r3
 8028186:	69ba      	ldr	r2, [r7, #24]
 8028188:	4313      	orrs	r3, r2
 802818a:	61bb      	str	r3, [r7, #24]

  slice->INS = ins;
 802818c:	68fb      	ldr	r3, [r7, #12]
 802818e:	69ba      	ldr	r2, [r7, #24]
 8028190:	601a      	str	r2, [r3, #0]
#endif
}
 8028192:	bf00      	nop
 8028194:	3724      	adds	r7, #36	; 0x24
 8028196:	46bd      	mov	sp, r7
 8028198:	f85d 7b04 	ldr.w	r7, [sp], #4
 802819c:	4770      	bx	lr

0802819e <XMC_CCU8_SLICE_SetTimerPeriodMatch>:
  slice->TC = tc;
}

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
 802819e:	b480      	push	{r7}
 80281a0:	b083      	sub	sp, #12
 80281a2:	af00      	add	r7, sp, #0
 80281a4:	6078      	str	r0, [r7, #4]
 80281a6:	460b      	mov	r3, r1
 80281a8:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 80281aa:	887a      	ldrh	r2, [r7, #2]
 80281ac:	687b      	ldr	r3, [r7, #4]
 80281ae:	635a      	str	r2, [r3, #52]	; 0x34
}
 80281b0:	bf00      	nop
 80281b2:	370c      	adds	r7, #12
 80281b4:	46bd      	mov	sp, r7
 80281b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281ba:	4770      	bx	lr

080281bc <XMC_CCU8_SLICE_SetTimerCompareMatch>:

/* Programs timer compare match value for channel 1 or 2 */
void XMC_CCU8_SLICE_SetTimerCompareMatch(XMC_CCU8_SLICE_t *const slice,
    const XMC_CCU8_SLICE_COMPARE_CHANNEL_t channel,
    const uint16_t compare_val)
{
 80281bc:	b480      	push	{r7}
 80281be:	b083      	sub	sp, #12
 80281c0:	af00      	add	r7, sp, #0
 80281c2:	6078      	str	r0, [r7, #4]
 80281c4:	460b      	mov	r3, r1
 80281c6:	70fb      	strb	r3, [r7, #3]
 80281c8:	4613      	mov	r3, r2
 80281ca:	803b      	strh	r3, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 80281cc:	78fb      	ldrb	r3, [r7, #3]
 80281ce:	2b00      	cmp	r3, #0
 80281d0:	d103      	bne.n	80281da <XMC_CCU8_SLICE_SetTimerCompareMatch+0x1e>
  {
    slice->CR1S = (uint32_t) compare_val;
 80281d2:	883a      	ldrh	r2, [r7, #0]
 80281d4:	687b      	ldr	r3, [r7, #4]
 80281d6:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
  }
}
 80281d8:	e002      	b.n	80281e0 <XMC_CCU8_SLICE_SetTimerCompareMatch+0x24>
    slice->CR2S = (uint32_t) compare_val;
 80281da:	883a      	ldrh	r2, [r7, #0]
 80281dc:	687b      	ldr	r3, [r7, #4]
 80281de:	645a      	str	r2, [r3, #68]	; 0x44
}
 80281e0:	bf00      	nop
 80281e2:	370c      	adds	r7, #12
 80281e4:	46bd      	mov	sp, r7
 80281e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281ea:	4770      	bx	lr

080281ec <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 80281ec:	b480      	push	{r7}
 80281ee:	b087      	sub	sp, #28
 80281f0:	af00      	add	r7, sp, #0
 80281f2:	6078      	str	r0, [r7, #4]
 80281f4:	460b      	mov	r3, r1
 80281f6:	70fb      	strb	r3, [r7, #3]
 80281f8:	4613      	mov	r3, r2
 80281fa:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 80281fc:	78fb      	ldrb	r3, [r7, #3]
 80281fe:	2b0b      	cmp	r3, #11
 8028200:	d83b      	bhi.n	802827a <XMC_CCU8_SLICE_SetInterruptNode+0x8e>
 8028202:	a201      	add	r2, pc, #4	; (adr r2, 8028208 <XMC_CCU8_SLICE_SetInterruptNode+0x1c>)
 8028204:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8028208:	08028239 	.word	0x08028239
 802820c:	08028239 	.word	0x08028239
 8028210:	08028243 	.word	0x08028243
 8028214:	08028243 	.word	0x08028243
 8028218:	0802824d 	.word	0x0802824d
 802821c:	0802824d 	.word	0x0802824d
 8028220:	0802827b 	.word	0x0802827b
 8028224:	0802827b 	.word	0x0802827b
 8028228:	08028257 	.word	0x08028257
 802822c:	08028263 	.word	0x08028263
 8028230:	0802826f 	.word	0x0802826f
 8028234:	0802826f 	.word	0x0802826f
  {
    case XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU8_CC8_SRS_POSR_Msk);
 8028238:	2303      	movs	r3, #3
 802823a:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_POSR_Pos;
 802823c:	2300      	movs	r3, #0
 802823e:	613b      	str	r3, [r7, #16]
      break;
 8028240:	e020      	b.n	8028284 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1:
    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1:
      mask = ((uint32_t) CCU8_CC8_SRS_CM1SR_Msk);
 8028242:	230c      	movs	r3, #12
 8028244:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_CM1SR_Pos;
 8028246:	2302      	movs	r3, #2
 8028248:	613b      	str	r3, [r7, #16]
      break;
 802824a:	e01b      	b.n	8028284 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2:
    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2:
      mask = ((uint32_t) CCU8_CC8_SRS_CM2SR_Msk);
 802824c:	2330      	movs	r3, #48	; 0x30
 802824e:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_CM2SR_Pos;
 8028250:	2304      	movs	r3, #4
 8028252:	613b      	str	r3, [r7, #16]
      break;
 8028254:	e016      	b.n	8028284 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU8_CC8_SRS_E0SR_Msk);
 8028256:	f44f 7340 	mov.w	r3, #768	; 0x300
 802825a:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E0SR_Pos;
 802825c:	2308      	movs	r3, #8
 802825e:	613b      	str	r3, [r7, #16]
      break;
 8028260:	e010      	b.n	8028284 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU8_CC8_SRS_E1SR_Msk);
 8028262:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8028266:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E1SR_Pos;
 8028268:	230a      	movs	r3, #10
 802826a:	613b      	str	r3, [r7, #16]
      break;
 802826c:	e00a      	b.n	8028284 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU8_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
 802826e:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8028272:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E2SR_Pos;
 8028274:	230c      	movs	r3, #12
 8028276:	613b      	str	r3, [r7, #16]
      break;
 8028278:	e004      	b.n	8028284 <XMC_CCU8_SLICE_SetInterruptNode+0x98>
	  
	default:
	  mask = 0;
 802827a:	2300      	movs	r3, #0
 802827c:	617b      	str	r3, [r7, #20]
	  pos = 0;
 802827e:	2300      	movs	r3, #0
 8028280:	613b      	str	r3, [r7, #16]
	  break;
 8028282:	bf00      	nop
  }

  if (mask != 0)
 8028284:	697b      	ldr	r3, [r7, #20]
 8028286:	2b00      	cmp	r3, #0
 8028288:	d013      	beq.n	80282b2 <XMC_CCU8_SLICE_SetInterruptNode+0xc6>
  {
    srs = slice->SRS;
 802828a:	687b      	ldr	r3, [r7, #4]
 802828c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8028290:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 8028292:	697b      	ldr	r3, [r7, #20]
 8028294:	43db      	mvns	r3, r3
 8028296:	68fa      	ldr	r2, [r7, #12]
 8028298:	4013      	ands	r3, r2
 802829a:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 802829c:	78ba      	ldrb	r2, [r7, #2]
 802829e:	693b      	ldr	r3, [r7, #16]
 80282a0:	fa02 f303 	lsl.w	r3, r2, r3
 80282a4:	68fa      	ldr	r2, [r7, #12]
 80282a6:	4313      	orrs	r3, r2
 80282a8:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 80282aa:	687b      	ldr	r3, [r7, #4]
 80282ac:	68fa      	ldr	r2, [r7, #12]
 80282ae:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 80282b2:	bf00      	nop
 80282b4:	371c      	adds	r7, #28
 80282b6:	46bd      	mov	sp, r7
 80282b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80282bc:	4770      	bx	lr
 80282be:	bf00      	nop

080282c0 <XMC_CCU8_SLICE_DeadTimeInit>:
}

/* Initializes Dead time configuration for the slice outputs */
void XMC_CCU8_SLICE_DeadTimeInit(XMC_CCU8_SLICE_t *const slice,
                                 const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const config)
{
 80282c0:	b480      	push	{r7}
 80282c2:	b083      	sub	sp, #12
 80282c4:	af00      	add	r7, sp, #0
 80282c6:	6078      	str	r0, [r7, #4]
 80282c8:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureDeadTime:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* Program dead time value for channel 1 */
  slice->DC1R = config->dc1r;
 80282ca:	683b      	ldr	r3, [r7, #0]
 80282cc:	685a      	ldr	r2, [r3, #4]
 80282ce:	687b      	ldr	r3, [r7, #4]
 80282d0:	651a      	str	r2, [r3, #80]	; 0x50
  /* Program dead time value for channel 2 */
  slice->DC2R = config->dc2r;
 80282d2:	683b      	ldr	r3, [r7, #0]
 80282d4:	689a      	ldr	r2, [r3, #8]
 80282d6:	687b      	ldr	r3, [r7, #4]
 80282d8:	655a      	str	r2, [r3, #84]	; 0x54
  /* Program dead time control configuration */
  slice->DTC = config->dtc;
 80282da:	683b      	ldr	r3, [r7, #0]
 80282dc:	681a      	ldr	r2, [r3, #0]
 80282de:	687b      	ldr	r3, [r7, #4]
 80282e0:	64da      	str	r2, [r3, #76]	; 0x4c
}
 80282e2:	bf00      	nop
 80282e4:	370c      	adds	r7, #12
 80282e6:	46bd      	mov	sp, r7
 80282e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80282ec:	4770      	bx	lr

080282ee <XMC_FCE_Init>:
/*
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
 80282ee:	b480      	push	{r7}
 80282f0:	b083      	sub	sp, #12
 80282f2:	af00      	add	r7, sp, #0
 80282f4:	6078      	str	r0, [r7, #4]
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 80282f6:	687b      	ldr	r3, [r7, #4]
 80282f8:	681b      	ldr	r3, [r3, #0]
 80282fa:	687a      	ldr	r2, [r7, #4]
 80282fc:	6852      	ldr	r2, [r2, #4]
 80282fe:	609a      	str	r2, [r3, #8]
  engine->kernel_ptr->CRC = engine->seedvalue;
 8028300:	687b      	ldr	r3, [r7, #4]
 8028302:	681b      	ldr	r3, [r3, #0]
 8028304:	687a      	ldr	r2, [r7, #4]
 8028306:	6892      	ldr	r2, [r2, #8]
 8028308:	619a      	str	r2, [r3, #24]

  return XMC_FCE_STATUS_OK;
 802830a:	2300      	movs	r3, #0
}
 802830c:	4618      	mov	r0, r3
 802830e:	370c      	adds	r7, #12
 8028310:	46bd      	mov	sp, r7
 8028312:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028316:	4770      	bx	lr

08028318 <XMC_FCE_Enable>:

}

/* Enable FCE */
void XMC_FCE_Enable(void)
{
 8028318:	b580      	push	{r7, lr}
 802831a:	af00      	add	r7, sp, #0
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_FCE);
#endif

  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_FCE);
 802831c:	4805      	ldr	r0, [pc, #20]	; (8028334 <XMC_FCE_Enable+0x1c>)
 802831e:	f7fe fae5 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>

  FCE->CLC &= (uint32_t)~FCE_CLC_DISR_Msk;
 8028322:	4b05      	ldr	r3, [pc, #20]	; (8028338 <XMC_FCE_Enable+0x20>)
 8028324:	681b      	ldr	r3, [r3, #0]
 8028326:	4a04      	ldr	r2, [pc, #16]	; (8028338 <XMC_FCE_Enable+0x20>)
 8028328:	f023 0301 	bic.w	r3, r3, #1
 802832c:	6013      	str	r3, [r2, #0]
}
 802832e:	bf00      	nop
 8028330:	bd80      	pop	{r7, pc}
 8028332:	bf00      	nop
 8028334:	20000040 	.word	0x20000040
 8028338:	50020000 	.word	0x50020000

0802833c <XMC_FCE_CalculateCRC32>:
/* Calculate and return the IEEE 802.3 Ethernet CRC32 checksum */
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
                                        uint32_t length,
                                        uint32_t *result)
{
 802833c:	b480      	push	{r7}
 802833e:	b087      	sub	sp, #28
 8028340:	af00      	add	r7, sp, #0
 8028342:	60f8      	str	r0, [r7, #12]
 8028344:	60b9      	str	r1, [r7, #8]
 8028346:	607a      	str	r2, [r7, #4]
 8028348:	603b      	str	r3, [r7, #0]
  XMC_FCE_STATUS_t status = XMC_FCE_STATUS_OK;
 802834a:	2300      	movs	r3, #0
 802834c:	75fb      	strb	r3, [r7, #23]
             (engine->kernel_ptr == XMC_FCE_CRC32_1)));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length field is empty", (length != 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length is not aligned", ((length & 0x3U) == 0));

  /* Check length is a multiple of 4 */
  if ((length == 0) || ((length & 0x3U) != 0U))
 802834e:	687b      	ldr	r3, [r7, #4]
 8028350:	2b00      	cmp	r3, #0
 8028352:	d004      	beq.n	802835e <XMC_FCE_CalculateCRC32+0x22>
 8028354:	687b      	ldr	r3, [r7, #4]
 8028356:	f003 0303 	and.w	r3, r3, #3
 802835a:	2b00      	cmp	r3, #0
 802835c:	d00d      	beq.n	802837a <XMC_FCE_CalculateCRC32+0x3e>
  {
    status = XMC_FCE_STATUS_ERROR;
 802835e:	2302      	movs	r3, #2
 8028360:	75fb      	strb	r3, [r7, #23]
 8028362:	e012      	b.n	802838a <XMC_FCE_CalculateCRC32+0x4e>
  }
  else
  {
    while (0UL != length)
    {
      engine->kernel_ptr->IR = *data;
 8028364:	68fb      	ldr	r3, [r7, #12]
 8028366:	681b      	ldr	r3, [r3, #0]
 8028368:	68ba      	ldr	r2, [r7, #8]
 802836a:	6812      	ldr	r2, [r2, #0]
 802836c:	601a      	str	r2, [r3, #0]
      data++;
 802836e:	68bb      	ldr	r3, [r7, #8]
 8028370:	3304      	adds	r3, #4
 8028372:	60bb      	str	r3, [r7, #8]
      length -= 4U;
 8028374:	687b      	ldr	r3, [r7, #4]
 8028376:	3b04      	subs	r3, #4
 8028378:	607b      	str	r3, [r7, #4]
    while (0UL != length)
 802837a:	687b      	ldr	r3, [r7, #4]
 802837c:	2b00      	cmp	r3, #0
 802837e:	d1f1      	bne.n	8028364 <XMC_FCE_CalculateCRC32+0x28>
    }

    *result = engine->kernel_ptr->CRC;
 8028380:	68fb      	ldr	r3, [r7, #12]
 8028382:	681b      	ldr	r3, [r3, #0]
 8028384:	699a      	ldr	r2, [r3, #24]
 8028386:	683b      	ldr	r3, [r7, #0]
 8028388:	601a      	str	r2, [r3, #0]
  }

  return status;
 802838a:	7dfb      	ldrb	r3, [r7, #23]
}
 802838c:	4618      	mov	r0, r3
 802838e:	371c      	adds	r7, #28
 8028390:	46bd      	mov	sp, r7
 8028392:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028396:	4770      	bx	lr

08028398 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8028398:	b480      	push	{r7}
 802839a:	b083      	sub	sp, #12
 802839c:	af00      	add	r7, sp, #0
 802839e:	6078      	str	r0, [r7, #4]
 80283a0:	460b      	mov	r3, r1
 80283a2:	70fb      	strb	r3, [r7, #3]
 80283a4:	4613      	mov	r3, r2
 80283a6:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 80283a8:	687b      	ldr	r3, [r7, #4]
 80283aa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80283ac:	78fb      	ldrb	r3, [r7, #3]
 80283ae:	005b      	lsls	r3, r3, #1
 80283b0:	2103      	movs	r1, #3
 80283b2:	fa01 f303 	lsl.w	r3, r1, r3
 80283b6:	43db      	mvns	r3, r3
 80283b8:	401a      	ands	r2, r3
 80283ba:	687b      	ldr	r3, [r7, #4]
 80283bc:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 80283be:	687b      	ldr	r3, [r7, #4]
 80283c0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80283c2:	78b9      	ldrb	r1, [r7, #2]
 80283c4:	78fb      	ldrb	r3, [r7, #3]
 80283c6:	005b      	lsls	r3, r3, #1
 80283c8:	fa01 f303 	lsl.w	r3, r1, r3
 80283cc:	431a      	orrs	r2, r3
 80283ce:	687b      	ldr	r3, [r7, #4]
 80283d0:	675a      	str	r2, [r3, #116]	; 0x74
}
 80283d2:	bf00      	nop
 80283d4:	370c      	adds	r7, #12
 80283d6:	46bd      	mov	sp, r7
 80283d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80283dc:	4770      	bx	lr

080283de <XMC_POSIF_Stop>:
{
 80283de:	b480      	push	{r7}
 80283e0:	b083      	sub	sp, #12
 80283e2:	af00      	add	r7, sp, #0
 80283e4:	6078      	str	r0, [r7, #4]
  peripheral->PRUNC = (uint32_t)(POSIF_PRUNC_CRB_Msk | POSIF_PRUNC_CSM_Msk);
 80283e6:	687b      	ldr	r3, [r7, #4]
 80283e8:	2203      	movs	r2, #3
 80283ea:	60da      	str	r2, [r3, #12]
}
 80283ec:	bf00      	nop
 80283ee:	370c      	adds	r7, #12
 80283f0:	46bd      	mov	sp, r7
 80283f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80283f6:	4770      	bx	lr

080283f8 <XMC_POSIF_Enable>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to enable the POSIF module */
void XMC_POSIF_Enable(XMC_POSIF_t *const peripheral)
{
 80283f8:	b580      	push	{r7, lr}
 80283fa:	b082      	sub	sp, #8
 80283fc:	af00      	add	r7, sp, #0
 80283fe:	6078      	str	r0, [r7, #4]
#if UC_FAMILY == XMC4
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8028400:	2010      	movs	r0, #16
 8028402:	f7fe fbaf 	bl	8026b64 <XMC_SCU_CLOCK_EnableClock>
#endif

  if (peripheral == POSIF0)
 8028406:	687b      	ldr	r3, [r7, #4]
 8028408:	4a09      	ldr	r2, [pc, #36]	; (8028430 <XMC_POSIF_Enable+0x38>)
 802840a:	4293      	cmp	r3, r2
 802840c:	d104      	bne.n	8028418 <XMC_POSIF_Enable+0x20>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_POSIF0);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_POSIF0);
 802840e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8028412:	f7fe fa6b 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_POSIF_Disable:Invalid module pointer", 0);
  }
}
 8028416:	e007      	b.n	8028428 <XMC_POSIF_Enable+0x30>
  else if (peripheral == POSIF1)
 8028418:	687b      	ldr	r3, [r7, #4]
 802841a:	4a06      	ldr	r2, [pc, #24]	; (8028434 <XMC_POSIF_Enable+0x3c>)
 802841c:	4293      	cmp	r3, r2
 802841e:	d103      	bne.n	8028428 <XMC_POSIF_Enable+0x30>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_POSIF1);
 8028420:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8028424:	f7fe fa62 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8028428:	bf00      	nop
 802842a:	3708      	adds	r7, #8
 802842c:	46bd      	mov	sp, r7
 802842e:	bd80      	pop	{r7, pc}
 8028430:	40028000 	.word	0x40028000
 8028434:	4002c000 	.word	0x4002c000

08028438 <XMC_POSIF_Init>:
  }
}

/* API to initialize POSIF global resources */
void XMC_POSIF_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_CONFIG_t *const config)
{
 8028438:	b580      	push	{r7, lr}
 802843a:	b082      	sub	sp, #8
 802843c:	af00      	add	r7, sp, #0
 802843e:	6078      	str	r0, [r7, #4]
 8028440:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_POSIF_Init:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_Init:NULL Pointer", (config != (XMC_POSIF_CONFIG_t *)NULL) );

  /* Enable the POSIF module */
  XMC_POSIF_Enable(peripheral);
 8028442:	6878      	ldr	r0, [r7, #4]
 8028444:	f7ff ffd8 	bl	80283f8 <XMC_POSIF_Enable>

  /* Stop POSIF */
  XMC_POSIF_Stop(peripheral);
 8028448:	6878      	ldr	r0, [r7, #4]
 802844a:	f7ff ffc8 	bl	80283de <XMC_POSIF_Stop>

  /* Program the operational mode, input selectors and debounce filter */
  peripheral->PCONF = config->pconf;
 802844e:	683b      	ldr	r3, [r7, #0]
 8028450:	681a      	ldr	r2, [r3, #0]
 8028452:	687b      	ldr	r3, [r7, #4]
 8028454:	601a      	str	r2, [r3, #0]
}
 8028456:	bf00      	nop
 8028458:	3708      	adds	r7, #8
 802845a:	46bd      	mov	sp, r7
 802845c:	bd80      	pop	{r7, pc}

0802845e <XMC_POSIF_HSC_Init>:

/* API to initialize hall sensor interface */
XMC_POSIF_STATUS_t XMC_POSIF_HSC_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_HSC_CONFIG_t *const config)
{
 802845e:	b480      	push	{r7}
 8028460:	b085      	sub	sp, #20
 8028462:	af00      	add	r7, sp, #0
 8028464:	6078      	str	r0, [r7, #4]
 8028466:	6039      	str	r1, [r7, #0]
  XMC_POSIF_STATUS_t retval;

  XMC_ASSERT("XMC_POSIF_HSC_Init:Invalid module pointer\n", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_HSC_Init:NULL Pointer\n", (config != (XMC_POSIF_HSC_CONFIG_t *)NULL) );

  if (XMC_POSIF_MODE_HALL_SENSOR == (XMC_POSIF_MODE_t)((peripheral->PCONF) & (uint32_t)POSIF_PCONF_FSEL_Msk) )
 8028468:	687b      	ldr	r3, [r7, #4]
 802846a:	681b      	ldr	r3, [r3, #0]
 802846c:	b2db      	uxtb	r3, r3
 802846e:	f003 0303 	and.w	r3, r3, #3
 8028472:	2b00      	cmp	r3, #0
 8028474:	d109      	bne.n	802848a <XMC_POSIF_HSC_Init+0x2c>
  {
    peripheral->PCONF |= config->hall_config;
 8028476:	687b      	ldr	r3, [r7, #4]
 8028478:	681a      	ldr	r2, [r3, #0]
 802847a:	683b      	ldr	r3, [r7, #0]
 802847c:	681b      	ldr	r3, [r3, #0]
 802847e:	431a      	orrs	r2, r3
 8028480:	687b      	ldr	r3, [r7, #4]
 8028482:	601a      	str	r2, [r3, #0]
    retval = XMC_POSIF_STATUS_OK;
 8028484:	2300      	movs	r3, #0
 8028486:	73fb      	strb	r3, [r7, #15]
 8028488:	e001      	b.n	802848e <XMC_POSIF_HSC_Init+0x30>
  }
  else
  {
    retval = XMC_POSIF_STATUS_ERROR;
 802848a:	2301      	movs	r3, #1
 802848c:	73fb      	strb	r3, [r7, #15]
  }
  return retval;
 802848e:	7bfb      	ldrb	r3, [r7, #15]
}
 8028490:	4618      	mov	r0, r3
 8028492:	3714      	adds	r7, #20
 8028494:	46bd      	mov	sp, r7
 8028496:	f85d 7b04 	ldr.w	r7, [sp], #4
 802849a:	4770      	bx	lr

0802849c <XMC_POSIF_MCM_Init>:

/* API to initialize multi-channel mode.
 * This is used in Hall mode, standalone multi-channel mode and quadrature with multi-channel mode
 */
XMC_POSIF_STATUS_t XMC_POSIF_MCM_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_MCM_CONFIG_t *const config)
{
 802849c:	b480      	push	{r7}
 802849e:	b085      	sub	sp, #20
 80284a0:	af00      	add	r7, sp, #0
 80284a2:	6078      	str	r0, [r7, #4]
 80284a4:	6039      	str	r1, [r7, #0]
  XMC_POSIF_STATUS_t retval;

  XMC_ASSERT("XMC_POSIF_MCM_Init:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_MCM_Init:NULL Pointer", (config != (XMC_POSIF_MCM_CONFIG_t *)NULL) );

  if ((XMC_POSIF_MODE_t)((peripheral->PCONF) & (uint32_t)POSIF_PCONF_FSEL_Msk) != XMC_POSIF_MODE_QD)
 80284a6:	687b      	ldr	r3, [r7, #4]
 80284a8:	681b      	ldr	r3, [r3, #0]
 80284aa:	b2db      	uxtb	r3, r3
 80284ac:	f003 0303 	and.w	r3, r3, #3
 80284b0:	2b01      	cmp	r3, #1
 80284b2:	d009      	beq.n	80284c8 <XMC_POSIF_MCM_Init+0x2c>
  {
    peripheral->PCONF |= config->mcm_config;
 80284b4:	687b      	ldr	r3, [r7, #4]
 80284b6:	681a      	ldr	r2, [r3, #0]
 80284b8:	683b      	ldr	r3, [r7, #0]
 80284ba:	681b      	ldr	r3, [r3, #0]
 80284bc:	431a      	orrs	r2, r3
 80284be:	687b      	ldr	r3, [r7, #4]
 80284c0:	601a      	str	r2, [r3, #0]
    retval = XMC_POSIF_STATUS_OK;
 80284c2:	2300      	movs	r3, #0
 80284c4:	73fb      	strb	r3, [r7, #15]
 80284c6:	e001      	b.n	80284cc <XMC_POSIF_MCM_Init+0x30>
  }
  else
  {
    retval = XMC_POSIF_STATUS_ERROR;
 80284c8:	2301      	movs	r3, #1
 80284ca:	73fb      	strb	r3, [r7, #15]
  }
  return retval;
 80284cc:	7bfb      	ldrb	r3, [r7, #15]
}
 80284ce:	4618      	mov	r0, r3
 80284d0:	3714      	adds	r7, #20
 80284d2:	46bd      	mov	sp, r7
 80284d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80284d8:	4770      	bx	lr

080284da <XMC_POSIF_SetInterruptNode>:
  peripheral->PCONF = ((peripheral->PCONF & ~(uint32_t)XMC_POSIF_PCONF_INSEL_Msk) | reg);
}

/* API to select an interrupt node */
void XMC_POSIF_SetInterruptNode(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event, const XMC_POSIF_SR_ID_t sr)
{
 80284da:	b480      	push	{r7}
 80284dc:	b085      	sub	sp, #20
 80284de:	af00      	add	r7, sp, #0
 80284e0:	6078      	str	r0, [r7, #4]
 80284e2:	460b      	mov	r3, r1
 80284e4:	70fb      	strb	r3, [r7, #3]
 80284e6:	4613      	mov	r3, r2
 80284e8:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Wrong IRQ event", (event <= XMC_POSIF_IRQ_EVENT_PCLK) );
  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Wrong SR ID", (sr <= XMC_POSIF_SR_ID_1) );

  reg = peripheral->PFLGE;
 80284ea:	687b      	ldr	r3, [r7, #4]
 80284ec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80284ee:	60fb      	str	r3, [r7, #12]
  reg &= ~((uint32_t)1 << ((uint32_t)event + (uint32_t)POSIF_PFLGE_CHESEL_Pos));
 80284f0:	78fb      	ldrb	r3, [r7, #3]
 80284f2:	3310      	adds	r3, #16
 80284f4:	2201      	movs	r2, #1
 80284f6:	fa02 f303 	lsl.w	r3, r2, r3
 80284fa:	43db      	mvns	r3, r3
 80284fc:	68fa      	ldr	r2, [r7, #12]
 80284fe:	4013      	ands	r3, r2
 8028500:	60fb      	str	r3, [r7, #12]
  reg |= (uint32_t)sr << ((uint32_t)event + (uint32_t)POSIF_PFLGE_CHESEL_Pos);
 8028502:	78ba      	ldrb	r2, [r7, #2]
 8028504:	78fb      	ldrb	r3, [r7, #3]
 8028506:	3310      	adds	r3, #16
 8028508:	fa02 f303 	lsl.w	r3, r2, r3
 802850c:	68fa      	ldr	r2, [r7, #12]
 802850e:	4313      	orrs	r3, r2
 8028510:	60fb      	str	r3, [r7, #12]
  peripheral->PFLGE = reg;
 8028512:	687b      	ldr	r3, [r7, #4]
 8028514:	68fa      	ldr	r2, [r7, #12]
 8028516:	675a      	str	r2, [r3, #116]	; 0x74
}
 8028518:	bf00      	nop
 802851a:	3714      	adds	r7, #20
 802851c:	46bd      	mov	sp, r7
 802851e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028522:	4770      	bx	lr

08028524 <XMC_VADC_GROUP_ExternalMuxControlInit>:
{
 8028524:	b480      	push	{r7}
 8028526:	b085      	sub	sp, #20
 8028528:	af00      	add	r7, sp, #0
 802852a:	6078      	str	r0, [r7, #4]
 802852c:	6039      	str	r1, [r7, #0]
  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 802852e:	783b      	ldrb	r3, [r7, #0]
 8028530:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8028534:	b2db      	uxtb	r3, r3
 8028536:	461a      	mov	r2, r3
                ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 8028538:	78bb      	ldrb	r3, [r7, #2]
 802853a:	f3c3 0304 	ubfx	r3, r3, #0, #5
 802853e:	b2db      	uxtb	r3, r3
 8028540:	041b      	lsls	r3, r3, #16
  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 8028542:	4313      	orrs	r3, r2
 8028544:	60fb      	str	r3, [r7, #12]
  group_ptr->EMUXCTR  = emux_config;
 8028546:	687b      	ldr	r3, [r7, #4]
 8028548:	68fa      	ldr	r2, [r7, #12]
 802854a:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 802854e:	78fb      	ldrb	r3, [r7, #3]
 8028550:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8028554:	b2db      	uxtb	r3, r3
 8028556:	071a      	lsls	r2, r3, #28
                ((uint32_t)emux_cfg.emux_mode  << (uint32_t)VADC_G_EMUXCTR_EMUXMODE_Pos) |
 8028558:	78fb      	ldrb	r3, [r7, #3]
 802855a:	f3c3 0381 	ubfx	r3, r3, #2, #2
 802855e:	b2db      	uxtb	r3, r3
 8028560:	069b      	lsls	r3, r3, #26
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 8028562:	431a      	orrs	r2, r3
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);
 8028564:	78fb      	ldrb	r3, [r7, #3]
 8028566:	f3c3 1340 	ubfx	r3, r3, #5, #1
 802856a:	b2db      	uxtb	r3, r3
 802856c:	075b      	lsls	r3, r3, #29
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 802856e:	4313      	orrs	r3, r2
 8028570:	60fb      	str	r3, [r7, #12]
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 8028572:	687b      	ldr	r3, [r7, #4]
 8028574:	f8d3 21f0 	ldr.w	r2, [r3, #496]	; 0x1f0
 8028578:	68fb      	ldr	r3, [r7, #12]
 802857a:	4313      	orrs	r3, r2
 802857c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8028580:	687b      	ldr	r3, [r7, #4]
 8028582:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
}
 8028586:	bf00      	nop
 8028588:	3714      	adds	r7, #20
 802858a:	46bd      	mov	sp, r7
 802858c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028590:	4770      	bx	lr

08028592 <XMC_VADC_GROUP_BackgroundEnableArbitrationSlot>:
{
 8028592:	b480      	push	{r7}
 8028594:	b083      	sub	sp, #12
 8028596:	af00      	add	r7, sp, #0
 8028598:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN2_Msk;
 802859a:	687b      	ldr	r3, [r7, #4]
 802859c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80285a0:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 80285a4:	687b      	ldr	r3, [r7, #4]
 80285a6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80285aa:	bf00      	nop
 80285ac:	370c      	adds	r7, #12
 80285ae:	46bd      	mov	sp, r7
 80285b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80285b4:	4770      	bx	lr

080285b6 <XMC_VADC_GROUP_BackgroundDisableArbitrationSlot>:
{
 80285b6:	b480      	push	{r7}
 80285b8:	b083      	sub	sp, #12
 80285ba:	af00      	add	r7, sp, #0
 80285bc:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN2_Msk);
 80285be:	687b      	ldr	r3, [r7, #4]
 80285c0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80285c4:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 80285c8:	687b      	ldr	r3, [r7, #4]
 80285ca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80285ce:	bf00      	nop
 80285d0:	370c      	adds	r7, #12
 80285d2:	46bd      	mov	sp, r7
 80285d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80285d8:	4770      	bx	lr

080285da <XMC_VADC_GROUP_QueueEnableArbitrationSlot>:
{
 80285da:	b480      	push	{r7}
 80285dc:	b083      	sub	sp, #12
 80285de:	af00      	add	r7, sp, #0
 80285e0:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 80285e2:	687b      	ldr	r3, [r7, #4]
 80285e4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80285e8:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 80285ec:	687b      	ldr	r3, [r7, #4]
 80285ee:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80285f2:	bf00      	nop
 80285f4:	370c      	adds	r7, #12
 80285f6:	46bd      	mov	sp, r7
 80285f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80285fc:	4770      	bx	lr

080285fe <XMC_VADC_GROUP_QueueDisableArbitrationSlot>:
{
 80285fe:	b480      	push	{r7}
 8028600:	b083      	sub	sp, #12
 8028602:	af00      	add	r7, sp, #0
 8028604:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 8028606:	687b      	ldr	r3, [r7, #4]
 8028608:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 802860c:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8028610:	687b      	ldr	r3, [r7, #4]
 8028612:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8028616:	bf00      	nop
 8028618:	370c      	adds	r7, #12
 802861a:	46bd      	mov	sp, r7
 802861c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028620:	4770      	bx	lr

08028622 <XMC_VADC_GLOBAL_EnableModule>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/*API to enable the VADC Module*/
void XMC_VADC_GLOBAL_EnableModule(void)
{
 8028622:	b580      	push	{r7, lr}
 8028624:	af00      	add	r7, sp, #0
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 8028626:	2001      	movs	r0, #1
 8028628:	f7fe f960 	bl	80268ec <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
}
 802862c:	bf00      	nop
 802862e:	bd80      	pop	{r7, pc}

08028630 <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 8028630:	b580      	push	{r7, lr}
 8028632:	b082      	sub	sp, #8
 8028634:	af00      	add	r7, sp, #0
 8028636:	6078      	str	r0, [r7, #4]
 8028638:	6039      	str	r1, [r7, #0]
#if (UC_SERIES == XMC14)
  XMC_SCU_CLOCK_SetAdcClockSrc(XMC_SCU_CLOCK_ADCCLKSRC_48MHZ);
#endif

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();
 802863a:	f7ff fff2 	bl	8028622 <XMC_VADC_GLOBAL_EnableModule>

  global_ptr->CLC = (uint32_t)(config->clc);
 802863e:	683b      	ldr	r3, [r7, #0]
 8028640:	695a      	ldr	r2, [r3, #20]
 8028642:	687b      	ldr	r3, [r7, #4]
 8028644:	601a      	str	r2, [r3, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 8028646:	683b      	ldr	r3, [r7, #0]
 8028648:	685b      	ldr	r3, [r3, #4]
 802864a:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 802864e:	687b      	ldr	r3, [r7, #4]
 8028650:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 8028654:	683b      	ldr	r3, [r7, #0]
 8028656:	689a      	ldr	r2, [r3, #8]
 8028658:	687b      	ldr	r3, [r7, #4]
 802865a:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 802865e:	683b      	ldr	r3, [r7, #0]
 8028660:	68da      	ldr	r2, [r3, #12]
 8028662:	687b      	ldr	r3, [r7, #4]
 8028664:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 8028668:	683b      	ldr	r3, [r7, #0]
 802866a:	691a      	ldr	r2, [r3, #16]
 802866c:	687b      	ldr	r3, [r7, #4]
 802866e:	f8c3 2280 	str.w	r2, [r3, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 8028672:	683b      	ldr	r3, [r7, #0]
 8028674:	681a      	ldr	r2, [r3, #0]
 8028676:	687b      	ldr	r3, [r7, #4]
 8028678:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

  /* From the Errata sheet of XMC1100 V1.7*/
  XMC_VADC_CONV_ENABLE_FOR_XMC11 = 1U;
#endif

}
 802867c:	bf00      	nop
 802867e:	3708      	adds	r7, #8
 8028680:	46bd      	mov	sp, r7
 8028682:	bd80      	pop	{r7, pc}

08028684 <XMC_VADC_GLOBAL_InputClassInit>:

/* API to Set the Global IClass registers*/
void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLASS_t config,
                                    const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8028684:	b480      	push	{r7}
 8028686:	b085      	sub	sp, #20
 8028688:	af00      	add	r7, sp, #0
 802868a:	60f8      	str	r0, [r7, #12]
 802868c:	60b9      	str	r1, [r7, #8]
 802868e:	603b      	str	r3, [r7, #0]
 8028690:	4613      	mov	r3, r2
 8028692:	71fb      	strb	r3, [r7, #7]
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 8028694:	79fb      	ldrb	r3, [r7, #7]
 8028696:	2b00      	cmp	r3, #0
 8028698:	d109      	bne.n	80286ae <XMC_VADC_GLOBAL_InputClassInit+0x2a>
  {
#endif
    XMC_UNUSED_ARG(conv_type);
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 802869a:	68ba      	ldr	r2, [r7, #8]
 802869c:	f240 731f 	movw	r3, #1823	; 0x71f
 80286a0:	4013      	ands	r3, r2
 80286a2:	68fa      	ldr	r2, [r7, #12]
 80286a4:	6839      	ldr	r1, [r7, #0]
 80286a6:	3128      	adds	r1, #40	; 0x28
 80286a8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
  }
#endif
}
 80286ac:	e007      	b.n	80286be <XMC_VADC_GLOBAL_InputClassInit+0x3a>
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 80286ae:	68ba      	ldr	r2, [r7, #8]
 80286b0:	4b06      	ldr	r3, [pc, #24]	; (80286cc <XMC_VADC_GLOBAL_InputClassInit+0x48>)
 80286b2:	4013      	ands	r3, r2
 80286b4:	68fa      	ldr	r2, [r7, #12]
 80286b6:	6839      	ldr	r1, [r7, #0]
 80286b8:	3128      	adds	r1, #40	; 0x28
 80286ba:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 80286be:	bf00      	nop
 80286c0:	3714      	adds	r7, #20
 80286c2:	46bd      	mov	sp, r7
 80286c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80286c8:	4770      	bx	lr
 80286ca:	bf00      	nop
 80286cc:	071f0000 	.word	0x071f0000

080286d0 <XMC_VADC_GLOBAL_StartupCalibration>:

/* API to enable startup calibration feature */
void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
{
 80286d0:	b480      	push	{r7}
 80286d2:	b085      	sub	sp, #20
 80286d4:	af00      	add	r7, sp, #0
 80286d6:	6078      	str	r0, [r7, #4]
  VADC_G_TypeDef *group_ptr;
#endif

  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 80286d8:	687b      	ldr	r3, [r7, #4]
 80286da:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80286de:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 80286e2:	687b      	ldr	r3, [r7, #4]
 80286e4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80286e8:	2300      	movs	r3, #0
 80286ea:	73fb      	strb	r3, [r7, #15]
 80286ec:	e017      	b.n	802871e <XMC_VADC_GLOBAL_StartupCalibration+0x4e>
  {
    group_ptr = g_xmc_vadc_group_array[i];
 80286ee:	7bfb      	ldrb	r3, [r7, #15]
 80286f0:	4a10      	ldr	r2, [pc, #64]	; (8028734 <XMC_VADC_GLOBAL_StartupCalibration+0x64>)
 80286f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80286f6:	60bb      	str	r3, [r7, #8]
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 80286f8:	68bb      	ldr	r3, [r7, #8]
 80286fa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80286fe:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8028702:	2b00      	cmp	r3, #0
 8028704:	d008      	beq.n	8028718 <XMC_VADC_GLOBAL_StartupCalibration+0x48>
      while ((group_ptr->ARBCFG & (uint32_t)VADC_G_ARBCFG_CALS_Msk) == 0)
      {
        __NOP();
      }
#endif
      while ((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 8028706:	e000      	b.n	802870a <XMC_VADC_GLOBAL_StartupCalibration+0x3a>
      {
        __NOP();
 8028708:	bf00      	nop
      while ((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 802870a:	68bb      	ldr	r3, [r7, #8]
 802870c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8028710:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8028714:	2b00      	cmp	r3, #0
 8028716:	d1f7      	bne.n	8028708 <XMC_VADC_GLOBAL_StartupCalibration+0x38>
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8028718:	7bfb      	ldrb	r3, [r7, #15]
 802871a:	3301      	adds	r3, #1
 802871c:	73fb      	strb	r3, [r7, #15]
 802871e:	7bfb      	ldrb	r3, [r7, #15]
 8028720:	2b03      	cmp	r3, #3
 8028722:	d9e4      	bls.n	80286ee <XMC_VADC_GLOBAL_StartupCalibration+0x1e>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    __NOP();
  }
#endif
}
 8028724:	bf00      	nop
 8028726:	bf00      	nop
 8028728:	3714      	adds	r7, #20
 802872a:	46bd      	mov	sp, r7
 802872c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028730:	4770      	bx	lr
 8028732:	bf00      	nop
 8028734:	0802b274 	.word	0x0802b274

08028738 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode>:
  global_ptr->GLOBEVNP |= (uint32_t)(node << VADC_GLOBEVNP_REV0NP_Pos);
}

/* API to bind request source event with a service request line */
void XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC_VADC_SR_t sr)
{
 8028738:	b480      	push	{r7}
 802873a:	b085      	sub	sp, #20
 802873c:	af00      	add	r7, sp, #0
 802873e:	6078      	str	r0, [r7, #4]
 8028740:	460b      	mov	r3, r1
 8028742:	70fb      	strb	r3, [r7, #3]
  uint32_t node;

  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:Wrong Module Pointer", (global_ptr == VADC))

  if (sr >= XMC_VADC_SR_SHARED_SR0)
 8028744:	78fb      	ldrb	r3, [r7, #3]
 8028746:	2b03      	cmp	r3, #3
 8028748:	d903      	bls.n	8028752 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode+0x1a>
  {
    node = (uint32_t)sr - (uint32_t)XMC_VADC_SR_SHARED_SR0;
 802874a:	78fb      	ldrb	r3, [r7, #3]
 802874c:	3b04      	subs	r3, #4
 802874e:	60fb      	str	r3, [r7, #12]
 8028750:	e001      	b.n	8028756 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode+0x1e>
  }
  else
  {
    node = (uint32_t)sr;
 8028752:	78fb      	ldrb	r3, [r7, #3]
 8028754:	60fb      	str	r3, [r7, #12]
  }

  global_ptr->GLOBEVNP &= ~((uint32_t)VADC_GLOBEVNP_SEV0NP_Msk);
 8028756:	687b      	ldr	r3, [r7, #4]
 8028758:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 802875c:	f023 020f 	bic.w	r2, r3, #15
 8028760:	687b      	ldr	r3, [r7, #4]
 8028762:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  global_ptr->GLOBEVNP |= (uint32_t) (node << VADC_GLOBEVNP_SEV0NP_Pos);
 8028766:	687b      	ldr	r3, [r7, #4]
 8028768:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 802876c:	68fb      	ldr	r3, [r7, #12]
 802876e:	431a      	orrs	r2, r3
 8028770:	687b      	ldr	r3, [r7, #4]
 8028772:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
}
 8028776:	bf00      	nop
 8028778:	3714      	adds	r7, #20
 802877a:	46bd      	mov	sp, r7
 802877c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028780:	4770      	bx	lr

08028782 <XMC_VADC_GROUP_Init>:

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8028782:	b580      	push	{r7, lr}
 8028784:	b082      	sub	sp, #8
 8028786:	af00      	add	r7, sp, #0
 8028788:	6078      	str	r0, [r7, #4]
 802878a:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_Init:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Program the input classes */
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
 802878c:	6839      	ldr	r1, [r7, #0]
 802878e:	2300      	movs	r3, #0
 8028790:	2200      	movs	r2, #0
 8028792:	6849      	ldr	r1, [r1, #4]
 8028794:	6878      	ldr	r0, [r7, #4]
 8028796:	f000 f828 	bl	80287ea <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
 802879a:	6839      	ldr	r1, [r7, #0]
 802879c:	2300      	movs	r3, #0
 802879e:	2201      	movs	r2, #1
 80287a0:	6849      	ldr	r1, [r1, #4]
 80287a2:	6878      	ldr	r0, [r7, #4]
 80287a4:	f000 f821 	bl	80287ea <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
 80287a8:	6839      	ldr	r1, [r7, #0]
 80287aa:	2301      	movs	r3, #1
 80287ac:	2200      	movs	r2, #0
 80287ae:	6889      	ldr	r1, [r1, #8]
 80287b0:	6878      	ldr	r0, [r7, #4]
 80287b2:	f000 f81a 	bl	80287ea <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);
 80287b6:	6839      	ldr	r1, [r7, #0]
 80287b8:	2301      	movs	r3, #1
 80287ba:	2201      	movs	r2, #1
 80287bc:	6889      	ldr	r1, [r1, #8]
 80287be:	6878      	ldr	r0, [r7, #4]
 80287c0:	f000 f813 	bl	80287ea <XMC_VADC_GROUP_InputClassInit>

  group_ptr->ARBCFG = config->g_arbcfg;
 80287c4:	683b      	ldr	r3, [r7, #0]
 80287c6:	691a      	ldr	r2, [r3, #16]
 80287c8:	687b      	ldr	r3, [r7, #4]
 80287ca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  group_ptr->BOUND = config->g_bound;
 80287ce:	683b      	ldr	r3, [r7, #0]
 80287d0:	68da      	ldr	r2, [r3, #12]
 80287d2:	687b      	ldr	r3, [r7, #4]
 80287d4:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

  /* External mux configuration */
  XMC_VADC_GROUP_ExternalMuxControlInit(group_ptr, config->emux_config);
 80287d8:	683b      	ldr	r3, [r7, #0]
 80287da:	6819      	ldr	r1, [r3, #0]
 80287dc:	6878      	ldr	r0, [r7, #4]
 80287de:	f7ff fea1 	bl	8028524 <XMC_VADC_GROUP_ExternalMuxControlInit>

}
 80287e2:	bf00      	nop
 80287e4:	3708      	adds	r7, #8
 80287e6:	46bd      	mov	sp, r7
 80287e8:	bd80      	pop	{r7, pc}

080287ea <XMC_VADC_GROUP_InputClassInit>:

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                   const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 80287ea:	b480      	push	{r7}
 80287ec:	b08d      	sub	sp, #52	; 0x34
 80287ee:	af00      	add	r7, sp, #0
 80287f0:	60f8      	str	r0, [r7, #12]
 80287f2:	60b9      	str	r1, [r7, #8]
 80287f4:	603b      	str	r3, [r7, #0]
 80287f6:	4613      	mov	r3, r2
 80287f8:	71fb      	strb	r3, [r7, #7]

  /*
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 80287fa:	79fb      	ldrb	r3, [r7, #7]
 80287fc:	2b00      	cmp	r3, #0
 80287fe:	d113      	bne.n	8028828 <XMC_VADC_GROUP_InputClassInit+0x3e>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
 8028800:	2308      	movs	r3, #8
 8028802:	62fb      	str	r3, [r7, #44]	; 0x2c
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
 8028804:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8028808:	627b      	str	r3, [r7, #36]	; 0x24
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
 802880a:	2300      	movs	r3, #0
 802880c:	62bb      	str	r3, [r7, #40]	; 0x28
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
 802880e:	231f      	movs	r3, #31
 8028810:	623b      	str	r3, [r7, #32]
    sample_time      = (uint32_t) config.sample_time_std_conv;
 8028812:	7a3b      	ldrb	r3, [r7, #8]
 8028814:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8028818:	b2db      	uxtb	r3, r3
 802881a:	61fb      	str	r3, [r7, #28]
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 802881c:	7a7b      	ldrb	r3, [r7, #9]
 802881e:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8028822:	b2db      	uxtb	r3, r3
 8028824:	76fb      	strb	r3, [r7, #27]
 8028826:	e013      	b.n	8028850 <XMC_VADC_GROUP_InputClassInit+0x66>
  }
  else
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
 8028828:	2318      	movs	r3, #24
 802882a:	62fb      	str	r3, [r7, #44]	; 0x2c
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
 802882c:	f04f 63e0 	mov.w	r3, #117440512	; 0x7000000
 8028830:	627b      	str	r3, [r7, #36]	; 0x24
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
 8028832:	2310      	movs	r3, #16
 8028834:	62bb      	str	r3, [r7, #40]	; 0x28
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
 8028836:	f44f 13f8 	mov.w	r3, #2031616	; 0x1f0000
 802883a:	623b      	str	r3, [r7, #32]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 802883c:	7abb      	ldrb	r3, [r7, #10]
 802883e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8028842:	b2db      	uxtb	r3, r3
 8028844:	61fb      	str	r3, [r7, #28]
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 8028846:	7afb      	ldrb	r3, [r7, #11]
 8028848:	f3c3 0302 	ubfx	r3, r3, #0, #3
 802884c:	b2db      	uxtb	r3, r3
 802884e:	76fb      	strb	r3, [r7, #27]
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8028850:	68fb      	ldr	r3, [r7, #12]
 8028852:	683a      	ldr	r2, [r7, #0]
 8028854:	3228      	adds	r2, #40	; 0x28
 8028856:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802885a:	617b      	str	r3, [r7, #20]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 802885c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802885e:	43db      	mvns	r3, r3
 8028860:	697a      	ldr	r2, [r7, #20]
 8028862:	4013      	ands	r3, r2
 8028864:	617b      	str	r3, [r7, #20]
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8028866:	7efa      	ldrb	r2, [r7, #27]
 8028868:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802886a:	fa02 f303 	lsl.w	r3, r2, r3
 802886e:	697a      	ldr	r2, [r7, #20]
 8028870:	4313      	orrs	r3, r2
 8028872:	617b      	str	r3, [r7, #20]
  conv_class &= ~(sample_time_mask);
 8028874:	6a3b      	ldr	r3, [r7, #32]
 8028876:	43db      	mvns	r3, r3
 8028878:	697a      	ldr	r2, [r7, #20]
 802887a:	4013      	ands	r3, r2
 802887c:	617b      	str	r3, [r7, #20]
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802887e:	69fa      	ldr	r2, [r7, #28]
 8028880:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8028882:	fa02 f303 	lsl.w	r3, r2, r3
 8028886:	697a      	ldr	r2, [r7, #20]
 8028888:	4313      	orrs	r3, r2
 802888a:	617b      	str	r3, [r7, #20]
  group_ptr->ICLASS[set_num] = conv_class;
 802888c:	68fb      	ldr	r3, [r7, #12]
 802888e:	683a      	ldr	r2, [r7, #0]
 8028890:	3228      	adds	r2, #40	; 0x28
 8028892:	6979      	ldr	r1, [r7, #20]
 8028894:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8028898:	bf00      	nop
 802889a:	3734      	adds	r7, #52	; 0x34
 802889c:	46bd      	mov	sp, r7
 802889e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80288a2:	4770      	bx	lr

080288a4 <XMC_VADC_GROUP_SetPowerMode>:

/* API which sets the power mode of analog converter of a VADC group */
void XMC_VADC_GROUP_SetPowerMode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_POWERMODE_t power_mode)
{
 80288a4:	b480      	push	{r7}
 80288a6:	b085      	sub	sp, #20
 80288a8:	af00      	add	r7, sp, #0
 80288aa:	6078      	str	r0, [r7, #4]
 80288ac:	460b      	mov	r3, r1
 80288ae:	70fb      	strb	r3, [r7, #3]
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 80288b0:	687b      	ldr	r3, [r7, #4]
 80288b2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80288b6:	60fb      	str	r3, [r7, #12]

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 80288b8:	68fb      	ldr	r3, [r7, #12]
 80288ba:	f023 0303 	bic.w	r3, r3, #3
 80288be:	60fb      	str	r3, [r7, #12]
  arbcfg |= (uint32_t)power_mode;
 80288c0:	78fb      	ldrb	r3, [r7, #3]
 80288c2:	68fa      	ldr	r2, [r7, #12]
 80288c4:	4313      	orrs	r3, r2
 80288c6:	60fb      	str	r3, [r7, #12]

  group_ptr->ARBCFG = arbcfg;
 80288c8:	687b      	ldr	r3, [r7, #4]
 80288ca:	68fa      	ldr	r2, [r7, #12]
 80288cc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 80288d0:	bf00      	nop
 80288d2:	3714      	adds	r7, #20
 80288d4:	46bd      	mov	sp, r7
 80288d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80288da:	4770      	bx	lr

080288dc <XMC_VADC_GROUP_SetBoundaries>:
  return ( (XMC_VADC_GROUP_STATE_t)arbcfg);
}

/* API to set boundaries for conversion results */
void XMC_VADC_GROUP_SetBoundaries(XMC_VADC_GROUP_t *const group_ptr, const uint32_t boundary0, const uint32_t boundary1)
{
 80288dc:	b480      	push	{r7}
 80288de:	b087      	sub	sp, #28
 80288e0:	af00      	add	r7, sp, #0
 80288e2:	60f8      	str	r0, [r7, #12]
 80288e4:	60b9      	str	r1, [r7, #8]
 80288e6:	607a      	str	r2, [r7, #4]
  uint32_t bound;

  XMC_ASSERT("XMC_VADC_GROUP_SetBoundaries:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Program the Boundary registers */
  bound  = group_ptr->BOUND;
 80288e8:	68fb      	ldr	r3, [r7, #12]
 80288ea:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80288ee:	617b      	str	r3, [r7, #20]
  bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY0_Msk);
 80288f0:	697b      	ldr	r3, [r7, #20]
 80288f2:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80288f6:	f023 030f 	bic.w	r3, r3, #15
 80288fa:	617b      	str	r3, [r7, #20]
  bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY1_Msk);
 80288fc:	697b      	ldr	r3, [r7, #20]
 80288fe:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8028902:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8028906:	617b      	str	r3, [r7, #20]
  bound |= (uint32_t) ((uint32_t) boundary0 << VADC_G_BOUND_BOUNDARY0_Pos);
 8028908:	697a      	ldr	r2, [r7, #20]
 802890a:	68bb      	ldr	r3, [r7, #8]
 802890c:	4313      	orrs	r3, r2
 802890e:	617b      	str	r3, [r7, #20]
  bound |= (uint32_t) ((uint32_t) boundary1 << VADC_G_BOUND_BOUNDARY1_Pos);
 8028910:	687b      	ldr	r3, [r7, #4]
 8028912:	041b      	lsls	r3, r3, #16
 8028914:	697a      	ldr	r2, [r7, #20]
 8028916:	4313      	orrs	r3, r2
 8028918:	617b      	str	r3, [r7, #20]
  group_ptr->BOUND = bound;
 802891a:	68fb      	ldr	r3, [r7, #12]
 802891c:	697a      	ldr	r2, [r7, #20]
 802891e:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
 8028922:	bf00      	nop
 8028924:	371c      	adds	r7, #28
 8028926:	46bd      	mov	sp, r7
 8028928:	f85d 7b04 	ldr.w	r7, [sp], #4
 802892c:	4770      	bx	lr
	...

08028930 <XMC_VADC_GLOBAL_BackgroundInit>:
}
#endif

/* API to initialize background scan request source hardware */
void XMC_VADC_GLOBAL_BackgroundInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_BACKGROUND_CONFIG_t *config)
{
 8028930:	b580      	push	{r7, lr}
 8028932:	b086      	sub	sp, #24
 8028934:	af00      	add	r7, sp, #0
 8028936:	6078      	str	r0, [r7, #4]
 8028938:	6039      	str	r1, [r7, #0]
#endif

  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundInit:Wrong Module Pointer", (global_ptr == VADC))

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 802893a:	2300      	movs	r3, #0
 802893c:	75fb      	strb	r3, [r7, #23]
 802893e:	e009      	b.n	8028954 <XMC_VADC_GLOBAL_BackgroundInit+0x24>
  {
    XMC_VADC_GROUP_BackgroundDisableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
 8028940:	7dfb      	ldrb	r3, [r7, #23]
 8028942:	4a3a      	ldr	r2, [pc, #232]	; (8028a2c <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8028944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8028948:	4618      	mov	r0, r3
 802894a:	f7ff fe34 	bl	80285b6 <XMC_VADC_GROUP_BackgroundDisableArbitrationSlot>
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 802894e:	7dfb      	ldrb	r3, [r7, #23]
 8028950:	3301      	adds	r3, #1
 8028952:	75fb      	strb	r3, [r7, #23]
 8028954:	7dfb      	ldrb	r3, [r7, #23]
 8028956:	2b03      	cmp	r3, #3
 8028958:	d9f2      	bls.n	8028940 <XMC_VADC_GLOBAL_BackgroundInit+0x10>
  }

  conv_start_mask = (uint32_t) 0;
 802895a:	2300      	movs	r3, #0
 802895c:	613b      	str	r3, [r7, #16]
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 802895e:	683b      	ldr	r3, [r7, #0]
 8028960:	781b      	ldrb	r3, [r3, #0]
 8028962:	f003 0303 	and.w	r3, r3, #3
 8028966:	b2db      	uxtb	r3, r3
 8028968:	2b00      	cmp	r3, #0
 802896a:	d002      	beq.n	8028972 <XMC_VADC_GLOBAL_BackgroundInit+0x42>
  {
    conv_start_mask = (uint32_t)VADC_G_ARBPR_CSM2_Msk;
 802896c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8028970:	613b      	str	r3, [r7, #16]
  }

  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8028972:	2300      	movs	r3, #0
 8028974:	75fb      	strb	r3, [r7, #23]
 8028976:	e021      	b.n	80289bc <XMC_VADC_GLOBAL_BackgroundInit+0x8c>
  {
    reg = g_xmc_vadc_group_array[i]->ARBPR;
 8028978:	7dfb      	ldrb	r3, [r7, #23]
 802897a:	4a2c      	ldr	r2, [pc, #176]	; (8028a2c <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 802897c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8028980:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8028984:	60fb      	str	r3, [r7, #12]

    reg &= ~(uint32_t)(VADC_G_ARBPR_PRIO2_Msk);
 8028986:	68fb      	ldr	r3, [r7, #12]
 8028988:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802898c:	60fb      	str	r3, [r7, #12]

    /* Program the priority of the request source */
    reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO2_Pos);
 802898e:	683b      	ldr	r3, [r7, #0]
 8028990:	781b      	ldrb	r3, [r3, #0]
 8028992:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8028996:	b2db      	uxtb	r3, r3
 8028998:	021b      	lsls	r3, r3, #8
 802899a:	68fa      	ldr	r2, [r7, #12]
 802899c:	4313      	orrs	r3, r2
 802899e:	60fb      	str	r3, [r7, #12]

    /* Program the start mode */
    reg |= conv_start_mask;
 80289a0:	68fa      	ldr	r2, [r7, #12]
 80289a2:	693b      	ldr	r3, [r7, #16]
 80289a4:	4313      	orrs	r3, r2
 80289a6:	60fb      	str	r3, [r7, #12]

    g_xmc_vadc_group_array[i]->ARBPR = reg;
 80289a8:	7dfb      	ldrb	r3, [r7, #23]
 80289aa:	4a20      	ldr	r2, [pc, #128]	; (8028a2c <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 80289ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80289b0:	68fa      	ldr	r2, [r7, #12]
 80289b2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80289b6:	7dfb      	ldrb	r3, [r7, #23]
 80289b8:	3301      	adds	r3, #1
 80289ba:	75fb      	strb	r3, [r7, #23]
 80289bc:	7dfb      	ldrb	r3, [r7, #23]
 80289be:	2b03      	cmp	r3, #3
 80289c0:	d9da      	bls.n	8028978 <XMC_VADC_GLOBAL_BackgroundInit+0x48>

  }
#endif

  /* program BRSCTRL register */
  global_ptr->BRSCTRL = (uint32_t)(config->asctrl | (uint32_t)VADC_BRSCTRL_XTWC_Msk | (uint32_t)VADC_BRSCTRL_GTWC_Msk);
 80289c2:	683b      	ldr	r3, [r7, #0]
 80289c4:	685b      	ldr	r3, [r3, #4]
 80289c6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80289ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80289ce:	687a      	ldr	r2, [r7, #4]
 80289d0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

  /* program BRSMR register */
  global_ptr->BRSMR = (uint32_t)((config->asmr) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_BRSMR_ENGT_Pos));
 80289d4:	683b      	ldr	r3, [r7, #0]
 80289d6:	689b      	ldr	r3, [r3, #8]
 80289d8:	f043 0201 	orr.w	r2, r3, #1
 80289dc:	687b      	ldr	r3, [r7, #4]
 80289de:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 80289e2:	683b      	ldr	r3, [r7, #0]
 80289e4:	781b      	ldrb	r3, [r3, #0]
 80289e6:	f003 0303 	and.w	r3, r3, #3
 80289ea:	b2db      	uxtb	r3, r3
 80289ec:	2b02      	cmp	r3, #2
 80289ee:	d107      	bne.n	8028a00 <XMC_VADC_GLOBAL_BackgroundInit+0xd0>
  {
    global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_RPTDIS_Msk;
 80289f0:	687b      	ldr	r3, [r7, #4]
 80289f2:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 80289f6:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80289fa:	687b      	ldr	r3, [r7, #4]
 80289fc:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  }
#endif

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8028a00:	2300      	movs	r3, #0
 8028a02:	75fb      	strb	r3, [r7, #23]
 8028a04:	e009      	b.n	8028a1a <XMC_VADC_GLOBAL_BackgroundInit+0xea>
  {
    XMC_VADC_GROUP_BackgroundEnableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
 8028a06:	7dfb      	ldrb	r3, [r7, #23]
 8028a08:	4a08      	ldr	r2, [pc, #32]	; (8028a2c <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8028a0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8028a0e:	4618      	mov	r0, r3
 8028a10:	f7ff fdbf 	bl	8028592 <XMC_VADC_GROUP_BackgroundEnableArbitrationSlot>
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8028a14:	7dfb      	ldrb	r3, [r7, #23]
 8028a16:	3301      	adds	r3, #1
 8028a18:	75fb      	strb	r3, [r7, #23]
 8028a1a:	7dfb      	ldrb	r3, [r7, #23]
 8028a1c:	2b03      	cmp	r3, #3
 8028a1e:	d9f2      	bls.n	8028a06 <XMC_VADC_GLOBAL_BackgroundInit+0xd6>
  }
#endif

}
 8028a20:	bf00      	nop
 8028a22:	bf00      	nop
 8028a24:	3718      	adds	r7, #24
 8028a26:	46bd      	mov	sp, r7
 8028a28:	bd80      	pop	{r7, pc}
 8028a2a:	bf00      	nop
 8028a2c:	0802b274 	.word	0x0802b274

08028a30 <XMC_VADC_GROUP_QueueInit>:
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 8028a30:	b580      	push	{r7, lr}
 8028a32:	b084      	sub	sp, #16
 8028a34:	af00      	add	r7, sp, #0
 8028a36:	6078      	str	r0, [r7, #4]
 8028a38:	6039      	str	r1, [r7, #0]
  uint32_t          reg;

  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
 8028a3a:	6878      	ldr	r0, [r7, #4]
 8028a3c:	f7ff fddf 	bl	80285fe <XMC_VADC_GROUP_QueueDisableArbitrationSlot>

  reg = group_ptr->ARBPR;
 8028a40:	687b      	ldr	r3, [r7, #4]
 8028a42:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8028a46:	60fb      	str	r3, [r7, #12]

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 8028a48:	68fb      	ldr	r3, [r7, #12]
 8028a4a:	f023 0303 	bic.w	r3, r3, #3
 8028a4e:	60fb      	str	r3, [r7, #12]
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8028a50:	683b      	ldr	r3, [r7, #0]
 8028a52:	781b      	ldrb	r3, [r3, #0]
 8028a54:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8028a58:	b2db      	uxtb	r3, r3
 8028a5a:	461a      	mov	r2, r3
 8028a5c:	68fb      	ldr	r3, [r7, #12]
 8028a5e:	4313      	orrs	r3, r2
 8028a60:	60fb      	str	r3, [r7, #12]

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8028a62:	683b      	ldr	r3, [r7, #0]
 8028a64:	781b      	ldrb	r3, [r3, #0]
 8028a66:	f003 0303 	and.w	r3, r3, #3
 8028a6a:	b2db      	uxtb	r3, r3
 8028a6c:	2b00      	cmp	r3, #0
 8028a6e:	d003      	beq.n	8028a78 <XMC_VADC_GROUP_QueueInit+0x48>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 8028a70:	68fb      	ldr	r3, [r7, #12]
 8028a72:	f043 0308 	orr.w	r3, r3, #8
 8028a76:	60fb      	str	r3, [r7, #12]
  }

  group_ptr->ARBPR = reg;
 8028a78:	687b      	ldr	r3, [r7, #4]
 8028a7a:	68fa      	ldr	r2, [r7, #12]
 8028a7c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0) | (uint32_t)(VADC_G_QCTRL0_XTWC_Msk) |
 8028a80:	683b      	ldr	r3, [r7, #0]
 8028a82:	685b      	ldr	r3, [r3, #4]
 8028a84:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8028a88:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8028a8c:	687a      	ldr	r2, [r7, #4]
 8028a8e:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
                                 (uint32_t)(VADC_G_QCTRL0_TMWC_Msk) |
                                 (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8028a92:	683b      	ldr	r3, [r7, #0]
 8028a94:	689b      	ldr	r3, [r3, #8]
 8028a96:	f043 0201 	orr.w	r2, r3, #1
 8028a9a:	687b      	ldr	r3, [r7, #4]
 8028a9c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8028aa0:	683b      	ldr	r3, [r7, #0]
 8028aa2:	781b      	ldrb	r3, [r3, #0]
 8028aa4:	f003 0303 	and.w	r3, r3, #3
 8028aa8:	b2db      	uxtb	r3, r3
 8028aaa:	2b02      	cmp	r3, #2
 8028aac:	d107      	bne.n	8028abe <XMC_VADC_GROUP_QueueInit+0x8e>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8028aae:	687b      	ldr	r3, [r7, #4]
 8028ab0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8028ab4:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8028ab8:	687b      	ldr	r3, [r7, #4]
 8028aba:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);
 8028abe:	6878      	ldr	r0, [r7, #4]
 8028ac0:	f7ff fd8b 	bl	80285da <XMC_VADC_GROUP_QueueEnableArbitrationSlot>

}
 8028ac4:	bf00      	nop
 8028ac6:	3710      	adds	r7, #16
 8028ac8:	46bd      	mov	sp, r7
 8028aca:	bd80      	pop	{r7, pc}

08028acc <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8028acc:	b480      	push	{r7}
 8028ace:	b089      	sub	sp, #36	; 0x24
 8028ad0:	af00      	add	r7, sp, #0
 8028ad2:	60f8      	str	r0, [r7, #12]
 8028ad4:	60b9      	str	r1, [r7, #8]
 8028ad6:	607a      	str	r2, [r7, #4]


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))

  prio  = (uint32_t)config->channel_priority;
 8028ad8:	687b      	ldr	r3, [r7, #4]
 8028ada:	7a1b      	ldrb	r3, [r3, #8]
 8028adc:	61bb      	str	r3, [r7, #24]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8028ade:	68fb      	ldr	r3, [r7, #12]
 8028ae0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8028ae4:	617b      	str	r3, [r7, #20]
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 8028ae6:	2201      	movs	r2, #1
 8028ae8:	68bb      	ldr	r3, [r7, #8]
 8028aea:	fa02 f303 	lsl.w	r3, r2, r3
 8028aee:	43db      	mvns	r3, r3
 8028af0:	697a      	ldr	r2, [r7, #20]
 8028af2:	4013      	ands	r3, r2
 8028af4:	617b      	str	r3, [r7, #20]
  ch_assign |= (uint32_t)(prio << ch_num);
 8028af6:	69ba      	ldr	r2, [r7, #24]
 8028af8:	68bb      	ldr	r3, [r7, #8]
 8028afa:	fa02 f303 	lsl.w	r3, r2, r3
 8028afe:	697a      	ldr	r2, [r7, #20]
 8028b00:	4313      	orrs	r3, r2
 8028b02:	617b      	str	r3, [r7, #20]
  group_ptr->CHASS = ch_assign;
 8028b04:	68fb      	ldr	r3, [r7, #12]
 8028b06:	697a      	ldr	r2, [r7, #20]
 8028b08:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 8028b0c:	687b      	ldr	r3, [r7, #4]
 8028b0e:	f993 3009 	ldrsb.w	r3, [r3, #9]
 8028b12:	2b00      	cmp	r3, #0
 8028b14:	db2a      	blt.n	8028b6c <XMC_VADC_GROUP_ChannelInit+0xa0>
  {
    mask = (uint32_t)0;
 8028b16:	2300      	movs	r3, #0
 8028b18:	61fb      	str	r3, [r7, #28]
    if ((uint32_t)1 == ch_num)
 8028b1a:	68bb      	ldr	r3, [r7, #8]
 8028b1c:	2b01      	cmp	r3, #1
 8028b1e:	d10a      	bne.n	8028b36 <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
 8028b20:	2308      	movs	r3, #8
 8028b22:	61fb      	str	r3, [r7, #28]
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 8028b24:	68fb      	ldr	r3, [r7, #12]
 8028b26:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8028b2a:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 8028b2e:	68fb      	ldr	r3, [r7, #12]
 8028b30:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
 8028b34:	e00c      	b.n	8028b50 <XMC_VADC_GROUP_ChannelInit+0x84>
    }
    else if ((uint32_t)0 == ch_num)
 8028b36:	68bb      	ldr	r3, [r7, #8]
 8028b38:	2b00      	cmp	r3, #0
 8028b3a:	d109      	bne.n	8028b50 <XMC_VADC_GROUP_ChannelInit+0x84>
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
 8028b3c:	2300      	movs	r3, #0
 8028b3e:	61fb      	str	r3, [r7, #28]
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 8028b40:	68fb      	ldr	r3, [r7, #12]
 8028b42:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8028b46:	f023 021f 	bic.w	r2, r3, #31
 8028b4a:	68fb      	ldr	r3, [r7, #12]
 8028b4c:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 8028b50:	68fb      	ldr	r3, [r7, #12]
 8028b52:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8028b56:	687a      	ldr	r2, [r7, #4]
 8028b58:	f992 2009 	ldrsb.w	r2, [r2, #9]
 8028b5c:	4611      	mov	r1, r2
 8028b5e:	69fa      	ldr	r2, [r7, #28]
 8028b60:	fa01 f202 	lsl.w	r2, r1, r2
 8028b64:	431a      	orrs	r2, r3
 8028b66:	68fb      	ldr	r3, [r7, #12]
 8028b68:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 8028b6c:	68fb      	ldr	r3, [r7, #12]
 8028b6e:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 8028b72:	687b      	ldr	r3, [r7, #4]
 8028b74:	685b      	ldr	r3, [r3, #4]
 8028b76:	431a      	orrs	r2, r3
 8028b78:	68fb      	ldr	r3, [r7, #12]
 8028b7a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 8028b7e:	687b      	ldr	r3, [r7, #4]
 8028b80:	6819      	ldr	r1, [r3, #0]
 8028b82:	68fb      	ldr	r3, [r7, #12]
 8028b84:	68ba      	ldr	r2, [r7, #8]
 8028b86:	3280      	adds	r2, #128	; 0x80
 8028b88:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

}
 8028b8c:	bf00      	nop
 8028b8e:	3724      	adds	r7, #36	; 0x24
 8028b90:	46bd      	mov	sp, r7
 8028b92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028b96:	4770      	bx	lr

08028b98 <XMC_VADC_GROUP_ChannelSetEventInterruptNode>:

/* API to bind channel event with a service request (NVIC Node) */
void XMC_VADC_GROUP_ChannelSetEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t ch_num,
    const XMC_VADC_SR_t sr)
{
 8028b98:	b480      	push	{r7}
 8028b9a:	b087      	sub	sp, #28
 8028b9c:	af00      	add	r7, sp, #0
 8028b9e:	60f8      	str	r0, [r7, #12]
 8028ba0:	60b9      	str	r1, [r7, #8]
 8028ba2:	4613      	mov	r3, r2
 8028ba4:	71fb      	strb	r3, [r7, #7]
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Channel Number",
             ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  route_mask  = group_ptr->CEVNP0;
 8028ba6:	68fb      	ldr	r3, [r7, #12]
 8028ba8:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8028bac:	617b      	str	r3, [r7, #20]
  route_mask &= ~((uint32_t)15 << (ch_num * (uint32_t)4));
 8028bae:	68bb      	ldr	r3, [r7, #8]
 8028bb0:	009b      	lsls	r3, r3, #2
 8028bb2:	220f      	movs	r2, #15
 8028bb4:	fa02 f303 	lsl.w	r3, r2, r3
 8028bb8:	43db      	mvns	r3, r3
 8028bba:	697a      	ldr	r2, [r7, #20]
 8028bbc:	4013      	ands	r3, r2
 8028bbe:	617b      	str	r3, [r7, #20]
  route_mask |= (uint32_t)( (uint32_t)sr << (ch_num * (uint32_t)4));
 8028bc0:	79fa      	ldrb	r2, [r7, #7]
 8028bc2:	68bb      	ldr	r3, [r7, #8]
 8028bc4:	009b      	lsls	r3, r3, #2
 8028bc6:	fa02 f303 	lsl.w	r3, r2, r3
 8028bca:	697a      	ldr	r2, [r7, #20]
 8028bcc:	4313      	orrs	r3, r2
 8028bce:	617b      	str	r3, [r7, #20]
  group_ptr->CEVNP0 = route_mask;
 8028bd0:	68fb      	ldr	r3, [r7, #12]
 8028bd2:	697a      	ldr	r2, [r7, #20]
 8028bd4:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
}
 8028bd8:	bf00      	nop
 8028bda:	371c      	adds	r7, #28
 8028bdc:	46bd      	mov	sp, r7
 8028bde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028be2:	4770      	bx	lr

08028be4 <_init>:
  }
}

/* Init */
void _init(void)
{}
 8028be4:	b480      	push	{r7}
 8028be6:	af00      	add	r7, sp, #0
 8028be8:	bf00      	nop
 8028bea:	46bd      	mov	sp, r7
 8028bec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028bf0:	4770      	bx	lr
	...

08028bf4 <__NVIC_GetPriorityGrouping>:
{
 8028bf4:	b480      	push	{r7}
 8028bf6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8028bf8:	4b04      	ldr	r3, [pc, #16]	; (8028c0c <__NVIC_GetPriorityGrouping+0x18>)
 8028bfa:	68db      	ldr	r3, [r3, #12]
 8028bfc:	0a1b      	lsrs	r3, r3, #8
 8028bfe:	f003 0307 	and.w	r3, r3, #7
}
 8028c02:	4618      	mov	r0, r3
 8028c04:	46bd      	mov	sp, r7
 8028c06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028c0a:	4770      	bx	lr
 8028c0c:	e000ed00 	.word	0xe000ed00

08028c10 <__NVIC_SetPriority>:
{
 8028c10:	b480      	push	{r7}
 8028c12:	b083      	sub	sp, #12
 8028c14:	af00      	add	r7, sp, #0
 8028c16:	4603      	mov	r3, r0
 8028c18:	6039      	str	r1, [r7, #0]
 8028c1a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8028c1c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8028c20:	2b00      	cmp	r3, #0
 8028c22:	db0a      	blt.n	8028c3a <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028c24:	683b      	ldr	r3, [r7, #0]
 8028c26:	b2da      	uxtb	r2, r3
 8028c28:	490c      	ldr	r1, [pc, #48]	; (8028c5c <__NVIC_SetPriority+0x4c>)
 8028c2a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8028c2e:	0092      	lsls	r2, r2, #2
 8028c30:	b2d2      	uxtb	r2, r2
 8028c32:	440b      	add	r3, r1
 8028c34:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8028c38:	e00a      	b.n	8028c50 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028c3a:	683b      	ldr	r3, [r7, #0]
 8028c3c:	b2da      	uxtb	r2, r3
 8028c3e:	4908      	ldr	r1, [pc, #32]	; (8028c60 <__NVIC_SetPriority+0x50>)
 8028c40:	79fb      	ldrb	r3, [r7, #7]
 8028c42:	f003 030f 	and.w	r3, r3, #15
 8028c46:	3b04      	subs	r3, #4
 8028c48:	0092      	lsls	r2, r2, #2
 8028c4a:	b2d2      	uxtb	r2, r2
 8028c4c:	440b      	add	r3, r1
 8028c4e:	761a      	strb	r2, [r3, #24]
}
 8028c50:	bf00      	nop
 8028c52:	370c      	adds	r7, #12
 8028c54:	46bd      	mov	sp, r7
 8028c56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028c5a:	4770      	bx	lr
 8028c5c:	e000e100 	.word	0xe000e100
 8028c60:	e000ed00 	.word	0xe000ed00

08028c64 <NVIC_EncodePriority>:
{
 8028c64:	b480      	push	{r7}
 8028c66:	b089      	sub	sp, #36	; 0x24
 8028c68:	af00      	add	r7, sp, #0
 8028c6a:	60f8      	str	r0, [r7, #12]
 8028c6c:	60b9      	str	r1, [r7, #8]
 8028c6e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8028c70:	68fb      	ldr	r3, [r7, #12]
 8028c72:	f003 0307 	and.w	r3, r3, #7
 8028c76:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8028c78:	69fb      	ldr	r3, [r7, #28]
 8028c7a:	f1c3 0307 	rsb	r3, r3, #7
 8028c7e:	2b06      	cmp	r3, #6
 8028c80:	bf28      	it	cs
 8028c82:	2306      	movcs	r3, #6
 8028c84:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8028c86:	69fb      	ldr	r3, [r7, #28]
 8028c88:	3306      	adds	r3, #6
 8028c8a:	2b06      	cmp	r3, #6
 8028c8c:	d902      	bls.n	8028c94 <NVIC_EncodePriority+0x30>
 8028c8e:	69fb      	ldr	r3, [r7, #28]
 8028c90:	3b01      	subs	r3, #1
 8028c92:	e000      	b.n	8028c96 <NVIC_EncodePriority+0x32>
 8028c94:	2300      	movs	r3, #0
 8028c96:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028c98:	f04f 32ff 	mov.w	r2, #4294967295
 8028c9c:	69bb      	ldr	r3, [r7, #24]
 8028c9e:	fa02 f303 	lsl.w	r3, r2, r3
 8028ca2:	43da      	mvns	r2, r3
 8028ca4:	68bb      	ldr	r3, [r7, #8]
 8028ca6:	401a      	ands	r2, r3
 8028ca8:	697b      	ldr	r3, [r7, #20]
 8028caa:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8028cac:	f04f 31ff 	mov.w	r1, #4294967295
 8028cb0:	697b      	ldr	r3, [r7, #20]
 8028cb2:	fa01 f303 	lsl.w	r3, r1, r3
 8028cb6:	43d9      	mvns	r1, r3
 8028cb8:	687b      	ldr	r3, [r7, #4]
 8028cba:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028cbc:	4313      	orrs	r3, r2
}
 8028cbe:	4618      	mov	r0, r3
 8028cc0:	3724      	adds	r7, #36	; 0x24
 8028cc2:	46bd      	mov	sp, r7
 8028cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028cc8:	4770      	bx	lr
	...

08028ccc <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8028ccc:	b580      	push	{r7, lr}
 8028cce:	b082      	sub	sp, #8
 8028cd0:	af00      	add	r7, sp, #0
 8028cd2:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8028cd4:	687b      	ldr	r3, [r7, #4]
 8028cd6:	3b01      	subs	r3, #1
 8028cd8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8028cdc:	d301      	bcc.n	8028ce2 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8028cde:	2301      	movs	r3, #1
 8028ce0:	e00f      	b.n	8028d02 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8028ce2:	4a0a      	ldr	r2, [pc, #40]	; (8028d0c <SysTick_Config+0x40>)
 8028ce4:	687b      	ldr	r3, [r7, #4]
 8028ce6:	3b01      	subs	r3, #1
 8028ce8:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8028cea:	213f      	movs	r1, #63	; 0x3f
 8028cec:	f04f 30ff 	mov.w	r0, #4294967295
 8028cf0:	f7ff ff8e 	bl	8028c10 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8028cf4:	4b05      	ldr	r3, [pc, #20]	; (8028d0c <SysTick_Config+0x40>)
 8028cf6:	2200      	movs	r2, #0
 8028cf8:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8028cfa:	4b04      	ldr	r3, [pc, #16]	; (8028d0c <SysTick_Config+0x40>)
 8028cfc:	2207      	movs	r2, #7
 8028cfe:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8028d00:	2300      	movs	r3, #0
}
 8028d02:	4618      	mov	r0, r3
 8028d04:	3708      	adds	r7, #8
 8028d06:	46bd      	mov	sp, r7
 8028d08:	bd80      	pop	{r7, pc}
 8028d0a:	bf00      	nop
 8028d0c:	e000e010 	.word	0xe000e010

08028d10 <SYSTIMER_lInsertTimerList>:
**********************************************************************************************************************/
/*
 * This function is called to insert a timer into the timer list.
 */
static void SYSTIMER_lInsertTimerList(uint32_t tbl_index)
{
 8028d10:	b490      	push	{r4, r7}
 8028d12:	b086      	sub	sp, #24
 8028d14:	af00      	add	r7, sp, #0
 8028d16:	6078      	str	r0, [r7, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
 8028d18:	2300      	movs	r3, #0
 8028d1a:	73fb      	strb	r3, [r7, #15]
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 8028d1c:	496d      	ldr	r1, [pc, #436]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d1e:	687a      	ldr	r2, [r7, #4]
 8028d20:	4613      	mov	r3, r2
 8028d22:	00db      	lsls	r3, r3, #3
 8028d24:	4413      	add	r3, r2
 8028d26:	009b      	lsls	r3, r3, #2
 8028d28:	440b      	add	r3, r1
 8028d2a:	3318      	adds	r3, #24
 8028d2c:	681b      	ldr	r3, [r3, #0]
 8028d2e:	60bb      	str	r3, [r7, #8]
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
 8028d30:	4b69      	ldr	r3, [pc, #420]	; (8028ed8 <SYSTIMER_lInsertTimerList+0x1c8>)
 8028d32:	681b      	ldr	r3, [r3, #0]
 8028d34:	2b00      	cmp	r3, #0
 8028d36:	d109      	bne.n	8028d4c <SYSTIMER_lInsertTimerList+0x3c>
  {
    /* Set this as first Timer */
    g_timer_list = &g_timer_tbl[tbl_index];
 8028d38:	687a      	ldr	r2, [r7, #4]
 8028d3a:	4613      	mov	r3, r2
 8028d3c:	00db      	lsls	r3, r3, #3
 8028d3e:	4413      	add	r3, r2
 8028d40:	009b      	lsls	r3, r3, #2
 8028d42:	4a64      	ldr	r2, [pc, #400]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d44:	4413      	add	r3, r2
 8028d46:	4a64      	ldr	r2, [pc, #400]	; (8028ed8 <SYSTIMER_lInsertTimerList+0x1c8>)
 8028d48:	6013      	str	r3, [r2, #0]
      }
      /* Get the next item in timer list */
      object_ptr = object_ptr->next;
    }
  }
}
 8028d4a:	e0bd      	b.n	8028ec8 <SYSTIMER_lInsertTimerList+0x1b8>
    object_ptr = g_timer_list;
 8028d4c:	4b62      	ldr	r3, [pc, #392]	; (8028ed8 <SYSTIMER_lInsertTimerList+0x1c8>)
 8028d4e:	681b      	ldr	r3, [r3, #0]
 8028d50:	617b      	str	r3, [r7, #20]
    delta_ticks = timer_count;
 8028d52:	68bb      	ldr	r3, [r7, #8]
 8028d54:	613b      	str	r3, [r7, #16]
    while ((NULL != object_ptr) && (false == found_flag))
 8028d56:	e0ad      	b.n	8028eb4 <SYSTIMER_lInsertTimerList+0x1a4>
      delta_ticks -= (int32_t)object_ptr->count;
 8028d58:	697b      	ldr	r3, [r7, #20]
 8028d5a:	699b      	ldr	r3, [r3, #24]
 8028d5c:	461a      	mov	r2, r3
 8028d5e:	693b      	ldr	r3, [r7, #16]
 8028d60:	1a9b      	subs	r3, r3, r2
 8028d62:	613b      	str	r3, [r7, #16]
      if (delta_ticks <= 0)
 8028d64:	693b      	ldr	r3, [r7, #16]
 8028d66:	2b00      	cmp	r3, #0
 8028d68:	dc7b      	bgt.n	8028e62 <SYSTIMER_lInsertTimerList+0x152>
        if (NULL != object_ptr->prev)
 8028d6a:	697b      	ldr	r3, [r7, #20]
 8028d6c:	685b      	ldr	r3, [r3, #4]
 8028d6e:	2b00      	cmp	r3, #0
 8028d70:	d027      	beq.n	8028dc2 <SYSTIMER_lInsertTimerList+0xb2>
          object_ptr->prev->next = &g_timer_tbl[tbl_index];
 8028d72:	697b      	ldr	r3, [r7, #20]
 8028d74:	6859      	ldr	r1, [r3, #4]
 8028d76:	687a      	ldr	r2, [r7, #4]
 8028d78:	4613      	mov	r3, r2
 8028d7a:	00db      	lsls	r3, r3, #3
 8028d7c:	4413      	add	r3, r2
 8028d7e:	009b      	lsls	r3, r3, #2
 8028d80:	4a54      	ldr	r2, [pc, #336]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d82:	4413      	add	r3, r2
 8028d84:	600b      	str	r3, [r1, #0]
          g_timer_tbl[tbl_index].prev = object_ptr->prev;
 8028d86:	697b      	ldr	r3, [r7, #20]
 8028d88:	6859      	ldr	r1, [r3, #4]
 8028d8a:	4852      	ldr	r0, [pc, #328]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d8c:	687a      	ldr	r2, [r7, #4]
 8028d8e:	4613      	mov	r3, r2
 8028d90:	00db      	lsls	r3, r3, #3
 8028d92:	4413      	add	r3, r2
 8028d94:	009b      	lsls	r3, r3, #2
 8028d96:	4403      	add	r3, r0
 8028d98:	3304      	adds	r3, #4
 8028d9a:	6019      	str	r1, [r3, #0]
          g_timer_tbl[tbl_index].next = object_ptr;
 8028d9c:	494d      	ldr	r1, [pc, #308]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d9e:	687a      	ldr	r2, [r7, #4]
 8028da0:	4613      	mov	r3, r2
 8028da2:	00db      	lsls	r3, r3, #3
 8028da4:	4413      	add	r3, r2
 8028da6:	009b      	lsls	r3, r3, #2
 8028da8:	440b      	add	r3, r1
 8028daa:	697a      	ldr	r2, [r7, #20]
 8028dac:	601a      	str	r2, [r3, #0]
          object_ptr->prev = &g_timer_tbl[tbl_index];
 8028dae:	687a      	ldr	r2, [r7, #4]
 8028db0:	4613      	mov	r3, r2
 8028db2:	00db      	lsls	r3, r3, #3
 8028db4:	4413      	add	r3, r2
 8028db6:	009b      	lsls	r3, r3, #2
 8028db8:	4a46      	ldr	r2, [pc, #280]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028dba:	441a      	add	r2, r3
 8028dbc:	697b      	ldr	r3, [r7, #20]
 8028dbe:	605a      	str	r2, [r3, #4]
 8028dc0:	e01c      	b.n	8028dfc <SYSTIMER_lInsertTimerList+0xec>
          g_timer_tbl[tbl_index].next = g_timer_list;
 8028dc2:	4b45      	ldr	r3, [pc, #276]	; (8028ed8 <SYSTIMER_lInsertTimerList+0x1c8>)
 8028dc4:	6819      	ldr	r1, [r3, #0]
 8028dc6:	4843      	ldr	r0, [pc, #268]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028dc8:	687a      	ldr	r2, [r7, #4]
 8028dca:	4613      	mov	r3, r2
 8028dcc:	00db      	lsls	r3, r3, #3
 8028dce:	4413      	add	r3, r2
 8028dd0:	009b      	lsls	r3, r3, #2
 8028dd2:	4403      	add	r3, r0
 8028dd4:	6019      	str	r1, [r3, #0]
          g_timer_list->prev = &g_timer_tbl[tbl_index];
 8028dd6:	4b40      	ldr	r3, [pc, #256]	; (8028ed8 <SYSTIMER_lInsertTimerList+0x1c8>)
 8028dd8:	6819      	ldr	r1, [r3, #0]
 8028dda:	687a      	ldr	r2, [r7, #4]
 8028ddc:	4613      	mov	r3, r2
 8028dde:	00db      	lsls	r3, r3, #3
 8028de0:	4413      	add	r3, r2
 8028de2:	009b      	lsls	r3, r3, #2
 8028de4:	4a3b      	ldr	r2, [pc, #236]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028de6:	4413      	add	r3, r2
 8028de8:	604b      	str	r3, [r1, #4]
          g_timer_list = &g_timer_tbl[tbl_index];
 8028dea:	687a      	ldr	r2, [r7, #4]
 8028dec:	4613      	mov	r3, r2
 8028dee:	00db      	lsls	r3, r3, #3
 8028df0:	4413      	add	r3, r2
 8028df2:	009b      	lsls	r3, r3, #2
 8028df4:	4a37      	ldr	r2, [pc, #220]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028df6:	4413      	add	r3, r2
 8028df8:	4a37      	ldr	r2, [pc, #220]	; (8028ed8 <SYSTIMER_lInsertTimerList+0x1c8>)
 8028dfa:	6013      	str	r3, [r2, #0]
        g_timer_tbl[tbl_index].count = g_timer_tbl[tbl_index].next->count + (uint32_t)delta_ticks;
 8028dfc:	4935      	ldr	r1, [pc, #212]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028dfe:	687a      	ldr	r2, [r7, #4]
 8028e00:	4613      	mov	r3, r2
 8028e02:	00db      	lsls	r3, r3, #3
 8028e04:	4413      	add	r3, r2
 8028e06:	009b      	lsls	r3, r3, #2
 8028e08:	440b      	add	r3, r1
 8028e0a:	681b      	ldr	r3, [r3, #0]
 8028e0c:	699a      	ldr	r2, [r3, #24]
 8028e0e:	693b      	ldr	r3, [r7, #16]
 8028e10:	18d1      	adds	r1, r2, r3
 8028e12:	4830      	ldr	r0, [pc, #192]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e14:	687a      	ldr	r2, [r7, #4]
 8028e16:	4613      	mov	r3, r2
 8028e18:	00db      	lsls	r3, r3, #3
 8028e1a:	4413      	add	r3, r2
 8028e1c:	009b      	lsls	r3, r3, #2
 8028e1e:	4403      	add	r3, r0
 8028e20:	3318      	adds	r3, #24
 8028e22:	6019      	str	r1, [r3, #0]
        g_timer_tbl[tbl_index].next->count  -= g_timer_tbl[tbl_index].count;
 8028e24:	492b      	ldr	r1, [pc, #172]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e26:	687a      	ldr	r2, [r7, #4]
 8028e28:	4613      	mov	r3, r2
 8028e2a:	00db      	lsls	r3, r3, #3
 8028e2c:	4413      	add	r3, r2
 8028e2e:	009b      	lsls	r3, r3, #2
 8028e30:	440b      	add	r3, r1
 8028e32:	681b      	ldr	r3, [r3, #0]
 8028e34:	6998      	ldr	r0, [r3, #24]
 8028e36:	4927      	ldr	r1, [pc, #156]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e38:	687a      	ldr	r2, [r7, #4]
 8028e3a:	4613      	mov	r3, r2
 8028e3c:	00db      	lsls	r3, r3, #3
 8028e3e:	4413      	add	r3, r2
 8028e40:	009b      	lsls	r3, r3, #2
 8028e42:	440b      	add	r3, r1
 8028e44:	3318      	adds	r3, #24
 8028e46:	6819      	ldr	r1, [r3, #0]
 8028e48:	4c22      	ldr	r4, [pc, #136]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e4a:	687a      	ldr	r2, [r7, #4]
 8028e4c:	4613      	mov	r3, r2
 8028e4e:	00db      	lsls	r3, r3, #3
 8028e50:	4413      	add	r3, r2
 8028e52:	009b      	lsls	r3, r3, #2
 8028e54:	4423      	add	r3, r4
 8028e56:	681b      	ldr	r3, [r3, #0]
 8028e58:	1a42      	subs	r2, r0, r1
 8028e5a:	619a      	str	r2, [r3, #24]
        found_flag = true;
 8028e5c:	2301      	movs	r3, #1
 8028e5e:	73fb      	strb	r3, [r7, #15]
 8028e60:	e025      	b.n	8028eae <SYSTIMER_lInsertTimerList+0x19e>
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
 8028e62:	693b      	ldr	r3, [r7, #16]
 8028e64:	2b00      	cmp	r3, #0
 8028e66:	dd22      	ble.n	8028eae <SYSTIMER_lInsertTimerList+0x19e>
 8028e68:	697b      	ldr	r3, [r7, #20]
 8028e6a:	681b      	ldr	r3, [r3, #0]
 8028e6c:	2b00      	cmp	r3, #0
 8028e6e:	d11e      	bne.n	8028eae <SYSTIMER_lInsertTimerList+0x19e>
          g_timer_tbl[tbl_index].prev = object_ptr;
 8028e70:	4918      	ldr	r1, [pc, #96]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e72:	687a      	ldr	r2, [r7, #4]
 8028e74:	4613      	mov	r3, r2
 8028e76:	00db      	lsls	r3, r3, #3
 8028e78:	4413      	add	r3, r2
 8028e7a:	009b      	lsls	r3, r3, #2
 8028e7c:	440b      	add	r3, r1
 8028e7e:	3304      	adds	r3, #4
 8028e80:	697a      	ldr	r2, [r7, #20]
 8028e82:	601a      	str	r2, [r3, #0]
          object_ptr->next = &g_timer_tbl[tbl_index];
 8028e84:	687a      	ldr	r2, [r7, #4]
 8028e86:	4613      	mov	r3, r2
 8028e88:	00db      	lsls	r3, r3, #3
 8028e8a:	4413      	add	r3, r2
 8028e8c:	009b      	lsls	r3, r3, #2
 8028e8e:	4a11      	ldr	r2, [pc, #68]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e90:	441a      	add	r2, r3
 8028e92:	697b      	ldr	r3, [r7, #20]
 8028e94:	601a      	str	r2, [r3, #0]
          g_timer_tbl[tbl_index].count = (uint32_t)delta_ticks;
 8028e96:	6939      	ldr	r1, [r7, #16]
 8028e98:	480e      	ldr	r0, [pc, #56]	; (8028ed4 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028e9a:	687a      	ldr	r2, [r7, #4]
 8028e9c:	4613      	mov	r3, r2
 8028e9e:	00db      	lsls	r3, r3, #3
 8028ea0:	4413      	add	r3, r2
 8028ea2:	009b      	lsls	r3, r3, #2
 8028ea4:	4403      	add	r3, r0
 8028ea6:	3318      	adds	r3, #24
 8028ea8:	6019      	str	r1, [r3, #0]
          found_flag = true;
 8028eaa:	2301      	movs	r3, #1
 8028eac:	73fb      	strb	r3, [r7, #15]
      object_ptr = object_ptr->next;
 8028eae:	697b      	ldr	r3, [r7, #20]
 8028eb0:	681b      	ldr	r3, [r3, #0]
 8028eb2:	617b      	str	r3, [r7, #20]
    while ((NULL != object_ptr) && (false == found_flag))
 8028eb4:	697b      	ldr	r3, [r7, #20]
 8028eb6:	2b00      	cmp	r3, #0
 8028eb8:	d006      	beq.n	8028ec8 <SYSTIMER_lInsertTimerList+0x1b8>
 8028eba:	7bfb      	ldrb	r3, [r7, #15]
 8028ebc:	f083 0301 	eor.w	r3, r3, #1
 8028ec0:	b2db      	uxtb	r3, r3
 8028ec2:	2b00      	cmp	r3, #0
 8028ec4:	f47f af48 	bne.w	8028d58 <SYSTIMER_lInsertTimerList+0x48>
}
 8028ec8:	bf00      	nop
 8028eca:	3718      	adds	r7, #24
 8028ecc:	46bd      	mov	sp, r7
 8028ece:	bc90      	pop	{r4, r7}
 8028ed0:	4770      	bx	lr
 8028ed2:	bf00      	nop
 8028ed4:	20000fd4 	.word	0x20000fd4
 8028ed8:	200010f4 	.word	0x200010f4

08028edc <SYSTIMER_lRemoveTimerList>:

/*
 * This function is called to remove a timer from the timer list. 
 */
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
 8028edc:	b480      	push	{r7}
 8028ede:	b085      	sub	sp, #20
 8028ee0:	af00      	add	r7, sp, #0
 8028ee2:	6078      	str	r0, [r7, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
 8028ee4:	687a      	ldr	r2, [r7, #4]
 8028ee6:	4613      	mov	r3, r2
 8028ee8:	00db      	lsls	r3, r3, #3
 8028eea:	4413      	add	r3, r2
 8028eec:	009b      	lsls	r3, r3, #2
 8028eee:	4a29      	ldr	r2, [pc, #164]	; (8028f94 <SYSTIMER_lRemoveTimerList+0xb8>)
 8028ef0:	4413      	add	r3, r2
 8028ef2:	60fb      	str	r3, [r7, #12]
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8028ef4:	68fb      	ldr	r3, [r7, #12]
 8028ef6:	685b      	ldr	r3, [r3, #4]
 8028ef8:	2b00      	cmp	r3, #0
 8028efa:	d107      	bne.n	8028f0c <SYSTIMER_lRemoveTimerList+0x30>
 8028efc:	68fb      	ldr	r3, [r7, #12]
 8028efe:	681b      	ldr	r3, [r3, #0]
 8028f00:	2b00      	cmp	r3, #0
 8028f02:	d103      	bne.n	8028f0c <SYSTIMER_lRemoveTimerList+0x30>
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 8028f04:	4b24      	ldr	r3, [pc, #144]	; (8028f98 <SYSTIMER_lRemoveTimerList+0xbc>)
 8028f06:	2200      	movs	r2, #0
 8028f08:	601a      	str	r2, [r3, #0]
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
    object_ptr->next = NULL;
    object_ptr->prev = NULL;
  }
}
 8028f0a:	e03d      	b.n	8028f88 <SYSTIMER_lRemoveTimerList+0xac>
  else if (NULL == object_ptr->prev)
 8028f0c:	68fb      	ldr	r3, [r7, #12]
 8028f0e:	685b      	ldr	r3, [r3, #4]
 8028f10:	2b00      	cmp	r3, #0
 8028f12:	d114      	bne.n	8028f3e <SYSTIMER_lRemoveTimerList+0x62>
    g_timer_list  = object_ptr->next;
 8028f14:	68fb      	ldr	r3, [r7, #12]
 8028f16:	681b      	ldr	r3, [r3, #0]
 8028f18:	4a1f      	ldr	r2, [pc, #124]	; (8028f98 <SYSTIMER_lRemoveTimerList+0xbc>)
 8028f1a:	6013      	str	r3, [r2, #0]
    g_timer_list->prev = NULL;
 8028f1c:	4b1e      	ldr	r3, [pc, #120]	; (8028f98 <SYSTIMER_lRemoveTimerList+0xbc>)
 8028f1e:	681b      	ldr	r3, [r3, #0]
 8028f20:	2200      	movs	r2, #0
 8028f22:	605a      	str	r2, [r3, #4]
    g_timer_list->count += object_ptr->count;
 8028f24:	4b1c      	ldr	r3, [pc, #112]	; (8028f98 <SYSTIMER_lRemoveTimerList+0xbc>)
 8028f26:	681b      	ldr	r3, [r3, #0]
 8028f28:	6999      	ldr	r1, [r3, #24]
 8028f2a:	68fb      	ldr	r3, [r7, #12]
 8028f2c:	699a      	ldr	r2, [r3, #24]
 8028f2e:	4b1a      	ldr	r3, [pc, #104]	; (8028f98 <SYSTIMER_lRemoveTimerList+0xbc>)
 8028f30:	681b      	ldr	r3, [r3, #0]
 8028f32:	440a      	add	r2, r1
 8028f34:	619a      	str	r2, [r3, #24]
    object_ptr->next    = NULL;
 8028f36:	68fb      	ldr	r3, [r7, #12]
 8028f38:	2200      	movs	r2, #0
 8028f3a:	601a      	str	r2, [r3, #0]
}
 8028f3c:	e024      	b.n	8028f88 <SYSTIMER_lRemoveTimerList+0xac>
  else if (NULL == object_ptr->next)
 8028f3e:	68fb      	ldr	r3, [r7, #12]
 8028f40:	681b      	ldr	r3, [r3, #0]
 8028f42:	2b00      	cmp	r3, #0
 8028f44:	d107      	bne.n	8028f56 <SYSTIMER_lRemoveTimerList+0x7a>
    object_ptr->prev->next = NULL;
 8028f46:	68fb      	ldr	r3, [r7, #12]
 8028f48:	685b      	ldr	r3, [r3, #4]
 8028f4a:	2200      	movs	r2, #0
 8028f4c:	601a      	str	r2, [r3, #0]
    object_ptr->prev = NULL;
 8028f4e:	68fb      	ldr	r3, [r7, #12]
 8028f50:	2200      	movs	r2, #0
 8028f52:	605a      	str	r2, [r3, #4]
}
 8028f54:	e018      	b.n	8028f88 <SYSTIMER_lRemoveTimerList+0xac>
    object_ptr->prev->next  =  object_ptr->next;
 8028f56:	68fb      	ldr	r3, [r7, #12]
 8028f58:	685b      	ldr	r3, [r3, #4]
 8028f5a:	68fa      	ldr	r2, [r7, #12]
 8028f5c:	6812      	ldr	r2, [r2, #0]
 8028f5e:	601a      	str	r2, [r3, #0]
    object_ptr->next->prev  =  object_ptr->prev;
 8028f60:	68fb      	ldr	r3, [r7, #12]
 8028f62:	681b      	ldr	r3, [r3, #0]
 8028f64:	68fa      	ldr	r2, [r7, #12]
 8028f66:	6852      	ldr	r2, [r2, #4]
 8028f68:	605a      	str	r2, [r3, #4]
    object_ptr->next->count += object_ptr->count;
 8028f6a:	68fb      	ldr	r3, [r7, #12]
 8028f6c:	681b      	ldr	r3, [r3, #0]
 8028f6e:	6999      	ldr	r1, [r3, #24]
 8028f70:	68fb      	ldr	r3, [r7, #12]
 8028f72:	699a      	ldr	r2, [r3, #24]
 8028f74:	68fb      	ldr	r3, [r7, #12]
 8028f76:	681b      	ldr	r3, [r3, #0]
 8028f78:	440a      	add	r2, r1
 8028f7a:	619a      	str	r2, [r3, #24]
    object_ptr->next = NULL;
 8028f7c:	68fb      	ldr	r3, [r7, #12]
 8028f7e:	2200      	movs	r2, #0
 8028f80:	601a      	str	r2, [r3, #0]
    object_ptr->prev = NULL;
 8028f82:	68fb      	ldr	r3, [r7, #12]
 8028f84:	2200      	movs	r2, #0
 8028f86:	605a      	str	r2, [r3, #4]
}
 8028f88:	bf00      	nop
 8028f8a:	3714      	adds	r7, #20
 8028f8c:	46bd      	mov	sp, r7
 8028f8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028f92:	4770      	bx	lr
 8028f94:	20000fd4 	.word	0x20000fd4
 8028f98:	200010f4 	.word	0x200010f4

08028f9c <SYSTIMER_lTimerHandler>:

/*
 * Handler function called from SysTick event handler.
 */
static void SYSTIMER_lTimerHandler(void)
{
 8028f9c:	b580      	push	{r7, lr}
 8028f9e:	b082      	sub	sp, #8
 8028fa0:	af00      	add	r7, sp, #0
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
 8028fa2:	4b30      	ldr	r3, [pc, #192]	; (8029064 <SYSTIMER_lTimerHandler+0xc8>)
 8028fa4:	681b      	ldr	r3, [r3, #0]
 8028fa6:	607b      	str	r3, [r7, #4]
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8028fa8:	e04e      	b.n	8029048 <SYSTIMER_lTimerHandler+0xac>
  {
    if (true == object_ptr->delete_swtmr)
 8028faa:	687b      	ldr	r3, [r7, #4]
 8028fac:	f893 3020 	ldrb.w	r3, [r3, #32]
 8028fb0:	2b00      	cmp	r3, #0
 8028fb2:	d013      	beq.n	8028fdc <SYSTIMER_lTimerHandler+0x40>
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8028fb4:	687b      	ldr	r3, [r7, #4]
 8028fb6:	695b      	ldr	r3, [r3, #20]
 8028fb8:	4618      	mov	r0, r3
 8028fba:	f7ff ff8f 	bl	8028edc <SYSTIMER_lRemoveTimerList>
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 8028fbe:	687b      	ldr	r3, [r7, #4]
 8028fc0:	2200      	movs	r2, #0
 8028fc2:	735a      	strb	r2, [r3, #13]
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 8028fc4:	687b      	ldr	r3, [r7, #4]
 8028fc6:	695b      	ldr	r3, [r3, #20]
 8028fc8:	2201      	movs	r2, #1
 8028fca:	fa02 f303 	lsl.w	r3, r2, r3
 8028fce:	43da      	mvns	r2, r3
 8028fd0:	4b25      	ldr	r3, [pc, #148]	; (8029068 <SYSTIMER_lTimerHandler+0xcc>)
 8028fd2:	681b      	ldr	r3, [r3, #0]
 8028fd4:	4013      	ands	r3, r2
 8028fd6:	4a24      	ldr	r2, [pc, #144]	; (8029068 <SYSTIMER_lTimerHandler+0xcc>)
 8028fd8:	6013      	str	r3, [r2, #0]
 8028fda:	e032      	b.n	8029042 <SYSTIMER_lTimerHandler+0xa6>
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
 8028fdc:	687b      	ldr	r3, [r7, #4]
 8028fde:	7b1b      	ldrb	r3, [r3, #12]
 8028fe0:	2b00      	cmp	r3, #0
 8028fe2:	d112      	bne.n	802900a <SYSTIMER_lTimerHandler+0x6e>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8028fe4:	687b      	ldr	r3, [r7, #4]
 8028fe6:	7b5b      	ldrb	r3, [r3, #13]
 8028fe8:	2b01      	cmp	r3, #1
 8028fea:	d12a      	bne.n	8029042 <SYSTIMER_lTimerHandler+0xa6>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8028fec:	687b      	ldr	r3, [r7, #4]
 8028fee:	695b      	ldr	r3, [r3, #20]
 8028ff0:	4618      	mov	r0, r3
 8028ff2:	f7ff ff73 	bl	8028edc <SYSTIMER_lRemoveTimerList>
        /* Set timer status as SYSTIMER_STATE_STOPPED */
        object_ptr->state = SYSTIMER_STATE_STOPPED;
 8028ff6:	687b      	ldr	r3, [r7, #4]
 8028ff8:	2202      	movs	r2, #2
 8028ffa:	735a      	strb	r2, [r3, #13]
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 8028ffc:	687b      	ldr	r3, [r7, #4]
 8028ffe:	689b      	ldr	r3, [r3, #8]
 8029000:	687a      	ldr	r2, [r7, #4]
 8029002:	6912      	ldr	r2, [r2, #16]
 8029004:	4610      	mov	r0, r2
 8029006:	4798      	blx	r3
 8029008:	e01b      	b.n	8029042 <SYSTIMER_lTimerHandler+0xa6>
      }
    }
    /* Check whether timer is periodic timer */
    else if (SYSTIMER_MODE_PERIODIC == object_ptr->mode)
 802900a:	687b      	ldr	r3, [r7, #4]
 802900c:	7b1b      	ldrb	r3, [r3, #12]
 802900e:	2b01      	cmp	r3, #1
 8029010:	d122      	bne.n	8029058 <SYSTIMER_lTimerHandler+0xbc>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8029012:	687b      	ldr	r3, [r7, #4]
 8029014:	7b5b      	ldrb	r3, [r3, #13]
 8029016:	2b01      	cmp	r3, #1
 8029018:	d113      	bne.n	8029042 <SYSTIMER_lTimerHandler+0xa6>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 802901a:	687b      	ldr	r3, [r7, #4]
 802901c:	695b      	ldr	r3, [r3, #20]
 802901e:	4618      	mov	r0, r3
 8029020:	f7ff ff5c 	bl	8028edc <SYSTIMER_lRemoveTimerList>
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8029024:	687b      	ldr	r3, [r7, #4]
 8029026:	69da      	ldr	r2, [r3, #28]
 8029028:	687b      	ldr	r3, [r7, #4]
 802902a:	619a      	str	r2, [r3, #24]
        /* Insert timer into timer list */
        SYSTIMER_lInsertTimerList((uint32_t)object_ptr->id);
 802902c:	687b      	ldr	r3, [r7, #4]
 802902e:	695b      	ldr	r3, [r3, #20]
 8029030:	4618      	mov	r0, r3
 8029032:	f7ff fe6d 	bl	8028d10 <SYSTIMER_lInsertTimerList>
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 8029036:	687b      	ldr	r3, [r7, #4]
 8029038:	689b      	ldr	r3, [r3, #8]
 802903a:	687a      	ldr	r2, [r7, #4]
 802903c:	6912      	ldr	r2, [r2, #16]
 802903e:	4610      	mov	r0, r2
 8029040:	4798      	blx	r3
    else
    {
      break;
    }
    /* Get first item of timer list */
    object_ptr = g_timer_list;
 8029042:	4b08      	ldr	r3, [pc, #32]	; (8029064 <SYSTIMER_lTimerHandler+0xc8>)
 8029044:	681b      	ldr	r3, [r3, #0]
 8029046:	607b      	str	r3, [r7, #4]
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8029048:	687b      	ldr	r3, [r7, #4]
 802904a:	2b00      	cmp	r3, #0
 802904c:	d005      	beq.n	802905a <SYSTIMER_lTimerHandler+0xbe>
 802904e:	687b      	ldr	r3, [r7, #4]
 8029050:	699b      	ldr	r3, [r3, #24]
 8029052:	2b00      	cmp	r3, #0
 8029054:	d0a9      	beq.n	8028faa <SYSTIMER_lTimerHandler+0xe>
  }
}
 8029056:	e000      	b.n	802905a <SYSTIMER_lTimerHandler+0xbe>
      break;
 8029058:	bf00      	nop
}
 802905a:	bf00      	nop
 802905c:	3708      	adds	r7, #8
 802905e:	46bd      	mov	sp, r7
 8029060:	bd80      	pop	{r7, pc}
 8029062:	bf00      	nop
 8029064:	200010f4 	.word	0x200010f4
 8029068:	200010f8 	.word	0x200010f8

0802906c <SysTick_Handler>:

/*
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
 802906c:	b580      	push	{r7, lr}
 802906e:	b082      	sub	sp, #8
 8029070:	af00      	add	r7, sp, #0
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 8029072:	4b0f      	ldr	r3, [pc, #60]	; (80290b0 <SysTick_Handler+0x44>)
 8029074:	681b      	ldr	r3, [r3, #0]
 8029076:	607b      	str	r3, [r7, #4]
  g_systick_count++;
 8029078:	4b0e      	ldr	r3, [pc, #56]	; (80290b4 <SysTick_Handler+0x48>)
 802907a:	681b      	ldr	r3, [r3, #0]
 802907c:	3301      	adds	r3, #1
 802907e:	4a0d      	ldr	r2, [pc, #52]	; (80290b4 <SysTick_Handler+0x48>)
 8029080:	6013      	str	r3, [r2, #0]

  if (NULL != object_ptr)
 8029082:	687b      	ldr	r3, [r7, #4]
 8029084:	2b00      	cmp	r3, #0
 8029086:	d00e      	beq.n	80290a6 <SysTick_Handler+0x3a>
  {
    if (object_ptr->count > 1UL)
 8029088:	687b      	ldr	r3, [r7, #4]
 802908a:	699b      	ldr	r3, [r3, #24]
 802908c:	2b01      	cmp	r3, #1
 802908e:	d905      	bls.n	802909c <SysTick_Handler+0x30>
    {
      object_ptr->count--;
 8029090:	687b      	ldr	r3, [r7, #4]
 8029092:	699b      	ldr	r3, [r3, #24]
 8029094:	1e5a      	subs	r2, r3, #1
 8029096:	687b      	ldr	r3, [r7, #4]
 8029098:	619a      	str	r2, [r3, #24]
    {
      object_ptr->count = 0U;
      SYSTIMER_lTimerHandler();
    }
  }
}
 802909a:	e004      	b.n	80290a6 <SysTick_Handler+0x3a>
      object_ptr->count = 0U;
 802909c:	687b      	ldr	r3, [r7, #4]
 802909e:	2200      	movs	r2, #0
 80290a0:	619a      	str	r2, [r3, #24]
      SYSTIMER_lTimerHandler();
 80290a2:	f7ff ff7b 	bl	8028f9c <SYSTIMER_lTimerHandler>
}
 80290a6:	bf00      	nop
 80290a8:	3708      	adds	r7, #8
 80290aa:	46bd      	mov	sp, r7
 80290ac:	bd80      	pop	{r7, pc}
 80290ae:	bf00      	nop
 80290b0:	200010f4 	.word	0x200010f4
 80290b4:	200010fc 	.word	0x200010fc

080290b8 <SYSTIMER_Init>:

/*
 * Initialization function which initializes the SYSTIMER APP, configures SysTick timer and SysTick exception.
 */
SYSTIMER_STATUS_t SYSTIMER_Init(SYSTIMER_t *handle)
{
 80290b8:	b580      	push	{r7, lr}
 80290ba:	b084      	sub	sp, #16
 80290bc:	af00      	add	r7, sp, #0
 80290be:	6078      	str	r0, [r7, #4]
  SYSTIMER_STATUS_t status = SYSTIMER_STATUS_SUCCESS;
 80290c0:	2300      	movs	r3, #0
 80290c2:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("SYSTIMER_Init: SYSTIMER APP handle pointer uninitialized", (handle != NULL));

  /* Check APP initialization status to ensure whether SYSTIMER_Init called or not, initialize SYSTIMER if
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
 80290c4:	687b      	ldr	r3, [r7, #4]
 80290c6:	781b      	ldrb	r3, [r3, #0]
 80290c8:	f083 0301 	eor.w	r3, r3, #1
 80290cc:	b2db      	uxtb	r3, r3
 80290ce:	2b00      	cmp	r3, #0
 80290d0:	d021      	beq.n	8029116 <SYSTIMER_Init+0x5e>
  {
    /* Initialize the header of the list */
    g_timer_list = NULL;
 80290d2:	4b13      	ldr	r3, [pc, #76]	; (8029120 <SYSTIMER_Init+0x68>)
 80290d4:	2200      	movs	r2, #0
 80290d6:	601a      	str	r2, [r3, #0]
    /* Initialize SysTick timer */
    status = (SYSTIMER_STATUS_t)SysTick_Config((uint32_t)(SYSTIMER_SYSTICK_CLOCK * SYSTIMER_TICK_PERIOD));
 80290d8:	f642 60e0 	movw	r0, #12000	; 0x2ee0
 80290dc:	f7ff fdf6 	bl	8028ccc <SysTick_Config>
 80290e0:	4603      	mov	r3, r0
 80290e2:	73fb      	strb	r3, [r7, #15]

    if (SYSTIMER_STATUS_FAILURE == status)
 80290e4:	7bfb      	ldrb	r3, [r7, #15]
 80290e6:	2b01      	cmp	r3, #1
 80290e8:	d015      	beq.n	8029116 <SYSTIMER_Init+0x5e>
    }
    else
    {
#if (UC_FAMILY == XMC4)
      /* setting of First SW Timer period is always and subpriority value for XMC4000 devices */
      NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(
 80290ea:	f7ff fd83 	bl	8028bf4 <__NVIC_GetPriorityGrouping>
 80290ee:	4603      	mov	r3, r0
 80290f0:	2200      	movs	r2, #0
 80290f2:	213f      	movs	r1, #63	; 0x3f
 80290f4:	4618      	mov	r0, r3
 80290f6:	f7ff fdb5 	bl	8028c64 <NVIC_EncodePriority>
 80290fa:	4603      	mov	r3, r0
 80290fc:	4619      	mov	r1, r3
 80290fe:	f04f 30ff 	mov.w	r0, #4294967295
 8029102:	f7ff fd85 	bl	8028c10 <__NVIC_SetPriority>
      NVIC_GetPriorityGrouping(), SYSTIMER_PRIORITY, SYSTIMER_SUBPRIORITY));
#elif (UC_FAMILY == XMC1)
      /* setting of priority value for XMC1000 devices */
      NVIC_SetPriority(SysTick_IRQn, SYSTIMER_PRIORITY);
#endif      
      g_timer_tracker = 0U;
 8029106:	4b07      	ldr	r3, [pc, #28]	; (8029124 <SYSTIMER_Init+0x6c>)
 8029108:	2200      	movs	r2, #0
 802910a:	601a      	str	r2, [r3, #0]
      /* Update the Initialization status of the SYSTIMER APP instance */
      handle->init_status = true;
 802910c:	687b      	ldr	r3, [r7, #4]
 802910e:	2201      	movs	r2, #1
 8029110:	701a      	strb	r2, [r3, #0]
      status = SYSTIMER_STATUS_SUCCESS;
 8029112:	2300      	movs	r3, #0
 8029114:	73fb      	strb	r3, [r7, #15]
    }
  }

  return (status);
 8029116:	7bfb      	ldrb	r3, [r7, #15]
}
 8029118:	4618      	mov	r0, r3
 802911a:	3710      	adds	r7, #16
 802911c:	46bd      	mov	sp, r7
 802911e:	bd80      	pop	{r7, pc}
 8029120:	200010f4 	.word	0x200010f4
 8029124:	200010f8 	.word	0x200010f8

08029128 <SYSTIMER_CreateTimer>:
  uint32_t period,
  SYSTIMER_MODE_t mode,
  SYSTIMER_CALLBACK_t callback,
  void  *args
)
{
 8029128:	b480      	push	{r7}
 802912a:	b089      	sub	sp, #36	; 0x24
 802912c:	af00      	add	r7, sp, #0
 802912e:	60f8      	str	r0, [r7, #12]
 8029130:	607a      	str	r2, [r7, #4]
 8029132:	603b      	str	r3, [r7, #0]
 8029134:	460b      	mov	r3, r1
 8029136:	72fb      	strb	r3, [r7, #11]
  uint32_t id = 0U;
 8029138:	2300      	movs	r3, #0
 802913a:	61fb      	str	r3, [r7, #28]
  uint32_t count = 0U;
 802913c:	2300      	movs	r3, #0
 802913e:	61bb      	str	r3, [r7, #24]
  uint32_t period_ratio = 0U;
 8029140:	2300      	movs	r3, #0
 8029142:	617b      	str	r3, [r7, #20]
            ((period >= SYSTIMER_TICK_PERIOD_US) && (period > 0U) && (period <= 0xFFFFFFFFU)));
  XMC_ASSERT("SYSTIMER_CreateTimer: Timer creation failure due to invalid timer mode",
            ((SYSTIMER_MODE_ONE_SHOT == mode) || (SYSTIMER_MODE_PERIODIC == mode)));
  XMC_ASSERT("SYSTIMER_CreateTimer: Can not create software without user callback", (NULL != callback));
  
  if (period < SYSTIMER_TICK_PERIOD_US)
 8029144:	68fb      	ldr	r3, [r7, #12]
 8029146:	2b63      	cmp	r3, #99	; 0x63
 8029148:	d802      	bhi.n	8029150 <SYSTIMER_CreateTimer+0x28>
  {
    id = 0U;
 802914a:	2300      	movs	r3, #0
 802914c:	61fb      	str	r3, [r7, #28]
 802914e:	e07c      	b.n	802924a <SYSTIMER_CreateTimer+0x122>
  }
  else
  {
    for (count = 0U; count < SYSTIMER_CFG_MAX_TMR; count++)
 8029150:	2300      	movs	r3, #0
 8029152:	61bb      	str	r3, [r7, #24]
 8029154:	e076      	b.n	8029244 <SYSTIMER_CreateTimer+0x11c>
    {
      /* Check for free timer ID */
      if (0U == (g_timer_tracker & (1U << count)))
 8029156:	2201      	movs	r2, #1
 8029158:	69bb      	ldr	r3, [r7, #24]
 802915a:	409a      	lsls	r2, r3
 802915c:	4b3e      	ldr	r3, [pc, #248]	; (8029258 <SYSTIMER_CreateTimer+0x130>)
 802915e:	681b      	ldr	r3, [r3, #0]
 8029160:	4013      	ands	r3, r2
 8029162:	2b00      	cmp	r3, #0
 8029164:	d16b      	bne.n	802923e <SYSTIMER_CreateTimer+0x116>
      {
        /* If yes, assign ID to this timer */
        g_timer_tracker |= (1U << count);
 8029166:	2201      	movs	r2, #1
 8029168:	69bb      	ldr	r3, [r7, #24]
 802916a:	409a      	lsls	r2, r3
 802916c:	4b3a      	ldr	r3, [pc, #232]	; (8029258 <SYSTIMER_CreateTimer+0x130>)
 802916e:	681b      	ldr	r3, [r3, #0]
 8029170:	4313      	orrs	r3, r2
 8029172:	4a39      	ldr	r2, [pc, #228]	; (8029258 <SYSTIMER_CreateTimer+0x130>)
 8029174:	6013      	str	r3, [r2, #0]
        /* Initialize the timer as per input values */
        g_timer_tbl[count].id     = count;
 8029176:	4939      	ldr	r1, [pc, #228]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 8029178:	69ba      	ldr	r2, [r7, #24]
 802917a:	4613      	mov	r3, r2
 802917c:	00db      	lsls	r3, r3, #3
 802917e:	4413      	add	r3, r2
 8029180:	009b      	lsls	r3, r3, #2
 8029182:	440b      	add	r3, r1
 8029184:	3314      	adds	r3, #20
 8029186:	69ba      	ldr	r2, [r7, #24]
 8029188:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].mode   = mode;
 802918a:	4934      	ldr	r1, [pc, #208]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 802918c:	69ba      	ldr	r2, [r7, #24]
 802918e:	4613      	mov	r3, r2
 8029190:	00db      	lsls	r3, r3, #3
 8029192:	4413      	add	r3, r2
 8029194:	009b      	lsls	r3, r3, #2
 8029196:	440b      	add	r3, r1
 8029198:	330c      	adds	r3, #12
 802919a:	7afa      	ldrb	r2, [r7, #11]
 802919c:	701a      	strb	r2, [r3, #0]
        g_timer_tbl[count].state  = SYSTIMER_STATE_STOPPED;
 802919e:	492f      	ldr	r1, [pc, #188]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 80291a0:	69ba      	ldr	r2, [r7, #24]
 80291a2:	4613      	mov	r3, r2
 80291a4:	00db      	lsls	r3, r3, #3
 80291a6:	4413      	add	r3, r2
 80291a8:	009b      	lsls	r3, r3, #2
 80291aa:	440b      	add	r3, r1
 80291ac:	330d      	adds	r3, #13
 80291ae:	2202      	movs	r2, #2
 80291b0:	701a      	strb	r2, [r3, #0]
        period_ratio = (uint32_t)(period / SYSTIMER_TICK_PERIOD_US);
 80291b2:	68fb      	ldr	r3, [r7, #12]
 80291b4:	4a2a      	ldr	r2, [pc, #168]	; (8029260 <SYSTIMER_CreateTimer+0x138>)
 80291b6:	fba2 2303 	umull	r2, r3, r2, r3
 80291ba:	095b      	lsrs	r3, r3, #5
 80291bc:	617b      	str	r3, [r7, #20]
        g_timer_tbl[count].count  = (period_ratio + HW_TIMER_ADDITIONAL_CNT);
 80291be:	697b      	ldr	r3, [r7, #20]
 80291c0:	1c59      	adds	r1, r3, #1
 80291c2:	4826      	ldr	r0, [pc, #152]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 80291c4:	69ba      	ldr	r2, [r7, #24]
 80291c6:	4613      	mov	r3, r2
 80291c8:	00db      	lsls	r3, r3, #3
 80291ca:	4413      	add	r3, r2
 80291cc:	009b      	lsls	r3, r3, #2
 80291ce:	4403      	add	r3, r0
 80291d0:	3318      	adds	r3, #24
 80291d2:	6019      	str	r1, [r3, #0]
        g_timer_tbl[count].reload  = period_ratio;
 80291d4:	4921      	ldr	r1, [pc, #132]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 80291d6:	69ba      	ldr	r2, [r7, #24]
 80291d8:	4613      	mov	r3, r2
 80291da:	00db      	lsls	r3, r3, #3
 80291dc:	4413      	add	r3, r2
 80291de:	009b      	lsls	r3, r3, #2
 80291e0:	440b      	add	r3, r1
 80291e2:	331c      	adds	r3, #28
 80291e4:	697a      	ldr	r2, [r7, #20]
 80291e6:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].callback = callback;
 80291e8:	491c      	ldr	r1, [pc, #112]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 80291ea:	69ba      	ldr	r2, [r7, #24]
 80291ec:	4613      	mov	r3, r2
 80291ee:	00db      	lsls	r3, r3, #3
 80291f0:	4413      	add	r3, r2
 80291f2:	009b      	lsls	r3, r3, #2
 80291f4:	440b      	add	r3, r1
 80291f6:	3308      	adds	r3, #8
 80291f8:	687a      	ldr	r2, [r7, #4]
 80291fa:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].args = args;
 80291fc:	4917      	ldr	r1, [pc, #92]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 80291fe:	69ba      	ldr	r2, [r7, #24]
 8029200:	4613      	mov	r3, r2
 8029202:	00db      	lsls	r3, r3, #3
 8029204:	4413      	add	r3, r2
 8029206:	009b      	lsls	r3, r3, #2
 8029208:	440b      	add	r3, r1
 802920a:	3310      	adds	r3, #16
 802920c:	683a      	ldr	r2, [r7, #0]
 802920e:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].prev   = NULL;
 8029210:	4912      	ldr	r1, [pc, #72]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 8029212:	69ba      	ldr	r2, [r7, #24]
 8029214:	4613      	mov	r3, r2
 8029216:	00db      	lsls	r3, r3, #3
 8029218:	4413      	add	r3, r2
 802921a:	009b      	lsls	r3, r3, #2
 802921c:	440b      	add	r3, r1
 802921e:	3304      	adds	r3, #4
 8029220:	2200      	movs	r2, #0
 8029222:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].next   = NULL;
 8029224:	490d      	ldr	r1, [pc, #52]	; (802925c <SYSTIMER_CreateTimer+0x134>)
 8029226:	69ba      	ldr	r2, [r7, #24]
 8029228:	4613      	mov	r3, r2
 802922a:	00db      	lsls	r3, r3, #3
 802922c:	4413      	add	r3, r2
 802922e:	009b      	lsls	r3, r3, #2
 8029230:	440b      	add	r3, r1
 8029232:	2200      	movs	r2, #0
 8029234:	601a      	str	r2, [r3, #0]
        id = count + 1U;
 8029236:	69bb      	ldr	r3, [r7, #24]
 8029238:	3301      	adds	r3, #1
 802923a:	61fb      	str	r3, [r7, #28]
        break;
 802923c:	e005      	b.n	802924a <SYSTIMER_CreateTimer+0x122>
    for (count = 0U; count < SYSTIMER_CFG_MAX_TMR; count++)
 802923e:	69bb      	ldr	r3, [r7, #24]
 8029240:	3301      	adds	r3, #1
 8029242:	61bb      	str	r3, [r7, #24]
 8029244:	69bb      	ldr	r3, [r7, #24]
 8029246:	2b07      	cmp	r3, #7
 8029248:	d985      	bls.n	8029156 <SYSTIMER_CreateTimer+0x2e>
      }
    }

  }

  return (id);
 802924a:	69fb      	ldr	r3, [r7, #28]
}  
 802924c:	4618      	mov	r0, r3
 802924e:	3724      	adds	r7, #36	; 0x24
 8029250:	46bd      	mov	sp, r7
 8029252:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029256:	4770      	bx	lr
 8029258:	200010f8 	.word	0x200010f8
 802925c:	20000fd4 	.word	0x20000fd4
 8029260:	51eb851f 	.word	0x51eb851f

08029264 <SYSTIMER_StartTimer>:

/*
 *  API to start the software timer.
 */
SYSTIMER_STATUS_t SYSTIMER_StartTimer(uint32_t id)
{
 8029264:	b580      	push	{r7, lr}
 8029266:	b084      	sub	sp, #16
 8029268:	af00      	add	r7, sp, #0
 802926a:	6078      	str	r0, [r7, #4]
  SYSTIMER_STATUS_t status;
  status = SYSTIMER_STATUS_FAILURE;
 802926c:	2301      	movs	r3, #1
 802926e:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("SYSTIMER_StartTimer: Failure in timer restart operation due to invalid timer ID",
            ((id <= SYSTIMER_CFG_MAX_TMR) && (id > 0U)));
  XMC_ASSERT("SYSTIMER_StartTimer: Error during start of software timer", (0U != (g_timer_tracker & (1U << (id - 1U)))));
  
  /* Check if timer is running */
  if (SYSTIMER_STATE_STOPPED == g_timer_tbl[id - 1U].state)
 8029270:	687b      	ldr	r3, [r7, #4]
 8029272:	1e5a      	subs	r2, r3, #1
 8029274:	491a      	ldr	r1, [pc, #104]	; (80292e0 <SYSTIMER_StartTimer+0x7c>)
 8029276:	4613      	mov	r3, r2
 8029278:	00db      	lsls	r3, r3, #3
 802927a:	4413      	add	r3, r2
 802927c:	009b      	lsls	r3, r3, #2
 802927e:	440b      	add	r3, r1
 8029280:	330d      	adds	r3, #13
 8029282:	781b      	ldrb	r3, [r3, #0]
 8029284:	2b02      	cmp	r3, #2
 8029286:	d126      	bne.n	80292d6 <SYSTIMER_StartTimer+0x72>
  {
    g_timer_tbl[id - 1U].count = (g_timer_tbl[id - 1U].reload + HW_TIMER_ADDITIONAL_CNT);
 8029288:	687b      	ldr	r3, [r7, #4]
 802928a:	1e5a      	subs	r2, r3, #1
 802928c:	4914      	ldr	r1, [pc, #80]	; (80292e0 <SYSTIMER_StartTimer+0x7c>)
 802928e:	4613      	mov	r3, r2
 8029290:	00db      	lsls	r3, r3, #3
 8029292:	4413      	add	r3, r2
 8029294:	009b      	lsls	r3, r3, #2
 8029296:	440b      	add	r3, r1
 8029298:	331c      	adds	r3, #28
 802929a:	681b      	ldr	r3, [r3, #0]
 802929c:	687a      	ldr	r2, [r7, #4]
 802929e:	3a01      	subs	r2, #1
 80292a0:	1c59      	adds	r1, r3, #1
 80292a2:	480f      	ldr	r0, [pc, #60]	; (80292e0 <SYSTIMER_StartTimer+0x7c>)
 80292a4:	4613      	mov	r3, r2
 80292a6:	00db      	lsls	r3, r3, #3
 80292a8:	4413      	add	r3, r2
 80292aa:	009b      	lsls	r3, r3, #2
 80292ac:	4403      	add	r3, r0
 80292ae:	3318      	adds	r3, #24
 80292b0:	6019      	str	r1, [r3, #0]
    /* set timer status as SYSTIMER_STATE_RUNNING */
    g_timer_tbl[id - 1U].state = SYSTIMER_STATE_RUNNING;
 80292b2:	687b      	ldr	r3, [r7, #4]
 80292b4:	1e5a      	subs	r2, r3, #1
 80292b6:	490a      	ldr	r1, [pc, #40]	; (80292e0 <SYSTIMER_StartTimer+0x7c>)
 80292b8:	4613      	mov	r3, r2
 80292ba:	00db      	lsls	r3, r3, #3
 80292bc:	4413      	add	r3, r2
 80292be:	009b      	lsls	r3, r3, #2
 80292c0:	440b      	add	r3, r1
 80292c2:	330d      	adds	r3, #13
 80292c4:	2201      	movs	r2, #1
 80292c6:	701a      	strb	r2, [r3, #0]
    /* Insert this timer into timer list */
    SYSTIMER_lInsertTimerList((id - 1U));
 80292c8:	687b      	ldr	r3, [r7, #4]
 80292ca:	3b01      	subs	r3, #1
 80292cc:	4618      	mov	r0, r3
 80292ce:	f7ff fd1f 	bl	8028d10 <SYSTIMER_lInsertTimerList>
    status = SYSTIMER_STATUS_SUCCESS;
 80292d2:	2300      	movs	r3, #0
 80292d4:	73fb      	strb	r3, [r7, #15]
  }

  return (status);
 80292d6:	7bfb      	ldrb	r3, [r7, #15]
}
 80292d8:	4618      	mov	r0, r3
 80292da:	3710      	adds	r7, #16
 80292dc:	46bd      	mov	sp, r7
 80292de:	bd80      	pop	{r7, pc}
 80292e0:	20000fd4 	.word	0x20000fd4

080292e4 <XMC_CCU4_EnableClock>:
{
 80292e4:	b480      	push	{r7}
 80292e6:	b083      	sub	sp, #12
 80292e8:	af00      	add	r7, sp, #0
 80292ea:	6078      	str	r0, [r7, #4]
 80292ec:	460b      	mov	r3, r1
 80292ee:	70fb      	strb	r3, [r7, #3]
  module->GIDLC = ((uint32_t) 1) << slice_number;
 80292f0:	78fb      	ldrb	r3, [r7, #3]
 80292f2:	2201      	movs	r2, #1
 80292f4:	409a      	lsls	r2, r3
 80292f6:	687b      	ldr	r3, [r7, #4]
 80292f8:	60da      	str	r2, [r3, #12]
}
 80292fa:	bf00      	nop
 80292fc:	370c      	adds	r7, #12
 80292fe:	46bd      	mov	sp, r7
 8029300:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029304:	4770      	bx	lr

08029306 <XMC_CCU4_SLICE_EnableTrap>:
{
 8029306:	b480      	push	{r7}
 8029308:	b083      	sub	sp, #12
 802930a:	af00      	add	r7, sp, #0
 802930c:	6078      	str	r0, [r7, #4]
  slice->TC |= (uint32_t) CCU4_CC4_TC_TRAPE_Msk;
 802930e:	687b      	ldr	r3, [r7, #4]
 8029310:	695b      	ldr	r3, [r3, #20]
 8029312:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 8029316:	687b      	ldr	r3, [r7, #4]
 8029318:	615a      	str	r2, [r3, #20]
}
 802931a:	bf00      	nop
 802931c:	370c      	adds	r7, #12
 802931e:	46bd      	mov	sp, r7
 8029320:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029324:	4770      	bx	lr

08029326 <XMC_CCU4_SLICE_StartTimer>:
{
 8029326:	b480      	push	{r7}
 8029328:	b083      	sub	sp, #12
 802932a:	af00      	add	r7, sp, #0
 802932c:	6078      	str	r0, [r7, #4]
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 802932e:	687b      	ldr	r3, [r7, #4]
 8029330:	2201      	movs	r2, #1
 8029332:	60da      	str	r2, [r3, #12]
}
 8029334:	bf00      	nop
 8029336:	370c      	adds	r7, #12
 8029338:	46bd      	mov	sp, r7
 802933a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802933e:	4770      	bx	lr

08029340 <XMC_CCU4_SLICE_StopTimer>:
{
 8029340:	b480      	push	{r7}
 8029342:	b083      	sub	sp, #12
 8029344:	af00      	add	r7, sp, #0
 8029346:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8029348:	687b      	ldr	r3, [r7, #4]
 802934a:	2201      	movs	r2, #1
 802934c:	611a      	str	r2, [r3, #16]
}
 802934e:	bf00      	nop
 8029350:	370c      	adds	r7, #12
 8029352:	46bd      	mov	sp, r7
 8029354:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029358:	4770      	bx	lr

0802935a <XMC_CCU4_SLICE_ClearTimer>:
{
 802935a:	b480      	push	{r7}
 802935c:	b083      	sub	sp, #12
 802935e:	af00      	add	r7, sp, #0
 8029360:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8029362:	687b      	ldr	r3, [r7, #4]
 8029364:	2202      	movs	r2, #2
 8029366:	611a      	str	r2, [r3, #16]
}
 8029368:	bf00      	nop
 802936a:	370c      	adds	r7, #12
 802936c:	46bd      	mov	sp, r7
 802936e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029372:	4770      	bx	lr

08029374 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
{
 8029374:	b480      	push	{r7}
 8029376:	b083      	sub	sp, #12
 8029378:	af00      	add	r7, sp, #0
 802937a:	6078      	str	r0, [r7, #4]
 802937c:	460b      	mov	r3, r1
 802937e:	807b      	strh	r3, [r7, #2]
  slice->PRS = (uint32_t) period_val;
 8029380:	887a      	ldrh	r2, [r7, #2]
 8029382:	687b      	ldr	r3, [r7, #4]
 8029384:	635a      	str	r2, [r3, #52]	; 0x34
}
 8029386:	bf00      	nop
 8029388:	370c      	adds	r7, #12
 802938a:	46bd      	mov	sp, r7
 802938c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029390:	4770      	bx	lr

08029392 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
{
 8029392:	b480      	push	{r7}
 8029394:	b083      	sub	sp, #12
 8029396:	af00      	add	r7, sp, #0
 8029398:	6078      	str	r0, [r7, #4]
 802939a:	460b      	mov	r3, r1
 802939c:	807b      	strh	r3, [r7, #2]
  slice->CRS = (uint32_t) compare_val;
 802939e:	887a      	ldrh	r2, [r7, #2]
 80293a0:	687b      	ldr	r3, [r7, #4]
 80293a2:	63da      	str	r2, [r3, #60]	; 0x3c
}
 80293a4:	bf00      	nop
 80293a6:	370c      	adds	r7, #12
 80293a8:	46bd      	mov	sp, r7
 80293aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80293ae:	4770      	bx	lr

080293b0 <XMC_CCU4_EnableShadowTransfer>:
{
 80293b0:	b480      	push	{r7}
 80293b2:	b083      	sub	sp, #12
 80293b4:	af00      	add	r7, sp, #0
 80293b6:	6078      	str	r0, [r7, #4]
 80293b8:	6039      	str	r1, [r7, #0]
  module->GCSS = (uint32_t)shadow_transfer_msk;
 80293ba:	687b      	ldr	r3, [r7, #4]
 80293bc:	683a      	ldr	r2, [r7, #0]
 80293be:	611a      	str	r2, [r3, #16]
}
 80293c0:	bf00      	nop
 80293c2:	370c      	adds	r7, #12
 80293c4:	46bd      	mov	sp, r7
 80293c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80293ca:	4770      	bx	lr

080293cc <XMC_CCU4_SLICE_EnableEvent>:
{
 80293cc:	b480      	push	{r7}
 80293ce:	b083      	sub	sp, #12
 80293d0:	af00      	add	r7, sp, #0
 80293d2:	6078      	str	r0, [r7, #4]
 80293d4:	460b      	mov	r3, r1
 80293d6:	70fb      	strb	r3, [r7, #3]
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 80293d8:	687b      	ldr	r3, [r7, #4]
 80293da:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 80293de:	78fb      	ldrb	r3, [r7, #3]
 80293e0:	2101      	movs	r1, #1
 80293e2:	fa01 f303 	lsl.w	r3, r1, r3
 80293e6:	431a      	orrs	r2, r3
 80293e8:	687b      	ldr	r3, [r7, #4]
 80293ea:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 80293ee:	bf00      	nop
 80293f0:	370c      	adds	r7, #12
 80293f2:	46bd      	mov	sp, r7
 80293f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80293f8:	4770      	bx	lr

080293fa <XMC_CCU4_SLICE_ClearEvent>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_EnableEvent()<BR> XMC_CCU4_SLICE_SetEvent()<BR> XMC_CCU4_SLICE_GetEvent().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 80293fa:	b480      	push	{r7}
 80293fc:	b083      	sub	sp, #12
 80293fe:	af00      	add	r7, sp, #0
 8029400:	6078      	str	r0, [r7, #4]
 8029402:	460b      	mov	r3, r1
 8029404:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR = ((uint32_t) 1) << ((uint32_t) event);
 8029406:	78fb      	ldrb	r3, [r7, #3]
 8029408:	2201      	movs	r2, #1
 802940a:	409a      	lsls	r2, r3
 802940c:	687b      	ldr	r3, [r7, #4]
 802940e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
 8029412:	bf00      	nop
 8029414:	370c      	adds	r7, #12
 8029416:	46bd      	mov	sp, r7
 8029418:	f85d 7b04 	ldr.w	r7, [sp], #4
 802941c:	4770      	bx	lr

0802941e <PWM_CCU4_Init>:
  return version;
}

/* This function initializes the app */
PWM_CCU4_STATUS_t PWM_CCU4_Init(PWM_CCU4_t* handle_ptr)
{
 802941e:	b580      	push	{r7, lr}
 8029420:	b086      	sub	sp, #24
 8029422:	af00      	add	r7, sp, #0
 8029424:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;
  GLOBAL_CCU4_STATUS_t status_ccu4_global;
  uint32_t frequency_module;
  uint32_t prescalar;

  status = PWM_CCU4_STATUS_FAILURE;
 8029426:	2301      	movs	r3, #1
 8029428:	75fb      	strb	r3, [r7, #23]
  status_ccu4_global = GLOBAL_CCU4_STATUS_FAILURE;
 802942a:	2301      	movs	r3, #1
 802942c:	75bb      	strb	r3, [r7, #22]
  XMC_ASSERT("PWM_CCU4_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU4_STATE_UNINITIALIZED == handle_ptr->state)
 802942e:	687b      	ldr	r3, [r7, #4]
 8029430:	7f1b      	ldrb	r3, [r3, #28]
 8029432:	2b00      	cmp	r3, #0
 8029434:	f040 808a 	bne.w	802954c <PWM_CCU4_Init+0x12e>
  {
    /* Initialize consumed Apps */
    status_ccu4_global = GLOBAL_CCU4_Init(handle_ptr->config_ptr->global_ccu4_handle);
 8029438:	687b      	ldr	r3, [r7, #4]
 802943a:	681b      	ldr	r3, [r3, #0]
 802943c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802943e:	4618      	mov	r0, r3
 8029440:	f000 fb7f 	bl	8029b42 <GLOBAL_CCU4_Init>
 8029444:	4603      	mov	r3, r0
 8029446:	75bb      	strb	r3, [r7, #22]

    /* Initialize CCU4x_CC4y slice */
    if (GLOBAL_CCU4_STATUS_SUCCESS == status_ccu4_global)
 8029448:	7dbb      	ldrb	r3, [r7, #22]
 802944a:	2b00      	cmp	r3, #0
 802944c:	d17a      	bne.n	8029544 <PWM_CCU4_Init+0x126>
    {
      XMC_DEBUG("PWM_CCU4_Init:Initilizing slice");

      /* Configure CCU4x_CC4y slice as timer */
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr);
 802944e:	687b      	ldr	r3, [r7, #4]
 8029450:	689a      	ldr	r2, [r3, #8]
 8029452:	687b      	ldr	r3, [r7, #4]
 8029454:	681b      	ldr	r3, [r3, #0]
 8029456:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8029458:	4619      	mov	r1, r3
 802945a:	4610      	mov	r0, r2
 802945c:	f7fe fa0b 	bl	8027876 <XMC_CCU4_SLICE_CompareInit>
      /* Set period match value of the timer  */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->period_value);
 8029460:	687b      	ldr	r3, [r7, #4]
 8029462:	689a      	ldr	r2, [r3, #8]
 8029464:	687b      	ldr	r3, [r7, #4]
 8029466:	681b      	ldr	r3, [r3, #0]
 8029468:	885b      	ldrh	r3, [r3, #2]
 802946a:	4619      	mov	r1, r3
 802946c:	4610      	mov	r0, r2
 802946e:	f7ff ff81 	bl	8029374 <XMC_CCU4_SLICE_SetTimerPeriodMatch>

      /* Set timer compare match value for channel 1 */
      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t) handle_ptr->config_ptr->compare_value);
 8029472:	687b      	ldr	r3, [r7, #4]
 8029474:	689a      	ldr	r2, [r3, #8]
 8029476:	687b      	ldr	r3, [r7, #4]
 8029478:	681b      	ldr	r3, [r3, #0]
 802947a:	889b      	ldrh	r3, [r3, #4]
 802947c:	4619      	mov	r1, r3
 802947e:	4610      	mov	r0, r2
 8029480:	f7ff ff87 	bl	8029392 <XMC_CCU4_SLICE_SetTimerCompareMatch>

      if (1U == handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->mcm_enable)
 8029484:	687b      	ldr	r3, [r7, #4]
 8029486:	681b      	ldr	r3, [r3, #0]
 8029488:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802948a:	78db      	ldrb	r3, [r3, #3]
 802948c:	f003 0302 	and.w	r3, r3, #2
 8029490:	b2db      	uxtb	r3, r3
 8029492:	2b00      	cmp	r3, #0
 8029494:	d008      	beq.n	80294a8 <PWM_CCU4_Init+0x8a>
      {
        XMC_CCU4_SetMultiChannelShadowTransferMode(handle_ptr->ccu4_module_ptr,
 8029496:	687b      	ldr	r3, [r7, #4]
 8029498:	685a      	ldr	r2, [r3, #4]
                                                   (uint32_t) handle_ptr->config_ptr->mcm_shadow_txfr_mode);
 802949a:	687b      	ldr	r3, [r7, #4]
 802949c:	681b      	ldr	r3, [r3, #0]
 802949e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
        XMC_CCU4_SetMultiChannelShadowTransferMode(handle_ptr->ccu4_module_ptr,
 80294a0:	4619      	mov	r1, r3
 80294a2:	4610      	mov	r0, r2
 80294a4:	f7fe f9cb 	bl	802783e <XMC_CCU4_SetMultiChannelShadowTransferMode>
        XMC_CCU4_SLICE_EnableCascadedShadowTransfer(handle_ptr->ccu4_slice_ptr);
      }
#endif

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->shadow_txfr_msk);
 80294a8:	687b      	ldr	r3, [r7, #4]
 80294aa:	685a      	ldr	r2, [r3, #4]
 80294ac:	687b      	ldr	r3, [r7, #4]
 80294ae:	691b      	ldr	r3, [r3, #16]
 80294b0:	4619      	mov	r1, r3
 80294b2:	4610      	mov	r0, r2
 80294b4:	f7ff ff7c 	bl	80293b0 <XMC_CCU4_EnableShadowTransfer>
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->dither_shadow_txfr_msk);
 80294b8:	687b      	ldr	r3, [r7, #4]
 80294ba:	685a      	ldr	r2, [r3, #4]
 80294bc:	687b      	ldr	r3, [r7, #4]
 80294be:	695b      	ldr	r3, [r3, #20]
 80294c0:	4619      	mov	r1, r3
 80294c2:	4610      	mov	r0, r2
 80294c4:	f7ff ff74 	bl	80293b0 <XMC_CCU4_EnableShadowTransfer>

      /* Configure events */
      PWM_CCU4_lConfigure_Events(handle_ptr);
 80294c8:	6878      	ldr	r0, [r7, #4]
 80294ca:	f000 f8da 	bl	8029682 <PWM_CCU4_lConfigure_Events>

      /* Enable the interrupts */
      PWM_CCU4_lInit_Interrupt(handle_ptr);
 80294ce:	6878      	ldr	r0, [r7, #4]
 80294d0:	f000 f843 	bl	802955a <PWM_CCU4_lInit_Interrupt>

      /*Initializes the GPIO*/
      if ((bool) true == handle_ptr->config_ptr->gpio_ch_out_enable)
 80294d4:	687b      	ldr	r3, [r7, #4]
 80294d6:	681b      	ldr	r3, [r3, #0]
 80294d8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80294dc:	2b00      	cmp	r3, #0
 80294de:	d00c      	beq.n	80294fa <PWM_CCU4_Init+0xdc>
      {
        XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch_out_ptr, handle_ptr->config_ptr->gpio_ch_out_pin,
 80294e0:	687b      	ldr	r3, [r7, #4]
 80294e2:	681b      	ldr	r3, [r3, #0]
 80294e4:	6c18      	ldr	r0, [r3, #64]	; 0x40
 80294e6:	687b      	ldr	r3, [r7, #4]
 80294e8:	681b      	ldr	r3, [r3, #0]
 80294ea:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
                      handle_ptr->config_ptr->gpio_ch_out_config_ptr);
 80294ee:	687b      	ldr	r3, [r7, #4]
 80294f0:	681b      	ldr	r3, [r3, #0]
        XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch_out_ptr, handle_ptr->config_ptr->gpio_ch_out_pin,
 80294f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80294f4:	461a      	mov	r2, r3
 80294f6:	f7fd f889 	bl	802660c <XMC_GPIO_Init>
      }

      frequency_module = handle_ptr->config_ptr->global_ccu4_handle->module_frequency;
 80294fa:	687b      	ldr	r3, [r7, #4]
 80294fc:	681b      	ldr	r3, [r3, #0]
 80294fe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8029500:	681b      	ldr	r3, [r3, #0]
 8029502:	613b      	str	r3, [r7, #16]
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->prescaler_initval;
 8029504:	687b      	ldr	r3, [r7, #4]
 8029506:	681b      	ldr	r3, [r3, #0]
 8029508:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802950a:	791b      	ldrb	r3, [r3, #4]
 802950c:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8029510:	b2db      	uxtb	r3, r3
 8029512:	60fb      	str	r3, [r7, #12]
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
 8029514:	693a      	ldr	r2, [r7, #16]
 8029516:	68fb      	ldr	r3, [r7, #12]
 8029518:	fa22 f303 	lsr.w	r3, r2, r3
 802951c:	613b      	str	r3, [r7, #16]
      handle_ptr->frequency_tclk = frequency_module;
 802951e:	687b      	ldr	r3, [r7, #4]
 8029520:	693a      	ldr	r2, [r7, #16]
 8029522:	621a      	str	r2, [r3, #32]

      handle_ptr->state = PWM_CCU4_STATE_INITIALIZED;
 8029524:	687b      	ldr	r3, [r7, #4]
 8029526:	2201      	movs	r2, #1
 8029528:	771a      	strb	r2, [r3, #28]
      status = PWM_CCU4_STATUS_SUCCESS;
 802952a:	2300      	movs	r3, #0
 802952c:	75fb      	strb	r3, [r7, #23]

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 802952e:	687b      	ldr	r3, [r7, #4]
 8029530:	681b      	ldr	r3, [r3, #0]
 8029532:	781b      	ldrb	r3, [r3, #0]
 8029534:	2b00      	cmp	r3, #0
 8029536:	d00b      	beq.n	8029550 <PWM_CCU4_Init+0x132>
      {
        status = PWM_CCU4_Start(handle_ptr);
 8029538:	6878      	ldr	r0, [r7, #4]
 802953a:	f000 f97b 	bl	8029834 <PWM_CCU4_Start>
 802953e:	4603      	mov	r3, r0
 8029540:	75fb      	strb	r3, [r7, #23]
 8029542:	e005      	b.n	8029550 <PWM_CCU4_Init+0x132>
      }
    }
    else
    {
      handle_ptr->state = PWM_CCU4_STATE_UNINITIALIZED;
 8029544:	687b      	ldr	r3, [r7, #4]
 8029546:	2200      	movs	r2, #0
 8029548:	771a      	strb	r2, [r3, #28]
 802954a:	e001      	b.n	8029550 <PWM_CCU4_Init+0x132>
    }

  }
  else
  {
    status = PWM_CCU4_STATUS_ALREADY_INITIALIZED;
 802954c:	2302      	movs	r3, #2
 802954e:	75fb      	strb	r3, [r7, #23]
    XMC_DEBUG("PWM_CCU4_Init:PWM_CCU4_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
 8029550:	7dfb      	ldrb	r3, [r7, #23]
} /* end of PWM_CCU4_Init() api */
 8029552:	4618      	mov	r0, r3
 8029554:	3718      	adds	r7, #24
 8029556:	46bd      	mov	sp, r7
 8029558:	bd80      	pop	{r7, pc}

0802955a <PWM_CCU4_lInit_Interrupt>:

static void PWM_CCU4_lInit_Interrupt(PWM_CCU4_t* handle_ptr)
{
 802955a:	b580      	push	{r7, lr}
 802955c:	b082      	sub	sp, #8
 802955e:	af00      	add	r7, sp, #0
 8029560:	6078      	str	r0, [r7, #4]

  /* Enable events. Bind event to corresponding service request node.Enable Interrupts. The user may choose to 
   disable the interrupts by LLD calls. */
  if ((bool) true == handle_ptr->config_ptr->int_per_match)
 8029562:	687b      	ldr	r3, [r7, #4]
 8029564:	681b      	ldr	r3, [r3, #0]
 8029566:	799b      	ldrb	r3, [r3, #6]
 8029568:	2b00      	cmp	r3, #0
 802956a:	d00e      	beq.n	802958a <PWM_CCU4_lInit_Interrupt+0x30>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt period match enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 802956c:	687b      	ldr	r3, [r7, #4]
 802956e:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_per_match);
 8029570:	687b      	ldr	r3, [r7, #4]
 8029572:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8029574:	7b5b      	ldrb	r3, [r3, #13]
 8029576:	461a      	mov	r2, r3
 8029578:	2100      	movs	r1, #0
 802957a:	f7fe fc49 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 802957e:	687b      	ldr	r3, [r7, #4]
 8029580:	689b      	ldr	r3, [r3, #8]
 8029582:	2100      	movs	r1, #0
 8029584:	4618      	mov	r0, r3
 8029586:	f7ff ff21 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp_match_up)
 802958a:	687b      	ldr	r3, [r7, #4]
 802958c:	681b      	ldr	r3, [r3, #0]
 802958e:	79db      	ldrb	r3, [r3, #7]
 8029590:	2b00      	cmp	r3, #0
 8029592:	d00e      	beq.n	80295b2 <PWM_CCU4_lInit_Interrupt+0x58>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt compare match up enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
 8029594:	687b      	ldr	r3, [r7, #4]
 8029596:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_cmp_match_up);
 8029598:	687b      	ldr	r3, [r7, #4]
 802959a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
 802959c:	7b9b      	ldrb	r3, [r3, #14]
 802959e:	461a      	mov	r2, r3
 80295a0:	2102      	movs	r1, #2
 80295a2:	f7fe fc35 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 80295a6:	687b      	ldr	r3, [r7, #4]
 80295a8:	689b      	ldr	r3, [r3, #8]
 80295aa:	2102      	movs	r1, #2
 80295ac:	4618      	mov	r0, r3
 80295ae:	f7ff ff0d 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp_match_down)
 80295b2:	687b      	ldr	r3, [r7, #4]
 80295b4:	681b      	ldr	r3, [r3, #0]
 80295b6:	7a1b      	ldrb	r3, [r3, #8]
 80295b8:	2b00      	cmp	r3, #0
 80295ba:	d00e      	beq.n	80295da <PWM_CCU4_lInit_Interrupt+0x80>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt compare match down enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN,
 80295bc:	687b      	ldr	r3, [r7, #4]
 80295be:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_cmp_match_down);
 80295c0:	687b      	ldr	r3, [r7, #4]
 80295c2:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN,
 80295c4:	7bdb      	ldrb	r3, [r3, #15]
 80295c6:	461a      	mov	r2, r3
 80295c8:	2103      	movs	r1, #3
 80295ca:	f7fe fc21 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN);
 80295ce:	687b      	ldr	r3, [r7, #4]
 80295d0:	689b      	ldr	r3, [r3, #8]
 80295d2:	2103      	movs	r1, #3
 80295d4:	4618      	mov	r0, r3
 80295d6:	f7ff fef9 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_one_match_down)
 80295da:	687b      	ldr	r3, [r7, #4]
 80295dc:	681b      	ldr	r3, [r3, #0]
 80295de:	7a5b      	ldrb	r3, [r3, #9]
 80295e0:	2b00      	cmp	r3, #0
 80295e2:	d00e      	beq.n	8029602 <PWM_CCU4_lInit_Interrupt+0xa8>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt one match enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH,
 80295e4:	687b      	ldr	r3, [r7, #4]
 80295e6:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_one_match_down);
 80295e8:	687b      	ldr	r3, [r7, #4]
 80295ea:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH,
 80295ec:	7c1b      	ldrb	r3, [r3, #16]
 80295ee:	461a      	mov	r2, r3
 80295f0:	2101      	movs	r1, #1
 80295f2:	f7fe fc0d 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH);
 80295f6:	687b      	ldr	r3, [r7, #4]
 80295f8:	689b      	ldr	r3, [r3, #8]
 80295fa:	2101      	movs	r1, #1
 80295fc:	4618      	mov	r0, r3
 80295fe:	f7ff fee5 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e0)
 8029602:	687b      	ldr	r3, [r7, #4]
 8029604:	681b      	ldr	r3, [r3, #0]
 8029606:	7a9b      	ldrb	r3, [r3, #10]
 8029608:	2b00      	cmp	r3, #0
 802960a:	d00e      	beq.n	802962a <PWM_CCU4_lInit_Interrupt+0xd0>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 0 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
 802960c:	687b      	ldr	r3, [r7, #4]
 802960e:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e0);
 8029610:	687b      	ldr	r3, [r7, #4]
 8029612:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
 8029614:	7c5b      	ldrb	r3, [r3, #17]
 8029616:	461a      	mov	r2, r3
 8029618:	2108      	movs	r1, #8
 802961a:	f7fe fbf9 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0);
 802961e:	687b      	ldr	r3, [r7, #4]
 8029620:	689b      	ldr	r3, [r3, #8]
 8029622:	2108      	movs	r1, #8
 8029624:	4618      	mov	r0, r3
 8029626:	f7ff fed1 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e1)
 802962a:	687b      	ldr	r3, [r7, #4]
 802962c:	681b      	ldr	r3, [r3, #0]
 802962e:	7adb      	ldrb	r3, [r3, #11]
 8029630:	2b00      	cmp	r3, #0
 8029632:	d00e      	beq.n	8029652 <PWM_CCU4_lInit_Interrupt+0xf8>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 1 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1,
 8029634:	687b      	ldr	r3, [r7, #4]
 8029636:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e1);
 8029638:	687b      	ldr	r3, [r7, #4]
 802963a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1,
 802963c:	7c9b      	ldrb	r3, [r3, #18]
 802963e:	461a      	mov	r2, r3
 8029640:	2109      	movs	r1, #9
 8029642:	f7fe fbe5 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1);
 8029646:	687b      	ldr	r3, [r7, #4]
 8029648:	689b      	ldr	r3, [r3, #8]
 802964a:	2109      	movs	r1, #9
 802964c:	4618      	mov	r0, r3
 802964e:	f7ff febd 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e2)
 8029652:	687b      	ldr	r3, [r7, #4]
 8029654:	681b      	ldr	r3, [r3, #0]
 8029656:	7b1b      	ldrb	r3, [r3, #12]
 8029658:	2b00      	cmp	r3, #0
 802965a:	d00e      	beq.n	802967a <PWM_CCU4_lInit_Interrupt+0x120>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 2 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2,
 802965c:	687b      	ldr	r3, [r7, #4]
 802965e:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e2);
 8029660:	687b      	ldr	r3, [r7, #4]
 8029662:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2,
 8029664:	7cdb      	ldrb	r3, [r3, #19]
 8029666:	461a      	mov	r2, r3
 8029668:	210a      	movs	r1, #10
 802966a:	f7fe fbd1 	bl	8027e10 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2);
 802966e:	687b      	ldr	r3, [r7, #4]
 8029670:	689b      	ldr	r3, [r3, #8]
 8029672:	210a      	movs	r1, #10
 8029674:	4618      	mov	r0, r3
 8029676:	f7ff fea9 	bl	80293cc <XMC_CCU4_SLICE_EnableEvent>
  }
}
 802967a:	bf00      	nop
 802967c:	3708      	adds	r7, #8
 802967e:	46bd      	mov	sp, r7
 8029680:	bd80      	pop	{r7, pc}

08029682 <PWM_CCU4_lConfigure_Events>:

static void PWM_CCU4_lConfigure_Events(PWM_CCU4_t* handle_ptr)
{
 8029682:	b580      	push	{r7, lr}
 8029684:	b082      	sub	sp, #8
 8029686:	af00      	add	r7, sp, #0
 8029688:	6078      	str	r0, [r7, #4]

  /* Configure slice to a external event 0 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0,
 802968a:	687b      	ldr	r3, [r7, #4]
 802968c:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event0_config_ptr);
 802968e:	687b      	ldr	r3, [r7, #4]
 8029690:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0,
 8029692:	695b      	ldr	r3, [r3, #20]
 8029694:	461a      	mov	r2, r3
 8029696:	2101      	movs	r1, #1
 8029698:	f7fe fb20 	bl	8027cdc <XMC_CCU4_SLICE_ConfigureEvent>

  /* Configure slice to a external event 1 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1,
 802969c:	687b      	ldr	r3, [r7, #4]
 802969e:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event1_config_ptr);
 80296a0:	687b      	ldr	r3, [r7, #4]
 80296a2:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1,
 80296a4:	699b      	ldr	r3, [r3, #24]
 80296a6:	461a      	mov	r2, r3
 80296a8:	2102      	movs	r1, #2
 80296aa:	f7fe fb17 	bl	8027cdc <XMC_CCU4_SLICE_ConfigureEvent>

  /* Configure slice to a external event 2 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_2,
 80296ae:	687b      	ldr	r3, [r7, #4]
 80296b0:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event2_config_ptr);
 80296b2:	687b      	ldr	r3, [r7, #4]
 80296b4:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_2,
 80296b6:	69db      	ldr	r3, [r3, #28]
 80296b8:	461a      	mov	r2, r3
 80296ba:	2103      	movs	r1, #3
 80296bc:	f7fe fb0e 	bl	8027cdc <XMC_CCU4_SLICE_ConfigureEvent>

  /* External signal controls start of the timer */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
 80296c0:	687b      	ldr	r3, [r7, #4]
 80296c2:	681b      	ldr	r3, [r3, #0]
 80296c4:	f893 3020 	ldrb.w	r3, [r3, #32]
 80296c8:	2b00      	cmp	r3, #0
 80296ca:	d00c      	beq.n	80296e6 <PWM_CCU4_lConfigure_Events+0x64>
  {
    XMC_CCU4_SLICE_StartConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 80296cc:	687b      	ldr	r3, [r7, #4]
 80296ce:	6898      	ldr	r0, [r3, #8]
 80296d0:	687b      	ldr	r3, [r7, #4]
 80296d2:	681b      	ldr	r3, [r3, #0]
 80296d4:	f893 1020 	ldrb.w	r1, [r3, #32]
                               handle_ptr->config_ptr->ext_start_mode);
 80296d8:	687b      	ldr	r3, [r7, #4]
 80296da:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_StartConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 80296dc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80296e0:	461a      	mov	r2, r3
 80296e2:	f7fe f926 	bl	8027932 <XMC_CCU4_SLICE_StartConfig>
  }

  /* External signal can stop the timer */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
 80296e6:	687b      	ldr	r3, [r7, #4]
 80296e8:	681b      	ldr	r3, [r3, #0]
 80296ea:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80296ee:	2b00      	cmp	r3, #0
 80296f0:	d00c      	beq.n	802970c <PWM_CCU4_lConfigure_Events+0x8a>
  {
    XMC_CCU4_SLICE_StopConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 80296f2:	687b      	ldr	r3, [r7, #4]
 80296f4:	6898      	ldr	r0, [r3, #8]
 80296f6:	687b      	ldr	r3, [r7, #4]
 80296f8:	681b      	ldr	r3, [r3, #0]
 80296fa:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
                              handle_ptr->config_ptr->ext_stop_mode);
 80296fe:	687b      	ldr	r3, [r7, #4]
 8029700:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_StopConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 8029702:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8029706:	461a      	mov	r2, r3
 8029708:	f7fe f941 	bl	802798e <XMC_CCU4_SLICE_StopConfig>
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
 802970c:	687b      	ldr	r3, [r7, #4]
 802970e:	681b      	ldr	r3, [r3, #0]
 8029710:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8029714:	2b00      	cmp	r3, #0
 8029716:	d009      	beq.n	802972c <PWM_CCU4_lConfigure_Events+0xaa>
  {
    XMC_CCU4_SLICE_DirectionConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
 8029718:	687b      	ldr	r3, [r7, #4]
 802971a:	689a      	ldr	r2, [r3, #8]
 802971c:	687b      	ldr	r3, [r7, #4]
 802971e:	681b      	ldr	r3, [r3, #0]
 8029720:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8029724:	4619      	mov	r1, r3
 8029726:	4610      	mov	r0, r2
 8029728:	f7fe fa09 	bl	8027b3e <XMC_CCU4_SLICE_DirectionConfig>
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
 802972c:	687b      	ldr	r3, [r7, #4]
 802972e:	681b      	ldr	r3, [r3, #0]
 8029730:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8029734:	2b00      	cmp	r3, #0
 8029736:	d009      	beq.n	802974c <PWM_CCU4_lConfigure_Events+0xca>
  {
    XMC_CCU4_SLICE_GateConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
 8029738:	687b      	ldr	r3, [r7, #4]
 802973a:	689a      	ldr	r2, [r3, #8]
 802973c:	687b      	ldr	r3, [r7, #4]
 802973e:	681b      	ldr	r3, [r3, #0]
 8029740:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8029744:	4619      	mov	r1, r3
 8029746:	4610      	mov	r0, r2
 8029748:	f7fe f9c3 	bl	8027ad2 <XMC_CCU4_SLICE_GateConfig>
  }
  /* Timer increments on external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
 802974c:	687b      	ldr	r3, [r7, #4]
 802974e:	681b      	ldr	r3, [r3, #0]
 8029750:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8029754:	2b00      	cmp	r3, #0
 8029756:	d009      	beq.n	802976c <PWM_CCU4_lConfigure_Events+0xea>
  {
    XMC_CCU4_SLICE_CountConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_count_event);
 8029758:	687b      	ldr	r3, [r7, #4]
 802975a:	689a      	ldr	r2, [r3, #8]
 802975c:	687b      	ldr	r3, [r7, #4]
 802975e:	681b      	ldr	r3, [r3, #0]
 8029760:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8029764:	4619      	mov	r1, r3
 8029766:	4610      	mov	r0, r2
 8029768:	f7fe f998 	bl	8027a9c <XMC_CCU4_SLICE_CountConfig>
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
 802976c:	687b      	ldr	r3, [r7, #4]
 802976e:	681b      	ldr	r3, [r3, #0]
 8029770:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8029774:	2b00      	cmp	r3, #0
 8029776:	d009      	beq.n	802978c <PWM_CCU4_lConfigure_Events+0x10a>
  {
    XMC_CCU4_SLICE_LoadConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_load_event);
 8029778:	687b      	ldr	r3, [r7, #4]
 802977a:	689a      	ldr	r2, [r3, #8]
 802977c:	687b      	ldr	r3, [r7, #4]
 802977e:	681b      	ldr	r3, [r3, #0]
 8029780:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8029784:	4619      	mov	r1, r3
 8029786:	4610      	mov	r0, r2
 8029788:	f7fe f92d 	bl	80279e6 <XMC_CCU4_SLICE_LoadConfig>
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
 802978c:	687b      	ldr	r3, [r7, #4]
 802978e:	681b      	ldr	r3, [r3, #0]
 8029790:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8029794:	2b00      	cmp	r3, #0
 8029796:	d00f      	beq.n	80297b8 <PWM_CCU4_lConfigure_Events+0x136>
  {
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 8029798:	687b      	ldr	r3, [r7, #4]
 802979a:	6898      	ldr	r0, [r3, #8]
 802979c:	687b      	ldr	r3, [r7, #4]
 802979e:	681b      	ldr	r3, [r3, #0]
 80297a0:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
                                    handle_ptr->config_ptr->ext_mod_mode, handle_ptr->config_ptr->ext_mod_sync);
 80297a4:	687b      	ldr	r3, [r7, #4]
 80297a6:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 80297a8:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
                                    handle_ptr->config_ptr->ext_mod_mode, handle_ptr->config_ptr->ext_mod_sync);
 80297ac:	687b      	ldr	r3, [r7, #4]
 80297ae:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 80297b0:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 80297b4:	f7fe f932 	bl	8027a1c <XMC_CCU4_SLICE_ModulationConfig>
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU4_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 80297b8:	687b      	ldr	r3, [r7, #4]
 80297ba:	681b      	ldr	r3, [r3, #0]
 80297bc:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 80297c0:	2b03      	cmp	r3, #3
 80297c2:	d117      	bne.n	80297f4 <PWM_CCU4_lConfigure_Events+0x172>
  {
    XMC_CCU4_SLICE_TrapConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 80297c4:	687b      	ldr	r3, [r7, #4]
 80297c6:	6898      	ldr	r0, [r3, #8]
 80297c8:	687b      	ldr	r3, [r7, #4]
 80297ca:	681b      	ldr	r3, [r3, #0]
 80297cc:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
                              handle_ptr->config_ptr->ext_trap_sync);
 80297d0:	687b      	ldr	r3, [r7, #4]
 80297d2:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_TrapConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 80297d4:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 80297d8:	461a      	mov	r2, r3
 80297da:	f7fe f9e3 	bl	8027ba4 <XMC_CCU4_SLICE_TrapConfig>

    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 80297de:	687b      	ldr	r3, [r7, #4]
 80297e0:	681b      	ldr	r3, [r3, #0]
 80297e2:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 80297e6:	2b00      	cmp	r3, #0
 80297e8:	d004      	beq.n	80297f4 <PWM_CCU4_lConfigure_Events+0x172>
    {
      XMC_CCU4_SLICE_EnableTrap(handle_ptr->ccu4_slice_ptr);
 80297ea:	687b      	ldr	r3, [r7, #4]
 80297ec:	689b      	ldr	r3, [r3, #8]
 80297ee:	4618      	mov	r0, r3
 80297f0:	f7ff fd89 	bl	8029306 <XMC_CCU4_SLICE_EnableTrap>
    }
  }
  if ((XMC_CCU4_SLICE_EVENT_1 == handle_ptr->config_ptr->ext_override_edge_event) && (XMC_CCU4_SLICE_EVENT_2
 80297f4:	687b      	ldr	r3, [r7, #4]
 80297f6:	681b      	ldr	r3, [r3, #0]
 80297f8:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 80297fc:	2b02      	cmp	r3, #2
 80297fe:	d115      	bne.n	802982c <PWM_CCU4_lConfigure_Events+0x1aa>
      == handle_ptr->config_ptr->ext_override_level_event))
 8029800:	687b      	ldr	r3, [r7, #4]
 8029802:	681b      	ldr	r3, [r3, #0]
 8029804:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
  if ((XMC_CCU4_SLICE_EVENT_1 == handle_ptr->config_ptr->ext_override_edge_event) && (XMC_CCU4_SLICE_EVENT_2
 8029808:	2b03      	cmp	r3, #3
 802980a:	d10f      	bne.n	802982c <PWM_CCU4_lConfigure_Events+0x1aa>
  {
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 802980c:	687b      	ldr	r3, [r7, #4]
 802980e:	6898      	ldr	r0, [r3, #8]
                                                   handle_ptr->config_ptr->event1_config_ptr,
 8029810:	687b      	ldr	r3, [r7, #4]
 8029812:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 8029814:	6999      	ldr	r1, [r3, #24]
                                                   handle_ptr->config_ptr->event2_config_ptr);
 8029816:	687b      	ldr	r3, [r7, #4]
 8029818:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 802981a:	69db      	ldr	r3, [r3, #28]
 802981c:	461a      	mov	r2, r3
 802981e:	f7fe f9fb 	bl	8027c18 <XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent>
    XMC_CCU4_SLICE_StatusBitOverrideConfig(handle_ptr->ccu4_slice_ptr);
 8029822:	687b      	ldr	r3, [r7, #4]
 8029824:	689b      	ldr	r3, [r3, #8]
 8029826:	4618      	mov	r0, r3
 8029828:	f7fe f9a4 	bl	8027b74 <XMC_CCU4_SLICE_StatusBitOverrideConfig>
  }

}
 802982c:	bf00      	nop
 802982e:	3708      	adds	r7, #8
 8029830:	46bd      	mov	sp, r7
 8029832:	bd80      	pop	{r7, pc}

08029834 <PWM_CCU4_Start>:
/**********************************************************************************************************/
/*Starts the CCU4_CC4 slice. This needs to be called even if external start is configured.*/
PWM_CCU4_STATUS_t PWM_CCU4_Start(PWM_CCU4_t* handle_ptr)
{
 8029834:	b580      	push	{r7, lr}
 8029836:	b084      	sub	sp, #16
 8029838:	af00      	add	r7, sp, #0
 802983a:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;

  status = PWM_CCU4_STATUS_FAILURE;
 802983c:	2301      	movs	r3, #1
 802983e:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("PWM_CCU4_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU4_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU4_STATE_STOPPED == handle_ptr->state))
 8029840:	687b      	ldr	r3, [r7, #4]
 8029842:	7f1b      	ldrb	r3, [r3, #28]
 8029844:	2b01      	cmp	r3, #1
 8029846:	d003      	beq.n	8029850 <PWM_CCU4_Start+0x1c>
 8029848:	687b      	ldr	r3, [r7, #4]
 802984a:	7f1b      	ldrb	r3, [r3, #28]
 802984c:	2b03      	cmp	r3, #3
 802984e:	d117      	bne.n	8029880 <PWM_CCU4_Start+0x4c>
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU4_EnableClock(handle_ptr->ccu4_module_ptr, handle_ptr->slice_number);
 8029850:	687b      	ldr	r3, [r7, #4]
 8029852:	685a      	ldr	r2, [r3, #4]
 8029854:	687b      	ldr	r3, [r7, #4]
 8029856:	7b5b      	ldrb	r3, [r3, #13]
 8029858:	4619      	mov	r1, r3
 802985a:	4610      	mov	r0, r2
 802985c:	f7ff fd42 	bl	80292e4 <XMC_CCU4_EnableClock>

    if (XMC_CCU4_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8029860:	687b      	ldr	r3, [r7, #4]
 8029862:	681b      	ldr	r3, [r3, #0]
 8029864:	f893 3020 	ldrb.w	r3, [r3, #32]
 8029868:	2b00      	cmp	r3, #0
 802986a:	d104      	bne.n	8029876 <PWM_CCU4_Start+0x42>
    {
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 802986c:	687b      	ldr	r3, [r7, #4]
 802986e:	689b      	ldr	r3, [r3, #8]
 8029870:	4618      	mov	r0, r3
 8029872:	f7ff fd58 	bl	8029326 <XMC_CCU4_SLICE_StartTimer>
    }

    handle_ptr->state = PWM_CCU4_STATE_RUNNING;
 8029876:	687b      	ldr	r3, [r7, #4]
 8029878:	2202      	movs	r2, #2
 802987a:	771a      	strb	r2, [r3, #28]
    status = PWM_CCU4_STATUS_SUCCESS;
 802987c:	2300      	movs	r3, #0
 802987e:	73fb      	strb	r3, [r7, #15]
    XMC_DEBUG("PWM_CCU4_Start:start PWM");
  }
  return (status);
 8029880:	7bfb      	ldrb	r3, [r7, #15]
} /* end of PWM_CCU4_Start() api */
 8029882:	4618      	mov	r0, r3
 8029884:	3710      	adds	r7, #16
 8029886:	46bd      	mov	sp, r7
 8029888:	bd80      	pop	{r7, pc}

0802988a <PWM_CCU4_Stop>:
/**********************************************************************************************************/
/*Stops the CCU4_CC4 slice. */
PWM_CCU4_STATUS_t PWM_CCU4_Stop(PWM_CCU4_t* handle_ptr)
{
 802988a:	b580      	push	{r7, lr}
 802988c:	b084      	sub	sp, #16
 802988e:	af00      	add	r7, sp, #0
 8029890:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;

  status = PWM_CCU4_STATUS_FAILURE;
 8029892:	2301      	movs	r3, #1
 8029894:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("PWM_CCU4_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU4_STATE_UNINITIALIZED != handle_ptr->state)
 8029896:	687b      	ldr	r3, [r7, #4]
 8029898:	7f1b      	ldrb	r3, [r3, #28]
 802989a:	2b00      	cmp	r3, #0
 802989c:	d00e      	beq.n	80298bc <PWM_CCU4_Stop+0x32>
  {
    XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
 802989e:	687b      	ldr	r3, [r7, #4]
 80298a0:	689b      	ldr	r3, [r3, #8]
 80298a2:	4618      	mov	r0, r3
 80298a4:	f7ff fd4c 	bl	8029340 <XMC_CCU4_SLICE_StopTimer>
    XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 80298a8:	687b      	ldr	r3, [r7, #4]
 80298aa:	689b      	ldr	r3, [r3, #8]
 80298ac:	4618      	mov	r0, r3
 80298ae:	f7ff fd54 	bl	802935a <XMC_CCU4_SLICE_ClearTimer>

    handle_ptr->state = PWM_CCU4_STATE_STOPPED;
 80298b2:	687b      	ldr	r3, [r7, #4]
 80298b4:	2203      	movs	r2, #3
 80298b6:	771a      	strb	r2, [r3, #28]
    status = PWM_CCU4_STATUS_SUCCESS;
 80298b8:	2300      	movs	r3, #0
 80298ba:	73fb      	strb	r3, [r7, #15]
    XMC_DEBUG("PWM_CCU4_Stop:stop PWM");
  }
  return (status);
 80298bc:	7bfb      	ldrb	r3, [r7, #15]

} /* end of PWM_CCU4_Stop() api */
 80298be:	4618      	mov	r0, r3
 80298c0:	3710      	adds	r7, #16
 80298c2:	46bd      	mov	sp, r7
 80298c4:	bd80      	pop	{r7, pc}
	...

080298c8 <PWM_CCU4_SetFreqAndDutyCycle>:

/**********************************************************************************************************/

/*Sets the frequency and duty cycle for CCU4_CC4 slice Symmetric Mode. */
PWM_CCU4_STATUS_t PWM_CCU4_SetFreqAndDutyCycle(PWM_CCU4_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t duty)
{
 80298c8:	b580      	push	{r7, lr}
 80298ca:	b088      	sub	sp, #32
 80298cc:	af00      	add	r7, sp, #0
 80298ce:	60f8      	str	r0, [r7, #12]
 80298d0:	60b9      	str	r1, [r7, #8]
 80298d2:	607a      	str	r2, [r7, #4]
  PWM_CCU4_STATUS_t status;
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare;

  status = PWM_CCU4_STATUS_FAILURE;
 80298d4:	2301      	movs	r3, #1
 80298d6:	77fb      	strb	r3, [r7, #31]
  frequency_tclk = 0U;
 80298d8:	2300      	movs	r3, #0
 80298da:	617b      	str	r3, [r7, #20]
  XMC_ASSERT("PWM_CCU4_SetFreqAndDutyCycle:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU4_STATE_UNINITIALIZED != handle_ptr->state)
 80298dc:	68fb      	ldr	r3, [r7, #12]
 80298de:	7f1b      	ldrb	r3, [r3, #28]
 80298e0:	2b00      	cmp	r3, #0
 80298e2:	d04d      	beq.n	8029980 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
  {
    if (0U == pwm_freq_hz)
 80298e4:	68bb      	ldr	r3, [r7, #8]
 80298e6:	2b00      	cmp	r3, #0
 80298e8:	d04a      	beq.n	8029980 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
    {
      XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycleSymmetric:cannot set frequency 0Hz");
    }
    else if (duty > PWM_CCU4_SYM_DUTY_MAX)
 80298ea:	687b      	ldr	r3, [r7, #4]
 80298ec:	f242 7210 	movw	r2, #10000	; 0x2710
 80298f0:	4293      	cmp	r3, r2
 80298f2:	d845      	bhi.n	8029980 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
    {
      XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycle:duty > 100%%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
 80298f4:	68fb      	ldr	r3, [r7, #12]
 80298f6:	6a1b      	ldr	r3, [r3, #32]
 80298f8:	617b      	str	r3, [r7, #20]
      period = frequency_tclk / pwm_freq_hz;
 80298fa:	697a      	ldr	r2, [r7, #20]
 80298fc:	68bb      	ldr	r3, [r7, #8]
 80298fe:	fbb2 f3f3 	udiv	r3, r2, r3
 8029902:	61bb      	str	r3, [r7, #24]

      if ((uint32_t) XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->timer_mode)
 8029904:	68fb      	ldr	r3, [r7, #12]
 8029906:	681b      	ldr	r3, [r3, #0]
 8029908:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802990a:	781b      	ldrb	r3, [r3, #0]
 802990c:	f003 0301 	and.w	r3, r3, #1
 8029910:	b2db      	uxtb	r3, r3
 8029912:	2b00      	cmp	r3, #0
 8029914:	d002      	beq.n	802991c <PWM_CCU4_SetFreqAndDutyCycle+0x54>
      {
        period = period >> 1U;/*divide by 2*/
 8029916:	69bb      	ldr	r3, [r7, #24]
 8029918:	085b      	lsrs	r3, r3, #1
 802991a:	61bb      	str	r3, [r7, #24]
      }

      if ((period != 0U) && (period <= PWM_CCU4_MAX_TIMER_COUNT))
 802991c:	69bb      	ldr	r3, [r7, #24]
 802991e:	2b00      	cmp	r3, #0
 8029920:	d02e      	beq.n	8029980 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
 8029922:	69bb      	ldr	r3, [r7, #24]
 8029924:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8029928:	d22a      	bcs.n	8029980 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare = ((period * (PWM_CCU4_DUTY_FULL_SCALE - duty)) / PWM_CCU4_DUTY_FULL_SCALE);
 802992a:	687b      	ldr	r3, [r7, #4]
 802992c:	f5c3 531c 	rsb	r3, r3, #9984	; 0x2700
 8029930:	3310      	adds	r3, #16
 8029932:	69ba      	ldr	r2, [r7, #24]
 8029934:	fb02 f303 	mul.w	r3, r2, r3
 8029938:	4a14      	ldr	r2, [pc, #80]	; (802998c <PWM_CCU4_SetFreqAndDutyCycle+0xc4>)
 802993a:	fba2 2303 	umull	r2, r3, r2, r3
 802993e:	0b5b      	lsrs	r3, r3, #13
 8029940:	613b      	str	r3, [r7, #16]

        XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, (uint16_t)(period - 1U));
 8029942:	68fb      	ldr	r3, [r7, #12]
 8029944:	689a      	ldr	r2, [r3, #8]
 8029946:	69bb      	ldr	r3, [r7, #24]
 8029948:	b29b      	uxth	r3, r3
 802994a:	3b01      	subs	r3, #1
 802994c:	b29b      	uxth	r3, r3
 802994e:	4619      	mov	r1, r3
 8029950:	4610      	mov	r0, r2
 8029952:	f7ff fd0f 	bl	8029374 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
        XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t) compare);
 8029956:	68fb      	ldr	r3, [r7, #12]
 8029958:	689b      	ldr	r3, [r3, #8]
 802995a:	693a      	ldr	r2, [r7, #16]
 802995c:	b292      	uxth	r2, r2
 802995e:	4611      	mov	r1, r2
 8029960:	4618      	mov	r0, r3
 8029962:	f7ff fd16 	bl	8029392 <XMC_CCU4_SLICE_SetTimerCompareMatch>

        XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->shadow_txfr_msk);
 8029966:	68fb      	ldr	r3, [r7, #12]
 8029968:	685a      	ldr	r2, [r3, #4]
 802996a:	68fb      	ldr	r3, [r7, #12]
 802996c:	691b      	ldr	r3, [r3, #16]
 802996e:	4619      	mov	r1, r3
 8029970:	4610      	mov	r0, r2
 8029972:	f7ff fd1d 	bl	80293b0 <XMC_CCU4_EnableShadowTransfer>

        handle_ptr->sym_duty = duty;
 8029976:	68fb      	ldr	r3, [r7, #12]
 8029978:	687a      	ldr	r2, [r7, #4]
 802997a:	625a      	str	r2, [r3, #36]	; 0x24

        XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycle:frequency set");
        status = PWM_CCU4_STATUS_SUCCESS;
 802997c:	2300      	movs	r3, #0
 802997e:	77fb      	strb	r3, [r7, #31]
      }
    }
  }
  return (status);
 8029980:	7ffb      	ldrb	r3, [r7, #31]

}/* end of PWM_CCU4_SetFreqAndDutyCycle() api */
 8029982:	4618      	mov	r0, r3
 8029984:	3720      	adds	r7, #32
 8029986:	46bd      	mov	sp, r7
 8029988:	bd80      	pop	{r7, pc}
 802998a:	bf00      	nop
 802998c:	d1b71759 	.word	0xd1b71759

08029990 <PWM_CCU4_ClearEvent>:

/**********************************************************************************************************/

/*Acknowledges the interrupt of  CCU4_CC4 slice. */
void PWM_CCU4_ClearEvent(PWM_CCU4_t* handle_ptr, XMC_CCU4_SLICE_IRQ_ID_t pwm_interrupt)
{
 8029990:	b580      	push	{r7, lr}
 8029992:	b082      	sub	sp, #8
 8029994:	af00      	add	r7, sp, #0
 8029996:	6078      	str	r0, [r7, #4]
 8029998:	460b      	mov	r3, r1
 802999a:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("PWM_CCU4_ClearEvent:handle_ptr NULL", (handle_ptr != NULL));
  XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, pwm_interrupt);
 802999c:	687b      	ldr	r3, [r7, #4]
 802999e:	689b      	ldr	r3, [r3, #8]
 80299a0:	78fa      	ldrb	r2, [r7, #3]
 80299a2:	4611      	mov	r1, r2
 80299a4:	4618      	mov	r0, r3
 80299a6:	f7ff fd28 	bl	80293fa <XMC_CCU4_SLICE_ClearEvent>
  XMC_DEBUG("PWM_CCU4_ClearEvent:Acknowledge Interrupt");
} /* end of PWM_CCU4_ClearEvent() api */
 80299aa:	bf00      	nop
 80299ac:	3708      	adds	r7, #8
 80299ae:	46bd      	mov	sp, r7
 80299b0:	bd80      	pop	{r7, pc}
	...

080299b4 <__NVIC_GetPriorityGrouping>:
{
 80299b4:	b480      	push	{r7}
 80299b6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80299b8:	4b04      	ldr	r3, [pc, #16]	; (80299cc <__NVIC_GetPriorityGrouping+0x18>)
 80299ba:	68db      	ldr	r3, [r3, #12]
 80299bc:	0a1b      	lsrs	r3, r3, #8
 80299be:	f003 0307 	and.w	r3, r3, #7
}
 80299c2:	4618      	mov	r0, r3
 80299c4:	46bd      	mov	sp, r7
 80299c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80299ca:	4770      	bx	lr
 80299cc:	e000ed00 	.word	0xe000ed00

080299d0 <__NVIC_EnableIRQ>:
{
 80299d0:	b480      	push	{r7}
 80299d2:	b083      	sub	sp, #12
 80299d4:	af00      	add	r7, sp, #0
 80299d6:	4603      	mov	r3, r0
 80299d8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80299da:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80299de:	2b00      	cmp	r3, #0
 80299e0:	db0b      	blt.n	80299fa <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80299e2:	79fb      	ldrb	r3, [r7, #7]
 80299e4:	f003 021f 	and.w	r2, r3, #31
 80299e8:	4907      	ldr	r1, [pc, #28]	; (8029a08 <__NVIC_EnableIRQ+0x38>)
 80299ea:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80299ee:	095b      	lsrs	r3, r3, #5
 80299f0:	2001      	movs	r0, #1
 80299f2:	fa00 f202 	lsl.w	r2, r0, r2
 80299f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80299fa:	bf00      	nop
 80299fc:	370c      	adds	r7, #12
 80299fe:	46bd      	mov	sp, r7
 8029a00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029a04:	4770      	bx	lr
 8029a06:	bf00      	nop
 8029a08:	e000e100 	.word	0xe000e100

08029a0c <__NVIC_SetPriority>:
{
 8029a0c:	b480      	push	{r7}
 8029a0e:	b083      	sub	sp, #12
 8029a10:	af00      	add	r7, sp, #0
 8029a12:	4603      	mov	r3, r0
 8029a14:	6039      	str	r1, [r7, #0]
 8029a16:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8029a18:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8029a1c:	2b00      	cmp	r3, #0
 8029a1e:	db0a      	blt.n	8029a36 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8029a20:	683b      	ldr	r3, [r7, #0]
 8029a22:	b2da      	uxtb	r2, r3
 8029a24:	490c      	ldr	r1, [pc, #48]	; (8029a58 <__NVIC_SetPriority+0x4c>)
 8029a26:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8029a2a:	0092      	lsls	r2, r2, #2
 8029a2c:	b2d2      	uxtb	r2, r2
 8029a2e:	440b      	add	r3, r1
 8029a30:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8029a34:	e00a      	b.n	8029a4c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8029a36:	683b      	ldr	r3, [r7, #0]
 8029a38:	b2da      	uxtb	r2, r3
 8029a3a:	4908      	ldr	r1, [pc, #32]	; (8029a5c <__NVIC_SetPriority+0x50>)
 8029a3c:	79fb      	ldrb	r3, [r7, #7]
 8029a3e:	f003 030f 	and.w	r3, r3, #15
 8029a42:	3b04      	subs	r3, #4
 8029a44:	0092      	lsls	r2, r2, #2
 8029a46:	b2d2      	uxtb	r2, r2
 8029a48:	440b      	add	r3, r1
 8029a4a:	761a      	strb	r2, [r3, #24]
}
 8029a4c:	bf00      	nop
 8029a4e:	370c      	adds	r7, #12
 8029a50:	46bd      	mov	sp, r7
 8029a52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029a56:	4770      	bx	lr
 8029a58:	e000e100 	.word	0xe000e100
 8029a5c:	e000ed00 	.word	0xe000ed00

08029a60 <NVIC_EncodePriority>:
{
 8029a60:	b480      	push	{r7}
 8029a62:	b089      	sub	sp, #36	; 0x24
 8029a64:	af00      	add	r7, sp, #0
 8029a66:	60f8      	str	r0, [r7, #12]
 8029a68:	60b9      	str	r1, [r7, #8]
 8029a6a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8029a6c:	68fb      	ldr	r3, [r7, #12]
 8029a6e:	f003 0307 	and.w	r3, r3, #7
 8029a72:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8029a74:	69fb      	ldr	r3, [r7, #28]
 8029a76:	f1c3 0307 	rsb	r3, r3, #7
 8029a7a:	2b06      	cmp	r3, #6
 8029a7c:	bf28      	it	cs
 8029a7e:	2306      	movcs	r3, #6
 8029a80:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8029a82:	69fb      	ldr	r3, [r7, #28]
 8029a84:	3306      	adds	r3, #6
 8029a86:	2b06      	cmp	r3, #6
 8029a88:	d902      	bls.n	8029a90 <NVIC_EncodePriority+0x30>
 8029a8a:	69fb      	ldr	r3, [r7, #28]
 8029a8c:	3b01      	subs	r3, #1
 8029a8e:	e000      	b.n	8029a92 <NVIC_EncodePriority+0x32>
 8029a90:	2300      	movs	r3, #0
 8029a92:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8029a94:	f04f 32ff 	mov.w	r2, #4294967295
 8029a98:	69bb      	ldr	r3, [r7, #24]
 8029a9a:	fa02 f303 	lsl.w	r3, r2, r3
 8029a9e:	43da      	mvns	r2, r3
 8029aa0:	68bb      	ldr	r3, [r7, #8]
 8029aa2:	401a      	ands	r2, r3
 8029aa4:	697b      	ldr	r3, [r7, #20]
 8029aa6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8029aa8:	f04f 31ff 	mov.w	r1, #4294967295
 8029aac:	697b      	ldr	r3, [r7, #20]
 8029aae:	fa01 f303 	lsl.w	r3, r1, r3
 8029ab2:	43d9      	mvns	r1, r3
 8029ab4:	687b      	ldr	r3, [r7, #4]
 8029ab6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8029ab8:	4313      	orrs	r3, r2
}
 8029aba:	4618      	mov	r0, r3
 8029abc:	3724      	adds	r7, #36	; 0x24
 8029abe:	46bd      	mov	sp, r7
 8029ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029ac4:	4770      	bx	lr

08029ac6 <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
 8029ac6:	b580      	push	{r7, lr}
 8029ac8:	b082      	sub	sp, #8
 8029aca:	af00      	add	r7, sp, #0
 8029acc:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
 8029ace:	687b      	ldr	r3, [r7, #4]
 8029ad0:	f993 3000 	ldrsb.w	r3, [r3]
 8029ad4:	4618      	mov	r0, r3
 8029ad6:	f7ff ff7b 	bl	80299d0 <__NVIC_EnableIRQ>
}
 8029ada:	bf00      	nop
 8029adc:	3708      	adds	r7, #8
 8029ade:	46bd      	mov	sp, r7
 8029ae0:	bd80      	pop	{r7, pc}

08029ae2 <INTERRUPT_Init>:

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 8029ae2:	b590      	push	{r4, r7, lr}
 8029ae4:	b083      	sub	sp, #12
 8029ae6:	af00      	add	r7, sp, #0
 8029ae8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 8029aea:	687b      	ldr	r3, [r7, #4]
 8029aec:	f993 4000 	ldrsb.w	r4, [r3]
 8029af0:	f7ff ff60 	bl	80299b4 <__NVIC_GetPriorityGrouping>
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
 8029af4:	687b      	ldr	r3, [r7, #4]
 8029af6:	785b      	ldrb	r3, [r3, #1]
  NVIC_SetPriority(handler->node,
 8029af8:	4619      	mov	r1, r3
                                       handler->subpriority));
 8029afa:	687b      	ldr	r3, [r7, #4]
 8029afc:	789b      	ldrb	r3, [r3, #2]
  NVIC_SetPriority(handler->node,
 8029afe:	461a      	mov	r2, r3
 8029b00:	f7ff ffae 	bl	8029a60 <NVIC_EncodePriority>
 8029b04:	4603      	mov	r3, r0
 8029b06:	4619      	mov	r1, r3
 8029b08:	4620      	mov	r0, r4
 8029b0a:	f7ff ff7f 	bl	8029a0c <__NVIC_SetPriority>
  if (handler->enable_at_init == true)
 8029b0e:	687b      	ldr	r3, [r7, #4]
 8029b10:	78db      	ldrb	r3, [r3, #3]
 8029b12:	2b00      	cmp	r3, #0
 8029b14:	d002      	beq.n	8029b1c <INTERRUPT_Init+0x3a>
  {
    INTERRUPT_Enable(handler);
 8029b16:	6878      	ldr	r0, [r7, #4]
 8029b18:	f7ff ffd5 	bl	8029ac6 <INTERRUPT_Enable>
  {
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
 8029b1c:	2300      	movs	r3, #0
}
 8029b1e:	4618      	mov	r0, r3
 8029b20:	370c      	adds	r7, #12
 8029b22:	46bd      	mov	sp, r7
 8029b24:	bd90      	pop	{r4, r7, pc}

08029b26 <XMC_CCU4_StartPrescaler>:
{
 8029b26:	b480      	push	{r7}
 8029b28:	b083      	sub	sp, #12
 8029b2a:	af00      	add	r7, sp, #0
 8029b2c:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8029b2e:	687b      	ldr	r3, [r7, #4]
 8029b30:	f44f 7280 	mov.w	r2, #256	; 0x100
 8029b34:	60da      	str	r2, [r3, #12]
}
 8029b36:	bf00      	nop
 8029b38:	370c      	adds	r7, #12
 8029b3a:	46bd      	mov	sp, r7
 8029b3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029b40:	4770      	bx	lr

08029b42 <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 8029b42:	b580      	push	{r7, lr}
 8029b44:	b082      	sub	sp, #8
 8029b46:	af00      	add	r7, sp, #0
 8029b48:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8029b4a:	687b      	ldr	r3, [r7, #4]
 8029b4c:	7b5b      	ldrb	r3, [r3, #13]
 8029b4e:	f083 0301 	eor.w	r3, r3, #1
 8029b52:	b2db      	uxtb	r3, r3
 8029b54:	2b00      	cmp	r3, #0
 8029b56:	d00f      	beq.n	8029b78 <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 8029b58:	687b      	ldr	r3, [r7, #4]
 8029b5a:	689a      	ldr	r2, [r3, #8]
 8029b5c:	687b      	ldr	r3, [r7, #4]
 8029b5e:	7b1b      	ldrb	r3, [r3, #12]
 8029b60:	4619      	mov	r1, r3
 8029b62:	4610      	mov	r0, r2
 8029b64:	f7fd fe4c 	bl	8027800 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 8029b68:	687b      	ldr	r3, [r7, #4]
 8029b6a:	689b      	ldr	r3, [r3, #8]
 8029b6c:	4618      	mov	r0, r3
 8029b6e:	f7ff ffda 	bl	8029b26 <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8029b72:	687b      	ldr	r3, [r7, #4]
 8029b74:	2201      	movs	r2, #1
 8029b76:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
 8029b78:	2300      	movs	r3, #0
}
 8029b7a:	4618      	mov	r0, r3
 8029b7c:	3708      	adds	r7, #8
 8029b7e:	46bd      	mov	sp, r7
 8029b80:	bd80      	pop	{r7, pc}

08029b82 <GLOBAL_CAN_Init>:
  return (version);
}

/*  Function to initialize the CAN Peripheral module clock.  */
GLOBAL_CAN_STATUS_t GLOBAL_CAN_Init(GLOBAL_CAN_t *handle)
{
 8029b82:	b580      	push	{r7, lr}
 8029b84:	b084      	sub	sp, #16
 8029b86:	af00      	add	r7, sp, #0
 8029b88:	6078      	str	r0, [r7, #4]
  GLOBAL_CAN_STATUS_t status = GLOBAL_CAN_STATUS_SUCCESS;
 8029b8a:	2300      	movs	r3, #0
 8029b8c:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("GLOBAL_CAN_Init: handle null", handle != NULL);

  if (handle->init_status != true)
 8029b8e:	687b      	ldr	r3, [r7, #4]
 8029b90:	7a5b      	ldrb	r3, [r3, #9]
 8029b92:	f083 0301 	eor.w	r3, r3, #1
 8029b96:	b2db      	uxtb	r3, r3
 8029b98:	2b00      	cmp	r3, #0
 8029b9a:	d00c      	beq.n	8029bb6 <GLOBAL_CAN_Init+0x34>
  {
#if defined(MULTICAN_PLUS)
    XMC_CAN_InitEx(handle->canglobal_ptr, (XMC_CAN_CANCLKSRC_t)handle->can_clock_src, handle->can_frequency);
#else
    XMC_CAN_InitEx(handle->canglobal_ptr, XMC_CAN_CANCLKSRC_FPERI, handle->can_frequency);
 8029b9c:	687b      	ldr	r3, [r7, #4]
 8029b9e:	6858      	ldr	r0, [r3, #4]
 8029ba0:	687b      	ldr	r3, [r7, #4]
 8029ba2:	681b      	ldr	r3, [r3, #0]
 8029ba4:	461a      	mov	r2, r3
 8029ba6:	2101      	movs	r1, #1
 8029ba8:	f7fd fb7e 	bl	80272a8 <XMC_CAN_InitEx>
#endif
    handle->init_status = true;
 8029bac:	687b      	ldr	r3, [r7, #4]
 8029bae:	2201      	movs	r2, #1
 8029bb0:	725a      	strb	r2, [r3, #9]
    status = GLOBAL_CAN_STATUS_SUCCESS;
 8029bb2:	2300      	movs	r3, #0
 8029bb4:	73fb      	strb	r3, [r7, #15]
  }
  return (status);
 8029bb6:	7bfb      	ldrb	r3, [r7, #15]

}
 8029bb8:	4618      	mov	r0, r3
 8029bba:	3710      	adds	r7, #16
 8029bbc:	46bd      	mov	sp, r7
 8029bbe:	bd80      	pop	{r7, pc}

08029bc0 <XMC_VADC_GLOBAL_DisablePostCalibration>:
{
 8029bc0:	b480      	push	{r7}
 8029bc2:	b083      	sub	sp, #12
 8029bc4:	af00      	add	r7, sp, #0
 8029bc6:	6078      	str	r0, [r7, #4]
 8029bc8:	6039      	str	r1, [r7, #0]
  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 8029bca:	687b      	ldr	r3, [r7, #4]
 8029bcc:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8029bd0:	683b      	ldr	r3, [r7, #0]
 8029bd2:	3310      	adds	r3, #16
 8029bd4:	2101      	movs	r1, #1
 8029bd6:	fa01 f303 	lsl.w	r3, r1, r3
 8029bda:	431a      	orrs	r2, r3
 8029bdc:	687b      	ldr	r3, [r7, #4]
 8029bde:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 8029be2:	bf00      	nop
 8029be4:	370c      	adds	r7, #12
 8029be6:	46bd      	mov	sp, r7
 8029be8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029bec:	4770      	bx	lr

08029bee <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 8029bee:	b580      	push	{r7, lr}
 8029bf0:	b084      	sub	sp, #16
 8029bf2:	af00      	add	r7, sp, #0
 8029bf4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL));
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 8029bf6:	687b      	ldr	r3, [r7, #4]
 8029bf8:	7e1b      	ldrb	r3, [r3, #24]
 8029bfa:	2b02      	cmp	r3, #2
 8029bfc:	d148      	bne.n	8029c90 <GLOBAL_ADC_Init+0xa2>
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 8029bfe:	687b      	ldr	r3, [r7, #4]
 8029c00:	695a      	ldr	r2, [r3, #20]
 8029c02:	687b      	ldr	r3, [r7, #4]
 8029c04:	691b      	ldr	r3, [r3, #16]
 8029c06:	4619      	mov	r1, r3
 8029c08:	4610      	mov	r0, r2
 8029c0a:	f7fe fd11 	bl	8028630 <XMC_VADC_GLOBAL_Init>

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8029c0e:	2300      	movs	r3, #0
 8029c10:	60fb      	str	r3, [r7, #12]
 8029c12:	e02e      	b.n	8029c72 <GLOBAL_ADC_Init+0x84>
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 8029c14:	687b      	ldr	r3, [r7, #4]
 8029c16:	68fa      	ldr	r2, [r7, #12]
 8029c18:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029c1c:	6818      	ldr	r0, [r3, #0]
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);
 8029c1e:	687b      	ldr	r3, [r7, #4]
 8029c20:	68fa      	ldr	r2, [r7, #12]
 8029c22:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 8029c26:	685b      	ldr	r3, [r3, #4]
 8029c28:	4619      	mov	r1, r3
 8029c2a:	f7fe fdaa 	bl	8028782 <XMC_VADC_GROUP_Init>

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 8029c2e:	687b      	ldr	r3, [r7, #4]
 8029c30:	68fa      	ldr	r2, [r7, #12]
 8029c32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029c36:	681b      	ldr	r3, [r3, #0]
 8029c38:	2103      	movs	r1, #3
 8029c3a:	4618      	mov	r0, r3
 8029c3c:	f7fe fe32 	bl	80288a4 <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 8029c40:	687b      	ldr	r3, [r7, #4]
 8029c42:	68fa      	ldr	r2, [r7, #12]
 8029c44:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029c48:	7a1b      	ldrb	r3, [r3, #8]
 8029c4a:	f083 0301 	eor.w	r3, r3, #1
 8029c4e:	b2db      	uxtb	r3, r3
 8029c50:	2b00      	cmp	r3, #0
 8029c52:	d005      	beq.n	8029c60 <GLOBAL_ADC_Init+0x72>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 8029c54:	687b      	ldr	r3, [r7, #4]
 8029c56:	695b      	ldr	r3, [r3, #20]
 8029c58:	68f9      	ldr	r1, [r7, #12]
 8029c5a:	4618      	mov	r0, r3
 8029c5c:	f7ff ffb0 	bl	8029bc0 <XMC_VADC_GLOBAL_DisablePostCalibration>

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 8029c60:	687b      	ldr	r3, [r7, #4]
 8029c62:	68fa      	ldr	r2, [r7, #12]
 8029c64:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029c68:	2200      	movs	r2, #0
 8029c6a:	725a      	strb	r2, [r3, #9]
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8029c6c:	68fb      	ldr	r3, [r7, #12]
 8029c6e:	3301      	adds	r3, #1
 8029c70:	60fb      	str	r3, [r7, #12]
 8029c72:	68fb      	ldr	r3, [r7, #12]
 8029c74:	2b03      	cmp	r3, #3
 8029c76:	d9cd      	bls.n	8029c14 <GLOBAL_ADC_Init+0x26>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 8029c78:	687b      	ldr	r3, [r7, #4]
 8029c7a:	7e5b      	ldrb	r3, [r3, #25]
 8029c7c:	2b00      	cmp	r3, #0
 8029c7e:	d004      	beq.n	8029c8a <GLOBAL_ADC_Init+0x9c>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 8029c80:	687b      	ldr	r3, [r7, #4]
 8029c82:	695b      	ldr	r3, [r3, #20]
 8029c84:	4618      	mov	r0, r3
 8029c86:	f7fe fd23 	bl	80286d0 <XMC_VADC_GLOBAL_StartupCalibration>
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 8029c8a:	687b      	ldr	r3, [r7, #4]
 8029c8c:	2200      	movs	r2, #0
 8029c8e:	761a      	strb	r2, [r3, #24]
  }
  return (handle_ptr->init_state);
 8029c90:	687b      	ldr	r3, [r7, #4]
 8029c92:	7e1b      	ldrb	r3, [r3, #24]
}
 8029c94:	4618      	mov	r0, r3
 8029c96:	3710      	adds	r7, #16
 8029c98:	46bd      	mov	sp, r7
 8029c9a:	bd80      	pop	{r7, pc}

08029c9c <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8029c9c:	b580      	push	{r7, lr}
 8029c9e:	b082      	sub	sp, #8
 8029ca0:	af00      	add	r7, sp, #0
 8029ca2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 8029ca4:	687b      	ldr	r3, [r7, #4]
 8029ca6:	6818      	ldr	r0, [r3, #0]
 8029ca8:	687b      	ldr	r3, [r7, #4]
 8029caa:	7c19      	ldrb	r1, [r3, #16]
 8029cac:	687b      	ldr	r3, [r7, #4]
 8029cae:	3304      	adds	r3, #4
 8029cb0:	461a      	mov	r2, r3
 8029cb2:	f7fc fcab 	bl	802660c <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8029cb6:	687b      	ldr	r3, [r7, #4]
 8029cb8:	6818      	ldr	r0, [r3, #0]
 8029cba:	687b      	ldr	r3, [r7, #4]
 8029cbc:	7c19      	ldrb	r1, [r3, #16]
 8029cbe:	687b      	ldr	r3, [r7, #4]
 8029cc0:	7c5b      	ldrb	r3, [r3, #17]
 8029cc2:	461a      	mov	r2, r3
 8029cc4:	f7fe fb68 	bl	8028398 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
 8029cc8:	2300      	movs	r3, #0
}
 8029cca:	4618      	mov	r0, r3
 8029ccc:	3708      	adds	r7, #8
 8029cce:	46bd      	mov	sp, r7
 8029cd0:	bd80      	pop	{r7, pc}
	...

08029cd4 <__NVIC_SetPriorityGrouping>:
{
 8029cd4:	b480      	push	{r7}
 8029cd6:	b085      	sub	sp, #20
 8029cd8:	af00      	add	r7, sp, #0
 8029cda:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8029cdc:	687b      	ldr	r3, [r7, #4]
 8029cde:	f003 0307 	and.w	r3, r3, #7
 8029ce2:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8029ce4:	4b0c      	ldr	r3, [pc, #48]	; (8029d18 <__NVIC_SetPriorityGrouping+0x44>)
 8029ce6:	68db      	ldr	r3, [r3, #12]
 8029ce8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8029cea:	68ba      	ldr	r2, [r7, #8]
 8029cec:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8029cf0:	4013      	ands	r3, r2
 8029cf2:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8029cf4:	68fb      	ldr	r3, [r7, #12]
 8029cf6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8029cf8:	68bb      	ldr	r3, [r7, #8]
 8029cfa:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8029cfc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8029d00:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8029d04:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8029d06:	4a04      	ldr	r2, [pc, #16]	; (8029d18 <__NVIC_SetPriorityGrouping+0x44>)
 8029d08:	68bb      	ldr	r3, [r7, #8]
 8029d0a:	60d3      	str	r3, [r2, #12]
}
 8029d0c:	bf00      	nop
 8029d0e:	3714      	adds	r7, #20
 8029d10:	46bd      	mov	sp, r7
 8029d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029d16:	4770      	bx	lr
 8029d18:	e000ed00 	.word	0xe000ed00

08029d1c <SystemCoreSetup>:
  .initialized = false
};	


void SystemCoreSetup(void)
{
 8029d1c:	b580      	push	{r7, lr}
 8029d1e:	b082      	sub	sp, #8
 8029d20:	af00      	add	r7, sp, #0
  uint32_t temp;

  NVIC_SetPriorityGrouping(1U);
 8029d22:	2001      	movs	r0, #1
 8029d24:	f7ff ffd6 	bl	8029cd4 <__NVIC_SetPriorityGrouping>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8029d28:	b672      	cpsid	i
}
 8029d2a:	bf00      	nop
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 8029d2c:	4b22      	ldr	r3, [pc, #136]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d2e:	4a23      	ldr	r2, [pc, #140]	; (8029dbc <SystemCoreSetup+0xa0>)
 8029d30:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8029d32:	f3bf 8f4f 	dsb	sy
}
 8029d36:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8029d38:	b662      	cpsie	i
}
 8029d3a:	bf00      	nop

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8029d3c:	4b1e      	ldr	r3, [pc, #120]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d3e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8029d42:	4a1d      	ldr	r2, [pc, #116]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d44:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8029d48:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8029d4c:	4b1c      	ldr	r3, [pc, #112]	; (8029dc0 <SystemCoreSetup+0xa4>)
 8029d4e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8029d52:	695b      	ldr	r3, [r3, #20]
 8029d54:	607b      	str	r3, [r7, #4]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8029d56:	687b      	ldr	r3, [r7, #4]
 8029d58:	f023 030f 	bic.w	r3, r3, #15
 8029d5c:	607b      	str	r3, [r7, #4]
  temp |= PMU_FLASH_WS;
 8029d5e:	687b      	ldr	r3, [r7, #4]
 8029d60:	f043 0303 	orr.w	r3, r3, #3
 8029d64:	607b      	str	r3, [r7, #4]
  FLASH0->FCON = temp;
 8029d66:	4b16      	ldr	r3, [pc, #88]	; (8029dc0 <SystemCoreSetup+0xa4>)
 8029d68:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8029d6c:	461a      	mov	r2, r3
 8029d6e:	687b      	ldr	r3, [r7, #4]
 8029d70:	6153      	str	r3, [r2, #20]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 8029d72:	4b11      	ldr	r3, [pc, #68]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d74:	695b      	ldr	r3, [r3, #20]
 8029d76:	4a10      	ldr	r2, [pc, #64]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d78:	f023 0310 	bic.w	r3, r3, #16
 8029d7c:	6153      	str	r3, [r2, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 8029d7e:	4b0e      	ldr	r3, [pc, #56]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d80:	695b      	ldr	r3, [r3, #20]
 8029d82:	4a0d      	ldr	r2, [pc, #52]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d84:	f023 0308 	bic.w	r3, r3, #8
 8029d88:	6153      	str	r3, [r2, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8029d8a:	4b0b      	ldr	r3, [pc, #44]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029d8e:	4a0a      	ldr	r2, [pc, #40]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d90:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8029d94:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 8029d96:	4b08      	ldr	r3, [pc, #32]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029d9a:	4a07      	ldr	r2, [pc, #28]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029d9c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8029da0:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 8029da2:	4b05      	ldr	r3, [pc, #20]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029da4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029da6:	4a04      	ldr	r2, [pc, #16]	; (8029db8 <SystemCoreSetup+0x9c>)
 8029da8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8029dac:	6253      	str	r3, [r2, #36]	; 0x24
}
 8029dae:	bf00      	nop
 8029db0:	3708      	adds	r7, #8
 8029db2:	46bd      	mov	sp, r7
 8029db4:	bd80      	pop	{r7, pc}
 8029db6:	bf00      	nop
 8029db8:	e000ed00 	.word	0xe000ed00
 8029dbc:	08020400 	.word	0x08020400
 8029dc0:	58001000 	.word	0x58001000

08029dc4 <CLOCK_XMC4_Init>:

/*
 * API to initialize the CLOCK_XMC4 APP TRAP events
 */
CLOCK_XMC4_STATUS_t CLOCK_XMC4_Init(CLOCK_XMC4_t *handle)
{
 8029dc4:	b480      	push	{r7}
 8029dc6:	b085      	sub	sp, #20
 8029dc8:	af00      	add	r7, sp, #0
 8029dca:	6078      	str	r0, [r7, #4]
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;
 8029dcc:	2300      	movs	r3, #0
 8029dce:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8029dd0:	687b      	ldr	r3, [r7, #4]
 8029dd2:	2201      	movs	r2, #1
 8029dd4:	701a      	strb	r2, [r3, #0]

  return (status);
 8029dd6:	7bfb      	ldrb	r3, [r7, #15]
}
 8029dd8:	4618      	mov	r0, r3
 8029dda:	3714      	adds	r7, #20
 8029ddc:	46bd      	mov	sp, r7
 8029dde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029de2:	4770      	bx	lr

08029de4 <OSCHP_GetFrequency>:

#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
 8029de4:	b480      	push	{r7}
 8029de6:	af00      	add	r7, sp, #0
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
 8029de8:	4b02      	ldr	r3, [pc, #8]	; (8029df4 <OSCHP_GetFrequency+0x10>)
}
 8029dea:	4618      	mov	r0, r3
 8029dec:	46bd      	mov	sp, r7
 8029dee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029df2:	4770      	bx	lr
 8029df4:	007a1200 	.word	0x007a1200

08029df8 <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8029df8:	b5b0      	push	{r4, r5, r7, lr}
 8029dfa:	b086      	sub	sp, #24
 8029dfc:	af00      	add	r7, sp, #0
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8029dfe:	4b13      	ldr	r3, [pc, #76]	; (8029e4c <SystemCoreClockSetup+0x54>)
 8029e00:	1d3c      	adds	r4, r7, #4
 8029e02:	461d      	mov	r5, r3
 8029e04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8029e06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8029e08:	682b      	ldr	r3, [r5, #0]
 8029e0a:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 8029e0c:	1d3b      	adds	r3, r7, #4
 8029e0e:	4618      	mov	r0, r3
 8029e10:	f7fc fcfe 	bl	8026810 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 8029e14:	2000      	movs	r0, #0
 8029e16:	f7fc fdf5 	bl	8026a04 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 8029e1a:	2000      	movs	r0, #0
 8029e1c:	f7fc fda8 	bl	8026970 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 8029e20:	2004      	movs	r0, #4
 8029e22:	f7fc fe5d 	bl	8026ae0 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_EnableUsbPll();
 8029e26:	f7fc fead 	bl	8026b84 <XMC_SCU_CLOCK_EnableUsbPll>
  XMC_SCU_CLOCK_StartUsbPll(1U, 48U);
 8029e2a:	2130      	movs	r1, #48	; 0x30
 8029e2c:	2001      	movs	r0, #1
 8029e2e:	f7fc febb 	bl	8026ba8 <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_OFI);
 8029e32:	2000      	movs	r0, #0
 8029e34:	f7fc fdb0 	bl	8026998 <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 8029e38:	2001      	movs	r0, #1
 8029e3a:	f7fc fe7d 	bl	8026b38 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 8029e3e:	2001      	movs	r0, #1
 8029e40:	f7fc fe64 	bl	8026b0c <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 8029e44:	bf00      	nop
 8029e46:	3718      	adds	r7, #24
 8029e48:	46bd      	mov	sp, r7
 8029e4a:	bdb0      	pop	{r4, r5, r7, pc}
 8029e4c:	0802b684 	.word	0x0802b684

08029e50 <XMC_CAN_NODE_SetEventNodePointer>:
{
 8029e50:	b480      	push	{r7}
 8029e52:	b085      	sub	sp, #20
 8029e54:	af00      	add	r7, sp, #0
 8029e56:	60f8      	str	r0, [r7, #12]
 8029e58:	460b      	mov	r3, r1
 8029e5a:	607a      	str	r2, [r7, #4]
 8029e5c:	72fb      	strb	r3, [r7, #11]
  can_node->NIPR = (uint32_t)((can_node->NIPR) & ~(uint32_t)(CAN_NODE_NIPR_Msk << (uint32_t)ptr_event)) | (service_request << (uint32_t)ptr_event);
 8029e5e:	68fb      	ldr	r3, [r7, #12]
 8029e60:	689a      	ldr	r2, [r3, #8]
 8029e62:	7afb      	ldrb	r3, [r7, #11]
 8029e64:	2107      	movs	r1, #7
 8029e66:	fa01 f303 	lsl.w	r3, r1, r3
 8029e6a:	43db      	mvns	r3, r3
 8029e6c:	401a      	ands	r2, r3
 8029e6e:	7afb      	ldrb	r3, [r7, #11]
 8029e70:	6879      	ldr	r1, [r7, #4]
 8029e72:	fa01 f303 	lsl.w	r3, r1, r3
 8029e76:	431a      	orrs	r2, r3
 8029e78:	68fb      	ldr	r3, [r7, #12]
 8029e7a:	609a      	str	r2, [r3, #8]
}
 8029e7c:	bf00      	nop
 8029e7e:	3714      	adds	r7, #20
 8029e80:	46bd      	mov	sp, r7
 8029e82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029e86:	4770      	bx	lr

08029e88 <XMC_CAN_NODE_SetReceiveInput>:
{
 8029e88:	b480      	push	{r7}
 8029e8a:	b083      	sub	sp, #12
 8029e8c:	af00      	add	r7, sp, #0
 8029e8e:	6078      	str	r0, [r7, #4]
 8029e90:	460b      	mov	r3, r1
 8029e92:	70fb      	strb	r3, [r7, #3]
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 8029e94:	687b      	ldr	r3, [r7, #4]
 8029e96:	68db      	ldr	r3, [r3, #12]
 8029e98:	f023 0207 	bic.w	r2, r3, #7
                   (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Msk);
 8029e9c:	78fb      	ldrb	r3, [r7, #3]
 8029e9e:	f003 0307 	and.w	r3, r3, #7
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 8029ea2:	431a      	orrs	r2, r3
 8029ea4:	687b      	ldr	r3, [r7, #4]
 8029ea6:	60da      	str	r2, [r3, #12]
}
 8029ea8:	bf00      	nop
 8029eaa:	370c      	adds	r7, #12
 8029eac:	46bd      	mov	sp, r7
 8029eae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029eb2:	4770      	bx	lr

08029eb4 <XMC_CAN_NODE_EnableLoopBack>:
{
 8029eb4:	b480      	push	{r7}
 8029eb6:	b083      	sub	sp, #12
 8029eb8:	af00      	add	r7, sp, #0
 8029eba:	6078      	str	r0, [r7, #4]
  can_node->NPCR |= (uint32_t)CAN_NODE_NPCR_LBM_Msk;
 8029ebc:	687b      	ldr	r3, [r7, #4]
 8029ebe:	68db      	ldr	r3, [r3, #12]
 8029ec0:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8029ec4:	687b      	ldr	r3, [r7, #4]
 8029ec6:	60da      	str	r2, [r3, #12]
}
 8029ec8:	bf00      	nop
 8029eca:	370c      	adds	r7, #12
 8029ecc:	46bd      	mov	sp, r7
 8029ece:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029ed2:	4770      	bx	lr

08029ed4 <XMC_CAN_NODE_GetStatus>:
{
 8029ed4:	b480      	push	{r7}
 8029ed6:	b083      	sub	sp, #12
 8029ed8:	af00      	add	r7, sp, #0
 8029eda:	6078      	str	r0, [r7, #4]
  return ((can_node->NSR));
 8029edc:	687b      	ldr	r3, [r7, #4]
 8029ede:	685b      	ldr	r3, [r3, #4]
}
 8029ee0:	4618      	mov	r0, r3
 8029ee2:	370c      	adds	r7, #12
 8029ee4:	46bd      	mov	sp, r7
 8029ee6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029eea:	4770      	bx	lr

08029eec <XMC_CAN_NODE_EnableConfigurationChange>:
{
 8029eec:	b480      	push	{r7}
 8029eee:	b083      	sub	sp, #12
 8029ef0:	af00      	add	r7, sp, #0
 8029ef2:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8029ef4:	687b      	ldr	r3, [r7, #4]
 8029ef6:	681b      	ldr	r3, [r3, #0]
 8029ef8:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8029efc:	687b      	ldr	r3, [r7, #4]
 8029efe:	601a      	str	r2, [r3, #0]
}
 8029f00:	bf00      	nop
 8029f02:	370c      	adds	r7, #12
 8029f04:	46bd      	mov	sp, r7
 8029f06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029f0a:	4770      	bx	lr

08029f0c <XMC_CAN_NODE_DisableConfigurationChange>:
{
 8029f0c:	b480      	push	{r7}
 8029f0e:	b083      	sub	sp, #12
 8029f10:	af00      	add	r7, sp, #0
 8029f12:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 8029f14:	687b      	ldr	r3, [r7, #4]
 8029f16:	681b      	ldr	r3, [r3, #0]
 8029f18:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8029f1c:	687b      	ldr	r3, [r7, #4]
 8029f1e:	601a      	str	r2, [r3, #0]
}
 8029f20:	bf00      	nop
 8029f22:	370c      	adds	r7, #12
 8029f24:	46bd      	mov	sp, r7
 8029f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029f2a:	4770      	bx	lr

08029f2c <XMC_CAN_NODE_SetInitBit>:
 * XMC_CAN_NODE_ResetInitBit()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_SetInitBit(XMC_CAN_NODE_t *const can_node)
{
 8029f2c:	b480      	push	{r7}
 8029f2e:	b083      	sub	sp, #12
 8029f30:	af00      	add	r7, sp, #0
 8029f32:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_INIT_Msk;
 8029f34:	687b      	ldr	r3, [r7, #4]
 8029f36:	681b      	ldr	r3, [r3, #0]
 8029f38:	f043 0201 	orr.w	r2, r3, #1
 8029f3c:	687b      	ldr	r3, [r7, #4]
 8029f3e:	601a      	str	r2, [r3, #0]
}
 8029f40:	bf00      	nop
 8029f42:	370c      	adds	r7, #12
 8029f44:	46bd      	mov	sp, r7
 8029f46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029f4a:	4770      	bx	lr

08029f4c <XMC_CAN_NODE_ResetInitBit>:
 * \par<b>Related API's:</b><br>
 * XMC_CAN_NODE_SetInitBit()
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_ResetInitBit(XMC_CAN_NODE_t *const can_node)
{
 8029f4c:	b480      	push	{r7}
 8029f4e:	b083      	sub	sp, #12
 8029f50:	af00      	add	r7, sp, #0
 8029f52:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_INIT_Msk;
 8029f54:	687b      	ldr	r3, [r7, #4]
 8029f56:	681b      	ldr	r3, [r3, #0]
 8029f58:	f023 0201 	bic.w	r2, r3, #1
 8029f5c:	687b      	ldr	r3, [r7, #4]
 8029f5e:	601a      	str	r2, [r3, #0]
}
 8029f60:	bf00      	nop
 8029f62:	370c      	adds	r7, #12
 8029f64:	46bd      	mov	sp, r7
 8029f66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029f6a:	4770      	bx	lr

08029f6c <XMC_CAN_NODE_ReSetAnalyzerMode>:
 * XMC_CAN_NODE_SetAnalyzerMode()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_ReSetAnalyzerMode(XMC_CAN_NODE_t *const can_node)
{
 8029f6c:	b480      	push	{r7}
 8029f6e:	b083      	sub	sp, #12
 8029f70:	af00      	add	r7, sp, #0
 8029f72:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CALM_Msk;
 8029f74:	687b      	ldr	r3, [r7, #4]
 8029f76:	681b      	ldr	r3, [r3, #0]
 8029f78:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8029f7c:	687b      	ldr	r3, [r7, #4]
 8029f7e:	601a      	str	r2, [r3, #0]
}
 8029f80:	bf00      	nop
 8029f82:	370c      	adds	r7, #12
 8029f84:	46bd      	mov	sp, r7
 8029f86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029f8a:	4770      	bx	lr

08029f8c <XMC_CAN_MO_SetEventNodePointer>:
 */

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
    const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
    const uint32_t service_request)
{
 8029f8c:	b480      	push	{r7}
 8029f8e:	b085      	sub	sp, #20
 8029f90:	af00      	add	r7, sp, #0
 8029f92:	60f8      	str	r0, [r7, #12]
 8029f94:	460b      	mov	r3, r1
 8029f96:	607a      	str	r2, [r7, #4]
 8029f98:	72fb      	strb	r3, [r7, #11]
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 8029f9a:	68fb      	ldr	r3, [r7, #12]
 8029f9c:	681b      	ldr	r3, [r3, #0]
 8029f9e:	689a      	ldr	r2, [r3, #8]
 8029fa0:	7afb      	ldrb	r3, [r7, #11]
 8029fa2:	2107      	movs	r1, #7
 8029fa4:	fa01 f303 	lsl.w	r3, r1, r3
 8029fa8:	43db      	mvns	r3, r3
 8029faa:	ea02 0103 	and.w	r1, r2, r3
                              (service_request << (uint32_t)can_mo_ptr_int);
 8029fae:	7afb      	ldrb	r3, [r7, #11]
 8029fb0:	687a      	ldr	r2, [r7, #4]
 8029fb2:	409a      	lsls	r2, r3
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 8029fb4:	68fb      	ldr	r3, [r7, #12]
 8029fb6:	681b      	ldr	r3, [r3, #0]
 8029fb8:	430a      	orrs	r2, r1
 8029fba:	609a      	str	r2, [r3, #8]
}
 8029fbc:	bf00      	nop
 8029fbe:	3714      	adds	r7, #20
 8029fc0:	46bd      	mov	sp, r7
 8029fc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029fc6:	4770      	bx	lr

08029fc8 <XMC_CAN_MO_EnableEvent>:
 *
 */

__STATIC_INLINE void XMC_CAN_MO_EnableEvent(const XMC_CAN_MO_t *const can_mo,
    const uint32_t event)
{
 8029fc8:	b480      	push	{r7}
 8029fca:	b083      	sub	sp, #12
 8029fcc:	af00      	add	r7, sp, #0
 8029fce:	6078      	str	r0, [r7, #4]
 8029fd0:	6039      	str	r1, [r7, #0]
  can_mo->can_mo_ptr->MOFCR |= event;
 8029fd2:	687b      	ldr	r3, [r7, #4]
 8029fd4:	681b      	ldr	r3, [r3, #0]
 8029fd6:	6819      	ldr	r1, [r3, #0]
 8029fd8:	687b      	ldr	r3, [r7, #4]
 8029fda:	681b      	ldr	r3, [r3, #0]
 8029fdc:	683a      	ldr	r2, [r7, #0]
 8029fde:	430a      	orrs	r2, r1
 8029fe0:	601a      	str	r2, [r3, #0]
}
 8029fe2:	bf00      	nop
 8029fe4:	370c      	adds	r7, #12
 8029fe6:	46bd      	mov	sp, r7
 8029fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029fec:	4770      	bx	lr

08029fee <CAN_NODE_MO_EnableTxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableTxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
 8029fee:	b580      	push	{r7, lr}
 8029ff0:	b082      	sub	sp, #8
 8029ff2:	af00      	add	r7, sp, #0
 8029ff4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableTxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_TRANSMIT);
 8029ff6:	687b      	ldr	r3, [r7, #4]
 8029ff8:	681b      	ldr	r3, [r3, #0]
 8029ffa:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8029ffe:	4618      	mov	r0, r3
 802a000:	f7ff ffe2 	bl	8029fc8 <XMC_CAN_MO_EnableEvent>
}
 802a004:	bf00      	nop
 802a006:	3708      	adds	r7, #8
 802a008:	46bd      	mov	sp, r7
 802a00a:	bd80      	pop	{r7, pc}

0802a00c <CAN_NODE_MO_EnableRxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableRxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
 802a00c:	b580      	push	{r7, lr}
 802a00e:	b082      	sub	sp, #8
 802a010:	af00      	add	r7, sp, #0
 802a012:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableRxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_RECEIVE);
 802a014:	687b      	ldr	r3, [r7, #4]
 802a016:	681b      	ldr	r3, [r3, #0]
 802a018:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 802a01c:	4618      	mov	r0, r3
 802a01e:	f7ff ffd3 	bl	8029fc8 <XMC_CAN_MO_EnableEvent>
}
 802a022:	bf00      	nop
 802a024:	3708      	adds	r7, #8
 802a026:	46bd      	mov	sp, r7
 802a028:	bd80      	pop	{r7, pc}

0802a02a <CAN_NODE_SetNodeEvents>:
  * @param  handle is a pointer pointing to APP data structure.
  * @return None
  */

static void CAN_NODE_SetNodeEvents(const CAN_NODE_t *handle)
{
 802a02a:	b580      	push	{r7, lr}
 802a02c:	b084      	sub	sp, #16
 802a02e:	af00      	add	r7, sp, #0
 802a030:	6078      	str	r0, [r7, #4]
  uint32_t lnode_event = 0U;
 802a032:	2300      	movs	r3, #0
 802a034:	60fb      	str	r3, [r7, #12]

  XMC_ASSERT("CAN_NODE_lInit: handle null", handle != NULL);

  CAN_NODE_SetNodePointer(handle); /* set node service pointer */
 802a036:	6878      	ldr	r0, [r7, #4]
 802a038:	f000 f831 	bl	802a09e <CAN_NODE_SetNodePointer>

  if (handle->txok_event_enable == true)
 802a03c:	687b      	ldr	r3, [r7, #4]
 802a03e:	f893 30a4 	ldrb.w	r3, [r3, #164]	; 0xa4
 802a042:	2b00      	cmp	r3, #0
 802a044:	d003      	beq.n	802a04e <CAN_NODE_SetNodeEvents+0x24>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_TX_INT;
 802a046:	68fb      	ldr	r3, [r7, #12]
 802a048:	f043 0302 	orr.w	r3, r3, #2
 802a04c:	60fb      	str	r3, [r7, #12]
  }
  if (handle->lec_event_enable == true)
 802a04e:	687b      	ldr	r3, [r7, #4]
 802a050:	f893 30a3 	ldrb.w	r3, [r3, #163]	; 0xa3
 802a054:	2b00      	cmp	r3, #0
 802a056:	d003      	beq.n	802a060 <CAN_NODE_SetNodeEvents+0x36>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_LEC;
 802a058:	68fb      	ldr	r3, [r7, #12]
 802a05a:	f043 0304 	orr.w	r3, r3, #4
 802a05e:	60fb      	str	r3, [r7, #12]
  }
  if (handle->alert_event_enable == true)
 802a060:	687b      	ldr	r3, [r7, #4]
 802a062:	f893 30a5 	ldrb.w	r3, [r3, #165]	; 0xa5
 802a066:	2b00      	cmp	r3, #0
 802a068:	d003      	beq.n	802a072 <CAN_NODE_SetNodeEvents+0x48>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_ALERT;
 802a06a:	68fb      	ldr	r3, [r7, #12]
 802a06c:	f043 0308 	orr.w	r3, r3, #8
 802a070:	60fb      	str	r3, [r7, #12]
  }
  XMC_CAN_NODE_EnableEvent(handle->node_ptr, (XMC_CAN_NODE_EVENT_t)lnode_event);
 802a072:	687b      	ldr	r3, [r7, #4]
 802a074:	685b      	ldr	r3, [r3, #4]
 802a076:	68f9      	ldr	r1, [r7, #12]
 802a078:	4618      	mov	r0, r3
 802a07a:	f7fd fb56 	bl	802772a <XMC_CAN_NODE_EnableEvent>

  if (handle->framecount_event_enable == true)
 802a07e:	687b      	ldr	r3, [r7, #4]
 802a080:	f893 30a6 	ldrb.w	r3, [r3, #166]	; 0xa6
 802a084:	2b00      	cmp	r3, #0
 802a086:	d006      	beq.n	802a096 <CAN_NODE_SetNodeEvents+0x6c>
  {
    XMC_CAN_NODE_EnableEvent(handle->node_ptr, XMC_CAN_NODE_EVENT_CFCIE);
 802a088:	687b      	ldr	r3, [r7, #4]
 802a08a:	685b      	ldr	r3, [r3, #4]
 802a08c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 802a090:	4618      	mov	r0, r3
 802a092:	f7fd fb4a 	bl	802772a <XMC_CAN_NODE_EnableEvent>
  }

}
 802a096:	bf00      	nop
 802a098:	3710      	adds	r7, #16
 802a09a:	46bd      	mov	sp, r7
 802a09c:	bd80      	pop	{r7, pc}

0802a09e <CAN_NODE_SetNodePointer>:
  * @brief  Function to set the Node event pointer
  *
  */

static void CAN_NODE_SetNodePointer(const CAN_NODE_t *handle)
{
 802a09e:	b580      	push	{r7, lr}
 802a0a0:	b082      	sub	sp, #8
 802a0a2:	af00      	add	r7, sp, #0
 802a0a4:	6078      	str	r0, [r7, #4]

  XMC_ASSERT("CAN_NODE_SetNodePointer: handle null", handle != NULL);

  /* Configured the node event pointer for the alert event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
 802a0a6:	687b      	ldr	r3, [r7, #4]
 802a0a8:	6858      	ldr	r0, [r3, #4]
                                                        handle->node_sr_ptr->alert_event_sr);
 802a0aa:	687b      	ldr	r3, [r7, #4]
 802a0ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 802a0b0:	781b      	ldrb	r3, [r3, #0]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
 802a0b2:	461a      	mov	r2, r3
 802a0b4:	2100      	movs	r1, #0
 802a0b6:	f7ff fecb 	bl	8029e50 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the LEC event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
 802a0ba:	687b      	ldr	r3, [r7, #4]
 802a0bc:	6858      	ldr	r0, [r3, #4]
                                                         handle->node_sr_ptr->lec_event_sr);
 802a0be:	687b      	ldr	r3, [r7, #4]
 802a0c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 802a0c4:	785b      	ldrb	r3, [r3, #1]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
 802a0c6:	461a      	mov	r2, r3
 802a0c8:	2104      	movs	r1, #4
 802a0ca:	f7ff fec1 	bl	8029e50 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the TXOK event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
 802a0ce:	687b      	ldr	r3, [r7, #4]
 802a0d0:	6858      	ldr	r0, [r3, #4]
                                                               handle->node_sr_ptr->txok_event_sr);
 802a0d2:	687b      	ldr	r3, [r7, #4]
 802a0d4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 802a0d8:	789b      	ldrb	r3, [r3, #2]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
 802a0da:	461a      	mov	r2, r3
 802a0dc:	2108      	movs	r1, #8
 802a0de:	f7ff feb7 	bl	8029e50 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the Frame counter event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
 802a0e2:	687b      	ldr	r3, [r7, #4]
 802a0e4:	6858      	ldr	r0, [r3, #4]
                                                             handle->node_sr_ptr->framecount_event_sr);
 802a0e6:	687b      	ldr	r3, [r7, #4]
 802a0e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 802a0ec:	78db      	ldrb	r3, [r3, #3]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
 802a0ee:	461a      	mov	r2, r3
 802a0f0:	210c      	movs	r1, #12
 802a0f2:	f7ff fead 	bl	8029e50 <XMC_CAN_NODE_SetEventNodePointer>

}
 802a0f6:	bf00      	nop
 802a0f8:	3708      	adds	r7, #8
 802a0fa:	46bd      	mov	sp, r7
 802a0fc:	bd80      	pop	{r7, pc}

0802a0fe <CAN_NODE_MO_Init>:
  XMC_CAN_NODE_NominalBitTimeConfigure(can_node, can_bit_time);
}

/*  Function to initialize the CAN MO based on UI configuration. */
void CAN_NODE_MO_Init(const CAN_NODE_LMO_t *lmo_ptr)
{
 802a0fe:	b580      	push	{r7, lr}
 802a100:	b082      	sub	sp, #8
 802a102:	af00      	add	r7, sp, #0
 802a104:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_Init: lmo_ptr null", lmo_ptr != NULL);

  XMC_CAN_MO_Config(lmo_ptr->mo_ptr);
 802a106:	687b      	ldr	r3, [r7, #4]
 802a108:	681b      	ldr	r3, [r3, #0]
 802a10a:	4618      	mov	r0, r3
 802a10c:	f7fd f942 	bl	8027394 <XMC_CAN_MO_Config>

  if (lmo_ptr->tx_event_enable == true)
 802a110:	687b      	ldr	r3, [r7, #4]
 802a112:	79db      	ldrb	r3, [r3, #7]
 802a114:	2b00      	cmp	r3, #0
 802a116:	d00a      	beq.n	802a12e <CAN_NODE_MO_Init+0x30>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_TRANSMIT, lmo_ptr->tx_sr);
 802a118:	687b      	ldr	r3, [r7, #4]
 802a11a:	6818      	ldr	r0, [r3, #0]
 802a11c:	687b      	ldr	r3, [r7, #4]
 802a11e:	795b      	ldrb	r3, [r3, #5]
 802a120:	461a      	mov	r2, r3
 802a122:	2104      	movs	r1, #4
 802a124:	f7ff ff32 	bl	8029f8c <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableTxEvent(lmo_ptr);
 802a128:	6878      	ldr	r0, [r7, #4]
 802a12a:	f7ff ff60 	bl	8029fee <CAN_NODE_MO_EnableTxEvent>
  }
  if (lmo_ptr->rx_event_enable == true)
 802a12e:	687b      	ldr	r3, [r7, #4]
 802a130:	7a1b      	ldrb	r3, [r3, #8]
 802a132:	2b00      	cmp	r3, #0
 802a134:	d00a      	beq.n	802a14c <CAN_NODE_MO_Init+0x4e>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_RECEIVE, lmo_ptr->rx_sr);
 802a136:	687b      	ldr	r3, [r7, #4]
 802a138:	6818      	ldr	r0, [r3, #0]
 802a13a:	687b      	ldr	r3, [r7, #4]
 802a13c:	799b      	ldrb	r3, [r3, #6]
 802a13e:	461a      	mov	r2, r3
 802a140:	2100      	movs	r1, #0
 802a142:	f7ff ff23 	bl	8029f8c <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableRxEvent(lmo_ptr);
 802a146:	6878      	ldr	r0, [r7, #4]
 802a148:	f7ff ff60 	bl	802a00c <CAN_NODE_MO_EnableRxEvent>
  }

}
 802a14c:	bf00      	nop
 802a14e:	3708      	adds	r7, #8
 802a150:	46bd      	mov	sp, r7
 802a152:	bd80      	pop	{r7, pc}

0802a154 <CAN_NODE_MO_Transmit>:

/* Function to transmit the can MO frame.  */
CAN_NODE_STATUS_t CAN_NODE_MO_Transmit(const CAN_NODE_LMO_t *lmo_ptr)
{
 802a154:	b580      	push	{r7, lr}
 802a156:	b084      	sub	sp, #16
 802a158:	af00      	add	r7, sp, #0
 802a15a:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a15c:	2300      	movs	r3, #0
 802a15e:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("CAN_NODE_MO_Transmit: lmo_ptr null", lmo_ptr != NULL);

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_Transmit(lmo_ptr->mo_ptr);
 802a160:	687b      	ldr	r3, [r7, #4]
 802a162:	681b      	ldr	r3, [r3, #0]
 802a164:	4618      	mov	r0, r3
 802a166:	f7fd f9e9 	bl	802753c <XMC_CAN_MO_Transmit>
 802a16a:	4603      	mov	r3, r0
 802a16c:	73fb      	strb	r3, [r7, #15]
  return (status);
 802a16e:	7bfb      	ldrb	r3, [r7, #15]
}
 802a170:	4618      	mov	r0, r3
 802a172:	3710      	adds	r7, #16
 802a174:	46bd      	mov	sp, r7
 802a176:	bd80      	pop	{r7, pc}

0802a178 <CAN_NODE_MO_Receive>:

/* Function to read the received CAN message from the selected message object. */
CAN_NODE_STATUS_t CAN_NODE_MO_Receive( CAN_NODE_LMO_t *lmo_ptr)
{
 802a178:	b580      	push	{r7, lr}
 802a17a:	b084      	sub	sp, #16
 802a17c:	af00      	add	r7, sp, #0
 802a17e:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a180:	2300      	movs	r3, #0
 802a182:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("CAN_NODE_MO_Receive: lmo_ptr null", lmo_ptr != NULL);

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_Receive(lmo_ptr->mo_ptr);
 802a184:	687b      	ldr	r3, [r7, #4]
 802a186:	681b      	ldr	r3, [r3, #0]
 802a188:	4618      	mov	r0, r3
 802a18a:	f7fd fa05 	bl	8027598 <XMC_CAN_MO_Receive>
 802a18e:	4603      	mov	r3, r0
 802a190:	73fb      	strb	r3, [r7, #15]
  return (status);
 802a192:	7bfb      	ldrb	r3, [r7, #15]
}
 802a194:	4618      	mov	r0, r3
 802a196:	3710      	adds	r7, #16
 802a198:	46bd      	mov	sp, r7
 802a19a:	bd80      	pop	{r7, pc}

0802a19c <CAN_NODE_MO_UpdateData>:
  return (status);
}

/* Function to updates the data for the CAN Message Object. */
CAN_NODE_STATUS_t CAN_NODE_MO_UpdateData(const CAN_NODE_LMO_t *const lmo_ptr, uint8_t *array_data)
{
 802a19c:	b580      	push	{r7, lr}
 802a19e:	b084      	sub	sp, #16
 802a1a0:	af00      	add	r7, sp, #0
 802a1a2:	6078      	str	r0, [r7, #4]
 802a1a4:	6039      	str	r1, [r7, #0]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a1a6:	2300      	movs	r3, #0
 802a1a8:	73fb      	strb	r3, [r7, #15]
  uint32_t *data_pointer = (uint32_t*) array_data;
 802a1aa:	683b      	ldr	r3, [r7, #0]
 802a1ac:	60bb      	str	r3, [r7, #8]

  XMC_ASSERT("CAN_NODE_MO_UpdateData: lmo_ptr null", lmo_ptr != NULL);

  lmo_ptr->mo_ptr->can_data[0U] = *data_pointer;
 802a1ae:	687b      	ldr	r3, [r7, #4]
 802a1b0:	681b      	ldr	r3, [r3, #0]
 802a1b2:	68ba      	ldr	r2, [r7, #8]
 802a1b4:	6812      	ldr	r2, [r2, #0]
 802a1b6:	611a      	str	r2, [r3, #16]
  lmo_ptr->mo_ptr->can_data[1U] = *(data_pointer + 1U);
 802a1b8:	687b      	ldr	r3, [r7, #4]
 802a1ba:	681b      	ldr	r3, [r3, #0]
 802a1bc:	68ba      	ldr	r2, [r7, #8]
 802a1be:	6852      	ldr	r2, [r2, #4]
 802a1c0:	615a      	str	r2, [r3, #20]

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_UpdateData(lmo_ptr->mo_ptr);
 802a1c2:	687b      	ldr	r3, [r7, #4]
 802a1c4:	681b      	ldr	r3, [r3, #0]
 802a1c6:	4618      	mov	r0, r3
 802a1c8:	f7fd f980 	bl	80274cc <XMC_CAN_MO_UpdateData>
 802a1cc:	4603      	mov	r3, r0
 802a1ce:	73fb      	strb	r3, [r7, #15]
  return (status);
 802a1d0:	7bfb      	ldrb	r3, [r7, #15]
}
 802a1d2:	4618      	mov	r0, r3
 802a1d4:	3710      	adds	r7, #16
 802a1d6:	46bd      	mov	sp, r7
 802a1d8:	bd80      	pop	{r7, pc}

0802a1da <CAN_NODE_GetStatus>:

}

/* Function to read the current status of the CAN node  */
uint32_t CAN_NODE_GetStatus(const CAN_NODE_t* handle)
{
 802a1da:	b580      	push	{r7, lr}
 802a1dc:	b084      	sub	sp, #16
 802a1de:	af00      	add	r7, sp, #0
 802a1e0:	6078      	str	r0, [r7, #4]
  uint32_t  status;

  XMC_ASSERT("CAN_NODE_GetStatus: handle null", handle != NULL);

  XMC_CAN_NODE_t *const can_node = handle->node_ptr;
 802a1e2:	687b      	ldr	r3, [r7, #4]
 802a1e4:	685b      	ldr	r3, [r3, #4]
 802a1e6:	60fb      	str	r3, [r7, #12]

  status = XMC_CAN_NODE_GetStatus(can_node);
 802a1e8:	68f8      	ldr	r0, [r7, #12]
 802a1ea:	f7ff fe73 	bl	8029ed4 <XMC_CAN_NODE_GetStatus>
 802a1ee:	60b8      	str	r0, [r7, #8]
  return (status);
 802a1f0:	68bb      	ldr	r3, [r7, #8]
}
 802a1f2:	4618      	mov	r0, r3
 802a1f4:	3710      	adds	r7, #16
 802a1f6:	46bd      	mov	sp, r7
 802a1f8:	bd80      	pop	{r7, pc}

0802a1fa <CAN_NODE_Init>:
/*  Function to initialize the CAN node by configuring the baud rate, can bus type (External or internal)
 *  and message objects.
 */

CAN_NODE_STATUS_t CAN_NODE_Init(const CAN_NODE_t* handle)
{
 802a1fa:	b580      	push	{r7, lr}
 802a1fc:	b086      	sub	sp, #24
 802a1fe:	af00      	add	r7, sp, #0
 802a200:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a202:	2300      	movs	r3, #0
 802a204:	75fb      	strb	r3, [r7, #23]
  uint32_t loop_count;
  const CAN_NODE_LMO_t *lmo_ptr;

  XMC_ASSERT("CAN_NODE_Init: handle null", handle != NULL);

  const CAN_NODE_GPIO_t *const lgpio_ptr = handle->gpio_out;
 802a206:	687b      	ldr	r3, [r7, #4]
 802a208:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 802a20c:	60fb      	str	r3, [r7, #12]

  /* Initialize the GLOBAL_CAN APP */
  status  = (CAN_NODE_STATUS_t)GLOBAL_CAN_Init(handle->global_ptr);
 802a20e:	687b      	ldr	r3, [r7, #4]
 802a210:	681b      	ldr	r3, [r3, #0]
 802a212:	4618      	mov	r0, r3
 802a214:	f7ff fcb5 	bl	8029b82 <GLOBAL_CAN_Init>
 802a218:	4603      	mov	r3, r0
 802a21a:	75fb      	strb	r3, [r7, #23]

  if (status == CAN_NODE_STATUS_SUCCESS)
 802a21c:	7dfb      	ldrb	r3, [r7, #23]
 802a21e:	2b00      	cmp	r3, #0
 802a220:	f040 8081 	bne.w	802a326 <CAN_NODE_Init+0x12c>
  {
    /* Initialize the GUI configured values for baud rate to NBTR Reg */
    if (XMC_CAN_NODE_NominalBitTimeConfigureEx(handle->node_ptr, handle->baudrate_config) == XMC_CAN_STATUS_SUCCESS)
 802a224:	687b      	ldr	r3, [r7, #4]
 802a226:	685a      	ldr	r2, [r3, #4]
 802a228:	687b      	ldr	r3, [r7, #4]
 802a22a:	689b      	ldr	r3, [r3, #8]
 802a22c:	4619      	mov	r1, r3
 802a22e:	4610      	mov	r0, r2
 802a230:	f7fc ff3c 	bl	80270ac <XMC_CAN_NODE_NominalBitTimeConfigureEx>
 802a234:	4603      	mov	r3, r0
 802a236:	2b00      	cmp	r3, #0
 802a238:	d172      	bne.n	802a320 <CAN_NODE_Init+0x126>
    {
      /* set CCE and INIT bit NCR for node configuration */

      XMC_CAN_NODE_EnableConfigurationChange(handle->node_ptr);
 802a23a:	687b      	ldr	r3, [r7, #4]
 802a23c:	685b      	ldr	r3, [r3, #4]
 802a23e:	4618      	mov	r0, r3
 802a240:	f7ff fe54 	bl	8029eec <XMC_CAN_NODE_EnableConfigurationChange>
      XMC_CAN_NODE_SetInitBit(handle->node_ptr);
 802a244:	687b      	ldr	r3, [r7, #4]
 802a246:	685b      	ldr	r3, [r3, #4]
 802a248:	4618      	mov	r0, r3
 802a24a:	f7ff fe6f 	bl	8029f2c <XMC_CAN_NODE_SetInitBit>
      XMC_CAN_NODE_ReSetAnalyzerMode(handle->node_ptr);
 802a24e:	687b      	ldr	r3, [r7, #4]
 802a250:	685b      	ldr	r3, [r3, #4]
 802a252:	4618      	mov	r0, r3
 802a254:	f7ff fe8a 	bl	8029f6c <XMC_CAN_NODE_ReSetAnalyzerMode>

      if (handle->loopback_enable == true) /* Loop back mode enabled */
 802a258:	687b      	ldr	r3, [r7, #4]
 802a25a:	f893 30a7 	ldrb.w	r3, [r3, #167]	; 0xa7
 802a25e:	2b00      	cmp	r3, #0
 802a260:	d005      	beq.n	802a26e <CAN_NODE_Init+0x74>
      {
        XMC_CAN_NODE_EnableLoopBack(handle->node_ptr);
 802a262:	687b      	ldr	r3, [r7, #4]
 802a264:	685b      	ldr	r3, [r3, #4]
 802a266:	4618      	mov	r0, r3
 802a268:	f7ff fe24 	bl	8029eb4 <XMC_CAN_NODE_EnableLoopBack>
 802a26c:	e016      	b.n	802a29c <CAN_NODE_Init+0xa2>
      }
      else
      {
        XMC_GPIO_Init(handle->gpio_in->port, handle->gpio_in->pin, handle->gpio_in_config);
 802a26e:	687b      	ldr	r3, [r7, #4]
 802a270:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 802a274:	6818      	ldr	r0, [r3, #0]
 802a276:	687b      	ldr	r3, [r7, #4]
 802a278:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 802a27c:	7919      	ldrb	r1, [r3, #4]
 802a27e:	687b      	ldr	r3, [r7, #4]
 802a280:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 802a284:	461a      	mov	r2, r3
 802a286:	f7fc f9c1 	bl	802660c <XMC_GPIO_Init>
        XMC_CAN_NODE_SetReceiveInput(handle->node_ptr, handle->rx_signal);
 802a28a:	687b      	ldr	r3, [r7, #4]
 802a28c:	685a      	ldr	r2, [r3, #4]
 802a28e:	687b      	ldr	r3, [r7, #4]
 802a290:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
 802a294:	4619      	mov	r1, r3
 802a296:	4610      	mov	r0, r2
 802a298:	f7ff fdf6 	bl	8029e88 <XMC_CAN_NODE_SetReceiveInput>
      }
      CAN_NODE_SetNodeEvents(handle); /* API to enable node events */
 802a29c:	6878      	ldr	r0, [r7, #4]
 802a29e:	f7ff fec4 	bl	802a02a <CAN_NODE_SetNodeEvents>

      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
 802a2a2:	2300      	movs	r3, #0
 802a2a4:	613b      	str	r3, [r7, #16]
 802a2a6:	e017      	b.n	802a2d8 <CAN_NODE_Init+0xde>
      {
        lmo_ptr = handle->lmobj_ptr[loop_count];
 802a2a8:	687a      	ldr	r2, [r7, #4]
 802a2aa:	693b      	ldr	r3, [r7, #16]
 802a2ac:	3302      	adds	r3, #2
 802a2ae:	009b      	lsls	r3, r3, #2
 802a2b0:	4413      	add	r3, r2
 802a2b2:	685b      	ldr	r3, [r3, #4]
 802a2b4:	60bb      	str	r3, [r7, #8]
        XMC_CAN_AllocateMOtoNodeList(handle->global_ptr->canglobal_ptr, handle->node_num, lmo_ptr->number);
 802a2b6:	687b      	ldr	r3, [r7, #4]
 802a2b8:	681b      	ldr	r3, [r3, #0]
 802a2ba:	6858      	ldr	r0, [r3, #4]
 802a2bc:	687b      	ldr	r3, [r7, #4]
 802a2be:	f893 10a1 	ldrb.w	r1, [r3, #161]	; 0xa1
 802a2c2:	68bb      	ldr	r3, [r7, #8]
 802a2c4:	791b      	ldrb	r3, [r3, #4]
 802a2c6:	461a      	mov	r2, r3
 802a2c8:	f7fc ff9a 	bl	8027200 <XMC_CAN_AllocateMOtoNodeList>
        CAN_NODE_MO_Init(lmo_ptr);
 802a2cc:	68b8      	ldr	r0, [r7, #8]
 802a2ce:	f7ff ff16 	bl	802a0fe <CAN_NODE_MO_Init>
      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
 802a2d2:	693b      	ldr	r3, [r7, #16]
 802a2d4:	3301      	adds	r3, #1
 802a2d6:	613b      	str	r3, [r7, #16]
 802a2d8:	687b      	ldr	r3, [r7, #4]
 802a2da:	f893 30a2 	ldrb.w	r3, [r3, #162]	; 0xa2
 802a2de:	461a      	mov	r2, r3
 802a2e0:	693b      	ldr	r3, [r7, #16]
 802a2e2:	4293      	cmp	r3, r2
 802a2e4:	d3e0      	bcc.n	802a2a8 <CAN_NODE_Init+0xae>
      }
      /* reset CCE and INIT bit NCR for node configuration */
      XMC_CAN_NODE_DisableConfigurationChange(handle->node_ptr);
 802a2e6:	687b      	ldr	r3, [r7, #4]
 802a2e8:	685b      	ldr	r3, [r3, #4]
 802a2ea:	4618      	mov	r0, r3
 802a2ec:	f7ff fe0e 	bl	8029f0c <XMC_CAN_NODE_DisableConfigurationChange>
      XMC_CAN_NODE_ResetInitBit(handle->node_ptr);
 802a2f0:	687b      	ldr	r3, [r7, #4]
 802a2f2:	685b      	ldr	r3, [r3, #4]
 802a2f4:	4618      	mov	r0, r3
 802a2f6:	f7ff fe29 	bl	8029f4c <XMC_CAN_NODE_ResetInitBit>
      if (handle->loopback_enable == false)
 802a2fa:	687b      	ldr	r3, [r7, #4]
 802a2fc:	f893 30a7 	ldrb.w	r3, [r3, #167]	; 0xa7
 802a300:	f083 0301 	eor.w	r3, r3, #1
 802a304:	b2db      	uxtb	r3, r3
 802a306:	2b00      	cmp	r3, #0
 802a308:	d00f      	beq.n	802a32a <CAN_NODE_Init+0x130>
      {
        /* CAN transmit pin configuration */
        XMC_GPIO_Init(lgpio_ptr->port, lgpio_ptr->pin, handle->gpio_out_config);
 802a30a:	68fb      	ldr	r3, [r7, #12]
 802a30c:	6818      	ldr	r0, [r3, #0]
 802a30e:	68fb      	ldr	r3, [r7, #12]
 802a310:	7919      	ldrb	r1, [r3, #4]
 802a312:	687b      	ldr	r3, [r7, #4]
 802a314:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 802a318:	461a      	mov	r2, r3
 802a31a:	f7fc f977 	bl	802660c <XMC_GPIO_Init>
 802a31e:	e004      	b.n	802a32a <CAN_NODE_Init+0x130>
      }
    }
    else
    {
      status = CAN_NODE_STATUS_FAILURE;
 802a320:	2301      	movs	r3, #1
 802a322:	75fb      	strb	r3, [r7, #23]
 802a324:	e001      	b.n	802a32a <CAN_NODE_Init+0x130>
    }
  }
  else
  {
    status = CAN_NODE_STATUS_FAILURE;
 802a326:	2301      	movs	r3, #1
 802a328:	75fb      	strb	r3, [r7, #23]
  }

  return (status);
 802a32a:	7dfb      	ldrb	r3, [r7, #23]
}
 802a32c:	4618      	mov	r0, r3
 802a32e:	3718      	adds	r7, #24
 802a330:	46bd      	mov	sp, r7
 802a332:	bd80      	pop	{r7, pc}

0802a334 <XMC_GPIO_SetOutputLevel>:
{
 802a334:	b480      	push	{r7}
 802a336:	b085      	sub	sp, #20
 802a338:	af00      	add	r7, sp, #0
 802a33a:	60f8      	str	r0, [r7, #12]
 802a33c:	460b      	mov	r3, r1
 802a33e:	607a      	str	r2, [r7, #4]
 802a340:	72fb      	strb	r3, [r7, #11]
  port->OMR = (uint32_t)level << pin;
 802a342:	7afb      	ldrb	r3, [r7, #11]
 802a344:	687a      	ldr	r2, [r7, #4]
 802a346:	409a      	lsls	r2, r3
 802a348:	68fb      	ldr	r3, [r7, #12]
 802a34a:	605a      	str	r2, [r3, #4]
}
 802a34c:	bf00      	nop
 802a34e:	3714      	adds	r7, #20
 802a350:	46bd      	mov	sp, r7
 802a352:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a356:	4770      	bx	lr

0802a358 <XMC_GPIO_GetInput>:
{
 802a358:	b480      	push	{r7}
 802a35a:	b083      	sub	sp, #12
 802a35c:	af00      	add	r7, sp, #0
 802a35e:	6078      	str	r0, [r7, #4]
 802a360:	460b      	mov	r3, r1
 802a362:	70fb      	strb	r3, [r7, #3]
  return (((port->IN) >> pin) & 0x1U);
 802a364:	687b      	ldr	r3, [r7, #4]
 802a366:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802a368:	78fb      	ldrb	r3, [r7, #3]
 802a36a:	fa22 f303 	lsr.w	r3, r2, r3
 802a36e:	f003 0301 	and.w	r3, r3, #1
}
 802a372:	4618      	mov	r0, r3
 802a374:	370c      	adds	r7, #12
 802a376:	46bd      	mov	sp, r7
 802a378:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a37c:	4770      	bx	lr

0802a37e <BUS_IO_Init>:
* @param handle_ptr Pointer pointing to APP data structure.
* @return BUS_IO_STATUS_t BUS_IO APP status.
*/

BUS_IO_STATUS_t BUS_IO_Init(BUS_IO_t *const handle_ptr)
{
 802a37e:	b580      	push	{r7, lr}
 802a380:	b084      	sub	sp, #16
 802a382:	af00      	add	r7, sp, #0
 802a384:	6078      	str	r0, [r7, #4]
  uint8_t i;

  XMC_ASSERT("BUS_IO_Init: handle_ptr null pointer", handle_ptr != NULL);

  if ((bool)false == handle_ptr->initialized)
 802a386:	687b      	ldr	r3, [r7, #4]
 802a388:	7c5b      	ldrb	r3, [r3, #17]
 802a38a:	f083 0301 	eor.w	r3, r3, #1
 802a38e:	b2db      	uxtb	r3, r3
 802a390:	2b00      	cmp	r3, #0
 802a392:	d01e      	beq.n	802a3d2 <BUS_IO_Init+0x54>
  {
    /* Iterate the list of pins initializing the pin according to the gpio_config */
    for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a394:	2300      	movs	r3, #0
 802a396:	73fb      	strb	r3, [r7, #15]
 802a398:	e013      	b.n	802a3c2 <BUS_IO_Init+0x44>
    {
      /* Initializes input / output characteristics */
      XMC_GPIO_Init(handle_ptr->pin_array[i].gpio_port, handle_ptr->pin_array[i].gpio_pin, &handle_ptr->gpio_config);
 802a39a:	687b      	ldr	r3, [r7, #4]
 802a39c:	681a      	ldr	r2, [r3, #0]
 802a39e:	7bfb      	ldrb	r3, [r7, #15]
 802a3a0:	00db      	lsls	r3, r3, #3
 802a3a2:	4413      	add	r3, r2
 802a3a4:	6818      	ldr	r0, [r3, #0]
 802a3a6:	687b      	ldr	r3, [r7, #4]
 802a3a8:	681a      	ldr	r2, [r3, #0]
 802a3aa:	7bfb      	ldrb	r3, [r7, #15]
 802a3ac:	00db      	lsls	r3, r3, #3
 802a3ae:	4413      	add	r3, r2
 802a3b0:	7919      	ldrb	r1, [r3, #4]
 802a3b2:	687b      	ldr	r3, [r7, #4]
 802a3b4:	3304      	adds	r3, #4
 802a3b6:	461a      	mov	r2, r3
 802a3b8:	f7fc f928 	bl	802660c <XMC_GPIO_Init>
    for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a3bc:	7bfb      	ldrb	r3, [r7, #15]
 802a3be:	3301      	adds	r3, #1
 802a3c0:	73fb      	strb	r3, [r7, #15]
 802a3c2:	687b      	ldr	r3, [r7, #4]
 802a3c4:	7c1b      	ldrb	r3, [r3, #16]
 802a3c6:	7bfa      	ldrb	r2, [r7, #15]
 802a3c8:	429a      	cmp	r2, r3
 802a3ca:	d3e6      	bcc.n	802a39a <BUS_IO_Init+0x1c>
    }
    handle_ptr->initialized = (bool)true;
 802a3cc:	687b      	ldr	r3, [r7, #4]
 802a3ce:	2201      	movs	r2, #1
 802a3d0:	745a      	strb	r2, [r3, #17]
  }
  return (BUS_IO_STATUS_OK);
 802a3d2:	2300      	movs	r3, #0
}
 802a3d4:	4618      	mov	r0, r3
 802a3d6:	3710      	adds	r7, #16
 802a3d8:	46bd      	mov	sp, r7
 802a3da:	bd80      	pop	{r7, pc}

0802a3dc <BUS_IO_Read>:
  }
}

/* Function to read the bus pins state */
uint16_t BUS_IO_Read(BUS_IO_t *const handle_ptr)
{
 802a3dc:	b580      	push	{r7, lr}
 802a3de:	b084      	sub	sp, #16
 802a3e0:	af00      	add	r7, sp, #0
 802a3e2:	6078      	str	r0, [r7, #4]
  uint8_t i;
  uint16_t count = 0U;
 802a3e4:	2300      	movs	r3, #0
 802a3e6:	81bb      	strh	r3, [r7, #12]

  XMC_ASSERT("BUS_IO_Read: handle_ptr null pointer", handle_ptr != NULL);

  /* Iterate the list of pins reading the pin state and packing the result according the pin position in the list, from LSB to MSB */
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a3e8:	2300      	movs	r3, #0
 802a3ea:	73fb      	strb	r3, [r7, #15]
 802a3ec:	e019      	b.n	802a422 <BUS_IO_Read+0x46>
  {
    /* Reading a bus pin's state */
    count |= (uint16_t)(XMC_GPIO_GetInput(handle_ptr->pin_array[i].gpio_port, handle_ptr->pin_array[i].gpio_pin) << i);
 802a3ee:	687b      	ldr	r3, [r7, #4]
 802a3f0:	681a      	ldr	r2, [r3, #0]
 802a3f2:	7bfb      	ldrb	r3, [r7, #15]
 802a3f4:	00db      	lsls	r3, r3, #3
 802a3f6:	4413      	add	r3, r2
 802a3f8:	6818      	ldr	r0, [r3, #0]
 802a3fa:	687b      	ldr	r3, [r7, #4]
 802a3fc:	681a      	ldr	r2, [r3, #0]
 802a3fe:	7bfb      	ldrb	r3, [r7, #15]
 802a400:	00db      	lsls	r3, r3, #3
 802a402:	4413      	add	r3, r2
 802a404:	791b      	ldrb	r3, [r3, #4]
 802a406:	4619      	mov	r1, r3
 802a408:	f7ff ffa6 	bl	802a358 <XMC_GPIO_GetInput>
 802a40c:	4602      	mov	r2, r0
 802a40e:	7bfb      	ldrb	r3, [r7, #15]
 802a410:	fa02 f303 	lsl.w	r3, r2, r3
 802a414:	b29a      	uxth	r2, r3
 802a416:	89bb      	ldrh	r3, [r7, #12]
 802a418:	4313      	orrs	r3, r2
 802a41a:	81bb      	strh	r3, [r7, #12]
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a41c:	7bfb      	ldrb	r3, [r7, #15]
 802a41e:	3301      	adds	r3, #1
 802a420:	73fb      	strb	r3, [r7, #15]
 802a422:	687b      	ldr	r3, [r7, #4]
 802a424:	7c1b      	ldrb	r3, [r3, #16]
 802a426:	7bfa      	ldrb	r2, [r7, #15]
 802a428:	429a      	cmp	r2, r3
 802a42a:	d3e0      	bcc.n	802a3ee <BUS_IO_Read+0x12>
  }
  return(count);
 802a42c:	89bb      	ldrh	r3, [r7, #12]
}
 802a42e:	4618      	mov	r0, r3
 802a430:	3710      	adds	r7, #16
 802a432:	46bd      	mov	sp, r7
 802a434:	bd80      	pop	{r7, pc}

0802a436 <BUS_IO_Write>:

/* Function to set the pins bus state */
void BUS_IO_Write(BUS_IO_t *const handle_ptr, const uint16_t data)
{
 802a436:	b580      	push	{r7, lr}
 802a438:	b084      	sub	sp, #16
 802a43a:	af00      	add	r7, sp, #0
 802a43c:	6078      	str	r0, [r7, #4]
 802a43e:	460b      	mov	r3, r1
 802a440:	807b      	strh	r3, [r7, #2]
  uint8_t i;
  const BUS_IO_PORT_PIN_t *bus_io_port_pin;

  XMC_ASSERT("BUS_IO_Write: handle_ptr null pointer", handle_ptr != NULL);

  bus_io_port_pin = handle_ptr->pin_array;
 802a442:	687b      	ldr	r3, [r7, #4]
 802a444:	681b      	ldr	r3, [r3, #0]
 802a446:	60bb      	str	r3, [r7, #8]
  /* Iterate the list of pins setting the pin state according the pin position in the list, , from LSB to MSB */
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a448:	2300      	movs	r3, #0
 802a44a:	73fb      	strb	r3, [r7, #15]
 802a44c:	e021      	b.n	802a492 <BUS_IO_Write+0x5c>
  {
    if (data & (uint16_t)((uint16_t)1 << i))
 802a44e:	7bfb      	ldrb	r3, [r7, #15]
 802a450:	2201      	movs	r2, #1
 802a452:	fa02 f303 	lsl.w	r3, r2, r3
 802a456:	b29a      	uxth	r2, r3
 802a458:	887b      	ldrh	r3, [r7, #2]
 802a45a:	4013      	ands	r3, r2
 802a45c:	b29b      	uxth	r3, r3
 802a45e:	2b00      	cmp	r3, #0
 802a460:	d008      	beq.n	802a474 <BUS_IO_Write+0x3e>
    {
      XMC_GPIO_SetOutputLevel(bus_io_port_pin->gpio_port, bus_io_port_pin->gpio_pin, XMC_GPIO_OUTPUT_LEVEL_HIGH);
 802a462:	68bb      	ldr	r3, [r7, #8]
 802a464:	6818      	ldr	r0, [r3, #0]
 802a466:	68bb      	ldr	r3, [r7, #8]
 802a468:	791b      	ldrb	r3, [r3, #4]
 802a46a:	2201      	movs	r2, #1
 802a46c:	4619      	mov	r1, r3
 802a46e:	f7ff ff61 	bl	802a334 <XMC_GPIO_SetOutputLevel>
 802a472:	e008      	b.n	802a486 <BUS_IO_Write+0x50>
    }
    else
    {
      XMC_GPIO_SetOutputLevel(bus_io_port_pin->gpio_port, bus_io_port_pin->gpio_pin, XMC_GPIO_OUTPUT_LEVEL_LOW);
 802a474:	68bb      	ldr	r3, [r7, #8]
 802a476:	6818      	ldr	r0, [r3, #0]
 802a478:	68bb      	ldr	r3, [r7, #8]
 802a47a:	791b      	ldrb	r3, [r3, #4]
 802a47c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802a480:	4619      	mov	r1, r3
 802a482:	f7ff ff57 	bl	802a334 <XMC_GPIO_SetOutputLevel>
    }
   bus_io_port_pin++;
 802a486:	68bb      	ldr	r3, [r7, #8]
 802a488:	3308      	adds	r3, #8
 802a48a:	60bb      	str	r3, [r7, #8]
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a48c:	7bfb      	ldrb	r3, [r7, #15]
 802a48e:	3301      	adds	r3, #1
 802a490:	73fb      	strb	r3, [r7, #15]
 802a492:	687b      	ldr	r3, [r7, #4]
 802a494:	7c1b      	ldrb	r3, [r3, #16]
 802a496:	7bfa      	ldrb	r2, [r7, #15]
 802a498:	429a      	cmp	r2, r3
 802a49a:	d3d8      	bcc.n	802a44e <BUS_IO_Write+0x18>
  }
}
 802a49c:	bf00      	nop
 802a49e:	bf00      	nop
 802a4a0:	3710      	adds	r7, #16
 802a4a2:	46bd      	mov	sp, r7
 802a4a4:	bd80      	pop	{r7, pc}

0802a4a6 <ANALOG_IO_Init>:
 * Input Parameter  : Handler Pointer pointing to APP data structure.
 * Output Parameter : ANALOG_IO_STATUS_t (ANALOG_IO APP initialization status).
 */

ANALOG_IO_STATUS_t ANALOG_IO_Init(const ANALOG_IO_t *const handle)
{
 802a4a6:	b580      	push	{r7, lr}
 802a4a8:	b082      	sub	sp, #8
 802a4aa:	af00      	add	r7, sp, #0
 802a4ac:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("ANALOG_IO_Init: Passed handler is a null pointer", handler != NULL);
  if (*(handle->state) == ANALOG_IO_STATE_NOT_INITIALIZED)
 802a4ae:	687b      	ldr	r3, [r7, #4]
 802a4b0:	685b      	ldr	r3, [r3, #4]
 802a4b2:	781b      	ldrb	r3, [r3, #0]
 802a4b4:	2b00      	cmp	r3, #0
 802a4b6:	d10a      	bne.n	802a4ce <ANALOG_IO_Init+0x28>
  {
    if (handle->config_ptr != NULL)
 802a4b8:	687b      	ldr	r3, [r7, #4]
 802a4ba:	681b      	ldr	r3, [r3, #0]
 802a4bc:	2b00      	cmp	r3, #0
 802a4be:	d002      	beq.n	802a4c6 <ANALOG_IO_Init+0x20>
    {
      /* Instance specific initialization function call*/
      handle->config_ptr();
 802a4c0:	687b      	ldr	r3, [r7, #4]
 802a4c2:	681b      	ldr	r3, [r3, #0]
 802a4c4:	4798      	blx	r3
    }
    /* Set the state variable to initialized state*/
    *(handle->state) = ANALOG_IO_STATE_INITIALIZED;
 802a4c6:	687b      	ldr	r3, [r7, #4]
 802a4c8:	685b      	ldr	r3, [r3, #4]
 802a4ca:	2201      	movs	r2, #1
 802a4cc:	701a      	strb	r2, [r3, #0]
  }
  return (ANALOG_IO_STATUS_OK);
 802a4ce:	2300      	movs	r3, #0
}
 802a4d0:	4618      	mov	r0, r3
 802a4d2:	3708      	adds	r7, #8
 802a4d4:	46bd      	mov	sp, r7
 802a4d6:	bd80      	pop	{r7, pc}

0802a4d8 <__NVIC_GetPriorityGrouping>:
{
 802a4d8:	b480      	push	{r7}
 802a4da:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802a4dc:	4b04      	ldr	r3, [pc, #16]	; (802a4f0 <__NVIC_GetPriorityGrouping+0x18>)
 802a4de:	68db      	ldr	r3, [r3, #12]
 802a4e0:	0a1b      	lsrs	r3, r3, #8
 802a4e2:	f003 0307 	and.w	r3, r3, #7
}
 802a4e6:	4618      	mov	r0, r3
 802a4e8:	46bd      	mov	sp, r7
 802a4ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a4ee:	4770      	bx	lr
 802a4f0:	e000ed00 	.word	0xe000ed00

0802a4f4 <__NVIC_EnableIRQ>:
{
 802a4f4:	b480      	push	{r7}
 802a4f6:	b083      	sub	sp, #12
 802a4f8:	af00      	add	r7, sp, #0
 802a4fa:	4603      	mov	r3, r0
 802a4fc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802a4fe:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a502:	2b00      	cmp	r3, #0
 802a504:	db0b      	blt.n	802a51e <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802a506:	79fb      	ldrb	r3, [r7, #7]
 802a508:	f003 021f 	and.w	r2, r3, #31
 802a50c:	4907      	ldr	r1, [pc, #28]	; (802a52c <__NVIC_EnableIRQ+0x38>)
 802a50e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a512:	095b      	lsrs	r3, r3, #5
 802a514:	2001      	movs	r0, #1
 802a516:	fa00 f202 	lsl.w	r2, r0, r2
 802a51a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 802a51e:	bf00      	nop
 802a520:	370c      	adds	r7, #12
 802a522:	46bd      	mov	sp, r7
 802a524:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a528:	4770      	bx	lr
 802a52a:	bf00      	nop
 802a52c:	e000e100 	.word	0xe000e100

0802a530 <__NVIC_SetPriority>:
{
 802a530:	b480      	push	{r7}
 802a532:	b083      	sub	sp, #12
 802a534:	af00      	add	r7, sp, #0
 802a536:	4603      	mov	r3, r0
 802a538:	6039      	str	r1, [r7, #0]
 802a53a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802a53c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a540:	2b00      	cmp	r3, #0
 802a542:	db0a      	blt.n	802a55a <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802a544:	683b      	ldr	r3, [r7, #0]
 802a546:	b2da      	uxtb	r2, r3
 802a548:	490c      	ldr	r1, [pc, #48]	; (802a57c <__NVIC_SetPriority+0x4c>)
 802a54a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a54e:	0092      	lsls	r2, r2, #2
 802a550:	b2d2      	uxtb	r2, r2
 802a552:	440b      	add	r3, r1
 802a554:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 802a558:	e00a      	b.n	802a570 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802a55a:	683b      	ldr	r3, [r7, #0]
 802a55c:	b2da      	uxtb	r2, r3
 802a55e:	4908      	ldr	r1, [pc, #32]	; (802a580 <__NVIC_SetPriority+0x50>)
 802a560:	79fb      	ldrb	r3, [r7, #7]
 802a562:	f003 030f 	and.w	r3, r3, #15
 802a566:	3b04      	subs	r3, #4
 802a568:	0092      	lsls	r2, r2, #2
 802a56a:	b2d2      	uxtb	r2, r2
 802a56c:	440b      	add	r3, r1
 802a56e:	761a      	strb	r2, [r3, #24]
}
 802a570:	bf00      	nop
 802a572:	370c      	adds	r7, #12
 802a574:	46bd      	mov	sp, r7
 802a576:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a57a:	4770      	bx	lr
 802a57c:	e000e100 	.word	0xe000e100
 802a580:	e000ed00 	.word	0xe000ed00

0802a584 <NVIC_EncodePriority>:
{
 802a584:	b480      	push	{r7}
 802a586:	b089      	sub	sp, #36	; 0x24
 802a588:	af00      	add	r7, sp, #0
 802a58a:	60f8      	str	r0, [r7, #12]
 802a58c:	60b9      	str	r1, [r7, #8]
 802a58e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 802a590:	68fb      	ldr	r3, [r7, #12]
 802a592:	f003 0307 	and.w	r3, r3, #7
 802a596:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802a598:	69fb      	ldr	r3, [r7, #28]
 802a59a:	f1c3 0307 	rsb	r3, r3, #7
 802a59e:	2b06      	cmp	r3, #6
 802a5a0:	bf28      	it	cs
 802a5a2:	2306      	movcs	r3, #6
 802a5a4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802a5a6:	69fb      	ldr	r3, [r7, #28]
 802a5a8:	3306      	adds	r3, #6
 802a5aa:	2b06      	cmp	r3, #6
 802a5ac:	d902      	bls.n	802a5b4 <NVIC_EncodePriority+0x30>
 802a5ae:	69fb      	ldr	r3, [r7, #28]
 802a5b0:	3b01      	subs	r3, #1
 802a5b2:	e000      	b.n	802a5b6 <NVIC_EncodePriority+0x32>
 802a5b4:	2300      	movs	r3, #0
 802a5b6:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802a5b8:	f04f 32ff 	mov.w	r2, #4294967295
 802a5bc:	69bb      	ldr	r3, [r7, #24]
 802a5be:	fa02 f303 	lsl.w	r3, r2, r3
 802a5c2:	43da      	mvns	r2, r3
 802a5c4:	68bb      	ldr	r3, [r7, #8]
 802a5c6:	401a      	ands	r2, r3
 802a5c8:	697b      	ldr	r3, [r7, #20]
 802a5ca:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802a5cc:	f04f 31ff 	mov.w	r1, #4294967295
 802a5d0:	697b      	ldr	r3, [r7, #20]
 802a5d2:	fa01 f303 	lsl.w	r3, r1, r3
 802a5d6:	43d9      	mvns	r1, r3
 802a5d8:	687b      	ldr	r3, [r7, #4]
 802a5da:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802a5dc:	4313      	orrs	r3, r2
}
 802a5de:	4618      	mov	r0, r3
 802a5e0:	3724      	adds	r7, #36	; 0x24
 802a5e2:	46bd      	mov	sp, r7
 802a5e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a5e8:	4770      	bx	lr

0802a5ea <XMC_VADC_GLOBAL_BackgroundTriggerConversion>:
{
 802a5ea:	b480      	push	{r7}
 802a5ec:	b083      	sub	sp, #12
 802a5ee:	af00      	add	r7, sp, #0
 802a5f0:	6078      	str	r0, [r7, #4]
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
 802a5f2:	687b      	ldr	r3, [r7, #4]
 802a5f4:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 802a5f8:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 802a5fc:	687b      	ldr	r3, [r7, #4]
 802a5fe:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
}
 802a602:	bf00      	nop
 802a604:	370c      	adds	r7, #12
 802a606:	46bd      	mov	sp, r7
 802a608:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a60c:	4770      	bx	lr

0802a60e <XMC_VADC_GLOBAL_BackgroundAddChannelToSequence>:
{
 802a60e:	b480      	push	{r7}
 802a610:	b085      	sub	sp, #20
 802a612:	af00      	add	r7, sp, #0
 802a614:	60f8      	str	r0, [r7, #12]
 802a616:	60b9      	str	r1, [r7, #8]
 802a618:	607a      	str	r2, [r7, #4]
  global_ptr->BRSSEL[grp_num] |= (uint32_t)((uint32_t)1 << ch_num);
 802a61a:	68fb      	ldr	r3, [r7, #12]
 802a61c:	68ba      	ldr	r2, [r7, #8]
 802a61e:	3260      	adds	r2, #96	; 0x60
 802a620:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802a624:	2101      	movs	r1, #1
 802a626:	687b      	ldr	r3, [r7, #4]
 802a628:	fa01 f303 	lsl.w	r3, r1, r3
 802a62c:	ea42 0103 	orr.w	r1, r2, r3
 802a630:	68fb      	ldr	r3, [r7, #12]
 802a632:	68ba      	ldr	r2, [r7, #8]
 802a634:	3260      	adds	r2, #96	; 0x60
 802a636:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 802a63a:	bf00      	nop
 802a63c:	3714      	adds	r7, #20
 802a63e:	46bd      	mov	sp, r7
 802a640:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a644:	4770      	bx	lr

0802a646 <XMC_VADC_GROUP_ResultInit>:
{
 802a646:	b480      	push	{r7}
 802a648:	b085      	sub	sp, #20
 802a64a:	af00      	add	r7, sp, #0
 802a64c:	60f8      	str	r0, [r7, #12]
 802a64e:	60b9      	str	r1, [r7, #8]
 802a650:	607a      	str	r2, [r7, #4]
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 802a652:	687b      	ldr	r3, [r7, #4]
 802a654:	6819      	ldr	r1, [r3, #0]
 802a656:	68fb      	ldr	r3, [r7, #12]
 802a658:	68ba      	ldr	r2, [r7, #8]
 802a65a:	32a0      	adds	r2, #160	; 0xa0
 802a65c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 802a660:	bf00      	nop
 802a662:	3714      	adds	r7, #20
 802a664:	46bd      	mov	sp, r7
 802a666:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a66a:	4770      	bx	lr

0802a66c <XMC_VADC_GROUP_GetResult>:
{
 802a66c:	b480      	push	{r7}
 802a66e:	b083      	sub	sp, #12
 802a670:	af00      	add	r7, sp, #0
 802a672:	6078      	str	r0, [r7, #4]
 802a674:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 802a676:	687b      	ldr	r3, [r7, #4]
 802a678:	683a      	ldr	r2, [r7, #0]
 802a67a:	32c0      	adds	r2, #192	; 0xc0
 802a67c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a680:	b29b      	uxth	r3, r3
}
 802a682:	4618      	mov	r0, r3
 802a684:	370c      	adds	r7, #12
 802a686:	46bd      	mov	sp, r7
 802a688:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a68c:	4770      	bx	lr

0802a68e <ADC_MEASUREMENT_Init>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr)
{
 802a68e:	b590      	push	{r4, r7, lr}
 802a690:	b085      	sub	sp, #20
 802a692:	af00      	add	r7, sp, #0
 802a694:	6078      	str	r0, [r7, #4]
  uint8_t j;
  ADC_MEASUREMENT_STATUS_t status;

  XMC_ASSERT("ADC_MEASUREMENT_Init:Invalid handle_ptr", (handle_ptr != NULL));

  if (ADC_MEASUREMENT_STATUS_UNINITIALIZED == handle_ptr->init_state)
 802a696:	687b      	ldr	r3, [r7, #4]
 802a698:	7e1b      	ldrb	r3, [r3, #24]
 802a69a:	2b02      	cmp	r3, #2
 802a69c:	f040 809e 	bne.w	802a7dc <ADC_MEASUREMENT_Init+0x14e>
  {
    /* Call the function to initialise Clock and ADC global functional units*/
    status = (ADC_MEASUREMENT_STATUS_t) GLOBAL_ADC_Init(handle_ptr->global_handle);
 802a6a0:	687b      	ldr	r3, [r7, #4]
 802a6a2:	68db      	ldr	r3, [r3, #12]
 802a6a4:	4618      	mov	r0, r3
 802a6a6:	f7ff faa2 	bl	8029bee <GLOBAL_ADC_Init>
 802a6aa:	4603      	mov	r3, r0
 802a6ac:	73bb      	strb	r3, [r7, #14]
  
    /*Initialize the Global Conversion class 0*/
    XMC_VADC_GLOBAL_InputClassInit(handle_ptr->global_handle->module_ptr,*handle_ptr->iclass_config_handle,
 802a6ae:	687b      	ldr	r3, [r7, #4]
 802a6b0:	68db      	ldr	r3, [r3, #12]
 802a6b2:	6958      	ldr	r0, [r3, #20]
 802a6b4:	687b      	ldr	r3, [r7, #4]
 802a6b6:	6899      	ldr	r1, [r3, #8]
 802a6b8:	2300      	movs	r3, #0
 802a6ba:	2200      	movs	r2, #0
 802a6bc:	6809      	ldr	r1, [r1, #0]
 802a6be:	f7fd ffe1 	bl	8028684 <XMC_VADC_GLOBAL_InputClassInit>
    XMC_VADC_GLOBAL_InputClassInit(handle_ptr->global_handle->module_ptr,*handle_ptr->iclass_config_handle,
                                      XMC_VADC_GROUP_CONV_STD,ADC_MEASUREMENT_ICLASS_NUM_XMC11);
#endif
  
    /* Initialize the Background Scan hardware */
    XMC_VADC_GLOBAL_BackgroundInit(handle_ptr->global_handle->module_ptr, handle_ptr->backgnd_config_handle);
 802a6c2:	687b      	ldr	r3, [r7, #4]
 802a6c4:	68db      	ldr	r3, [r3, #12]
 802a6c6:	695a      	ldr	r2, [r3, #20]
 802a6c8:	687b      	ldr	r3, [r7, #4]
 802a6ca:	685b      	ldr	r3, [r3, #4]
 802a6cc:	4619      	mov	r1, r3
 802a6ce:	4610      	mov	r0, r2
 802a6d0:	f7fe f92e 	bl	8028930 <XMC_VADC_GLOBAL_BackgroundInit>
#if (XMC_VADC_GROUP_AVAILABLE == 0U)
    /* Initialize the global result register */
    XMC_VADC_GLOBAL_ResultInit(handle_ptr->global_handle->module_ptr,handle_ptr->array->res_handle);
#endif

    for (j = (uint8_t)0; j < (uint8_t)ADC_MEASUREMENT_MAXCHANNELS; j++)
 802a6d4:	2300      	movs	r3, #0
 802a6d6:	73fb      	strb	r3, [r7, #15]
 802a6d8:	e039      	b.n	802a74e <ADC_MEASUREMENT_Init+0xc0>
    {
      indexed = handle_ptr->array->channel_array[j];
 802a6da:	687b      	ldr	r3, [r7, #4]
 802a6dc:	681b      	ldr	r3, [r3, #0]
 802a6de:	7bfa      	ldrb	r2, [r7, #15]
 802a6e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a6e4:	60bb      	str	r3, [r7, #8]
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(indexed->group_handle,(uint32_t)indexed->ch_num, indexed->ch_handle);
 802a6e6:	68bb      	ldr	r3, [r7, #8]
 802a6e8:	6898      	ldr	r0, [r3, #8]
 802a6ea:	68bb      	ldr	r3, [r7, #8]
 802a6ec:	7c5b      	ldrb	r3, [r3, #17]
 802a6ee:	4619      	mov	r1, r3
 802a6f0:	68bb      	ldr	r3, [r7, #8]
 802a6f2:	681b      	ldr	r3, [r3, #0]
 802a6f4:	461a      	mov	r2, r3
 802a6f6:	f7fe f9e9 	bl	8028acc <XMC_VADC_GROUP_ChannelInit>
  
      /* Initialize for configured result registers */
      XMC_VADC_GROUP_ResultInit(indexed->group_handle, (uint32_t)indexed->ch_handle->result_reg_number,
 802a6fa:	68bb      	ldr	r3, [r7, #8]
 802a6fc:	6898      	ldr	r0, [r3, #8]
 802a6fe:	68bb      	ldr	r3, [r7, #8]
 802a700:	681b      	ldr	r3, [r3, #0]
 802a702:	789b      	ldrb	r3, [r3, #2]
 802a704:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802a708:	b2db      	uxtb	r3, r3
 802a70a:	4619      	mov	r1, r3
                                indexed->res_handle);
 802a70c:	68bb      	ldr	r3, [r7, #8]
 802a70e:	685b      	ldr	r3, [r3, #4]
      XMC_VADC_GROUP_ResultInit(indexed->group_handle, (uint32_t)indexed->ch_handle->result_reg_number,
 802a710:	461a      	mov	r2, r3
 802a712:	f7ff ff98 	bl	802a646 <XMC_VADC_GROUP_ResultInit>
#endif
      /* Add all channels into the Background Request Source Channel Select Register */
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 802a716:	687b      	ldr	r3, [r7, #4]
 802a718:	68db      	ldr	r3, [r3, #12]
 802a71a:	6958      	ldr	r0, [r3, #20]
                                                     (uint32_t)indexed->group_index, (uint32_t)indexed->ch_num);
 802a71c:	68bb      	ldr	r3, [r7, #8]
 802a71e:	7c1b      	ldrb	r3, [r3, #16]
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 802a720:	4619      	mov	r1, r3
                                                     (uint32_t)indexed->group_index, (uint32_t)indexed->ch_num);
 802a722:	68bb      	ldr	r3, [r7, #8]
 802a724:	7c5b      	ldrb	r3, [r3, #17]
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 802a726:	461a      	mov	r2, r3
 802a728:	f7ff ff71 	bl	802a60e <XMC_VADC_GLOBAL_BackgroundAddChannelToSequence>

#ifdef ADC_MEASUREMENT_ANALOG_IO_USED
      /* ANALOG_IO initialization for the channel*/
      if(indexed->analog_io_config != NULL)
 802a72c:	68bb      	ldr	r3, [r7, #8]
 802a72e:	68db      	ldr	r3, [r3, #12]
 802a730:	2b00      	cmp	r3, #0
 802a732:	d009      	beq.n	802a748 <ADC_MEASUREMENT_Init+0xba>
      {
        status |= (ADC_MEASUREMENT_STATUS_t) ANALOG_IO_Init(indexed->analog_io_config);
 802a734:	68bb      	ldr	r3, [r7, #8]
 802a736:	68db      	ldr	r3, [r3, #12]
 802a738:	4618      	mov	r0, r3
 802a73a:	f7ff feb4 	bl	802a4a6 <ANALOG_IO_Init>
 802a73e:	4603      	mov	r3, r0
 802a740:	461a      	mov	r2, r3
 802a742:	7bbb      	ldrb	r3, [r7, #14]
 802a744:	4313      	orrs	r3, r2
 802a746:	73bb      	strb	r3, [r7, #14]
    for (j = (uint8_t)0; j < (uint8_t)ADC_MEASUREMENT_MAXCHANNELS; j++)
 802a748:	7bfb      	ldrb	r3, [r7, #15]
 802a74a:	3301      	adds	r3, #1
 802a74c:	73fb      	strb	r3, [r7, #15]
 802a74e:	7bfb      	ldrb	r3, [r7, #15]
 802a750:	2b02      	cmp	r3, #2
 802a752:	d9c2      	bls.n	802a6da <ADC_MEASUREMENT_Init+0x4c>
      }
#endif
    }
#if(UC_SERIES != XMC11)
    if ((handle_ptr->backgnd_config_handle->req_src_interrupt) && (handle_ptr->req_src_intr_handle != NULL ))
 802a754:	687b      	ldr	r3, [r7, #4]
 802a756:	685b      	ldr	r3, [r3, #4]
 802a758:	7a1b      	ldrb	r3, [r3, #8]
 802a75a:	f003 0308 	and.w	r3, r3, #8
 802a75e:	b2db      	uxtb	r3, r3
 802a760:	2b00      	cmp	r3, #0
 802a762:	d027      	beq.n	802a7b4 <ADC_MEASUREMENT_Init+0x126>
 802a764:	687b      	ldr	r3, [r7, #4]
 802a766:	691b      	ldr	r3, [r3, #16]
 802a768:	2b00      	cmp	r3, #0
 802a76a:	d023      	beq.n	802a7b4 <ADC_MEASUREMENT_Init+0x126>
    {
#if (UC_FAMILY == XMC1)
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
                        handle_ptr->req_src_intr_handle->priority);
#else
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 802a76c:	687b      	ldr	r3, [r7, #4]
 802a76e:	691b      	ldr	r3, [r3, #16]
 802a770:	681b      	ldr	r3, [r3, #0]
 802a772:	b25c      	sxtb	r4, r3
 802a774:	f7ff feb0 	bl	802a4d8 <__NVIC_GetPriorityGrouping>
                        NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                        handle_ptr->req_src_intr_handle->priority, handle_ptr->req_src_intr_handle->sub_priority));
 802a778:	687b      	ldr	r3, [r7, #4]
 802a77a:	691b      	ldr	r3, [r3, #16]
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 802a77c:	6859      	ldr	r1, [r3, #4]
                        handle_ptr->req_src_intr_handle->priority, handle_ptr->req_src_intr_handle->sub_priority));
 802a77e:	687b      	ldr	r3, [r7, #4]
 802a780:	691b      	ldr	r3, [r3, #16]
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 802a782:	689b      	ldr	r3, [r3, #8]
 802a784:	461a      	mov	r2, r3
 802a786:	f7ff fefd 	bl	802a584 <NVIC_EncodePriority>
 802a78a:	4603      	mov	r3, r0
 802a78c:	4619      	mov	r1, r3
 802a78e:	4620      	mov	r0, r4
 802a790:	f7ff fece 	bl	802a530 <__NVIC_SetPriority>
#endif
      /* Connect background Request Source Event to NVIC node */
      XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(handle_ptr->global_handle->module_ptr,
 802a794:	687b      	ldr	r3, [r7, #4]
 802a796:	68db      	ldr	r3, [r3, #12]
 802a798:	695a      	ldr	r2, [r3, #20]
                                                 (XMC_VADC_SR_t) handle_ptr->srv_req_node);
 802a79a:	687b      	ldr	r3, [r7, #4]
 802a79c:	7e5b      	ldrb	r3, [r3, #25]
      XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(handle_ptr->global_handle->module_ptr,
 802a79e:	4619      	mov	r1, r3
 802a7a0:	4610      	mov	r0, r2
 802a7a2:	f7fd ffc9 	bl	8028738 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode>
    
      /* Enable Background Scan Request source IRQ */
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->req_src_intr_handle->node_id);
 802a7a6:	687b      	ldr	r3, [r7, #4]
 802a7a8:	691b      	ldr	r3, [r3, #16]
 802a7aa:	681b      	ldr	r3, [r3, #0]
 802a7ac:	b25b      	sxtb	r3, r3
 802a7ae:	4618      	mov	r0, r3
 802a7b0:	f7ff fea0 	bl	802a4f4 <__NVIC_EnableIRQ>
    /* Enable Background Scan Request source IRQ */
    NVIC_EnableIRQ((IRQn_Type)handle_ptr->result_intr_handle->node_id);
#endif
#endif
    /* Mux Configuration is done*/
    if (handle_ptr->mux_config != NULL)
 802a7b4:	687b      	ldr	r3, [r7, #4]
 802a7b6:	695b      	ldr	r3, [r3, #20]
 802a7b8:	2b00      	cmp	r3, #0
 802a7ba:	d002      	beq.n	802a7c2 <ADC_MEASUREMENT_Init+0x134>
    {
      (handle_ptr->mux_config)();
 802a7bc:	687b      	ldr	r3, [r7, #4]
 802a7be:	695b      	ldr	r3, [r3, #20]
 802a7c0:	4798      	blx	r3
    }
  
    if (handle_ptr->start_conversion != (bool)false)
 802a7c2:	687b      	ldr	r3, [r7, #4]
 802a7c4:	7e9b      	ldrb	r3, [r3, #26]
 802a7c6:	2b00      	cmp	r3, #0
 802a7c8:	d005      	beq.n	802a7d6 <ADC_MEASUREMENT_Init+0x148>
    {
      /* Start conversion manually using load event trigger*/
      XMC_VADC_GLOBAL_BackgroundTriggerConversion(handle_ptr->global_handle->module_ptr);
 802a7ca:	687b      	ldr	r3, [r7, #4]
 802a7cc:	68db      	ldr	r3, [r3, #12]
 802a7ce:	695b      	ldr	r3, [r3, #20]
 802a7d0:	4618      	mov	r0, r3
 802a7d2:	f7ff ff0a 	bl	802a5ea <XMC_VADC_GLOBAL_BackgroundTriggerConversion>
    }
    handle_ptr->init_state = status;
 802a7d6:	687b      	ldr	r3, [r7, #4]
 802a7d8:	7bba      	ldrb	r2, [r7, #14]
 802a7da:	761a      	strb	r2, [r3, #24]
  }
  return (handle_ptr->init_state);
 802a7dc:	687b      	ldr	r3, [r7, #4]
 802a7de:	7e1b      	ldrb	r3, [r3, #24]
}
 802a7e0:	4618      	mov	r0, r3
 802a7e2:	3714      	adds	r7, #20
 802a7e4:	46bd      	mov	sp, r7
 802a7e6:	bd90      	pop	{r4, r7, pc}

0802a7e8 <ADC_MEASUREMENT_StartConversion>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* This API will Software trigger ADC Background request source and starts conversion*/
void ADC_MEASUREMENT_StartConversion(ADC_MEASUREMENT_t *const handle_ptr)
{
 802a7e8:	b580      	push	{r7, lr}
 802a7ea:	b082      	sub	sp, #8
 802a7ec:	af00      	add	r7, sp, #0
 802a7ee:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("ADC_MEASUREMENT_Start:Invalid handle_ptr", (handle_ptr != NULL));

  /* Generate a load event to start background request source conversion*/
  XMC_VADC_GLOBAL_BackgroundTriggerConversion(handle_ptr->global_handle->module_ptr);
 802a7f0:	687b      	ldr	r3, [r7, #4]
 802a7f2:	68db      	ldr	r3, [r3, #12]
 802a7f4:	695b      	ldr	r3, [r3, #20]
 802a7f6:	4618      	mov	r0, r3
 802a7f8:	f7ff fef7 	bl	802a5ea <XMC_VADC_GLOBAL_BackgroundTriggerConversion>
}
 802a7fc:	bf00      	nop
 802a7fe:	3708      	adds	r7, #8
 802a800:	46bd      	mov	sp, r7
 802a802:	bd80      	pop	{r7, pc}

0802a804 <ADC_MEASUREMENT_GetResult>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#if(XMC_VADC_GROUP_AVAILABLE == 1U)
/* This API will get the result of a conversion for a specific channel*/
XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr)
{
 802a804:	b580      	push	{r7, lr}
 802a806:	b084      	sub	sp, #16
 802a808:	af00      	add	r7, sp, #0
 802a80a:	6078      	str	r0, [r7, #4]
  XMC_VADC_RESULT_SIZE_t result;

  XMC_ASSERT("ADC_MEASUREMENT_GetResult:Invalid handle_ptr", (handle_ptr != NULL));

  result = XMC_VADC_GROUP_GetResult(handle_ptr->group_handle, handle_ptr->ch_handle->result_reg_number);
 802a80c:	687b      	ldr	r3, [r7, #4]
 802a80e:	689a      	ldr	r2, [r3, #8]
 802a810:	687b      	ldr	r3, [r7, #4]
 802a812:	681b      	ldr	r3, [r3, #0]
 802a814:	789b      	ldrb	r3, [r3, #2]
 802a816:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802a81a:	b2db      	uxtb	r3, r3
 802a81c:	4619      	mov	r1, r3
 802a81e:	4610      	mov	r0, r2
 802a820:	f7ff ff24 	bl	802a66c <XMC_VADC_GROUP_GetResult>
 802a824:	4603      	mov	r3, r0
 802a826:	81fb      	strh	r3, [r7, #14]

  return (result);
 802a828:	89fb      	ldrh	r3, [r7, #14]
}
 802a82a:	4618      	mov	r0, r3
 802a82c:	3710      	adds	r7, #16
 802a82e:	46bd      	mov	sp, r7
 802a830:	bd80      	pop	{r7, pc}
	...

0802a834 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
 802a834:	b580      	push	{r7, lr}
 802a836:	b082      	sub	sp, #8
 802a838:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
 802a83a:	2300      	movs	r3, #0
 802a83c:	71fb      	strb	r3, [r7, #7]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 802a83e:	48aa      	ldr	r0, [pc, #680]	; (802aae8 <DAVE_Init+0x2b4>)
 802a840:	f7ff fac0 	bl	8029dc4 <CLOCK_XMC4_Init>
 802a844:	4603      	mov	r3, r0
 802a846:	71fb      	strb	r3, [r7, #7]

  if (init_status == DAVE_STATUS_SUCCESS)
 802a848:	79fb      	ldrb	r3, [r7, #7]
 802a84a:	2b00      	cmp	r3, #0
 802a84c:	d104      	bne.n	802a858 <DAVE_Init+0x24>
  {
	 /**  Initialization of DIGITAL_IO APP instance SERVICE_BUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&SERVICE_BUT); 
 802a84e:	48a7      	ldr	r0, [pc, #668]	; (802aaec <DAVE_Init+0x2b8>)
 802a850:	f7ff fa24 	bl	8029c9c <DIGITAL_IO_Init>
 802a854:	4603      	mov	r3, r0
 802a856:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a858:	79fb      	ldrb	r3, [r7, #7]
 802a85a:	2b00      	cmp	r3, #0
 802a85c:	d104      	bne.n	802a868 <DAVE_Init+0x34>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_G */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_G); 
 802a85e:	48a4      	ldr	r0, [pc, #656]	; (802aaf0 <DAVE_Init+0x2bc>)
 802a860:	f7ff fa1c 	bl	8029c9c <DIGITAL_IO_Init>
 802a864:	4603      	mov	r3, r0
 802a866:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a868:	79fb      	ldrb	r3, [r7, #7]
 802a86a:	2b00      	cmp	r3, #0
 802a86c:	d104      	bne.n	802a878 <DAVE_Init+0x44>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_Y */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_Y); 
 802a86e:	48a1      	ldr	r0, [pc, #644]	; (802aaf4 <DAVE_Init+0x2c0>)
 802a870:	f7ff fa14 	bl	8029c9c <DIGITAL_IO_Init>
 802a874:	4603      	mov	r3, r0
 802a876:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a878:	79fb      	ldrb	r3, [r7, #7]
 802a87a:	2b00      	cmp	r3, #0
 802a87c:	d104      	bne.n	802a888 <DAVE_Init+0x54>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_R */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_R); 
 802a87e:	489e      	ldr	r0, [pc, #632]	; (802aaf8 <DAVE_Init+0x2c4>)
 802a880:	f7ff fa0c 	bl	8029c9c <DIGITAL_IO_Init>
 802a884:	4603      	mov	r3, r0
 802a886:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a888:	79fb      	ldrb	r3, [r7, #7]
 802a88a:	2b00      	cmp	r3, #0
 802a88c:	d104      	bne.n	802a898 <DAVE_Init+0x64>
  {
	 /**  Initialization of SYSTIMER APP instance SYSTIMER_0 */
	 init_status = (DAVE_STATUS_t)SYSTIMER_Init(&SYSTIMER_0); 
 802a88e:	489b      	ldr	r0, [pc, #620]	; (802aafc <DAVE_Init+0x2c8>)
 802a890:	f7fe fc12 	bl	80290b8 <SYSTIMER_Init>
 802a894:	4603      	mov	r3, r0
 802a896:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a898:	79fb      	ldrb	r3, [r7, #7]
 802a89a:	2b00      	cmp	r3, #0
 802a89c:	d104      	bne.n	802a8a8 <DAVE_Init+0x74>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_EXT */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_EXT); 
 802a89e:	4898      	ldr	r0, [pc, #608]	; (802ab00 <DAVE_Init+0x2cc>)
 802a8a0:	f7ff fcab 	bl	802a1fa <CAN_NODE_Init>
 802a8a4:	4603      	mov	r3, r0
 802a8a6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8a8:	79fb      	ldrb	r3, [r7, #7]
 802a8aa:	2b00      	cmp	r3, #0
 802a8ac:	d104      	bne.n	802a8b8 <DAVE_Init+0x84>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_INT */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_INT); 
 802a8ae:	4895      	ldr	r0, [pc, #596]	; (802ab04 <DAVE_Init+0x2d0>)
 802a8b0:	f7ff fca3 	bl	802a1fa <CAN_NODE_Init>
 802a8b4:	4603      	mov	r3, r0
 802a8b6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8b8:	79fb      	ldrb	r3, [r7, #7]
 802a8ba:	2b00      	cmp	r3, #0
 802a8bc:	d104      	bne.n	802a8c8 <DAVE_Init+0x94>
  {
	 /**  Initialization of INTERRUPT APP instance CAN1_RX_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN1_RX_INT); 
 802a8be:	4892      	ldr	r0, [pc, #584]	; (802ab08 <DAVE_Init+0x2d4>)
 802a8c0:	f7ff f90f 	bl	8029ae2 <INTERRUPT_Init>
 802a8c4:	4603      	mov	r3, r0
 802a8c6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8c8:	79fb      	ldrb	r3, [r7, #7]
 802a8ca:	2b00      	cmp	r3, #0
 802a8cc:	d104      	bne.n	802a8d8 <DAVE_Init+0xa4>
  {
	 /**  Initialization of PWM_CCU4 APP instance CLUTCH_PWM */
	 init_status = (DAVE_STATUS_t)PWM_CCU4_Init(&CLUTCH_PWM); 
 802a8ce:	488f      	ldr	r0, [pc, #572]	; (802ab0c <DAVE_Init+0x2d8>)
 802a8d0:	f7fe fda5 	bl	802941e <PWM_CCU4_Init>
 802a8d4:	4603      	mov	r3, r0
 802a8d6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8d8:	79fb      	ldrb	r3, [r7, #7]
 802a8da:	2b00      	cmp	r3, #0
 802a8dc:	d104      	bne.n	802a8e8 <DAVE_Init+0xb4>
  {
	 /**  Initialization of INTERRUPT APP instance CLUTCH_INT_CMP */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CLUTCH_INT_CMP); 
 802a8de:	488c      	ldr	r0, [pc, #560]	; (802ab10 <DAVE_Init+0x2dc>)
 802a8e0:	f7ff f8ff 	bl	8029ae2 <INTERRUPT_Init>
 802a8e4:	4603      	mov	r3, r0
 802a8e6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8e8:	79fb      	ldrb	r3, [r7, #7]
 802a8ea:	2b00      	cmp	r3, #0
 802a8ec:	d104      	bne.n	802a8f8 <DAVE_Init+0xc4>
  {
	 /**  Initialization of INTERRUPT APP instance CLUTCH_INT_OVF */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CLUTCH_INT_OVF); 
 802a8ee:	4889      	ldr	r0, [pc, #548]	; (802ab14 <DAVE_Init+0x2e0>)
 802a8f0:	f7ff f8f7 	bl	8029ae2 <INTERRUPT_Init>
 802a8f4:	4603      	mov	r3, r0
 802a8f6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8f8:	79fb      	ldrb	r3, [r7, #7]
 802a8fa:	2b00      	cmp	r3, #0
 802a8fc:	d104      	bne.n	802a908 <DAVE_Init+0xd4>
  {
	 /**  Initialization of DIGITAL_IO APP instance TRANS_OUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&TRANS_OUT); 
 802a8fe:	4886      	ldr	r0, [pc, #536]	; (802ab18 <DAVE_Init+0x2e4>)
 802a900:	f7ff f9cc 	bl	8029c9c <DIGITAL_IO_Init>
 802a904:	4603      	mov	r3, r0
 802a906:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a908:	79fb      	ldrb	r3, [r7, #7]
 802a90a:	2b00      	cmp	r3, #0
 802a90c:	d104      	bne.n	802a918 <DAVE_Init+0xe4>
  {
	 /**  Initialization of BUS_IO APP instance GROUP_IN */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&GROUP_IN); 
 802a90e:	4883      	ldr	r0, [pc, #524]	; (802ab1c <DAVE_Init+0x2e8>)
 802a910:	f7ff fd35 	bl	802a37e <BUS_IO_Init>
 802a914:	4603      	mov	r3, r0
 802a916:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a918:	79fb      	ldrb	r3, [r7, #7]
 802a91a:	2b00      	cmp	r3, #0
 802a91c:	d104      	bne.n	802a928 <DAVE_Init+0xf4>
  {
	 /**  Initialization of BUS_IO APP instance GROUP_OUT */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&GROUP_OUT); 
 802a91e:	4880      	ldr	r0, [pc, #512]	; (802ab20 <DAVE_Init+0x2ec>)
 802a920:	f7ff fd2d 	bl	802a37e <BUS_IO_Init>
 802a924:	4603      	mov	r3, r0
 802a926:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a928:	79fb      	ldrb	r3, [r7, #7]
 802a92a:	2b00      	cmp	r3, #0
 802a92c:	d104      	bne.n	802a938 <DAVE_Init+0x104>
  {
	 /**  Initialization of DIGITAL_IO APP instance GROUP_IN_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&GROUP_IN_EN); 
 802a92e:	487d      	ldr	r0, [pc, #500]	; (802ab24 <DAVE_Init+0x2f0>)
 802a930:	f7ff f9b4 	bl	8029c9c <DIGITAL_IO_Init>
 802a934:	4603      	mov	r3, r0
 802a936:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a938:	79fb      	ldrb	r3, [r7, #7]
 802a93a:	2b00      	cmp	r3, #0
 802a93c:	d104      	bne.n	802a948 <DAVE_Init+0x114>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_NRES */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_NRES); 
 802a93e:	487a      	ldr	r0, [pc, #488]	; (802ab28 <DAVE_Init+0x2f4>)
 802a940:	f7ff f9ac 	bl	8029c9c <DIGITAL_IO_Init>
 802a944:	4603      	mov	r3, r0
 802a946:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a948:	79fb      	ldrb	r3, [r7, #7]
 802a94a:	2b00      	cmp	r3, #0
 802a94c:	d104      	bne.n	802a958 <DAVE_Init+0x124>
  {
	 /**  Initialization of BUS_IO APP instance DI_PNP */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&DI_PNP); 
 802a94e:	4877      	ldr	r0, [pc, #476]	; (802ab2c <DAVE_Init+0x2f8>)
 802a950:	f7ff fd15 	bl	802a37e <BUS_IO_Init>
 802a954:	4603      	mov	r3, r0
 802a956:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a958:	79fb      	ldrb	r3, [r7, #7]
 802a95a:	2b00      	cmp	r3, #0
 802a95c:	d104      	bne.n	802a968 <DAVE_Init+0x134>
  {
	 /**  Initialization of BUS_IO APP instance DI_NPN */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&DI_NPN); 
 802a95e:	4874      	ldr	r0, [pc, #464]	; (802ab30 <DAVE_Init+0x2fc>)
 802a960:	f7ff fd0d 	bl	802a37e <BUS_IO_Init>
 802a964:	4603      	mov	r3, r0
 802a966:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a968:	79fb      	ldrb	r3, [r7, #7]
 802a96a:	2b00      	cmp	r3, #0
 802a96c:	d104      	bne.n	802a978 <DAVE_Init+0x144>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_1); 
 802a96e:	4871      	ldr	r0, [pc, #452]	; (802ab34 <DAVE_Init+0x300>)
 802a970:	f7ff f994 	bl	8029c9c <DIGITAL_IO_Init>
 802a974:	4603      	mov	r3, r0
 802a976:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a978:	79fb      	ldrb	r3, [r7, #7]
 802a97a:	2b00      	cmp	r3, #0
 802a97c:	d104      	bne.n	802a988 <DAVE_Init+0x154>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_2); 
 802a97e:	486e      	ldr	r0, [pc, #440]	; (802ab38 <DAVE_Init+0x304>)
 802a980:	f7ff f98c 	bl	8029c9c <DIGITAL_IO_Init>
 802a984:	4603      	mov	r3, r0
 802a986:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a988:	79fb      	ldrb	r3, [r7, #7]
 802a98a:	2b00      	cmp	r3, #0
 802a98c:	d104      	bne.n	802a998 <DAVE_Init+0x164>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_3); 
 802a98e:	486b      	ldr	r0, [pc, #428]	; (802ab3c <DAVE_Init+0x308>)
 802a990:	f7ff f984 	bl	8029c9c <DIGITAL_IO_Init>
 802a994:	4603      	mov	r3, r0
 802a996:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a998:	79fb      	ldrb	r3, [r7, #7]
 802a99a:	2b00      	cmp	r3, #0
 802a99c:	d104      	bne.n	802a9a8 <DAVE_Init+0x174>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_4); 
 802a99e:	4868      	ldr	r0, [pc, #416]	; (802ab40 <DAVE_Init+0x30c>)
 802a9a0:	f7ff f97c 	bl	8029c9c <DIGITAL_IO_Init>
 802a9a4:	4603      	mov	r3, r0
 802a9a6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a9a8:	79fb      	ldrb	r3, [r7, #7]
 802a9aa:	2b00      	cmp	r3, #0
 802a9ac:	d104      	bne.n	802a9b8 <DAVE_Init+0x184>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_1); 
 802a9ae:	4865      	ldr	r0, [pc, #404]	; (802ab44 <DAVE_Init+0x310>)
 802a9b0:	f7ff f974 	bl	8029c9c <DIGITAL_IO_Init>
 802a9b4:	4603      	mov	r3, r0
 802a9b6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a9b8:	79fb      	ldrb	r3, [r7, #7]
 802a9ba:	2b00      	cmp	r3, #0
 802a9bc:	d104      	bne.n	802a9c8 <DAVE_Init+0x194>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_2); 
 802a9be:	4862      	ldr	r0, [pc, #392]	; (802ab48 <DAVE_Init+0x314>)
 802a9c0:	f7ff f96c 	bl	8029c9c <DIGITAL_IO_Init>
 802a9c4:	4603      	mov	r3, r0
 802a9c6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a9c8:	79fb      	ldrb	r3, [r7, #7]
 802a9ca:	2b00      	cmp	r3, #0
 802a9cc:	d104      	bne.n	802a9d8 <DAVE_Init+0x1a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_3); 
 802a9ce:	485f      	ldr	r0, [pc, #380]	; (802ab4c <DAVE_Init+0x318>)
 802a9d0:	f7ff f964 	bl	8029c9c <DIGITAL_IO_Init>
 802a9d4:	4603      	mov	r3, r0
 802a9d6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a9d8:	79fb      	ldrb	r3, [r7, #7]
 802a9da:	2b00      	cmp	r3, #0
 802a9dc:	d104      	bne.n	802a9e8 <DAVE_Init+0x1b4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_4); 
 802a9de:	485c      	ldr	r0, [pc, #368]	; (802ab50 <DAVE_Init+0x31c>)
 802a9e0:	f7ff f95c 	bl	8029c9c <DIGITAL_IO_Init>
 802a9e4:	4603      	mov	r3, r0
 802a9e6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a9e8:	79fb      	ldrb	r3, [r7, #7]
 802a9ea:	2b00      	cmp	r3, #0
 802a9ec:	d104      	bne.n	802a9f8 <DAVE_Init+0x1c4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_5); 
 802a9ee:	4859      	ldr	r0, [pc, #356]	; (802ab54 <DAVE_Init+0x320>)
 802a9f0:	f7ff f954 	bl	8029c9c <DIGITAL_IO_Init>
 802a9f4:	4603      	mov	r3, r0
 802a9f6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a9f8:	79fb      	ldrb	r3, [r7, #7]
 802a9fa:	2b00      	cmp	r3, #0
 802a9fc:	d104      	bne.n	802aa08 <DAVE_Init+0x1d4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_6); 
 802a9fe:	4856      	ldr	r0, [pc, #344]	; (802ab58 <DAVE_Init+0x324>)
 802aa00:	f7ff f94c 	bl	8029c9c <DIGITAL_IO_Init>
 802aa04:	4603      	mov	r3, r0
 802aa06:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa08:	79fb      	ldrb	r3, [r7, #7]
 802aa0a:	2b00      	cmp	r3, #0
 802aa0c:	d104      	bne.n	802aa18 <DAVE_Init+0x1e4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_7); 
 802aa0e:	4853      	ldr	r0, [pc, #332]	; (802ab5c <DAVE_Init+0x328>)
 802aa10:	f7ff f944 	bl	8029c9c <DIGITAL_IO_Init>
 802aa14:	4603      	mov	r3, r0
 802aa16:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa18:	79fb      	ldrb	r3, [r7, #7]
 802aa1a:	2b00      	cmp	r3, #0
 802aa1c:	d104      	bne.n	802aa28 <DAVE_Init+0x1f4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_8 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_8); 
 802aa1e:	4850      	ldr	r0, [pc, #320]	; (802ab60 <DAVE_Init+0x32c>)
 802aa20:	f7ff f93c 	bl	8029c9c <DIGITAL_IO_Init>
 802aa24:	4603      	mov	r3, r0
 802aa26:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa28:	79fb      	ldrb	r3, [r7, #7]
 802aa2a:	2b00      	cmp	r3, #0
 802aa2c:	d104      	bne.n	802aa38 <DAVE_Init+0x204>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_NRES */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_NRES); 
 802aa2e:	484d      	ldr	r0, [pc, #308]	; (802ab64 <DAVE_Init+0x330>)
 802aa30:	f7ff f934 	bl	8029c9c <DIGITAL_IO_Init>
 802aa34:	4603      	mov	r3, r0
 802aa36:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa38:	79fb      	ldrb	r3, [r7, #7]
 802aa3a:	2b00      	cmp	r3, #0
 802aa3c:	d104      	bne.n	802aa48 <DAVE_Init+0x214>
  {
	 /**  Initialization of DIGITAL_IO APP instance DI_PNP_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DI_PNP_EN); 
 802aa3e:	484a      	ldr	r0, [pc, #296]	; (802ab68 <DAVE_Init+0x334>)
 802aa40:	f7ff f92c 	bl	8029c9c <DIGITAL_IO_Init>
 802aa44:	4603      	mov	r3, r0
 802aa46:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa48:	79fb      	ldrb	r3, [r7, #7]
 802aa4a:	2b00      	cmp	r3, #0
 802aa4c:	d104      	bne.n	802aa58 <DAVE_Init+0x224>
  {
	 /**  Initialization of DIGITAL_IO APP instance DI_NPN_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DI_NPN_EN); 
 802aa4e:	4847      	ldr	r0, [pc, #284]	; (802ab6c <DAVE_Init+0x338>)
 802aa50:	f7ff f924 	bl	8029c9c <DIGITAL_IO_Init>
 802aa54:	4603      	mov	r3, r0
 802aa56:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa58:	79fb      	ldrb	r3, [r7, #7]
 802aa5a:	2b00      	cmp	r3, #0
 802aa5c:	d104      	bne.n	802aa68 <DAVE_Init+0x234>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_POWER_EN1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_POWER_EN1); 
 802aa5e:	4844      	ldr	r0, [pc, #272]	; (802ab70 <DAVE_Init+0x33c>)
 802aa60:	f7ff f91c 	bl	8029c9c <DIGITAL_IO_Init>
 802aa64:	4603      	mov	r3, r0
 802aa66:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa68:	79fb      	ldrb	r3, [r7, #7]
 802aa6a:	2b00      	cmp	r3, #0
 802aa6c:	d104      	bne.n	802aa78 <DAVE_Init+0x244>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_POWER_EN2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_POWER_EN2); 
 802aa6e:	4841      	ldr	r0, [pc, #260]	; (802ab74 <DAVE_Init+0x340>)
 802aa70:	f7ff f914 	bl	8029c9c <DIGITAL_IO_Init>
 802aa74:	4603      	mov	r3, r0
 802aa76:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa78:	79fb      	ldrb	r3, [r7, #7]
 802aa7a:	2b00      	cmp	r3, #0
 802aa7c:	d104      	bne.n	802aa88 <DAVE_Init+0x254>
  {
	 /**  Initialization of DIGITAL_IO APP instance POWER_SWITCH */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&POWER_SWITCH); 
 802aa7e:	483e      	ldr	r0, [pc, #248]	; (802ab78 <DAVE_Init+0x344>)
 802aa80:	f7ff f90c 	bl	8029c9c <DIGITAL_IO_Init>
 802aa84:	4603      	mov	r3, r0
 802aa86:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa88:	79fb      	ldrb	r3, [r7, #7]
 802aa8a:	2b00      	cmp	r3, #0
 802aa8c:	d104      	bne.n	802aa98 <DAVE_Init+0x264>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_1); 
 802aa8e:	483b      	ldr	r0, [pc, #236]	; (802ab7c <DAVE_Init+0x348>)
 802aa90:	f7ff f904 	bl	8029c9c <DIGITAL_IO_Init>
 802aa94:	4603      	mov	r3, r0
 802aa96:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa98:	79fb      	ldrb	r3, [r7, #7]
 802aa9a:	2b00      	cmp	r3, #0
 802aa9c:	d104      	bne.n	802aaa8 <DAVE_Init+0x274>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_2); 
 802aa9e:	4838      	ldr	r0, [pc, #224]	; (802ab80 <DAVE_Init+0x34c>)
 802aaa0:	f7ff f8fc 	bl	8029c9c <DIGITAL_IO_Init>
 802aaa4:	4603      	mov	r3, r0
 802aaa6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aaa8:	79fb      	ldrb	r3, [r7, #7]
 802aaaa:	2b00      	cmp	r3, #0
 802aaac:	d104      	bne.n	802aab8 <DAVE_Init+0x284>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_3); 
 802aaae:	4835      	ldr	r0, [pc, #212]	; (802ab84 <DAVE_Init+0x350>)
 802aab0:	f7ff f8f4 	bl	8029c9c <DIGITAL_IO_Init>
 802aab4:	4603      	mov	r3, r0
 802aab6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aab8:	79fb      	ldrb	r3, [r7, #7]
 802aaba:	2b00      	cmp	r3, #0
 802aabc:	d104      	bne.n	802aac8 <DAVE_Init+0x294>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_4); 
 802aabe:	4832      	ldr	r0, [pc, #200]	; (802ab88 <DAVE_Init+0x354>)
 802aac0:	f7ff f8ec 	bl	8029c9c <DIGITAL_IO_Init>
 802aac4:	4603      	mov	r3, r0
 802aac6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aac8:	79fb      	ldrb	r3, [r7, #7]
 802aaca:	2b00      	cmp	r3, #0
 802aacc:	d104      	bne.n	802aad8 <DAVE_Init+0x2a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_5); 
 802aace:	482f      	ldr	r0, [pc, #188]	; (802ab8c <DAVE_Init+0x358>)
 802aad0:	f7ff f8e4 	bl	8029c9c <DIGITAL_IO_Init>
 802aad4:	4603      	mov	r3, r0
 802aad6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aad8:	79fb      	ldrb	r3, [r7, #7]
 802aada:	2b00      	cmp	r3, #0
 802aadc:	d15c      	bne.n	802ab98 <DAVE_Init+0x364>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_6); 
 802aade:	482c      	ldr	r0, [pc, #176]	; (802ab90 <DAVE_Init+0x35c>)
 802aae0:	f7ff f8dc 	bl	8029c9c <DIGITAL_IO_Init>
 802aae4:	e056      	b.n	802ab94 <DAVE_Init+0x360>
 802aae6:	bf00      	nop
 802aae8:	20001104 	.word	0x20001104
 802aaec:	0802b3dc 	.word	0x0802b3dc
 802aaf0:	0802b3f0 	.word	0x0802b3f0
 802aaf4:	0802b404 	.word	0x0802b404
 802aaf8:	0802b418 	.word	0x0802b418
 802aafc:	20001100 	.word	0x20001100
 802ab00:	0802b730 	.word	0x0802b730
 802ab04:	0802b870 	.word	0x0802b870
 802ab08:	0802b34c 	.word	0x0802b34c
 802ab0c:	20000268 	.word	0x20000268
 802ab10:	0802b350 	.word	0x0802b350
 802ab14:	0802b354 	.word	0x0802b354
 802ab18:	0802b42c 	.word	0x0802b42c
 802ab1c:	20000520 	.word	0x20000520
 802ab20:	20000534 	.word	0x20000534
 802ab24:	0802b440 	.word	0x0802b440
 802ab28:	0802b454 	.word	0x0802b454
 802ab2c:	20000548 	.word	0x20000548
 802ab30:	2000055c 	.word	0x2000055c
 802ab34:	0802b468 	.word	0x0802b468
 802ab38:	0802b47c 	.word	0x0802b47c
 802ab3c:	0802b490 	.word	0x0802b490
 802ab40:	0802b4a4 	.word	0x0802b4a4
 802ab44:	0802b4b8 	.word	0x0802b4b8
 802ab48:	0802b4cc 	.word	0x0802b4cc
 802ab4c:	0802b4e0 	.word	0x0802b4e0
 802ab50:	0802b4f4 	.word	0x0802b4f4
 802ab54:	0802b508 	.word	0x0802b508
 802ab58:	0802b51c 	.word	0x0802b51c
 802ab5c:	0802b530 	.word	0x0802b530
 802ab60:	0802b544 	.word	0x0802b544
 802ab64:	0802b558 	.word	0x0802b558
 802ab68:	0802b56c 	.word	0x0802b56c
 802ab6c:	0802b580 	.word	0x0802b580
 802ab70:	0802b594 	.word	0x0802b594
 802ab74:	0802b5a8 	.word	0x0802b5a8
 802ab78:	0802b5bc 	.word	0x0802b5bc
 802ab7c:	0802b5d0 	.word	0x0802b5d0
 802ab80:	0802b5e4 	.word	0x0802b5e4
 802ab84:	0802b5f8 	.word	0x0802b5f8
 802ab88:	0802b60c 	.word	0x0802b60c
 802ab8c:	0802b620 	.word	0x0802b620
 802ab90:	0802b634 	.word	0x0802b634
 802ab94:	4603      	mov	r3, r0
 802ab96:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802ab98:	79fb      	ldrb	r3, [r7, #7]
 802ab9a:	2b00      	cmp	r3, #0
 802ab9c:	d104      	bne.n	802aba8 <DAVE_Init+0x374>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_7); 
 802ab9e:	4831      	ldr	r0, [pc, #196]	; (802ac64 <DAVE_Init+0x430>)
 802aba0:	f7ff f87c 	bl	8029c9c <DIGITAL_IO_Init>
 802aba4:	4603      	mov	r3, r0
 802aba6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aba8:	79fb      	ldrb	r3, [r7, #7]
 802abaa:	2b00      	cmp	r3, #0
 802abac:	d104      	bne.n	802abb8 <DAVE_Init+0x384>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_8 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_8); 
 802abae:	482e      	ldr	r0, [pc, #184]	; (802ac68 <DAVE_Init+0x434>)
 802abb0:	f7ff f874 	bl	8029c9c <DIGITAL_IO_Init>
 802abb4:	4603      	mov	r3, r0
 802abb6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802abb8:	79fb      	ldrb	r3, [r7, #7]
 802abba:	2b00      	cmp	r3, #0
 802abbc:	d104      	bne.n	802abc8 <DAVE_Init+0x394>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_2_RESET_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_2_RESET_INT); 
 802abbe:	482b      	ldr	r0, [pc, #172]	; (802ac6c <DAVE_Init+0x438>)
 802abc0:	f7fe ff8f 	bl	8029ae2 <INTERRUPT_Init>
 802abc4:	4603      	mov	r3, r0
 802abc6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802abc8:	79fb      	ldrb	r3, [r7, #7]
 802abca:	2b00      	cmp	r3, #0
 802abcc:	d104      	bne.n	802abd8 <DAVE_Init+0x3a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance MOTOR_FAULT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&MOTOR_FAULT); 
 802abce:	4828      	ldr	r0, [pc, #160]	; (802ac70 <DAVE_Init+0x43c>)
 802abd0:	f7ff f864 	bl	8029c9c <DIGITAL_IO_Init>
 802abd4:	4603      	mov	r3, r0
 802abd6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802abd8:	79fb      	ldrb	r3, [r7, #7]
 802abda:	2b00      	cmp	r3, #0
 802abdc:	d104      	bne.n	802abe8 <DAVE_Init+0x3b4>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_1_TRAP_SENSOR_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_1_TRAP_SENSOR_INT); 
 802abde:	4825      	ldr	r0, [pc, #148]	; (802ac74 <DAVE_Init+0x440>)
 802abe0:	f7fe ff7f 	bl	8029ae2 <INTERRUPT_Init>
 802abe4:	4603      	mov	r3, r0
 802abe6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802abe8:	79fb      	ldrb	r3, [r7, #7]
 802abea:	2b00      	cmp	r3, #0
 802abec:	d104      	bne.n	802abf8 <DAVE_Init+0x3c4>
  {
	 /**  Initialization of INTERRUPT APP instance SERV_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&SERV_INT); 
 802abee:	4822      	ldr	r0, [pc, #136]	; (802ac78 <DAVE_Init+0x444>)
 802abf0:	f7fe ff77 	bl	8029ae2 <INTERRUPT_Init>
 802abf4:	4603      	mov	r3, r0
 802abf6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802abf8:	79fb      	ldrb	r3, [r7, #7]
 802abfa:	2b00      	cmp	r3, #0
 802abfc:	d104      	bne.n	802ac08 <DAVE_Init+0x3d4>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_1_STOP_BUT_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_1_STOP_BUT_INT); 
 802abfe:	481f      	ldr	r0, [pc, #124]	; (802ac7c <DAVE_Init+0x448>)
 802ac00:	f7fe ff6f 	bl	8029ae2 <INTERRUPT_Init>
 802ac04:	4603      	mov	r3, r0
 802ac06:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802ac08:	79fb      	ldrb	r3, [r7, #7]
 802ac0a:	2b00      	cmp	r3, #0
 802ac0c:	d104      	bne.n	802ac18 <DAVE_Init+0x3e4>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_NODE_ALLERT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_NODE_ALLERT); 
 802ac0e:	481c      	ldr	r0, [pc, #112]	; (802ac80 <DAVE_Init+0x44c>)
 802ac10:	f7fe ff67 	bl	8029ae2 <INTERRUPT_Init>
 802ac14:	4603      	mov	r3, r0
 802ac16:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802ac18:	79fb      	ldrb	r3, [r7, #7]
 802ac1a:	2b00      	cmp	r3, #0
 802ac1c:	d104      	bne.n	802ac28 <DAVE_Init+0x3f4>
  {
	 /**  Initialization of ADC_MEASUREMENT APP instance ADC_MEASUREMENT_0 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_Init(&ADC_MEASUREMENT_0); 
 802ac1e:	4819      	ldr	r0, [pc, #100]	; (802ac84 <DAVE_Init+0x450>)
 802ac20:	f7ff fd35 	bl	802a68e <ADC_MEASUREMENT_Init>
 802ac24:	4603      	mov	r3, r0
 802ac26:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802ac28:	79fb      	ldrb	r3, [r7, #7]
 802ac2a:	2b00      	cmp	r3, #0
 802ac2c:	d104      	bne.n	802ac38 <DAVE_Init+0x404>
  {
	 /**  Initialization of PWM_CCU4 APP instance BUZZ_PWM */
	 init_status = (DAVE_STATUS_t)PWM_CCU4_Init(&BUZZ_PWM); 
 802ac2e:	4816      	ldr	r0, [pc, #88]	; (802ac88 <DAVE_Init+0x454>)
 802ac30:	f7fe fbf5 	bl	802941e <PWM_CCU4_Init>
 802ac34:	4603      	mov	r3, r0
 802ac36:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802ac38:	79fb      	ldrb	r3, [r7, #7]
 802ac3a:	2b00      	cmp	r3, #0
 802ac3c:	d104      	bne.n	802ac48 <DAVE_Init+0x414>
  {
	 /**  Initialization of INTERRUPT APP instance BUZZ_INT_OVF */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&BUZZ_INT_OVF); 
 802ac3e:	4813      	ldr	r0, [pc, #76]	; (802ac8c <DAVE_Init+0x458>)
 802ac40:	f7fe ff4f 	bl	8029ae2 <INTERRUPT_Init>
 802ac44:	4603      	mov	r3, r0
 802ac46:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802ac48:	79fb      	ldrb	r3, [r7, #7]
 802ac4a:	2b00      	cmp	r3, #0
 802ac4c:	d104      	bne.n	802ac58 <DAVE_Init+0x424>
  {
	 /**  Initialization of INTERRUPT APP instance BUZZ_INT_CMP */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&BUZZ_INT_CMP); 
 802ac4e:	4810      	ldr	r0, [pc, #64]	; (802ac90 <DAVE_Init+0x45c>)
 802ac50:	f7fe ff47 	bl	8029ae2 <INTERRUPT_Init>
 802ac54:	4603      	mov	r3, r0
 802ac56:	71fb      	strb	r3, [r7, #7]
   }  
  return init_status;
 802ac58:	79fb      	ldrb	r3, [r7, #7]
} /**  End of function DAVE_Init */
 802ac5a:	4618      	mov	r0, r3
 802ac5c:	3708      	adds	r7, #8
 802ac5e:	46bd      	mov	sp, r7
 802ac60:	bd80      	pop	{r7, pc}
 802ac62:	bf00      	nop
 802ac64:	0802b648 	.word	0x0802b648
 802ac68:	0802b65c 	.word	0x0802b65c
 802ac6c:	0802b358 	.word	0x0802b358
 802ac70:	0802b670 	.word	0x0802b670
 802ac74:	0802b35c 	.word	0x0802b35c
 802ac78:	0802b360 	.word	0x0802b360
 802ac7c:	0802b364 	.word	0x0802b364
 802ac80:	0802b368 	.word	0x0802b368
 802ac84:	200005dc 	.word	0x200005dc
 802ac88:	20000290 	.word	0x20000290
 802ac8c:	0802b36c 	.word	0x0802b36c
 802ac90:	0802b370 	.word	0x0802b370

0802ac94 <XMC_GPIO_SetOutputHigh>:
{
 802ac94:	b480      	push	{r7}
 802ac96:	b083      	sub	sp, #12
 802ac98:	af00      	add	r7, sp, #0
 802ac9a:	6078      	str	r0, [r7, #4]
 802ac9c:	460b      	mov	r3, r1
 802ac9e:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 802aca0:	78fb      	ldrb	r3, [r7, #3]
 802aca2:	2201      	movs	r2, #1
 802aca4:	409a      	lsls	r2, r3
 802aca6:	687b      	ldr	r3, [r7, #4]
 802aca8:	605a      	str	r2, [r3, #4]
}
 802acaa:	bf00      	nop
 802acac:	370c      	adds	r7, #12
 802acae:	46bd      	mov	sp, r7
 802acb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802acb4:	4770      	bx	lr

0802acb6 <XMC_GPIO_SetOutputLow>:
{
 802acb6:	b480      	push	{r7}
 802acb8:	b083      	sub	sp, #12
 802acba:	af00      	add	r7, sp, #0
 802acbc:	6078      	str	r0, [r7, #4]
 802acbe:	460b      	mov	r3, r1
 802acc0:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 802acc2:	78fb      	ldrb	r3, [r7, #3]
 802acc4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802acc8:	409a      	lsls	r2, r3
 802acca:	687b      	ldr	r3, [r7, #4]
 802accc:	605a      	str	r2, [r3, #4]
}
 802acce:	bf00      	nop
 802acd0:	370c      	adds	r7, #12
 802acd2:	46bd      	mov	sp, r7
 802acd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802acd8:	4770      	bx	lr

0802acda <XMC_GPIO_ToggleOutput>:
{
 802acda:	b480      	push	{r7}
 802acdc:	b083      	sub	sp, #12
 802acde:	af00      	add	r7, sp, #0
 802ace0:	6078      	str	r0, [r7, #4]
 802ace2:	460b      	mov	r3, r1
 802ace4:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10001U << pin;
 802ace6:	78fb      	ldrb	r3, [r7, #3]
 802ace8:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 802acec:	409a      	lsls	r2, r3
 802acee:	687b      	ldr	r3, [r7, #4]
 802acf0:	605a      	str	r2, [r3, #4]
}
 802acf2:	bf00      	nop
 802acf4:	370c      	adds	r7, #12
 802acf6:	46bd      	mov	sp, r7
 802acf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 802acfc:	4770      	bx	lr

0802acfe <DIGITAL_IO_SetOutputHigh>:
{
 802acfe:	b580      	push	{r7, lr}
 802ad00:	b082      	sub	sp, #8
 802ad02:	af00      	add	r7, sp, #0
 802ad04:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 802ad06:	687b      	ldr	r3, [r7, #4]
 802ad08:	681a      	ldr	r2, [r3, #0]
 802ad0a:	687b      	ldr	r3, [r7, #4]
 802ad0c:	7c1b      	ldrb	r3, [r3, #16]
 802ad0e:	4619      	mov	r1, r3
 802ad10:	4610      	mov	r0, r2
 802ad12:	f7ff ffbf 	bl	802ac94 <XMC_GPIO_SetOutputHigh>
}
 802ad16:	bf00      	nop
 802ad18:	3708      	adds	r7, #8
 802ad1a:	46bd      	mov	sp, r7
 802ad1c:	bd80      	pop	{r7, pc}

0802ad1e <DIGITAL_IO_SetOutputLow>:
{
 802ad1e:	b580      	push	{r7, lr}
 802ad20:	b082      	sub	sp, #8
 802ad22:	af00      	add	r7, sp, #0
 802ad24:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 802ad26:	687b      	ldr	r3, [r7, #4]
 802ad28:	681a      	ldr	r2, [r3, #0]
 802ad2a:	687b      	ldr	r3, [r7, #4]
 802ad2c:	7c1b      	ldrb	r3, [r3, #16]
 802ad2e:	4619      	mov	r1, r3
 802ad30:	4610      	mov	r0, r2
 802ad32:	f7ff ffc0 	bl	802acb6 <XMC_GPIO_SetOutputLow>
}
 802ad36:	bf00      	nop
 802ad38:	3708      	adds	r7, #8
 802ad3a:	46bd      	mov	sp, r7
 802ad3c:	bd80      	pop	{r7, pc}

0802ad3e <DIGITAL_IO_ToggleOutput>:
{
 802ad3e:	b580      	push	{r7, lr}
 802ad40:	b082      	sub	sp, #8
 802ad42:	af00      	add	r7, sp, #0
 802ad44:	6078      	str	r0, [r7, #4]
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 802ad46:	687b      	ldr	r3, [r7, #4]
 802ad48:	681a      	ldr	r2, [r3, #0]
 802ad4a:	687b      	ldr	r3, [r7, #4]
 802ad4c:	7c1b      	ldrb	r3, [r3, #16]
 802ad4e:	4619      	mov	r1, r3
 802ad50:	4610      	mov	r0, r2
 802ad52:	f7ff ffc2 	bl	802acda <XMC_GPIO_ToggleOutput>
}
 802ad56:	bf00      	nop
 802ad58:	3708      	adds	r7, #8
 802ad5a:	46bd      	mov	sp, r7
 802ad5c:	bd80      	pop	{r7, pc}
	...

0802ad60 <XMC_SCU_RESET_ClearDeviceResetReason>:
{
 802ad60:	b480      	push	{r7}
 802ad62:	af00      	add	r7, sp, #0
  SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_RSCLR_Msk;
 802ad64:	4b03      	ldr	r3, [pc, #12]	; (802ad74 <XMC_SCU_RESET_ClearDeviceResetReason+0x14>)
 802ad66:	2201      	movs	r2, #1
 802ad68:	609a      	str	r2, [r3, #8]
}
 802ad6a:	bf00      	nop
 802ad6c:	46bd      	mov	sp, r7
 802ad6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ad72:	4770      	bx	lr
 802ad74:	50004400 	.word	0x50004400

0802ad78 <CCU43_0_IRQHandler>:
extern uint8_t Can1Rx3Data[8];
//extern int32_t ExtCanOnline;


void ClutchCmpHandler (void)
{
 802ad78:	b580      	push	{r7, lr}
 802ad7a:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&CLUTCH_PWM,XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 802ad7c:	2102      	movs	r1, #2
 802ad7e:	4805      	ldr	r0, [pc, #20]	; (802ad94 <CCU43_0_IRQHandler+0x1c>)
 802ad80:	f7fe fe06 	bl	8029990 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputLow(&HS_SW_1);
 802ad84:	4804      	ldr	r0, [pc, #16]	; (802ad98 <CCU43_0_IRQHandler+0x20>)
 802ad86:	f7ff ffca 	bl	802ad1e <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputLow(&HS_SW_2);
 802ad8a:	4804      	ldr	r0, [pc, #16]	; (802ad9c <CCU43_0_IRQHandler+0x24>)
 802ad8c:	f7ff ffc7 	bl	802ad1e <DIGITAL_IO_SetOutputLow>
}
 802ad90:	bf00      	nop
 802ad92:	bd80      	pop	{r7, pc}
 802ad94:	20000268 	.word	0x20000268
 802ad98:	0802b4b8 	.word	0x0802b4b8
 802ad9c:	0802b4cc 	.word	0x0802b4cc

0802ada0 <CCU43_1_IRQHandler>:
void ClutchOvfHandler(void)
{
 802ada0:	b580      	push	{r7, lr}
 802ada2:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&CLUTCH_PWM,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 802ada4:	2100      	movs	r1, #0
 802ada6:	4805      	ldr	r0, [pc, #20]	; (802adbc <CCU43_1_IRQHandler+0x1c>)
 802ada8:	f7fe fdf2 	bl	8029990 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputHigh(&HS_SW_1);
 802adac:	4804      	ldr	r0, [pc, #16]	; (802adc0 <CCU43_1_IRQHandler+0x20>)
 802adae:	f7ff ffa6 	bl	802acfe <DIGITAL_IO_SetOutputHigh>
	DIGITAL_IO_SetOutputHigh(&HS_SW_2);
 802adb2:	4804      	ldr	r0, [pc, #16]	; (802adc4 <CCU43_1_IRQHandler+0x24>)
 802adb4:	f7ff ffa3 	bl	802acfe <DIGITAL_IO_SetOutputHigh>
}
 802adb8:	bf00      	nop
 802adba:	bd80      	pop	{r7, pc}
 802adbc:	20000268 	.word	0x20000268
 802adc0:	0802b4b8 	.word	0x0802b4b8
 802adc4:	0802b4cc 	.word	0x0802b4cc

0802adc8 <MCU_ProgramReset>:


void MCU_ProgramReset( void )
{
 802adc8:	b580      	push	{r7, lr}
 802adca:	af00      	add	r7, sp, #0

	// clear the reset cause field for proper reset detection of the ssw
	XMC_SCU_RESET_ClearDeviceResetReason();
 802adcc:	f7ff ffc8 	bl	802ad60 <XMC_SCU_RESET_ClearDeviceResetReason>

	// set normal boot as boot mode in SWCON field of STCON register
	XMC_SCU_SetBootMode(XMC_SCU_BOOTMODE_NORMAL);
 802add0:	2000      	movs	r0, #0
 802add2:	f7fb fd0d 	bl	80267f0 <XMC_SCU_SetBootMode>

	// trigger power on reset
	PPB->AIRCR = 1 << PPB_AIRCR_SYSRESETREQ_Pos |0x5FA<<PPB_AIRCR_VECTKEY_Pos | 0x1 << PPB_AIRCR_PRIGROUP_Pos;
 802add6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802adda:	4a02      	ldr	r2, [pc, #8]	; (802ade4 <MCU_ProgramReset+0x1c>)
 802addc:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	while (1) {};
 802ade0:	e7fe      	b.n	802ade0 <MCU_ProgramReset+0x18>
 802ade2:	bf00      	nop
 802ade4:	05fa0104 	.word	0x05fa0104

0802ade8 <VADC0_C0_2_IRQHandler>:

} //MCU_ProgramReset()

void Adc_Measurement_Handler(void)
{
 802ade8:	b580      	push	{r7, lr}
 802adea:	b082      	sub	sp, #8
 802adec:	af00      	add	r7, sp, #0
	float temp = 0;
 802adee:	f04f 0300 	mov.w	r3, #0
 802adf2:	607b      	str	r3, [r7, #4]

	Inputs.RIN1 = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A_handle);
 802adf4:	481b      	ldr	r0, [pc, #108]	; (802ae64 <VADC0_C0_2_IRQHandler+0x7c>)
 802adf6:	f7ff fd05 	bl	802a804 <ADC_MEASUREMENT_GetResult>
 802adfa:	4603      	mov	r3, r0
 802adfc:	461a      	mov	r2, r3
 802adfe:	4b1a      	ldr	r3, [pc, #104]	; (802ae68 <VADC0_C0_2_IRQHandler+0x80>)
 802ae00:	811a      	strh	r2, [r3, #8]
	else
	{
		ActiveRubberL = 0;
	}
*/
    Inputs.RIN2 = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_B_handle);
 802ae02:	481a      	ldr	r0, [pc, #104]	; (802ae6c <VADC0_C0_2_IRQHandler+0x84>)
 802ae04:	f7ff fcfe 	bl	802a804 <ADC_MEASUREMENT_GetResult>
 802ae08:	4603      	mov	r3, r0
 802ae0a:	461a      	mov	r2, r3
 802ae0c:	4b16      	ldr	r3, [pc, #88]	; (802ae68 <VADC0_C0_2_IRQHandler+0x80>)
 802ae0e:	815a      	strh	r2, [r3, #10]
    else
    {
        ActiveRubberR = 0;
    }
*/
   Inputs.DCIN = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_C_handle);
 802ae10:	4817      	ldr	r0, [pc, #92]	; (802ae70 <VADC0_C0_2_IRQHandler+0x88>)
 802ae12:	f7ff fcf7 	bl	802a804 <ADC_MEASUREMENT_GetResult>
 802ae16:	4603      	mov	r3, r0
 802ae18:	461a      	mov	r2, r3
 802ae1a:	4b13      	ldr	r3, [pc, #76]	; (802ae68 <VADC0_C0_2_IRQHandler+0x80>)
 802ae1c:	819a      	strh	r2, [r3, #12]
   //temp = Inputs.InputPower;
   temp = (1200 + (Inputs.DCIN - 1300)/20*18);
 802ae1e:	4b12      	ldr	r3, [pc, #72]	; (802ae68 <VADC0_C0_2_IRQHandler+0x80>)
 802ae20:	899b      	ldrh	r3, [r3, #12]
 802ae22:	f2a3 5314 	subw	r3, r3, #1300	; 0x514
 802ae26:	4a13      	ldr	r2, [pc, #76]	; (802ae74 <VADC0_C0_2_IRQHandler+0x8c>)
 802ae28:	fb82 1203 	smull	r1, r2, r2, r3
 802ae2c:	10d2      	asrs	r2, r2, #3
 802ae2e:	17db      	asrs	r3, r3, #31
 802ae30:	1ad2      	subs	r2, r2, r3
 802ae32:	4613      	mov	r3, r2
 802ae34:	00db      	lsls	r3, r3, #3
 802ae36:	4413      	add	r3, r2
 802ae38:	005b      	lsls	r3, r3, #1
 802ae3a:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 802ae3e:	ee07 3a90 	vmov	s15, r3
 802ae42:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ae46:	edc7 7a01 	vstr	s15, [r7, #4]
   Inputs.DCIN = (uint16_t)temp;
 802ae4a:	edd7 7a01 	vldr	s15, [r7, #4]
 802ae4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802ae52:	ee17 3a90 	vmov	r3, s15
 802ae56:	b29a      	uxth	r2, r3
 802ae58:	4b03      	ldr	r3, [pc, #12]	; (802ae68 <VADC0_C0_2_IRQHandler+0x80>)
 802ae5a:	819a      	strh	r2, [r3, #12]

   //Inputs.DriveCurrent = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_D_handle);
}
 802ae5c:	bf00      	nop
 802ae5e:	3708      	adds	r7, #8
 802ae60:	46bd      	mov	sp, r7
 802ae62:	bd80      	pop	{r7, pc}
 802ae64:	2000057c 	.word	0x2000057c
 802ae68:	20000668 	.word	0x20000668
 802ae6c:	2000059c 	.word	0x2000059c
 802ae70:	200005bc 	.word	0x200005bc
 802ae74:	66666667 	.word	0x66666667

0802ae78 <CAN0_1_IRQHandler>:
void ResetISRCan2Handler (void)
{
 802ae78:	b580      	push	{r7, lr}
 802ae7a:	b092      	sub	sp, #72	; 0x48
 802ae7c:	af00      	add	r7, sp, #0
	char tempCanData[8] = {'C','M','D','_','B','O','O','T'};
 802ae7e:	4a41      	ldr	r2, [pc, #260]	; (802af84 <CAN0_1_IRQHandler+0x10c>)
 802ae80:	f107 0308 	add.w	r3, r7, #8
 802ae84:	e892 0003 	ldmia.w	r2, {r0, r1}
 802ae88:	e883 0003 	stmia.w	r3, {r0, r1}
	char tempCanDataAddress[8] = {'R','E','S','E','T','_','0','0'};
 802ae8c:	4a3e      	ldr	r2, [pc, #248]	; (802af88 <CAN0_1_IRQHandler+0x110>)
 802ae8e:	463b      	mov	r3, r7
 802ae90:	e892 0003 	ldmia.w	r2, {r0, r1}
 802ae94:	e883 0003 	stmia.w	r3, {r0, r1}
	uint8_t temp = 0;
 802ae98:	2300      	movs	r3, #0
 802ae9a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	//uint64_t temp_long = 0;

	DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 802ae9e:	483b      	ldr	r0, [pc, #236]	; (802af8c <CAN0_1_IRQHandler+0x114>)
 802aea0:	f7ff ff4d 	bl	802ad3e <DIGITAL_IO_ToggleOutput>

	CAN_NODE_MO_Receive(&CAN_INT_LMO_08_Config);
 802aea4:	483a      	ldr	r0, [pc, #232]	; (802af90 <CAN0_1_IRQHandler+0x118>)
 802aea6:	f7ff f967 	bl	802a178 <CAN_NODE_MO_Receive>

	if (CAN_INT_LMO_08_Config.mo_ptr->can_identifier == 0x06)
 802aeaa:	4b39      	ldr	r3, [pc, #228]	; (802af90 <CAN0_1_IRQHandler+0x118>)
 802aeac:	681b      	ldr	r3, [r3, #0]
 802aeae:	685b      	ldr	r3, [r3, #4]
 802aeb0:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802aeb4:	2b06      	cmp	r3, #6
 802aeb6:	d117      	bne.n	802aee8 <CAN0_1_IRQHandler+0x70>
	{
		uint64_t ul1 = CAN_INT_LMO_08_Config.mo_ptr->can_data_long;
 802aeb8:	4b35      	ldr	r3, [pc, #212]	; (802af90 <CAN0_1_IRQHandler+0x118>)
 802aeba:	681b      	ldr	r3, [r3, #0]
 802aebc:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 802aec0:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

		uint64_t * p = (uint64_t *)(tempCanData);
 802aec4:	f107 0308 	add.w	r3, r7, #8
 802aec8:	637b      	str	r3, [r7, #52]	; 0x34
		uint64_t ul2 = *p;
 802aeca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802aecc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802aed0:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

		if (ul1 == ul2)
 802aed4:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 802aed8:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 802aedc:	4299      	cmp	r1, r3
 802aede:	bf08      	it	eq
 802aee0:	4290      	cmpeq	r0, r2
 802aee2:	d101      	bne.n	802aee8 <CAN0_1_IRQHandler+0x70>
		{
			MCU_ProgramReset();
 802aee4:	f7ff ff70 	bl	802adc8 <MCU_ProgramReset>
		}
	}

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_08_Config);
 802aee8:	482a      	ldr	r0, [pc, #168]	; (802af94 <CAN0_1_IRQHandler+0x11c>)
 802aeea:	f7ff f945 	bl	802a178 <CAN_NODE_MO_Receive>

	if (CAN_EXT_LMO_08_Config.mo_ptr->can_identifier == 0x06)
 802aeee:	4b29      	ldr	r3, [pc, #164]	; (802af94 <CAN0_1_IRQHandler+0x11c>)
 802aef0:	681b      	ldr	r3, [r3, #0]
 802aef2:	685b      	ldr	r3, [r3, #4]
 802aef4:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802aef8:	2b06      	cmp	r3, #6
 802aefa:	d13f      	bne.n	802af7c <CAN0_1_IRQHandler+0x104>
	{
		uint64_t ul1 = CAN_EXT_LMO_08_Config.mo_ptr->can_data_long;
 802aefc:	4b25      	ldr	r3, [pc, #148]	; (802af94 <CAN0_1_IRQHandler+0x11c>)
 802aefe:	681b      	ldr	r3, [r3, #0]
 802af00:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 802af04:	e9c7 2308 	strd	r2, r3, [r7, #32]

		temp = (uint8_t)Presets.CAN_ADRESS; // calculate address
 802af08:	4b23      	ldr	r3, [pc, #140]	; (802af98 <CAN0_1_IRQHandler+0x120>)
 802af0a:	689b      	ldr	r3, [r3, #8]
 802af0c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		temp = temp/10;		// 00 - 90 from address (tens)
 802af10:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802af14:	4a21      	ldr	r2, [pc, #132]	; (802af9c <CAN0_1_IRQHandler+0x124>)
 802af16:	fba2 2303 	umull	r2, r3, r2, r3
 802af1a:	08db      	lsrs	r3, r3, #3
 802af1c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		tempCanDataAddress[6] += temp; // add to string
 802af20:	79ba      	ldrb	r2, [r7, #6]
 802af22:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802af26:	4413      	add	r3, r2
 802af28:	b2db      	uxtb	r3, r3
 802af2a:	71bb      	strb	r3, [r7, #6]

		temp = (uint8_t)Presets.CAN_ADRESS;
 802af2c:	4b1a      	ldr	r3, [pc, #104]	; (802af98 <CAN0_1_IRQHandler+0x120>)
 802af2e:	689b      	ldr	r3, [r3, #8]
 802af30:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		temp = temp%10;	// 0 - 9 from address
 802af34:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 802af38:	4b18      	ldr	r3, [pc, #96]	; (802af9c <CAN0_1_IRQHandler+0x124>)
 802af3a:	fba3 1302 	umull	r1, r3, r3, r2
 802af3e:	08d9      	lsrs	r1, r3, #3
 802af40:	460b      	mov	r3, r1
 802af42:	009b      	lsls	r3, r3, #2
 802af44:	440b      	add	r3, r1
 802af46:	005b      	lsls	r3, r3, #1
 802af48:	1ad3      	subs	r3, r2, r3
 802af4a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		tempCanDataAddress[7] += temp; // add to string
 802af4e:	79fa      	ldrb	r2, [r7, #7]
 802af50:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802af54:	4413      	add	r3, r2
 802af56:	b2db      	uxtb	r3, r3
 802af58:	71fb      	strb	r3, [r7, #7]

		uint64_t * p = (uint64_t *)(tempCanDataAddress);
 802af5a:	463b      	mov	r3, r7
 802af5c:	61fb      	str	r3, [r7, #28]
		uint64_t ul2 = *p;
 802af5e:	69fb      	ldr	r3, [r7, #28]
 802af60:	e9d3 2300 	ldrd	r2, r3, [r3]
 802af64:	e9c7 2304 	strd	r2, r3, [r7, #16]

		if (ul1 == ul2)
 802af68:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 802af6c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 802af70:	4299      	cmp	r1, r3
 802af72:	bf08      	it	eq
 802af74:	4290      	cmpeq	r0, r2
 802af76:	d101      	bne.n	802af7c <CAN0_1_IRQHandler+0x104>
		{
			MCU_ProgramReset();
 802af78:	f7ff ff26 	bl	802adc8 <MCU_ProgramReset>
		}
	}

}
 802af7c:	bf00      	nop
 802af7e:	3748      	adds	r7, #72	; 0x48
 802af80:	46bd      	mov	sp, r7
 802af82:	bd80      	pop	{r7, pc}
 802af84:	0802b9e4 	.word	0x0802b9e4
 802af88:	0802b9ec 	.word	0x0802b9ec
 802af8c:	0802b404 	.word	0x0802b404
 802af90:	0802b864 	.word	0x0802b864
 802af94:	0802b724 	.word	0x0802b724
 802af98:	20000770 	.word	0x20000770
 802af9c:	cccccccd 	.word	0xcccccccd

0802afa0 <CAN0_2_IRQHandler>:

void ServiceISRHandler(void)
{
 802afa0:	b580      	push	{r7, lr}
 802afa2:	b082      	sub	sp, #8
 802afa4:	af00      	add	r7, sp, #0
	CAN_NODE_MO_Receive(&CAN_INT_LMO_06_Config);
 802afa6:	4820      	ldr	r0, [pc, #128]	; (802b028 <CAN0_2_IRQHandler+0x88>)
 802afa8:	f7ff f8e6 	bl	802a178 <CAN_NODE_MO_Receive>

	if (CAN_INT_LMO_06_Config.mo_ptr->can_identifier == 0x100)
 802afac:	4b1e      	ldr	r3, [pc, #120]	; (802b028 <CAN0_2_IRQHandler+0x88>)
 802afae:	681b      	ldr	r3, [r3, #0]
 802afb0:	685b      	ldr	r3, [r3, #4]
 802afb2:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802afb6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802afba:	d113      	bne.n	802afe4 <CAN0_2_IRQHandler+0x44>
	{
		for (int i = 0; i < 8; i++)
 802afbc:	2300      	movs	r3, #0
 802afbe:	607b      	str	r3, [r7, #4]
 802afc0:	e00d      	b.n	802afde <CAN0_2_IRQHandler+0x3e>
		{
			ServCanRxData1[i] = CAN_INT_LMO_06_Config.mo_ptr->can_data_byte[i];
 802afc2:	4b19      	ldr	r3, [pc, #100]	; (802b028 <CAN0_2_IRQHandler+0x88>)
 802afc4:	681a      	ldr	r2, [r3, #0]
 802afc6:	687b      	ldr	r3, [r7, #4]
 802afc8:	4413      	add	r3, r2
 802afca:	3310      	adds	r3, #16
 802afcc:	7819      	ldrb	r1, [r3, #0]
 802afce:	4a17      	ldr	r2, [pc, #92]	; (802b02c <CAN0_2_IRQHandler+0x8c>)
 802afd0:	687b      	ldr	r3, [r7, #4]
 802afd2:	4413      	add	r3, r2
 802afd4:	460a      	mov	r2, r1
 802afd6:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 802afd8:	687b      	ldr	r3, [r7, #4]
 802afda:	3301      	adds	r3, #1
 802afdc:	607b      	str	r3, [r7, #4]
 802afde:	687b      	ldr	r3, [r7, #4]
 802afe0:	2b07      	cmp	r3, #7
 802afe2:	ddee      	ble.n	802afc2 <CAN0_2_IRQHandler+0x22>
		}
	}
	if (CAN_INT_LMO_06_Config.mo_ptr->can_identifier == 0x101)
 802afe4:	4b10      	ldr	r3, [pc, #64]	; (802b028 <CAN0_2_IRQHandler+0x88>)
 802afe6:	681b      	ldr	r3, [r3, #0]
 802afe8:	685b      	ldr	r3, [r3, #4]
 802afea:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802afee:	f240 1201 	movw	r2, #257	; 0x101
 802aff2:	4293      	cmp	r3, r2
 802aff4:	d113      	bne.n	802b01e <CAN0_2_IRQHandler+0x7e>
	{
		for (int i = 0; i < 8; i++)
 802aff6:	2300      	movs	r3, #0
 802aff8:	603b      	str	r3, [r7, #0]
 802affa:	e00d      	b.n	802b018 <CAN0_2_IRQHandler+0x78>
		{
			ServCanRxData2[i] = CAN_INT_LMO_06_Config.mo_ptr->can_data_byte[i];
 802affc:	4b0a      	ldr	r3, [pc, #40]	; (802b028 <CAN0_2_IRQHandler+0x88>)
 802affe:	681a      	ldr	r2, [r3, #0]
 802b000:	683b      	ldr	r3, [r7, #0]
 802b002:	4413      	add	r3, r2
 802b004:	3310      	adds	r3, #16
 802b006:	7819      	ldrb	r1, [r3, #0]
 802b008:	4a09      	ldr	r2, [pc, #36]	; (802b030 <CAN0_2_IRQHandler+0x90>)
 802b00a:	683b      	ldr	r3, [r7, #0]
 802b00c:	4413      	add	r3, r2
 802b00e:	460a      	mov	r2, r1
 802b010:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 802b012:	683b      	ldr	r3, [r7, #0]
 802b014:	3301      	adds	r3, #1
 802b016:	603b      	str	r3, [r7, #0]
 802b018:	683b      	ldr	r3, [r7, #0]
 802b01a:	2b07      	cmp	r3, #7
 802b01c:	ddee      	ble.n	802affc <CAN0_2_IRQHandler+0x5c>
		}
	}
}
 802b01e:	bf00      	nop
 802b020:	3708      	adds	r7, #8
 802b022:	46bd      	mov	sp, r7
 802b024:	bd80      	pop	{r7, pc}
 802b026:	bf00      	nop
 802b028:	0802b84c 	.word	0x0802b84c
 802b02c:	20000fc0 	.word	0x20000fc0
 802b030:	20000fc8 	.word	0x20000fc8

0802b034 <main>:

int main(void)
{
 802b034:	b580      	push	{r7, lr}
 802b036:	b082      	sub	sp, #8
 802b038:	af00      	add	r7, sp, #0
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */
 802b03a:	f7ff fbfb 	bl	802a834 <DAVE_Init>
 802b03e:	4603      	mov	r3, r0
 802b040:	71fb      	strb	r3, [r7, #7]

  if (status != DAVE_STATUS_SUCCESS)
 802b042:	79fb      	ldrb	r3, [r7, #7]
 802b044:	2b00      	cmp	r3, #0
 802b046:	d000      	beq.n	802b04a <main+0x16>
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
 802b048:	e7fe      	b.n	802b048 <main+0x14>
    }
  }

  // Init Internal Retain Memory Code:

  E_EEPROM_XMC4_STATUS_t e_status = E_EEPROM_XMC4_Init( &RETAIN );
 802b04a:	481a      	ldr	r0, [pc, #104]	; (802b0b4 <main+0x80>)
 802b04c:	f7fa ffb4 	bl	8025fb8 <E_EEPROM_XMC4_Init>
 802b050:	4603      	mov	r3, r0
 802b052:	71bb      	strb	r3, [r7, #6]
    switch ( e_status ) {
 802b054:	79bb      	ldrb	r3, [r7, #6]
 802b056:	2b04      	cmp	r3, #4
 802b058:	d012      	beq.n	802b080 <main+0x4c>
 802b05a:	2b04      	cmp	r3, #4
 802b05c:	dc1c      	bgt.n	802b098 <main+0x64>
 802b05e:	2b00      	cmp	r3, #0
 802b060:	d002      	beq.n	802b068 <main+0x34>
 802b062:	2b01      	cmp	r3, #1
 802b064:	d00c      	beq.n	802b080 <main+0x4c>
 802b066:	e017      	b.n	802b098 <main+0x64>
    	case  E_EEPROM_XMC4_STATUS_OK: {
    		  if ( E_EEPROM_XMC4_IsFlashEmpty())
 802b068:	f7fb f8bc 	bl	80261e4 <E_EEPROM_XMC4_IsFlashEmpty>
 802b06c:	4603      	mov	r3, r0
 802b06e:	2b00      	cmp	r3, #0
 802b070:	d002      	beq.n	802b078 <main+0x44>
    		  {
    			  SaveAllPresets(&DefaultPresets);
 802b072:	4811      	ldr	r0, [pc, #68]	; (802b0b8 <main+0x84>)
 802b074:	f7fa ff3d 	bl	8025ef2 <SaveAllPresets>
    		  } //if
    		  ReadAllPresets( &Presets );
 802b078:	4810      	ldr	r0, [pc, #64]	; (802b0bc <main+0x88>)
 802b07a:	f7fa ff2d 	bl	8025ed8 <ReadAllPresets>
    		break;
 802b07e:	e015      	b.n	802b0ac <main+0x78>
    	case E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA:
    	case E_EEPROM_XMC4_STATUS_ERASE_ERROR:
    	{
    		/* add here the memory error handler */

    		Presets = DefaultPresets; // for example...
 802b080:	4a0e      	ldr	r2, [pc, #56]	; (802b0bc <main+0x88>)
 802b082:	4b0d      	ldr	r3, [pc, #52]	; (802b0b8 <main+0x84>)
 802b084:	4610      	mov	r0, r2
 802b086:	4619      	mov	r1, r3
 802b088:	234c      	movs	r3, #76	; 0x4c
 802b08a:	461a      	mov	r2, r3
 802b08c:	f000 f852 	bl	802b134 <memcpy>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
 802b090:	480b      	ldr	r0, [pc, #44]	; (802b0c0 <main+0x8c>)
 802b092:	f7ff fe34 	bl	802acfe <DIGITAL_IO_SetOutputHigh>
    		break;
 802b096:	e009      	b.n	802b0ac <main+0x78>
    	}

    	default :
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
 802b098:	4809      	ldr	r0, [pc, #36]	; (802b0c0 <main+0x8c>)
 802b09a:	f7ff fe30 	bl	802acfe <DIGITAL_IO_SetOutputHigh>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 802b09e:	4809      	ldr	r0, [pc, #36]	; (802b0c4 <main+0x90>)
 802b0a0:	f7ff fe2d 	bl	802acfe <DIGITAL_IO_SetOutputHigh>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_Y);
 802b0a4:	4808      	ldr	r0, [pc, #32]	; (802b0c8 <main+0x94>)
 802b0a6:	f7ff fe2a 	bl	802acfe <DIGITAL_IO_SetOutputHigh>
    		break;
 802b0aa:	bf00      	nop

    	} //switch

  MainAlgInit();
 802b0ac:	f7f8 ff22 	bl	8023ef4 <MainAlgInit>

  /* Placeholder for user application code. The while loop below can be replaced with user application code. */
  while(1U)
 802b0b0:	e7fe      	b.n	802b0b0 <main+0x7c>
 802b0b2:	bf00      	nop
 802b0b4:	20000fbc 	.word	0x20000fbc
 802b0b8:	0802b21c 	.word	0x0802b21c
 802b0bc:	20000770 	.word	0x20000770
 802b0c0:	0802b418 	.word	0x0802b418
 802b0c4:	0802b3f0 	.word	0x0802b3f0
 802b0c8:	0802b404 	.word	0x0802b404

0802b0cc <__libc_init_array>:
 802b0cc:	b570      	push	{r4, r5, r6, lr}
 802b0ce:	4d0d      	ldr	r5, [pc, #52]	; (802b104 <__libc_init_array+0x38>)
 802b0d0:	4c0d      	ldr	r4, [pc, #52]	; (802b108 <__libc_init_array+0x3c>)
 802b0d2:	1b64      	subs	r4, r4, r5
 802b0d4:	10a4      	asrs	r4, r4, #2
 802b0d6:	2600      	movs	r6, #0
 802b0d8:	42a6      	cmp	r6, r4
 802b0da:	d109      	bne.n	802b0f0 <__libc_init_array+0x24>
 802b0dc:	4d0b      	ldr	r5, [pc, #44]	; (802b10c <__libc_init_array+0x40>)
 802b0de:	4c0c      	ldr	r4, [pc, #48]	; (802b110 <__libc_init_array+0x44>)
 802b0e0:	f7fd fd80 	bl	8028be4 <_init>
 802b0e4:	1b64      	subs	r4, r4, r5
 802b0e6:	10a4      	asrs	r4, r4, #2
 802b0e8:	2600      	movs	r6, #0
 802b0ea:	42a6      	cmp	r6, r4
 802b0ec:	d105      	bne.n	802b0fa <__libc_init_array+0x2e>
 802b0ee:	bd70      	pop	{r4, r5, r6, pc}
 802b0f0:	f855 3b04 	ldr.w	r3, [r5], #4
 802b0f4:	4798      	blx	r3
 802b0f6:	3601      	adds	r6, #1
 802b0f8:	e7ee      	b.n	802b0d8 <__libc_init_array+0xc>
 802b0fa:	f855 3b04 	ldr.w	r3, [r5], #4
 802b0fe:	4798      	blx	r3
 802b100:	3601      	adds	r6, #1
 802b102:	e7f2      	b.n	802b0ea <__libc_init_array+0x1e>
 802b104:	200005f8 	.word	0x200005f8
 802b108:	200005f8 	.word	0x200005f8
 802b10c:	200005f8 	.word	0x200005f8
 802b110:	200005f8 	.word	0x200005f8

0802b114 <memcmp>:
 802b114:	b510      	push	{r4, lr}
 802b116:	3901      	subs	r1, #1
 802b118:	4402      	add	r2, r0
 802b11a:	4290      	cmp	r0, r2
 802b11c:	d101      	bne.n	802b122 <memcmp+0xe>
 802b11e:	2000      	movs	r0, #0
 802b120:	e005      	b.n	802b12e <memcmp+0x1a>
 802b122:	7803      	ldrb	r3, [r0, #0]
 802b124:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802b128:	42a3      	cmp	r3, r4
 802b12a:	d001      	beq.n	802b130 <memcmp+0x1c>
 802b12c:	1b18      	subs	r0, r3, r4
 802b12e:	bd10      	pop	{r4, pc}
 802b130:	3001      	adds	r0, #1
 802b132:	e7f2      	b.n	802b11a <memcmp+0x6>

0802b134 <memcpy>:
 802b134:	440a      	add	r2, r1
 802b136:	4291      	cmp	r1, r2
 802b138:	f100 33ff 	add.w	r3, r0, #4294967295
 802b13c:	d100      	bne.n	802b140 <memcpy+0xc>
 802b13e:	4770      	bx	lr
 802b140:	b510      	push	{r4, lr}
 802b142:	f811 4b01 	ldrb.w	r4, [r1], #1
 802b146:	f803 4f01 	strb.w	r4, [r3, #1]!
 802b14a:	4291      	cmp	r1, r2
 802b14c:	d1f9      	bne.n	802b142 <memcpy+0xe>
 802b14e:	bd10      	pop	{r4, pc}

0802b150 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer>:
 802b150:	f85f f000 	ldr.w	pc, [pc]	; 802b154 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer+0x4>
 802b154:	10001001 	.word	0x10001001

0802b158 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>:
 802b158:	f85f f000 	ldr.w	pc, [pc]	; 802b15c <__Motor0_BLDC_SCALAR_PatternInitiator_veneer+0x4>
 802b15c:	10000f3d 	.word	0x10000f3d

0802b160 <__Motor0_BLDC_SCALAR_MSM_veneer>:
 802b160:	f85f f000 	ldr.w	pc, [pc]	; 802b164 <__Motor0_BLDC_SCALAR_MSM_veneer+0x4>
 802b164:	10000ec9 	.word	0x10000ec9

0802b168 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer>:
 802b168:	f85f f000 	ldr.w	pc, [pc]	; 802b16c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer+0x4>
 802b16c:	10000c7d 	.word	0x10000c7d

0802b170 <Motor0_BLDC_SCALAR_CCU8ExtStartEventConf>:
 802b170:	00000107                                ....

0802b174 <Motor0_BLDC_SCALAR_CCU8ExtStopEventConf>:
 802b174:	00000207                                ....

0802b178 <Motor0_BLDC_SCALAR_CCU8CompareConf>:
 802b178:	02000001 00000003 00000004 00000000     ................

0802b188 <Motor0_BLDC_SCALAR_GPIO_PhU_High_Config>:
 802b188:	00000098 00010000 00000000              ............

0802b194 <Motor0_BLDC_SCALAR_GPIO_PhU_Low_Config>:
 802b194:	00000098 00010000 00000000              ............

0802b1a0 <Motor0_BLDC_SCALAR_GPIO_PhV_High_Config>:
 802b1a0:	00000098 00010000 00000000              ............

0802b1ac <Motor0_BLDC_SCALAR_GPIO_PhV_Low_Config>:
 802b1ac:	00000098 00010000 00000000              ............

0802b1b8 <Motor0_BLDC_SCALAR_GPIO_PhW_High_Config>:
 802b1b8:	00000098 00010000 00000000              ............

0802b1c4 <Motor0_BLDC_SCALAR_GPIO_PhW_Low_Config>:
 802b1c4:	00000098 00010000 00000000              ............

0802b1d0 <Motor0_BLDC_SCALAR_GPIO_Hall_Config>:
 802b1d0:	00000000 00010000 00000000              ............

0802b1dc <Motor0_BLDC_SCALAR_GPIO_Inverter_Config>:
 802b1dc:	00000080 00010000 00000001              ............

0802b1e8 <Motor0_BLDC_SCALAR_POSIF_HALL_Config>:
 802b1e8:	00000010                                ....

0802b1ec <Motor0_BLDC_SCALAR_POSIF_GLOBAL_Config>:
 802b1ec:	50000000                                ...P

0802b1f0 <Motor0_BLDC_SCALAR_POSIF_MCM_Config>:
 802b1f0:	00000000                                ....

0802b1f4 <Motor0_BLDC_SCALAR_VADC_GLOBAL_config>:
	...

0802b20c <Motor0_BLDC_SCALAR_VADC_GROUP_class0>:
 802b20c:	00000001                                ....

0802b210 <Motor0_BLDC_SCALAR_VADC_QUEUE_3_cfg>:
 802b210:	00000000 00004800 00000004              .....H......

0802b21c <DefaultPresets>:
 802b21c:	00000001 00000001 00000002 00000001     ................
 802b22c:	00010005 00100245 00000000 000000c8     ....E...........
 802b23c:	00000bb8 00000000 000007d0 000000c8     ................
 802b24c:	000007d0 00000320 000000a0 00000320     .... ....... ...
 802b25c:	00000320 000000a0 00000000               ...........

0802b268 <e_eeprom_xmc4_fce>:
 802b268:	50020020 00000700 00000000               ..P........

0802b274 <g_xmc_vadc_group_array>:
 802b274:	40004400 40004800 40004c00 40005000     .D.@.H.@.L.@.P.@

0802b284 <CLUTCH_PWM_timer_handle>:
 802b284:	00000000 00000006                       ........

0802b28c <CLUTCH_PWM_event0_config>:
 802b28c:	00010000                                ....

0802b290 <CLUTCH_PWM_event1_config>:
 802b290:	00010000                                ....

0802b294 <CLUTCH_PWM_event2_config>:
 802b294:	00010000                                ....

0802b298 <CLUTCH_PWM_config_handle>:
 802b298:	07520000 010103a9 00000000 00000100     ..R.............
 802b2a8:	00000001 0802b28c 0802b290 0802b294     ................
	...
 802b2c4:	01000000 00000000 10000000 0802b284     ................
	...
 802b2e4:	200002b8                                ... 

0802b2e8 <BUZZ_PWM_timer_handle>:
 802b2e8:	00000000 00000006                       ........

0802b2f0 <BUZZ_PWM_event0_config>:
 802b2f0:	00010000                                ....

0802b2f4 <BUZZ_PWM_event1_config>:
 802b2f4:	00010000                                ....

0802b2f8 <BUZZ_PWM_event2_config>:
 802b2f8:	00010000                                ....

0802b2fc <BUZZ_PWM_config_handle>:
 802b2fc:	07520000 010103a9 00000000 03030200     ..R.............
 802b30c:	00000002 0802b2f0 0802b2f4 0802b2f8     ................
	...
 802b328:	01000000 00000000 20000000 0802b2e8     ........... ....
	...
 802b348:	200002b8                                ... 

0802b34c <CAN1_RX_INT>:
 802b34c:	01003f52                                R?..

0802b350 <CLUTCH_INT_CMP>:
 802b350:	01003f38                                8?..

0802b354 <CLUTCH_INT_OVF>:
 802b354:	01003f39                                9?..

0802b358 <CAN_2_RESET_INT>:
 802b358:	01003f4d                                M?..

0802b35c <CAN_1_TRAP_SENSOR_INT>:
 802b35c:	01003f4f                                O?..

0802b360 <SERV_INT>:
 802b360:	01003f4e                                N?..

0802b364 <CAN_1_STOP_BUT_INT>:
 802b364:	01003f51                                Q?..

0802b368 <CAN_NODE_ALLERT>:
 802b368:	01003f4c                                L?..

0802b36c <BUZZ_INT_OVF>:
 802b36c:	01003f3a                                :?..

0802b370 <BUZZ_INT_CMP>:
 802b370:	01003f3b                                ;?..

0802b374 <group_init_handle0>:
	...

0802b388 <group_init_handle1>:
	...

0802b39c <group_init_handle2>:
	...

0802b3b0 <group_init_handle3>:
	...

0802b3c4 <global_config>:
 802b3c4:	00000000 00000003 00000000 00000000     ................
	...

0802b3dc <SERVICE_BUT>:
 802b3dc:	48028f00 00000000 00000000 00000000     ...H............
 802b3ec:	00000002                                ....

0802b3f0 <STATUS_LED_G>:
 802b3f0:	48028300 00000080 00010000 00000004     ...H............
 802b400:	00000009                                ....

0802b404 <STATUS_LED_Y>:
 802b404:	48028300 00000080 00010000 00000004     ...H............
 802b414:	0000000a                                ....

0802b418 <STATUS_LED_R>:
 802b418:	48028300 00000080 00010000 00000004     ...H............
 802b428:	0000000b                                ....

0802b42c <TRANS_OUT>:
 802b42c:	48028100 00000080 00010000 00000004     ...H............
 802b43c:	0000000f                                ....

0802b440 <GROUP_IN_EN>:
 802b440:	48028200 00000080 00010000 00000000     ...H............
 802b450:	00000000                                ....

0802b454 <LED_SW_NRES>:
 802b454:	48028000 00000080 00010000 00000004     ...H............
 802b464:	0000000e                                ....

0802b468 <LS_SW_1>:
 802b468:	48028000 00000080 00010000 00000004     ...H............
 802b478:	00000000                                ....

0802b47c <LS_SW_2>:
 802b47c:	48028000 00000080 00010000 00000004     ...H............
 802b48c:	0000000a                                ....

0802b490 <LS_SW_3>:
 802b490:	48028000 00000080 00010000 00000004     ...H............
 802b4a0:	00000009                                ....

0802b4a4 <LS_SW_4>:
 802b4a4:	48028300 00000080 00010000 00000004     ...H............
 802b4b4:	00000002                                ....

0802b4b8 <HS_SW_1>:
 802b4b8:	48028100 00000080 00010000 00000004     ...H............
 802b4c8:	0000000a                                ....

0802b4cc <HS_SW_2>:
 802b4cc:	48028100 00000080 00010000 00000004     ...H............
 802b4dc:	0000000b                                ....

0802b4e0 <HS_SW_3>:
 802b4e0:	48028100 00000080 00010000 00000004     ...H............
 802b4f0:	0000000c                                ....

0802b4f4 <HS_SW_4>:
 802b4f4:	48028100 00000080 00010000 00000004     ...H............
 802b504:	0000000d                                ....

0802b508 <HS_SW_5>:
 802b508:	48028100 00000080 00010000 00000004     ...H............
 802b518:	0000000e                                ....

0802b51c <HS_SW_6>:
 802b51c:	48028600 00000080 00010000 00000004     ...H............
 802b52c:	00000000                                ....

0802b530 <HS_SW_7>:
 802b530:	48028600 00000080 00010000 00000004     ...H............
 802b540:	00000001                                ....

0802b544 <HS_SW_8>:
 802b544:	48028600 00000080 00010000 00000004     ...H............
 802b554:	00000002                                ....

0802b558 <LS_SW_NRES>:
 802b558:	48028000 00000080 00010000 00000004     ...H............
 802b568:	0000000f                                ....

0802b56c <DI_PNP_EN>:
 802b56c:	48028300 00000080 00010000 00000004     ...H............
 802b57c:	00000008                                ....

0802b580 <DI_NPN_EN>:
 802b580:	48028300 00000080 00010000 00000004     ...H............
 802b590:	00000007                                ....

0802b594 <LED_POWER_EN1>:
 802b594:	48028000 00000080 00010000 00000004     ...H............
 802b5a4:	00000006                                ....

0802b5a8 <LED_POWER_EN2>:
 802b5a8:	48028000 00000080 00010000 00000004     ...H............
 802b5b8:	00000007                                ....

0802b5bc <POWER_SWITCH>:
 802b5bc:	48028100 00000080 00010000 00000004     ...H............
 802b5cc:	00000006                                ....

0802b5d0 <LED_SW_1>:
 802b5d0:	48028400 00000080 00010000 00000004     ...H............
 802b5e0:	00000000                                ....

0802b5e4 <LED_SW_2>:
 802b5e4:	48028400 00000080 00010000 00000004     ...H............
 802b5f4:	00000001                                ....

0802b5f8 <LED_SW_3>:
 802b5f8:	48028400 00000080 00010000 00000004     ...H............
 802b608:	00000002                                ....

0802b60c <LED_SW_4>:
 802b60c:	48028400 00000080 00010000 00000004     ...H............
 802b61c:	00000003                                ....

0802b620 <LED_SW_5>:
 802b620:	48028400 00000080 00010000 00000004     ...H............
 802b630:	00000004                                ....

0802b634 <LED_SW_6>:
 802b634:	48028400 00000080 00010000 00000004     ...H............
 802b644:	00000005                                ....

0802b648 <LED_SW_7>:
 802b648:	48028400 00000080 00010000 00000004     ...H............
 802b658:	00000006                                ....

0802b65c <LED_SW_8>:
 802b65c:	48028400 00000080 00010000 00000004     ...H............
 802b66c:	00000007                                ....

0802b670 <MOTOR_FAULT>:
 802b670:	48028f00 00000000 00000000 00000000     ...H............
 802b680:	0000000e 01040278 00010000 00000000     ....x...........
 802b690:	00010000 01010101                       ........

0802b698 <CAN_EXT_gpio_out>:
 802b698:	48028100 00000009                       ...H....

0802b6a0 <CAN_EXT_gpio_out_config>:
 802b6a0:	00000090 00000001 00000002              ............

0802b6ac <CAN_EXT_gpio_in>:
 802b6ac:	48028100 00000008                       ...H....

0802b6b4 <CAN_EXT_gpio_in_config>:
	...

0802b6c0 <CAN_EXT_BitTimeConfig>:
 802b6c0:	07270e00 0001e848 00011f40              ..'.H...@...

0802b6cc <CAN_EXT_sr>:
 802b6cc:	00000000                                ....

0802b6d0 <CAN_EXT_LMO_01_Config>:
 802b6d0:	20000320 00060021 00000001               .. !.......

0802b6dc <CAN_EXT_LMO_02_Config>:
 802b6dc:	20000340 00000007 00000000              @.. ........

0802b6e8 <CAN_EXT_LMO_03_Config>:
 802b6e8:	20000360 00000008 00000000              `.. ........

0802b6f4 <CAN_EXT_LMO_04_Config>:
 802b6f4:	20000380 00050020 00000001              ...  .......

0802b700 <CAN_EXT_LMO_05_Config>:
 802b700:	200003a0 0003001f 00000001              ... ........

0802b70c <CAN_EXT_LMO_06_Config>:
 802b70c:	200003c0 00000005 00000000              ... ........

0802b718 <CAN_EXT_LMO_07_Config>:
 802b718:	200003e0 00000006 00000000              ... ........

0802b724 <CAN_EXT_LMO_08_Config>:
 802b724:	20000400 0001001e 00000001              ... ........

0802b730 <CAN_EXT>:
 802b730:	200002c8 48014400 0802b6c0 0802b6d0     ... .D.H........
 802b740:	0802b6dc 0802b6e8 0802b6f4 0802b700     ................
 802b750:	0802b70c 0802b718 0802b724 00000000     ........$.......
	...
 802b7bc:	0802b6cc 0802b698 0802b6a0 0802b6ac     ................
 802b7cc:	0802b6b4 00080200 00010100              ............

0802b7d8 <CAN_INT_gpio_out>:
 802b7d8:	48028100 00000004                       ...H....

0802b7e0 <CAN_INT_gpio_out_config>:
 802b7e0:	00000090 00000001 00000002              ............

0802b7ec <CAN_INT_gpio_in>:
 802b7ec:	48028100 00000005                       ...H....

0802b7f4 <CAN_INT_gpio_in_config>:
	...

0802b800 <CAN_INT_BitTimeConfig>:
 802b800:	07270e00 0001e848 00011f40              ..'.H...@...

0802b80c <CAN_INT_sr>:
 802b80c:	00000000                                ....

0802b810 <CAN_INT_LMO_01_Config>:
 802b810:	20000420 0000003c 00000000               .. <.......

0802b81c <CAN_INT_LMO_02_Config>:
 802b81c:	20000440 00000009 00000000              @.. ........

0802b828 <CAN_INT_LMO_03_Config>:
 802b828:	20000460 00000024 00000000              `.. $.......

0802b834 <CAN_INT_LMO_04_Config>:
 802b834:	20000480 00000025 00000000              ... %.......

0802b840 <CAN_INT_LMO_05_Config>:
 802b840:	200004a0 00000026 00000000              ... &.......

0802b84c <CAN_INT_LMO_06_Config>:
 802b84c:	200004c0 00020022 00000001              ... ".......

0802b858 <CAN_INT_LMO_07_Config>:
 802b858:	200004e0 00000027 00000000              ... '.......

0802b864 <CAN_INT_LMO_08_Config>:
 802b864:	20000500 00010023 00000001              ... #.......

0802b870 <CAN_INT>:
 802b870:	200002c8 48014200 0802b800 0802b810     ... .B.H........
 802b880:	0802b81c 0802b828 0802b834 0802b840     ....(...4...@...
 802b890:	0802b84c 0802b858 0802b864 00000000     L...X...d.......
	...
 802b8fc:	0802b80c 0802b7d8 0802b7e0 0802b7ec     ................
 802b90c:	0802b7f4 00080000 00000000              ............

0802b918 <GROUP_IN_pin_list>:
 802b918:	48028500 00000000 48028500 00000001     ...H.......H....
 802b928:	48028500 00000002 48028500 00000003     ...H.......H....

0802b938 <GROUP_OUT_pin_list>:
 802b938:	48028500 00000004 48028500 00000005     ...H.......H....
 802b948:	48028500 00000006 48028500 00000007     ...H.......H....

0802b958 <DI_PNP_pin_list>:
 802b958:	48028e00 0000000f 48028e00 0000000e     ...H.......H....
 802b968:	48028e00 0000000d 48028e00 0000000c     ...H.......H....

0802b978 <DI_NPN_pin_list>:
 802b978:	48028f00 00000007 48028f00 00000006     ...H.......H....
 802b988:	48028f00 00000005 48028f00 00000004     ...H.......H....

0802b998 <RES_IN1>:
 802b998:	00000000 20001105 48028f00 00000003     ....... ...H....

0802b9a8 <RES_IN2>:
 802b9a8:	00000000 20001106 48028e00 00000007     ....... ...H....

0802b9b8 <DC_INPUT>:
 802b9b8:	00000000 20001107 48028f00 0000000f     ....... ...H....

0802b9c8 <global_iclass_config>:
 802b9c8:	00000000                                ....

0802b9cc <backgnd_rs_intr_handle>:
 802b9cc:	00000010 0000003f 00000000              ....?.......

0802b9d8 <backgnd_config>:
 802b9d8:	00000005 00000000 00000008 5f444d43     ............CMD_
 802b9e8:	544f4f42 45534552 30305f54              BOOTRESET_00

Disassembly of section .ram_code:

10000800 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect>:
/*
 * This function check the actual MCM register and modulate high side PWM output and
 * complementary PWM output for same leg. And keep other low side output is either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect(uint16_t mcm_val)
{
10000800:	b580      	push	{r7, lr}
10000802:	b084      	sub	sp, #16
10000804:	af00      	add	r7, sp, #0
10000806:	4603      	mov	r3, r0
10000808:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1000080a:	2300      	movs	r3, #0
1000080c:	73fb      	strb	r3, [r7, #15]
1000080e:	e040      	b.n	10000892 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x92>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000810:	7bfb      	ldrb	r3, [r7, #15]
10000812:	4a24      	ldr	r2, [pc, #144]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000814:	3308      	adds	r3, #8
10000816:	005b      	lsls	r3, r3, #1
10000818:	4413      	add	r3, r2
1000081a:	885a      	ldrh	r2, [r3, #2]
1000081c:	7bfb      	ldrb	r3, [r7, #15]
1000081e:	4921      	ldr	r1, [pc, #132]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000820:	3308      	adds	r3, #8
10000822:	005b      	lsls	r3, r3, #1
10000824:	440b      	add	r3, r1
10000826:	8859      	ldrh	r1, [r3, #2]
10000828:	88fb      	ldrh	r3, [r7, #6]
1000082a:	400b      	ands	r3, r1
1000082c:	b29b      	uxth	r3, r3
1000082e:	429a      	cmp	r2, r3
10000830:	d10d      	bne.n	1000084e <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x4e>
      /*
       * Dead Time Enable for Channel 1
       * Dead Time Enable for CC8yST1
       * Dead Time Enable for inverted CC8yST1
       */
      Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000832:	7bfb      	ldrb	r3, [r7, #15]
10000834:	4a1c      	ldr	r2, [pc, #112]	; (100008a8 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa8>)
10000836:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1000083a:	210d      	movs	r1, #13
1000083c:	4618      	mov	r0, r3
1000083e:	f000 fc8f 	bl	10001160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>

      /*Set the compare flag to set the inverse duty*/
       Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
10000842:	7bfb      	ldrb	r3, [r7, #15]
10000844:	4a17      	ldr	r2, [pc, #92]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000846:	4413      	add	r3, r2
10000848:	2203      	movs	r2, #3
1000084a:	739a      	strb	r2, [r3, #14]
1000084c:	e01e      	b.n	1000088c <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x8c>
    } /* End of high side switch is ON */

    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1000084e:	7bfb      	ldrb	r3, [r7, #15]
10000850:	4a14      	ldr	r2, [pc, #80]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000852:	3308      	adds	r3, #8
10000854:	005b      	lsls	r3, r3, #1
10000856:	4413      	add	r3, r2
10000858:	885b      	ldrh	r3, [r3, #2]
1000085a:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
1000085c:	88f9      	ldrh	r1, [r7, #6]
1000085e:	7bfb      	ldrb	r3, [r7, #15]
10000860:	4810      	ldr	r0, [pc, #64]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000862:	3308      	adds	r3, #8
10000864:	005b      	lsls	r3, r3, #1
10000866:	4403      	add	r3, r0
10000868:	885b      	ldrh	r3, [r3, #2]
1000086a:	005b      	lsls	r3, r3, #1
1000086c:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1000086e:	429a      	cmp	r2, r3
10000870:	d10c      	bne.n	1000088c <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x8c>
    {
      /* Disable dead time */
      Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000872:	7bfb      	ldrb	r3, [r7, #15]
10000874:	4a0c      	ldr	r2, [pc, #48]	; (100008a8 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa8>)
10000876:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1000087a:	210d      	movs	r1, #13
1000087c:	4618      	mov	r0, r3
1000087e:	f000 fc8f 	bl	100011a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>

      /*Set the compare flag to switch on completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
10000882:	7bfb      	ldrb	r3, [r7, #15]
10000884:	4a07      	ldr	r2, [pc, #28]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000886:	4413      	add	r3, r2
10000888:	2201      	movs	r2, #1
1000088a:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1000088c:	7bfb      	ldrb	r3, [r7, #15]
1000088e:	3301      	adds	r3, #1
10000890:	73fb      	strb	r3, [r7, #15]
10000892:	7bfb      	ldrb	r3, [r7, #15]
10000894:	2b02      	cmp	r3, #2
10000896:	d9bb      	bls.n	10000810 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x10>
    {
      /*do nothing*/
    }
  }

}
10000898:	bf00      	nop
1000089a:	bf00      	nop
1000089c:	3710      	adds	r7, #16
1000089e:	46bd      	mov	sp, r7
100008a0:	bd80      	pop	{r7, pc}
100008a2:	bf00      	nop
100008a4:	200000d0 	.word	0x200000d0
100008a8:	20000068 	.word	0x20000068

100008ac <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod>:
/*
 * This function check the actual MCM register and modulate high
 * side PWM output and keep low side output either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod(uint16_t mcm_val)
{
100008ac:	b480      	push	{r7}
100008ae:	b085      	sub	sp, #20
100008b0:	af00      	add	r7, sp, #0
100008b2:	4603      	mov	r3, r0
100008b4:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
100008b6:	2300      	movs	r3, #0
100008b8:	73fb      	strb	r3, [r7, #15]
100008ba:	e030      	b.n	1000091e <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x72>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
100008bc:	7bfb      	ldrb	r3, [r7, #15]
100008be:	4a1d      	ldr	r2, [pc, #116]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008c0:	3308      	adds	r3, #8
100008c2:	005b      	lsls	r3, r3, #1
100008c4:	4413      	add	r3, r2
100008c6:	885a      	ldrh	r2, [r3, #2]
100008c8:	7bfb      	ldrb	r3, [r7, #15]
100008ca:	491a      	ldr	r1, [pc, #104]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008cc:	3308      	adds	r3, #8
100008ce:	005b      	lsls	r3, r3, #1
100008d0:	440b      	add	r3, r1
100008d2:	8859      	ldrh	r1, [r3, #2]
100008d4:	88fb      	ldrh	r3, [r7, #6]
100008d6:	400b      	ands	r3, r1
100008d8:	b29b      	uxth	r3, r3
100008da:	429a      	cmp	r2, r3
100008dc:	d105      	bne.n	100008ea <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x3e>
    {
      /*Set the compare flag to set the inverse duty*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
100008de:	7bfb      	ldrb	r3, [r7, #15]
100008e0:	4a14      	ldr	r2, [pc, #80]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008e2:	4413      	add	r3, r2
100008e4:	2203      	movs	r2, #3
100008e6:	739a      	strb	r2, [r3, #14]
100008e8:	e016      	b.n	10000918 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x6c>

    } /* End of high side switch is ON */
    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
100008ea:	7bfb      	ldrb	r3, [r7, #15]
100008ec:	4a11      	ldr	r2, [pc, #68]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008ee:	3308      	adds	r3, #8
100008f0:	005b      	lsls	r3, r3, #1
100008f2:	4413      	add	r3, r2
100008f4:	885b      	ldrh	r3, [r3, #2]
100008f6:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
100008f8:	88f9      	ldrh	r1, [r7, #6]
100008fa:	7bfb      	ldrb	r3, [r7, #15]
100008fc:	480d      	ldr	r0, [pc, #52]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008fe:	3308      	adds	r3, #8
10000900:	005b      	lsls	r3, r3, #1
10000902:	4403      	add	r3, r0
10000904:	885b      	ldrh	r3, [r3, #2]
10000906:	005b      	lsls	r3, r3, #1
10000908:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1000090a:	429a      	cmp	r2, r3
1000090c:	d104      	bne.n	10000918 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x6c>
    {
      /*Set the compare flag to switch on completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
1000090e:	7bfb      	ldrb	r3, [r7, #15]
10000910:	4a08      	ldr	r2, [pc, #32]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
10000912:	4413      	add	r3, r2
10000914:	2201      	movs	r2, #1
10000916:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000918:	7bfb      	ldrb	r3, [r7, #15]
1000091a:	3301      	adds	r3, #1
1000091c:	73fb      	strb	r3, [r7, #15]
1000091e:	7bfb      	ldrb	r3, [r7, #15]
10000920:	2b02      	cmp	r3, #2
10000922:	d9cb      	bls.n	100008bc <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x10>
    else
    {
      /*do nothing*/
    }
  }
}
10000924:	bf00      	nop
10000926:	bf00      	nop
10000928:	3714      	adds	r7, #20
1000092a:	46bd      	mov	sp, r7
1000092c:	f85d 7b04 	ldr.w	r7, [sp], #4
10000930:	4770      	bx	lr
10000932:	bf00      	nop
10000934:	200000d0 	.word	0x200000d0

10000938 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod>:
/*
 * This function check the actual MCM register and modulate low side PWM output
 * and keep high side output either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod(uint16_t mcm_val)
{
10000938:	b480      	push	{r7}
1000093a:	b085      	sub	sp, #20
1000093c:	af00      	add	r7, sp, #0
1000093e:	4603      	mov	r3, r0
10000940:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000942:	2300      	movs	r3, #0
10000944:	73fb      	strb	r3, [r7, #15]
10000946:	e030      	b.n	100009aa <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x72>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000948:	7bfb      	ldrb	r3, [r7, #15]
1000094a:	4a1d      	ldr	r2, [pc, #116]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000094c:	3308      	adds	r3, #8
1000094e:	005b      	lsls	r3, r3, #1
10000950:	4413      	add	r3, r2
10000952:	885a      	ldrh	r2, [r3, #2]
10000954:	7bfb      	ldrb	r3, [r7, #15]
10000956:	491a      	ldr	r1, [pc, #104]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
10000958:	3308      	adds	r3, #8
1000095a:	005b      	lsls	r3, r3, #1
1000095c:	440b      	add	r3, r1
1000095e:	8859      	ldrh	r1, [r3, #2]
10000960:	88fb      	ldrh	r3, [r7, #6]
10000962:	400b      	ands	r3, r1
10000964:	b29b      	uxth	r3, r3
10000966:	429a      	cmp	r2, r3
10000968:	d105      	bne.n	10000976 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x3e>
    {
      /*Set the compare flag to switch off completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
1000096a:	7bfb      	ldrb	r3, [r7, #15]
1000096c:	4a14      	ldr	r2, [pc, #80]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000096e:	4413      	add	r3, r2
10000970:	2200      	movs	r2, #0
10000972:	739a      	strb	r2, [r3, #14]
10000974:	e016      	b.n	100009a4 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x6c>

    } /* End of high side switch is ON */
    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000976:	7bfb      	ldrb	r3, [r7, #15]
10000978:	4a11      	ldr	r2, [pc, #68]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000097a:	3308      	adds	r3, #8
1000097c:	005b      	lsls	r3, r3, #1
1000097e:	4413      	add	r3, r2
10000980:	885b      	ldrh	r3, [r3, #2]
10000982:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
10000984:	88f9      	ldrh	r1, [r7, #6]
10000986:	7bfb      	ldrb	r3, [r7, #15]
10000988:	480d      	ldr	r0, [pc, #52]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000098a:	3308      	adds	r3, #8
1000098c:	005b      	lsls	r3, r3, #1
1000098e:	4403      	add	r3, r0
10000990:	885b      	ldrh	r3, [r3, #2]
10000992:	005b      	lsls	r3, r3, #1
10000994:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000996:	429a      	cmp	r2, r3
10000998:	d104      	bne.n	100009a4 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x6c>
    {
     /*Set the compare flag to set the duty*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
1000099a:	7bfb      	ldrb	r3, [r7, #15]
1000099c:	4a08      	ldr	r2, [pc, #32]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000099e:	4413      	add	r3, r2
100009a0:	2202      	movs	r2, #2
100009a2:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
100009a4:	7bfb      	ldrb	r3, [r7, #15]
100009a6:	3301      	adds	r3, #1
100009a8:	73fb      	strb	r3, [r7, #15]
100009aa:	7bfb      	ldrb	r3, [r7, #15]
100009ac:	2b02      	cmp	r3, #2
100009ae:	d9cb      	bls.n	10000948 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x10>
    {
      /*do nothing*/
    }
  }

}
100009b0:	bf00      	nop
100009b2:	bf00      	nop
100009b4:	3714      	adds	r7, #20
100009b6:	46bd      	mov	sp, r7
100009b8:	f85d 7b04 	ldr.w	r7, [sp], #4
100009bc:	4770      	bx	lr
100009be:	bf00      	nop
100009c0:	200000d0 	.word	0x200000d0

100009c4 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect>:
 * This function check the non conducting phase and modulate high side PWM output and complementary
 * PWM output for same leg based on the MCMS shadow register.
 * And keep other low side output is either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect(uint16_t mcm_val, uint16_t mcms_val)
{
100009c4:	b580      	push	{r7, lr}
100009c6:	b084      	sub	sp, #16
100009c8:	af00      	add	r7, sp, #0
100009ca:	4603      	mov	r3, r0
100009cc:	460a      	mov	r2, r1
100009ce:	80fb      	strh	r3, [r7, #6]
100009d0:	4613      	mov	r3, r2
100009d2:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
100009d4:	2300      	movs	r3, #0
100009d6:	73fb      	strb	r3, [r7, #15]
100009d8:	e038      	b.n	10000a4c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x88>
  {
    /* if phase is not conducting in current cycle */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
100009da:	7bfb      	ldrb	r3, [r7, #15]
100009dc:	4a1f      	ldr	r2, [pc, #124]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
100009de:	330c      	adds	r3, #12
100009e0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
100009e4:	88fb      	ldrh	r3, [r7, #6]
100009e6:	4013      	ands	r3, r2
100009e8:	b29b      	uxth	r3, r3
100009ea:	2b00      	cmp	r3, #0
100009ec:	d12b      	bne.n	10000a46 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x82>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
100009ee:	7bfb      	ldrb	r3, [r7, #15]
100009f0:	4a1a      	ldr	r2, [pc, #104]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
100009f2:	3308      	adds	r3, #8
100009f4:	005b      	lsls	r3, r3, #1
100009f6:	4413      	add	r3, r2
100009f8:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
100009fa:	7bfb      	ldrb	r3, [r7, #15]
100009fc:	4917      	ldr	r1, [pc, #92]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
100009fe:	3308      	adds	r3, #8
10000a00:	005b      	lsls	r3, r3, #1
10000a02:	440b      	add	r3, r1
10000a04:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000a06:	88bb      	ldrh	r3, [r7, #4]
10000a08:	400b      	ands	r3, r1
10000a0a:	b29b      	uxth	r3, r3
10000a0c:	429a      	cmp	r2, r3
10000a0e:	d10d      	bne.n	10000a2c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x68>
        /*
         * Dead Time Enable for Channel 1
         * Dead Time Enable for CC8yST1
         * Dead Time Enable for inverted CC8yST1
         */
        Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000a10:	7bfb      	ldrb	r3, [r7, #15]
10000a12:	4a13      	ldr	r2, [pc, #76]	; (10000a60 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x9c>)
10000a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
10000a18:	210d      	movs	r1, #13
10000a1a:	4618      	mov	r0, r3
10000a1c:	f000 fba0 	bl	10001160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>

        /*Set the compare flag to set the inverse duty*/
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
10000a20:	7bfb      	ldrb	r3, [r7, #15]
10000a22:	4a0e      	ldr	r2, [pc, #56]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
10000a24:	4413      	add	r3, r2
10000a26:	2203      	movs	r2, #3
10000a28:	739a      	strb	r2, [r3, #14]
10000a2a:	e00c      	b.n	10000a46 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x82>
      }
      /* if low side switch is ON*/
      else
      {
        /* Disable dead time */
        Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000a2c:	7bfb      	ldrb	r3, [r7, #15]
10000a2e:	4a0c      	ldr	r2, [pc, #48]	; (10000a60 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x9c>)
10000a30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
10000a34:	210d      	movs	r1, #13
10000a36:	4618      	mov	r0, r3
10000a38:	f000 fbb2 	bl	100011a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>

        /*Set the compare flag to switch on completely*/
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
10000a3c:	7bfb      	ldrb	r3, [r7, #15]
10000a3e:	4a07      	ldr	r2, [pc, #28]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
10000a40:	4413      	add	r3, r2
10000a42:	2201      	movs	r2, #1
10000a44:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000a46:	7bfb      	ldrb	r3, [r7, #15]
10000a48:	3301      	adds	r3, #1
10000a4a:	73fb      	strb	r3, [r7, #15]
10000a4c:	7bfb      	ldrb	r3, [r7, #15]
10000a4e:	2b02      	cmp	r3, #2
10000a50:	d9c3      	bls.n	100009da <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x16>
      }
    }
  }
}
10000a52:	bf00      	nop
10000a54:	bf00      	nop
10000a56:	3710      	adds	r7, #16
10000a58:	46bd      	mov	sp, r7
10000a5a:	bd80      	pop	{r7, pc}
10000a5c:	200000d0 	.word	0x200000d0
10000a60:	20000068 	.word	0x20000068

10000a64 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod>:
/*
 * This function check the non conducting phase and modulate high side PWM output and keep low side
 * output either high or low based on the MCMS shadow register.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod(uint16_t mcm_val, uint16_t mcms_val)
{
10000a64:	b480      	push	{r7}
10000a66:	b085      	sub	sp, #20
10000a68:	af00      	add	r7, sp, #0
10000a6a:	4603      	mov	r3, r0
10000a6c:	460a      	mov	r2, r1
10000a6e:	80fb      	strh	r3, [r7, #6]
10000a70:	4613      	mov	r3, r2
10000a72:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000a74:	2300      	movs	r3, #0
10000a76:	73fb      	strb	r3, [r7, #15]
10000a78:	e028      	b.n	10000acc <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x68>
  {
    /* if phase is not conducting */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
10000a7a:	7bfb      	ldrb	r3, [r7, #15]
10000a7c:	4a18      	ldr	r2, [pc, #96]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000a7e:	330c      	adds	r3, #12
10000a80:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
10000a84:	88fb      	ldrh	r3, [r7, #6]
10000a86:	4013      	ands	r3, r2
10000a88:	b29b      	uxth	r3, r3
10000a8a:	2b00      	cmp	r3, #0
10000a8c:	d11b      	bne.n	10000ac6 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x62>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000a8e:	7bfb      	ldrb	r3, [r7, #15]
10000a90:	4a13      	ldr	r2, [pc, #76]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000a92:	3308      	adds	r3, #8
10000a94:	005b      	lsls	r3, r3, #1
10000a96:	4413      	add	r3, r2
10000a98:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000a9a:	7bfb      	ldrb	r3, [r7, #15]
10000a9c:	4910      	ldr	r1, [pc, #64]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000a9e:	3308      	adds	r3, #8
10000aa0:	005b      	lsls	r3, r3, #1
10000aa2:	440b      	add	r3, r1
10000aa4:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000aa6:	88bb      	ldrh	r3, [r7, #4]
10000aa8:	400b      	ands	r3, r1
10000aaa:	b29b      	uxth	r3, r3
10000aac:	429a      	cmp	r2, r3
10000aae:	d105      	bne.n	10000abc <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x58>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
10000ab0:	7bfb      	ldrb	r3, [r7, #15]
10000ab2:	4a0b      	ldr	r2, [pc, #44]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000ab4:	4413      	add	r3, r2
10000ab6:	2203      	movs	r2, #3
10000ab8:	739a      	strb	r2, [r3, #14]
10000aba:	e004      	b.n	10000ac6 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x62>
      }
      /* if low side switch is ON */
      else
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
10000abc:	7bfb      	ldrb	r3, [r7, #15]
10000abe:	4a08      	ldr	r2, [pc, #32]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000ac0:	4413      	add	r3, r2
10000ac2:	2201      	movs	r2, #1
10000ac4:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000ac6:	7bfb      	ldrb	r3, [r7, #15]
10000ac8:	3301      	adds	r3, #1
10000aca:	73fb      	strb	r3, [r7, #15]
10000acc:	7bfb      	ldrb	r3, [r7, #15]
10000ace:	2b02      	cmp	r3, #2
10000ad0:	d9d3      	bls.n	10000a7a <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x16>
      }
    }
  }
}
10000ad2:	bf00      	nop
10000ad4:	bf00      	nop
10000ad6:	3714      	adds	r7, #20
10000ad8:	46bd      	mov	sp, r7
10000ada:	f85d 7b04 	ldr.w	r7, [sp], #4
10000ade:	4770      	bx	lr
10000ae0:	200000d0 	.word	0x200000d0

10000ae4 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod>:
/*
 * This function check the non conducting phase and modulate low side PWM output and keep high side
 * output either high or low based on the MCMS shadow register.
 */
void Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod(uint16_t mcm_val, uint16_t mcms_val)
{
10000ae4:	b480      	push	{r7}
10000ae6:	b085      	sub	sp, #20
10000ae8:	af00      	add	r7, sp, #0
10000aea:	4603      	mov	r3, r0
10000aec:	460a      	mov	r2, r1
10000aee:	80fb      	strh	r3, [r7, #6]
10000af0:	4613      	mov	r3, r2
10000af2:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000af4:	2300      	movs	r3, #0
10000af6:	73fb      	strb	r3, [r7, #15]
10000af8:	e03a      	b.n	10000b70 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x8c>
  {
    /* if phase is not conducting */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
10000afa:	7bfb      	ldrb	r3, [r7, #15]
10000afc:	4a21      	ldr	r2, [pc, #132]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000afe:	330c      	adds	r3, #12
10000b00:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
10000b04:	88fb      	ldrh	r3, [r7, #6]
10000b06:	4013      	ands	r3, r2
10000b08:	b29b      	uxth	r3, r3
10000b0a:	2b00      	cmp	r3, #0
10000b0c:	d12d      	bne.n	10000b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000b0e:	7bfb      	ldrb	r3, [r7, #15]
10000b10:	4a1c      	ldr	r2, [pc, #112]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b12:	3308      	adds	r3, #8
10000b14:	005b      	lsls	r3, r3, #1
10000b16:	4413      	add	r3, r2
10000b18:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000b1a:	7bfb      	ldrb	r3, [r7, #15]
10000b1c:	4919      	ldr	r1, [pc, #100]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b1e:	3308      	adds	r3, #8
10000b20:	005b      	lsls	r3, r3, #1
10000b22:	440b      	add	r3, r1
10000b24:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000b26:	88bb      	ldrh	r3, [r7, #4]
10000b28:	400b      	ands	r3, r1
10000b2a:	b29b      	uxth	r3, r3
10000b2c:	429a      	cmp	r2, r3
10000b2e:	d105      	bne.n	10000b3c <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x58>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
10000b30:	7bfb      	ldrb	r3, [r7, #15]
10000b32:	4a14      	ldr	r2, [pc, #80]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b34:	4413      	add	r3, r2
10000b36:	2200      	movs	r2, #0
10000b38:	739a      	strb	r2, [r3, #14]
10000b3a:	e016      	b.n	10000b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
      }
      /* if low side switch is ON */
      else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000b3c:	7bfb      	ldrb	r3, [r7, #15]
10000b3e:	4a11      	ldr	r2, [pc, #68]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b40:	3308      	adds	r3, #8
10000b42:	005b      	lsls	r3, r3, #1
10000b44:	4413      	add	r3, r2
10000b46:	885b      	ldrh	r3, [r3, #2]
10000b48:	005a      	lsls	r2, r3, #1
            (mcms_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
10000b4a:	88b9      	ldrh	r1, [r7, #4]
10000b4c:	7bfb      	ldrb	r3, [r7, #15]
10000b4e:	480d      	ldr	r0, [pc, #52]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b50:	3308      	adds	r3, #8
10000b52:	005b      	lsls	r3, r3, #1
10000b54:	4403      	add	r3, r0
10000b56:	885b      	ldrh	r3, [r3, #2]
10000b58:	005b      	lsls	r3, r3, #1
10000b5a:	400b      	ands	r3, r1
      else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000b5c:	429a      	cmp	r2, r3
10000b5e:	d104      	bne.n	10000b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
10000b60:	7bfb      	ldrb	r3, [r7, #15]
10000b62:	4a08      	ldr	r2, [pc, #32]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b64:	4413      	add	r3, r2
10000b66:	2202      	movs	r2, #2
10000b68:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000b6a:	7bfb      	ldrb	r3, [r7, #15]
10000b6c:	3301      	adds	r3, #1
10000b6e:	73fb      	strb	r3, [r7, #15]
10000b70:	7bfb      	ldrb	r3, [r7, #15]
10000b72:	2b02      	cmp	r3, #2
10000b74:	d9c1      	bls.n	10000afa <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x16>
      {

      }
    }
  }
}
10000b76:	bf00      	nop
10000b78:	bf00      	nop
10000b7a:	3714      	adds	r7, #20
10000b7c:	46bd      	mov	sp, r7
10000b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
10000b82:	4770      	bx	lr
10000b84:	200000d0 	.word	0x200000d0

10000b88 <CCU80_0_IRQHandler>:
 * Control loop interrupt is based on the PWM frequency.\n
 * This ISR executes the control scheme (PI), direction control, current and voltage reading,
 * voltage compensation and updates the duty cycle of the PWM.
 */
RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_ControlLoop_ISR(void)
{
10000b88:	b580      	push	{r7, lr}
10000b8a:	b084      	sub	sp, #16
10000b8c:	af00      	add	r7, sp, #0
  int32_t voltage_output = 0;  /* output of the control scheme */
10000b8e:	2300      	movs	r3, #0
10000b90:	60fb      	str	r3, [r7, #12]
#endif /* end of #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U)) */

  /***************** Current Reading ***************************************/
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  /* Get the IDC Link instantaneous current value */
  Motor0_BLDC_SCALAR_GetCurrentValue(&direct_current);
10000b92:	1d3b      	adds	r3, r7, #4
10000b94:	4618      	mov	r0, r3
10000b96:	f000 faf7 	bl	10001188 <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer>
  Motor0_BLDC_SCALAR.motor_current = Motor0_BLDC_SCALAR.motor_set_direction * direct_current;
10000b9a:	4b36      	ldr	r3, [pc, #216]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000b9c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000b9e:	687a      	ldr	r2, [r7, #4]
10000ba0:	fb02 f303 	mul.w	r3, r2, r3
10000ba4:	4a33      	ldr	r2, [pc, #204]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000ba6:	6713      	str	r3, [r2, #112]	; 0x70
  #endif  /* end of #if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) */

  #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U))
  /* Get the IDC Link average current value */
  Motor0_BLDC_SCALAR_GetAverageCurrentValue(&avg_current);
10000ba8:	463b      	mov	r3, r7
10000baa:	4618      	mov	r0, r3
10000bac:	f000 fad4 	bl	10001158 <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer>
  Motor0_BLDC_SCALAR.motor_average_current = Motor0_BLDC_SCALAR.motor_set_direction * avg_current;
10000bb0:	4b30      	ldr	r3, [pc, #192]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bb2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000bb4:	683a      	ldr	r2, [r7, #0]
10000bb6:	fb02 f303 	mul.w	r3, r2, r3
10000bba:	4a2e      	ldr	r2, [pc, #184]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bbc:	6753      	str	r3, [r2, #116]	; 0x74
  #endif /* end of #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U))*/

  #if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  /* Over-current detection timing */
  if (Motor0_BLDC_SCALAR.overcurrent_counter != 0U)
10000bbe:	4b2d      	ldr	r3, [pc, #180]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bc0:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
10000bc4:	2b00      	cmp	r3, #0
10000bc6:	d006      	beq.n	10000bd6 <CCU80_0_IRQHandler+0x4e>
  {
    Motor0_BLDC_SCALAR.overcurrent_counter--;
10000bc8:	4b2a      	ldr	r3, [pc, #168]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bca:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
10000bce:	3b01      	subs	r3, #1
10000bd0:	4a28      	ldr	r2, [pc, #160]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bd2:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
#if (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_VOLTAGE_CTRL)
  /* Voltage control */
  Motor0_BLDC_SCALAR_VoltageControlScheme(&voltage_output);
#elif (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL)
  /* Speed control */
  Motor0_BLDC_SCALAR.speedcontrol_rate_counter++;
10000bd6:	4b27      	ldr	r3, [pc, #156]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bd8:	f893 30c3 	ldrb.w	r3, [r3, #195]	; 0xc3
10000bdc:	3301      	adds	r3, #1
10000bde:	b2da      	uxtb	r2, r3
10000be0:	4b24      	ldr	r3, [pc, #144]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000be2:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
  if (Motor0_BLDC_SCALAR.speedcontrol_rate_counter >= Motor0_BLDC_SCALAR.speedcontrol_rate)
10000be6:	4b23      	ldr	r3, [pc, #140]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000be8:	f893 20c3 	ldrb.w	r2, [r3, #195]	; 0xc3
10000bec:	4b21      	ldr	r3, [pc, #132]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bee:	f893 30c2 	ldrb.w	r3, [r3, #194]	; 0xc2
10000bf2:	429a      	cmp	r2, r3
10000bf4:	d309      	bcc.n	10000c0a <CCU80_0_IRQHandler+0x82>
  {
    Motor0_BLDC_SCALAR_SpeedControlScheme(&voltage_output);
10000bf6:	f107 030c 	add.w	r3, r7, #12
10000bfa:	4618      	mov	r0, r3
10000bfc:	f000 faa4 	bl	10001148 <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer>
    Motor0_BLDC_SCALAR.speedcontrol_rate_counter = 0U;
10000c00:	4b1c      	ldr	r3, [pc, #112]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c02:	2200      	movs	r2, #0
10000c04:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
10000c08:	e002      	b.n	10000c10 <CCU80_0_IRQHandler+0x88>
  }
  else
  {
    voltage_output = Motor0_BLDC_SCALAR_SpeedControl_PI.uk;
10000c0a:	4b1b      	ldr	r3, [pc, #108]	; (10000c78 <CCU80_0_IRQHandler+0xf0>)
10000c0c:	681b      	ldr	r3, [r3, #0]
10000c0e:	60fb      	str	r3, [r7, #12]

  /*
   * Calculate absolute value of amplitude and
   * if seamless bi-directional control is enabled, change the direction of the rotation at the appropriate time.
   */
  Motor0_BLDC_SCALAR_DirectionControl(voltage_output, &duty_cycle);
10000c10:	68fb      	ldr	r3, [r7, #12]
10000c12:	f107 0208 	add.w	r2, r7, #8
10000c16:	4611      	mov	r1, r2
10000c18:	4618      	mov	r0, r3
10000c1a:	f000 fa6d 	bl	100010f8 <__Motor0_BLDC_SCALAR_DirectionControl_veneer>
#if ((MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE_SYNCHRECTI) || (MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE))
  /*
   * To avoid discharging of the bootstrap capacitor in high side modulation,
   * apply 100% voltage if voltage amplitude is greater than amplitude threshold limit
   */
  if (duty_cycle > Motor0_BLDC_SCALAR.amplitude_high_threshold)
10000c1e:	4b15      	ldr	r3, [pc, #84]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c20:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
10000c24:	68bb      	ldr	r3, [r7, #8]
10000c26:	429a      	cmp	r2, r3
10000c28:	d203      	bcs.n	10000c32 <CCU80_0_IRQHandler+0xaa>
  {
    duty_cycle = Motor0_BLDC_SCALAR.max_amplitude;
10000c2a:	4b12      	ldr	r3, [pc, #72]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c2c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
10000c30:	60bb      	str	r3, [r7, #8]
  }
#endif  /* end of #if ((MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE_SYNCHRECTI) || (MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE)) */

  /* max_amplitude is decided by MOTOR0_BLDC_SCALAR_MAX_AMPLITUDE */
  if (duty_cycle > Motor0_BLDC_SCALAR.max_amplitude)
10000c32:	4b10      	ldr	r3, [pc, #64]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c34:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
10000c38:	68bb      	ldr	r3, [r7, #8]
10000c3a:	429a      	cmp	r2, r3
10000c3c:	d203      	bcs.n	10000c46 <CCU80_0_IRQHandler+0xbe>
  {
    duty_cycle = Motor0_BLDC_SCALAR.max_amplitude;
10000c3e:	4b0d      	ldr	r3, [pc, #52]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c40:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
10000c44:	60bb      	str	r3, [r7, #8]
  }
  /* min_amplitude is decided by MOTOR0_BLDC_SCALAR_MIN_AMPLITUDE */
  if (duty_cycle < Motor0_BLDC_SCALAR.min_amplitude)
10000c46:	4b0b      	ldr	r3, [pc, #44]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c48:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
10000c4c:	68bb      	ldr	r3, [r7, #8]
10000c4e:	429a      	cmp	r2, r3
10000c50:	d901      	bls.n	10000c56 <CCU80_0_IRQHandler+0xce>
  {
    duty_cycle = 0U;
10000c52:	2300      	movs	r3, #0
10000c54:	60bb      	str	r3, [r7, #8]
  }
  Motor0_BLDC_SCALAR.amplitude = duty_cycle;
10000c56:	68bb      	ldr	r3, [r7, #8]
10000c58:	4a06      	ldr	r2, [pc, #24]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c5a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  /* Update the CCU8 compare values */
  Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate((uint16_t)Motor0_BLDC_SCALAR.amplitude);
10000c5e:	4b05      	ldr	r3, [pc, #20]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c60:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
10000c64:	b29b      	uxth	r3, r3
10000c66:	4618      	mov	r0, r3
10000c68:	f000 fa4e 	bl	10001108 <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer>

}
10000c6c:	bf00      	nop
10000c6e:	3710      	adds	r7, #16
10000c70:	46bd      	mov	sp, r7
10000c72:	bd80      	pop	{r7, pc}
10000c74:	2000018c 	.word	0x2000018c
10000c78:	2000008c 	.word	0x2000008c

10000c7c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>:
{
10000c7c:	b480      	push	{r7}
10000c7e:	b083      	sub	sp, #12
10000c80:	af00      	add	r7, sp, #0
10000c82:	6078      	str	r0, [r7, #4]
10000c84:	6039      	str	r1, [r7, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum -= Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000c86:	4b27      	ldr	r3, [pc, #156]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c88:	6a1a      	ldr	r2, [r3, #32]
10000c8a:	4b26      	ldr	r3, [pc, #152]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c8c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000c90:	4619      	mov	r1, r3
10000c92:	4b24      	ldr	r3, [pc, #144]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c94:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000c98:	1ad3      	subs	r3, r2, r3
10000c9a:	4a22      	ldr	r2, [pc, #136]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c9c:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex] = capval;
10000c9e:	4b21      	ldr	r3, [pc, #132]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000ca0:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000ca4:	4619      	mov	r1, r3
10000ca6:	4a1f      	ldr	r2, [pc, #124]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000ca8:	687b      	ldr	r3, [r7, #4]
10000caa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum += Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000cae:	4b1d      	ldr	r3, [pc, #116]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cb0:	6a1a      	ldr	r2, [r3, #32]
10000cb2:	4b1c      	ldr	r3, [pc, #112]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cb4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000cb8:	4619      	mov	r1, r3
10000cba:	4b1a      	ldr	r3, [pc, #104]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cbc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000cc0:	4413      	add	r3, r2
10000cc2:	4a18      	ldr	r2, [pc, #96]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cc4:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex++;
10000cc6:	4b17      	ldr	r3, [pc, #92]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cc8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000ccc:	3301      	adds	r3, #1
10000cce:	b2da      	uxtb	r2, r3
10000cd0:	4b14      	ldr	r3, [pc, #80]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cd2:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex > BLDC_SCALAR_SPEED_POS_HALL_SPEEDACCUMLIMITCHECK)
10000cd6:	4b13      	ldr	r3, [pc, #76]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cd8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000cdc:	2b05      	cmp	r3, #5
10000cde:	d906      	bls.n	10000cee <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x72>
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
10000ce0:	4b10      	ldr	r3, [pc, #64]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000ce2:	2200      	movs	r2, #0
10000ce4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 1U;
10000ce8:	4b0e      	ldr	r3, [pc, #56]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cea:	2201      	movs	r2, #1
10000cec:	61da      	str	r2, [r3, #28]
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck == 1U)
10000cee:	4b0d      	ldr	r3, [pc, #52]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cf0:	69db      	ldr	r3, [r3, #28]
10000cf2:	2b01      	cmp	r3, #1
10000cf4:	d10c      	bne.n	10000d10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x94>
    if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum > 0U)
10000cf6:	4b0b      	ldr	r3, [pc, #44]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cf8:	6a1b      	ldr	r3, [r3, #32]
10000cfa:	2b00      	cmp	r3, #0
10000cfc:	d00b      	beq.n	10000d16 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
      *speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant) / (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum);
10000cfe:	4b09      	ldr	r3, [pc, #36]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d00:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10000d02:	4b08      	ldr	r3, [pc, #32]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d04:	6a1b      	ldr	r3, [r3, #32]
10000d06:	fbb2 f2f3 	udiv	r2, r2, r3
10000d0a:	683b      	ldr	r3, [r7, #0]
10000d0c:	601a      	str	r2, [r3, #0]
}
10000d0e:	e002      	b.n	10000d16 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
    *speed = 0U;
10000d10:	683b      	ldr	r3, [r7, #0]
10000d12:	2200      	movs	r2, #0
10000d14:	601a      	str	r2, [r3, #0]
}
10000d16:	bf00      	nop
10000d18:	370c      	adds	r7, #12
10000d1a:	46bd      	mov	sp, r7
10000d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
10000d20:	4770      	bx	lr
10000d22:	bf00      	nop
10000d24:	200000f8 	.word	0x200000f8

10000d28 <POSIF0_0_IRQHandler>:
{
10000d28:	b580      	push	{r7, lr}
10000d2a:	af00      	add	r7, sp, #0
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus(XMC_POSIF_IRQ_EVENT_WHE) == (uint8_t)1)
10000d2c:	2001      	movs	r0, #1
10000d2e:	f000 fa03 	bl	10001138 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer>
10000d32:	4603      	mov	r3, r0
10000d34:	2b01      	cmp	r3, #1
10000d36:	d102      	bne.n	10000d3e <POSIF0_0_IRQHandler+0x16>
    Motor0_BLDC_SCALAR_WrongHallEvent();
10000d38:	f000 f9e2 	bl	10001100 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer>
}
10000d3c:	e001      	b.n	10000d42 <POSIF0_0_IRQHandler+0x1a>
    Motor0_BLDC_SCALAR_CorrectHallEvent();
10000d3e:	f000 f9f7 	bl	10001130 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer>
}
10000d42:	bf00      	nop
10000d44:	bd80      	pop	{r7, pc}
10000d46:	bf00      	nop

10000d48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>:
{
10000d48:	b480      	push	{r7}
10000d4a:	b083      	sub	sp, #12
10000d4c:	af00      	add	r7, sp, #0
10000d4e:	6078      	str	r0, [r7, #4]
10000d50:	6039      	str	r1, [r7, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum -= Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000d52:	4b27      	ldr	r3, [pc, #156]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d54:	6a1a      	ldr	r2, [r3, #32]
10000d56:	4b26      	ldr	r3, [pc, #152]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d58:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d5c:	4619      	mov	r1, r3
10000d5e:	4b24      	ldr	r3, [pc, #144]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d60:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000d64:	1ad3      	subs	r3, r2, r3
10000d66:	4a22      	ldr	r2, [pc, #136]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d68:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex] = capval;
10000d6a:	4b21      	ldr	r3, [pc, #132]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d6c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d70:	4619      	mov	r1, r3
10000d72:	4a1f      	ldr	r2, [pc, #124]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d74:	687b      	ldr	r3, [r7, #4]
10000d76:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum += Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000d7a:	4b1d      	ldr	r3, [pc, #116]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d7c:	6a1a      	ldr	r2, [r3, #32]
10000d7e:	4b1c      	ldr	r3, [pc, #112]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d80:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d84:	4619      	mov	r1, r3
10000d86:	4b1a      	ldr	r3, [pc, #104]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d88:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000d8c:	4413      	add	r3, r2
10000d8e:	4a18      	ldr	r2, [pc, #96]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d90:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex++;
10000d92:	4b17      	ldr	r3, [pc, #92]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d94:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d98:	3301      	adds	r3, #1
10000d9a:	b2da      	uxtb	r2, r3
10000d9c:	4b14      	ldr	r3, [pc, #80]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d9e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex > BLDC_SCALAR_SPEED_POS_HALL_SPEEDACCUMLIMITCHECK)
10000da2:	4b13      	ldr	r3, [pc, #76]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000da4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000da8:	2b05      	cmp	r3, #5
10000daa:	d906      	bls.n	10000dba <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x72>
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
10000dac:	4b10      	ldr	r3, [pc, #64]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dae:	2200      	movs	r2, #0
10000db0:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 1U;
10000db4:	4b0e      	ldr	r3, [pc, #56]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000db6:	2201      	movs	r2, #1
10000db8:	61da      	str	r2, [r3, #28]
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck == 1U)
10000dba:	4b0d      	ldr	r3, [pc, #52]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dbc:	69db      	ldr	r3, [r3, #28]
10000dbe:	2b01      	cmp	r3, #1
10000dc0:	d10c      	bne.n	10000ddc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x94>
    if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum > 0U)
10000dc2:	4b0b      	ldr	r3, [pc, #44]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dc4:	6a1b      	ldr	r3, [r3, #32]
10000dc6:	2b00      	cmp	r3, #0
10000dc8:	d00b      	beq.n	10000de2 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
      *speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant) / (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum);
10000dca:	4b09      	ldr	r3, [pc, #36]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dcc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10000dce:	4b08      	ldr	r3, [pc, #32]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dd0:	6a1b      	ldr	r3, [r3, #32]
10000dd2:	fbb2 f2f3 	udiv	r2, r2, r3
10000dd6:	683b      	ldr	r3, [r7, #0]
10000dd8:	601a      	str	r2, [r3, #0]
}
10000dda:	e002      	b.n	10000de2 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
    *speed = 0U;
10000ddc:	683b      	ldr	r3, [r7, #0]
10000dde:	2200      	movs	r2, #0
10000de0:	601a      	str	r2, [r3, #0]
}
10000de2:	bf00      	nop
10000de4:	370c      	adds	r7, #12
10000de6:	46bd      	mov	sp, r7
10000de8:	f85d 7b04 	ldr.w	r7, [sp], #4
10000dec:	4770      	bx	lr
10000dee:	bf00      	nop
10000df0:	200000f8 	.word	0x200000f8

10000df4 <POSIF0_1_IRQHandler>:
 * Prepare hall and multi-channel pattern for the next commutation.
 * Calculate the Speed based on captured value in CCU4 capture slice.
 */

RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_PatternShadowTx_ISR(void)
{
10000df4:	b580      	push	{r7, lr}
10000df6:	b084      	sub	sp, #16
10000df8:	af00      	add	r7, sp, #0
  uint8_t pos;            /* array index variable */
  uint16_t mcmval;  /*current multi-channel pattern */
  uint16_t mcmvals; /*shadow multi-channel pattern */
  uint32_t capval;  /* calculated time between last two hall events */
  uint8_t status;   /* return status of the API to read the captured value from capture register */
  uint32_t speed = 0U; /* electrical speed in RPM */
10000dfa:	2300      	movs	r3, #0
10000dfc:	603b      	str	r3, [r7, #0]
  uint8_t direction = (uint8_t)Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
10000dfe:	4b2e      	ldr	r3, [pc, #184]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e00:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000e02:	b2db      	uxtb	r3, r3
10000e04:	f003 0308 	and.w	r3, r3, #8
10000e08:	73fb      	strb	r3, [r7, #15]

  /* store the sampled pattern */
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
10000e0a:	f000 f9a1 	bl	10001150 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer>
10000e0e:	4603      	mov	r3, r0
10000e10:	461a      	mov	r2, r3
10000e12:	4b2a      	ldr	r3, [pc, #168]	; (10000ebc <POSIF0_1_IRQHandler+0xc8>)
10000e14:	745a      	strb	r2, [r3, #17]
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  /* To blank the direct DC link current measurement at the commutation point */
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 1U;
10000e16:	4b2a      	ldr	r3, [pc, #168]	; (10000ec0 <POSIF0_1_IRQHandler+0xcc>)
10000e18:	2201      	movs	r2, #1
10000e1a:	f883 2020 	strb.w	r2, [r3, #32]
#endif  /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
#endif /* end of #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) */

  /*Get the expected hall pattern.*/
  pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
10000e1e:	f000 f9a7 	bl	10001170 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>
10000e22:	4603      	mov	r3, r0
10000e24:	73bb      	strb	r3, [r7, #14]
  /*Set next hall pattern and MCM pattern based on the expected hall pattern.*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t)(Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
10000e26:	7bba      	ldrb	r2, [r7, #14]
10000e28:	7bfb      	ldrb	r3, [r7, #15]
10000e2a:	4413      	add	r3, r2
10000e2c:	4a23      	ldr	r2, [pc, #140]	; (10000ebc <POSIF0_1_IRQHandler+0xc8>)
10000e2e:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
10000e30:	4618      	mov	r0, r3
10000e32:	f000 f951 	bl	100010d8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
      (uint16_t)Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pos) +
10000e36:	4b23      	ldr	r3, [pc, #140]	; (10000ec4 <POSIF0_1_IRQHandler+0xd0>)
10000e38:	7b1b      	ldrb	r3, [r3, #12]
10000e3a:	4618      	mov	r0, r3
10000e3c:	7bba      	ldrb	r2, [r7, #14]
                                          (uint8_t)direction]);
10000e3e:	7bfb      	ldrb	r3, [r7, #15]
      (uint16_t)Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pos) +
10000e40:	4413      	add	r3, r2
10000e42:	491d      	ldr	r1, [pc, #116]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e44:	0102      	lsls	r2, r0, #4
10000e46:	4413      	add	r3, r2
10000e48:	005b      	lsls	r3, r3, #1
10000e4a:	440b      	add	r3, r1
10000e4c:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
10000e4e:	4618      	mov	r0, r3
10000e50:	f000 f9b2 	bl	100011b8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>

  /*Get the shadow multi-channel pattern value and apply the PWM modulation.*/
  mcmval = (uint16_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
10000e54:	f000 f964 	bl	10001120 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
10000e58:	4603      	mov	r3, r0
10000e5a:	81bb      	strh	r3, [r7, #12]
  mcmvals = (uint16_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern();
10000e5c:	f000 f940 	bl	100010e0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>
10000e60:	4603      	mov	r3, r0
10000e62:	817b      	strh	r3, [r7, #10]
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval,mcmvals);
10000e64:	4b17      	ldr	r3, [pc, #92]	; (10000ec4 <POSIF0_1_IRQHandler+0xd0>)
10000e66:	685b      	ldr	r3, [r3, #4]
10000e68:	8979      	ldrh	r1, [r7, #10]
10000e6a:	89ba      	ldrh	r2, [r7, #12]
10000e6c:	4610      	mov	r0, r2
10000e6e:	4798      	blx	r3

    /*Get the captured value from capture timer */
  status = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue(&capval);
10000e70:	1d3b      	adds	r3, r7, #4
10000e72:	4618      	mov	r0, r3
10000e74:	f000 f984 	bl	10001180 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer>
10000e78:	4603      	mov	r3, r0
10000e7a:	727b      	strb	r3, [r7, #9]
#if (MOTOR0_BLDC_SCALAR_ENABLE_STALL_DETECTION == 1U)
  /* Reset the stall detection count as hall event is detected for timeout*/
  Motor0_BLDC_SCALAR.stall_detection_counter = 0U;
#endif
  /* if valid speed capture value */
  if (status == (uint8_t)BLDC_SCALAR_SPEED_POS_HALL_STATUS_SUCCESS)
10000e7c:	7a7b      	ldrb	r3, [r7, #9]
10000e7e:	2b00      	cmp	r3, #0
10000e80:	d116      	bne.n	10000eb0 <POSIF0_1_IRQHandler+0xbc>
  {
    /* speed calculation */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation(capval, &speed);
10000e82:	687b      	ldr	r3, [r7, #4]
10000e84:	463a      	mov	r2, r7
10000e86:	4611      	mov	r1, r2
10000e88:	4618      	mov	r0, r3
10000e8a:	f7ff ff5d 	bl	10000d48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>

    Motor0_BLDC_SCALAR.actual_motor_direction = Motor0_BLDC_SCALAR.motor_set_direction;
10000e8e:	4b0a      	ldr	r3, [pc, #40]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e90:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000e92:	4a09      	ldr	r2, [pc, #36]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e94:	67d3      	str	r3, [r2, #124]	; 0x7c
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
10000e96:	4b08      	ldr	r3, [pc, #32]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e98:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
10000e9a:	683a      	ldr	r2, [r7, #0]
10000e9c:	fb02 f303 	mul.w	r3, r2, r3
                                     (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
10000ea0:	4a05      	ldr	r2, [pc, #20]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000ea2:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
10000ea6:	fb02 f303 	mul.w	r3, r2, r3
                                     (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
10000eaa:	129b      	asrs	r3, r3, #10
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
10000eac:	4a02      	ldr	r2, [pc, #8]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000eae:	66d3      	str	r3, [r2, #108]	; 0x6c
      }
    }
#endif
  }

}
10000eb0:	bf00      	nop
10000eb2:	3710      	adds	r7, #16
10000eb4:	46bd      	mov	sp, r7
10000eb6:	bd80      	pop	{r7, pc}
10000eb8:	2000018c 	.word	0x2000018c
10000ebc:	20000158 	.word	0x20000158
10000ec0:	20000124 	.word	0x20000124
10000ec4:	200000d0 	.word	0x200000d0

10000ec8 <Motor0_BLDC_SCALAR_MSM>:
{
10000ec8:	b580      	push	{r7, lr}
10000eca:	af00      	add	r7, sp, #0
  switch (Motor0_BLDC_SCALAR.msm_state)
10000ecc:	4b1a      	ldr	r3, [pc, #104]	; (10000f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
10000ece:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
10000ed2:	b2db      	uxtb	r3, r3
10000ed4:	2b08      	cmp	r3, #8
10000ed6:	d824      	bhi.n	10000f22 <Motor0_BLDC_SCALAR_MSM+0x5a>
10000ed8:	a201      	add	r2, pc, #4	; (adr r2, 10000ee0 <Motor0_BLDC_SCALAR_MSM+0x18>)
10000eda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
10000ede:	bf00      	nop
10000ee0:	10000f1d 	.word	0x10000f1d
10000ee4:	10000f17 	.word	0x10000f17
10000ee8:	10000f0b 	.word	0x10000f0b
10000eec:	10000f23 	.word	0x10000f23
10000ef0:	10000f23 	.word	0x10000f23
10000ef4:	10000f23 	.word	0x10000f23
10000ef8:	10000f23 	.word	0x10000f23
10000efc:	10000f05 	.word	0x10000f05
10000f00:	10000f11 	.word	0x10000f11
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func();
10000f04:	f000 f8f0 	bl	100010e8 <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer>
      break;
10000f08:	e00c      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func();
10000f0a:	f000 f941 	bl	10001190 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer>
      break;
10000f0e:	e009      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_ERROR_Func();
10000f10:	f000 f94a 	bl	100011a8 <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer>
      break;
10000f14:	e006      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_START_Func();
10000f16:	f000 f93f 	bl	10001198 <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer>
      break;
10000f1a:	e003      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MotorStop();
10000f1c:	f000 f924 	bl	10001168 <__Motor0_BLDC_SCALAR_MotorStop_veneer>
      break;
10000f20:	e000      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      break;
10000f22:	bf00      	nop
  if (Motor0_BLDC_SCALAR.error_status != 0U)
10000f24:	4b04      	ldr	r3, [pc, #16]	; (10000f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
10000f26:	6e9b      	ldr	r3, [r3, #104]	; 0x68
10000f28:	2b00      	cmp	r3, #0
10000f2a:	d003      	beq.n	10000f34 <Motor0_BLDC_SCALAR_MSM+0x6c>
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
10000f2c:	4b02      	ldr	r3, [pc, #8]	; (10000f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
10000f2e:	2208      	movs	r2, #8
10000f30:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
10000f34:	bf00      	nop
10000f36:	bd80      	pop	{r7, pc}
10000f38:	2000018c 	.word	0x2000018c

10000f3c <Motor0_BLDC_SCALAR_PatternInitiator>:
{
10000f3c:	b580      	push	{r7, lr}
10000f3e:	b084      	sub	sp, #16
10000f40:	af00      	add	r7, sp, #0
10000f42:	4603      	mov	r3, r0
10000f44:	71fb      	strb	r3, [r7, #7]
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_DIRECTION_INDEX;   /* Intended direction */
10000f46:	4b2b      	ldr	r3, [pc, #172]	; (10000ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
10000f48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000f4a:	b2db      	uxtb	r3, r3
10000f4c:	f003 0308 	and.w	r3, r3, #8
10000f50:	73fb      	strb	r3, [r7, #15]
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[curpos + (uint32_t) direction]));
10000f52:	79fa      	ldrb	r2, [r7, #7]
10000f54:	7bfb      	ldrb	r3, [r7, #15]
10000f56:	4413      	add	r3, r2
10000f58:	4a27      	ldr	r2, [pc, #156]	; (10000ff8 <Motor0_BLDC_SCALAR_PatternInitiator+0xbc>)
10000f5a:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
10000f5c:	4618      	mov	r0, r3
10000f5e:	f000 f8e3 	bl	10001128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
10000f62:	f000 f909 	bl	10001178 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer>
      (uint16_t) Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(curpos) + (uint8_t) direction]);
10000f66:	4b25      	ldr	r3, [pc, #148]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000f68:	7b1b      	ldrb	r3, [r3, #12]
10000f6a:	4618      	mov	r0, r3
10000f6c:	79fa      	ldrb	r2, [r7, #7]
10000f6e:	7bfb      	ldrb	r3, [r7, #15]
10000f70:	4413      	add	r3, r2
10000f72:	4920      	ldr	r1, [pc, #128]	; (10000ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
10000f74:	0102      	lsls	r2, r0, #4
10000f76:	4413      	add	r3, r2
10000f78:	005b      	lsls	r3, r3, #1
10000f7a:	440b      	add	r3, r1
10000f7c:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
10000f7e:	4618      	mov	r0, r3
10000f80:	f000 f8ca 	bl	10001118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern();
10000f84:	f000 f8b4 	bl	100010f0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer>
  pattern_index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
10000f88:	f000 f8da 	bl	10001140 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>
10000f8c:	4603      	mov	r3, r0
10000f8e:	73bb      	strb	r3, [r7, #14]
  mcmval = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
10000f90:	f000 f8be 	bl	10001110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
10000f94:	4603      	mov	r3, r0
10000f96:	81bb      	strh	r3, [r7, #12]
  Motor0_BLDC_SCALAR_PWM_BC.immediate_modulation_ptr(mcmval);
10000f98:	4b18      	ldr	r3, [pc, #96]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000f9a:	689b      	ldr	r3, [r3, #8]
10000f9c:	89ba      	ldrh	r2, [r7, #12]
10000f9e:	4610      	mov	r0, r2
10000fa0:	4798      	blx	r3
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pattern_index + (uint32_t) direction]));
10000fa2:	7bba      	ldrb	r2, [r7, #14]
10000fa4:	7bfb      	ldrb	r3, [r7, #15]
10000fa6:	4413      	add	r3, r2
10000fa8:	4a13      	ldr	r2, [pc, #76]	; (10000ff8 <Motor0_BLDC_SCALAR_PatternInitiator+0xbc>)
10000faa:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
10000fac:	4618      	mov	r0, r3
10000fae:	f000 f8bb 	bl	10001128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
      (uint16_t) Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pattern_index) + (uint8_t) direction]);
10000fb2:	4b12      	ldr	r3, [pc, #72]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000fb4:	7b1b      	ldrb	r3, [r3, #12]
10000fb6:	4618      	mov	r0, r3
10000fb8:	7bba      	ldrb	r2, [r7, #14]
10000fba:	7bfb      	ldrb	r3, [r7, #15]
10000fbc:	4413      	add	r3, r2
10000fbe:	490d      	ldr	r1, [pc, #52]	; (10000ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
10000fc0:	0102      	lsls	r2, r0, #4
10000fc2:	4413      	add	r3, r2
10000fc4:	005b      	lsls	r3, r3, #1
10000fc6:	440b      	add	r3, r1
10000fc8:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
10000fca:	4618      	mov	r0, r3
10000fcc:	f000 f8a4 	bl	10001118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>
  mcmval = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
10000fd0:	f000 f89e 	bl	10001110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
10000fd4:	4603      	mov	r3, r0
10000fd6:	81bb      	strh	r3, [r7, #12]
  mcmshadow = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern();
10000fd8:	f000 f8ea 	bl	100011b0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>
10000fdc:	4603      	mov	r3, r0
10000fde:	817b      	strh	r3, [r7, #10]
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval, mcmshadow);
10000fe0:	4b06      	ldr	r3, [pc, #24]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000fe2:	685b      	ldr	r3, [r3, #4]
10000fe4:	8979      	ldrh	r1, [r7, #10]
10000fe6:	89ba      	ldrh	r2, [r7, #12]
10000fe8:	4610      	mov	r0, r2
10000fea:	4798      	blx	r3
}
10000fec:	bf00      	nop
10000fee:	3710      	adds	r7, #16
10000ff0:	46bd      	mov	sp, r7
10000ff2:	bd80      	pop	{r7, pc}
10000ff4:	2000018c 	.word	0x2000018c
10000ff8:	20000158 	.word	0x20000158
10000ffc:	200000d0 	.word	0x200000d0

10001000 <Motor0_BLDC_SCALAR_Ramp_Linear>:
 * API IMPLEMENTATION
 **********************************************************************************************************************/
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
/* This generates the linear ramp as per configured slew rate */
RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_Ramp_Linear(void)
{
10001000:	b480      	push	{r7}
10001002:	b083      	sub	sp, #12
10001004:	af00      	add	r7, sp, #0
  static int32_t sum;     /* to find the increment/decrement value */
  int32_t setval_diff;   /* difference between ramp input and output value */
  int32_t ramp_val;      /* value by which set value is incremented or decremented */

  /* ramp up - if target end value is greater than the ramp output set_value */
  if ((Motor0_BLDC_SCALAR_Ramp.input_value) >= Motor0_BLDC_SCALAR_Ramp.set_value)
10001006:	4b32      	ldr	r3, [pc, #200]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001008:	685a      	ldr	r2, [r3, #4]
1000100a:	4b31      	ldr	r3, [pc, #196]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000100c:	681b      	ldr	r3, [r3, #0]
1000100e:	429a      	cmp	r2, r3
10001010:	db29      	blt.n	10001066 <Motor0_BLDC_SCALAR_Ramp_Linear+0x66>
  {
    /* Find increment value using fixed point representation */
    setval_diff = (Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value;
10001012:	4b2f      	ldr	r3, [pc, #188]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001014:	685a      	ldr	r2, [r3, #4]
10001016:	4b2e      	ldr	r3, [pc, #184]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001018:	681b      	ldr	r3, [r3, #0]
1000101a:	1ad3      	subs	r3, r2, r3
1000101c:	607b      	str	r3, [r7, #4]
    sum = (int32_t)(sum + (int32_t)Motor0_BLDC_SCALAR_Ramp.ramp_rate);
1000101e:	4b2c      	ldr	r3, [pc, #176]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001020:	689b      	ldr	r3, [r3, #8]
10001022:	461a      	mov	r2, r3
10001024:	4b2b      	ldr	r3, [pc, #172]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001026:	681b      	ldr	r3, [r3, #0]
10001028:	4413      	add	r3, r2
1000102a:	4a2a      	ldr	r2, [pc, #168]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000102c:	6013      	str	r3, [r2, #0]
    ramp_val = (int32_t)(sum >> BLDC_SCALAR_RAMP_SHIFT_16);
1000102e:	4b29      	ldr	r3, [pc, #164]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001030:	681b      	ldr	r3, [r3, #0]
10001032:	141b      	asrs	r3, r3, #16
10001034:	603b      	str	r3, [r7, #0]
    sum = (int32_t)(sum & BLDC_SCALAR_RAMP_POW_16);
10001036:	4b27      	ldr	r3, [pc, #156]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001038:	681b      	ldr	r3, [r3, #0]
1000103a:	b29b      	uxth	r3, r3
1000103c:	4a25      	ldr	r2, [pc, #148]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000103e:	6013      	str	r3, [r2, #0]

    /* Set value reached the end point */
    if (setval_diff <= ramp_val)
10001040:	687a      	ldr	r2, [r7, #4]
10001042:	683b      	ldr	r3, [r7, #0]
10001044:	429a      	cmp	r2, r3
10001046:	dc07      	bgt.n	10001058 <Motor0_BLDC_SCALAR_Ramp_Linear+0x58>
    {
      Motor0_BLDC_SCALAR_Ramp.set_value = (Motor0_BLDC_SCALAR_Ramp.input_value);
10001048:	4b21      	ldr	r3, [pc, #132]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000104a:	685b      	ldr	r3, [r3, #4]
1000104c:	4a20      	ldr	r2, [pc, #128]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000104e:	6013      	str	r3, [r2, #0]
      sum = 0;
10001050:	4b20      	ldr	r3, [pc, #128]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001052:	2200      	movs	r2, #0
10001054:	601a      	str	r2, [r3, #0]
  }
  else
  {

  }
}
10001056:	e035      	b.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
      Motor0_BLDC_SCALAR_Ramp.set_value += ramp_val;
10001058:	4b1d      	ldr	r3, [pc, #116]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000105a:	681a      	ldr	r2, [r3, #0]
1000105c:	683b      	ldr	r3, [r7, #0]
1000105e:	4413      	add	r3, r2
10001060:	4a1b      	ldr	r2, [pc, #108]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001062:	6013      	str	r3, [r2, #0]
}
10001064:	e02e      	b.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
  else if ((Motor0_BLDC_SCALAR_Ramp.input_value) < Motor0_BLDC_SCALAR_Ramp.set_value)
10001066:	4b1a      	ldr	r3, [pc, #104]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001068:	685a      	ldr	r2, [r3, #4]
1000106a:	4b19      	ldr	r3, [pc, #100]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000106c:	681b      	ldr	r3, [r3, #0]
1000106e:	429a      	cmp	r2, r3
10001070:	da28      	bge.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
    setval_diff =  Motor0_BLDC_SCALAR_Ramp.set_value - (Motor0_BLDC_SCALAR_Ramp.input_value);
10001072:	4b17      	ldr	r3, [pc, #92]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001074:	681a      	ldr	r2, [r3, #0]
10001076:	4b16      	ldr	r3, [pc, #88]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001078:	685b      	ldr	r3, [r3, #4]
1000107a:	1ad3      	subs	r3, r2, r3
1000107c:	607b      	str	r3, [r7, #4]
    sum = (int32_t)(sum + (int32_t)Motor0_BLDC_SCALAR_Ramp.ramp_rate);
1000107e:	4b14      	ldr	r3, [pc, #80]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001080:	689b      	ldr	r3, [r3, #8]
10001082:	461a      	mov	r2, r3
10001084:	4b13      	ldr	r3, [pc, #76]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001086:	681b      	ldr	r3, [r3, #0]
10001088:	4413      	add	r3, r2
1000108a:	4a12      	ldr	r2, [pc, #72]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000108c:	6013      	str	r3, [r2, #0]
    ramp_val = (int32_t)(sum >> BLDC_SCALAR_RAMP_SHIFT_16);
1000108e:	4b11      	ldr	r3, [pc, #68]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001090:	681b      	ldr	r3, [r3, #0]
10001092:	141b      	asrs	r3, r3, #16
10001094:	603b      	str	r3, [r7, #0]
    sum = (int32_t)(sum & BLDC_SCALAR_RAMP_POW_16);
10001096:	4b0f      	ldr	r3, [pc, #60]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001098:	681b      	ldr	r3, [r3, #0]
1000109a:	b29b      	uxth	r3, r3
1000109c:	4a0d      	ldr	r2, [pc, #52]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000109e:	6013      	str	r3, [r2, #0]
    if (setval_diff <= ramp_val)
100010a0:	687a      	ldr	r2, [r7, #4]
100010a2:	683b      	ldr	r3, [r7, #0]
100010a4:	429a      	cmp	r2, r3
100010a6:	dc07      	bgt.n	100010b8 <Motor0_BLDC_SCALAR_Ramp_Linear+0xb8>
      Motor0_BLDC_SCALAR_Ramp.set_value = (Motor0_BLDC_SCALAR_Ramp.input_value);
100010a8:	4b09      	ldr	r3, [pc, #36]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010aa:	685b      	ldr	r3, [r3, #4]
100010ac:	4a08      	ldr	r2, [pc, #32]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010ae:	6013      	str	r3, [r2, #0]
      sum = 0;
100010b0:	4b08      	ldr	r3, [pc, #32]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
100010b2:	2200      	movs	r2, #0
100010b4:	601a      	str	r2, [r3, #0]
}
100010b6:	e005      	b.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
      Motor0_BLDC_SCALAR_Ramp.set_value -= ramp_val;
100010b8:	4b05      	ldr	r3, [pc, #20]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010ba:	681a      	ldr	r2, [r3, #0]
100010bc:	683b      	ldr	r3, [r7, #0]
100010be:	1ad3      	subs	r3, r2, r3
100010c0:	4a03      	ldr	r2, [pc, #12]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010c2:	6013      	str	r3, [r2, #0]
}
100010c4:	bf00      	nop
100010c6:	370c      	adds	r7, #12
100010c8:	46bd      	mov	sp, r7
100010ca:	f85d 7b04 	ldr.w	r7, [sp], #4
100010ce:	4770      	bx	lr
100010d0:	200000bc 	.word	0x200000bc
100010d4:	200005fc 	.word	0x200005fc

100010d8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>:
100010d8:	f85f f000 	ldr.w	pc, [pc]	; 100010dc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer+0x4>
100010dc:	08021e6d 	.word	0x08021e6d

100010e0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>:
100010e0:	f85f f000 	ldr.w	pc, [pc]	; 100010e4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer+0x4>
100010e4:	08021e4d 	.word	0x08021e4d

100010e8 <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer>:
100010e8:	f85f f000 	ldr.w	pc, [pc]	; 100010ec <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer+0x4>
100010ec:	0802233d 	.word	0x0802233d

100010f0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer>:
100010f0:	f85f f000 	ldr.w	pc, [pc]	; 100010f4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer+0x4>
100010f4:	08022625 	.word	0x08022625

100010f8 <__Motor0_BLDC_SCALAR_DirectionControl_veneer>:
100010f8:	f85f f000 	ldr.w	pc, [pc]	; 100010fc <__Motor0_BLDC_SCALAR_DirectionControl_veneer+0x4>
100010fc:	08021711 	.word	0x08021711

10001100 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer>:
10001100:	f85f f000 	ldr.w	pc, [pc]	; 10001104 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer+0x4>
10001104:	08021a6d 	.word	0x08021a6d

10001108 <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer>:
10001108:	f85f f000 	ldr.w	pc, [pc]	; 1000110c <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer+0x4>
1000110c:	08021361 	.word	0x08021361

10001110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>:
10001110:	f85f f000 	ldr.w	pc, [pc]	; 10001114 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer+0x4>
10001114:	08022639 	.word	0x08022639

10001118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>:
10001118:	f85f f000 	ldr.w	pc, [pc]	; 1000111c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer+0x4>
1000111c:	08022605 	.word	0x08022605

10001120 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>:
10001120:	f85f f000 	ldr.w	pc, [pc]	; 10001124 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer+0x4>
10001124:	08021e2d 	.word	0x08021e2d

10001128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>:
10001128:	f85f f000 	ldr.w	pc, [pc]	; 1000112c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer+0x4>
1000112c:	08022679 	.word	0x08022679

10001130 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer>:
10001130:	f85f f000 	ldr.w	pc, [pc]	; 10001134 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer+0x4>
10001134:	08021bf5 	.word	0x08021bf5

10001138 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer>:
10001138:	f85f f000 	ldr.w	pc, [pc]	; 1000113c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer+0x4>
1000113c:	08021a29 	.word	0x08021a29

10001140 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>:
10001140:	f85f f000 	ldr.w	pc, [pc]	; 10001144 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer+0x4>
10001144:	080226ad 	.word	0x080226ad

10001148 <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer>:
10001148:	f85f f000 	ldr.w	pc, [pc]	; 1000114c <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer+0x4>
1000114c:	080216c5 	.word	0x080216c5

10001150 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer>:
10001150:	f85f f000 	ldr.w	pc, [pc]	; 10001154 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer+0x4>
10001154:	08021ead 	.word	0x08021ead

10001158 <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer>:
10001158:	f85f f000 	ldr.w	pc, [pc]	; 1000115c <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer+0x4>
1000115c:	080215a1 	.word	0x080215a1

10001160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>:
10001160:	f85f f000 	ldr.w	pc, [pc]	; 10001164 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer+0x4>
10001164:	08020993 	.word	0x08020993

10001168 <__Motor0_BLDC_SCALAR_MotorStop_veneer>:
10001168:	f85f f000 	ldr.w	pc, [pc]	; 1000116c <__Motor0_BLDC_SCALAR_MotorStop_veneer+0x4>
1000116c:	08022999 	.word	0x08022999

10001170 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>:
10001170:	f85f f000 	ldr.w	pc, [pc]	; 10001174 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer+0x4>
10001174:	08021e8d 	.word	0x08021e8d

10001178 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer>:
10001178:	f85f f000 	ldr.w	pc, [pc]	; 1000117c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer+0x4>
1000117c:	08022699 	.word	0x08022699

10001180 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer>:
10001180:	f85f f000 	ldr.w	pc, [pc]	; 10001184 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer+0x4>
10001184:	08021d99 	.word	0x08021d99

10001188 <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer>:
10001188:	f85f f000 	ldr.w	pc, [pc]	; 1000118c <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer+0x4>
1000118c:	08021505 	.word	0x08021505

10001190 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer>:
10001190:	f85f f000 	ldr.w	pc, [pc]	; 10001194 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer+0x4>
10001194:	08022435 	.word	0x08022435

10001198 <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer>:
10001198:	f85f f000 	ldr.w	pc, [pc]	; 1000119c <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer+0x4>
1000119c:	0802228d 	.word	0x0802228d

100011a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>:
100011a0:	f85f f000 	ldr.w	pc, [pc]	; 100011a4 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer+0x4>
100011a4:	080209b7 	.word	0x080209b7

100011a8 <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer>:
100011a8:	f85f f000 	ldr.w	pc, [pc]	; 100011ac <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer+0x4>
100011ac:	080224e5 	.word	0x080224e5

100011b0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>:
100011b0:	f85f f000 	ldr.w	pc, [pc]	; 100011b4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer+0x4>
100011b4:	08022659 	.word	0x08022659

100011b8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>:
100011b8:	f85f f000 	ldr.w	pc, [pc]	; 100011bc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer+0x4>
100011bc:	08021e0d 	.word	0x08021e0d
