
_PKDS_TSTS06_923M_X45_V1_8.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .app_info     00000400  08020000  0c020000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000b45c  08020400  0c020400  00010400  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000800  10000000  10000000  00040000  2**0
                  ALLOC
  3 .ram_code     000009c0  10000800  0c02b85c  00020800  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 PSRAM_DATA    00000000  100011c0  100011c0  000305f8  2**0
                  CONTENTS
  5 PSRAM_BSS     00000000  100011c0  100011c0  000305f8  2**0
                  CONTENTS
  6 .data         000005f8  20000000  0c02c21c  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000b10  200005f8  0c02c814  000305f8  2**2
                  ALLOC
  8 .no_init      00000014  2000ffc0  2000ffc0  0003ffc0  2**2
                  ALLOC
  9 DSRAM2_DATA   00000000  30000000  30000000  000305f8  2**0
                  CONTENTS
 10 DSRAM2_BSS    00000000  30000000  30000000  000305f8  2**0
                  CONTENTS
 11 .debug_aranges 00001f18  00000000  00000000  000305f8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_info   0003b168  00000000  00000000  00032510  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00007ef6  00000000  00000000  0006d678  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00015633  00000000  00000000  0007556e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_frame  00007678  00000000  00000000  0008aba4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    000119bf  00000000  00000000  0009221c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_loc    0000fda4  00000000  00000000  000a3bdb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_ranges 00001a80  00000000  00000000  000b397f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .build_attributes 00000e3f  00000000  00000000  000b53ff  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020400 <__Vectors>:
 8020400:	00 08 00 10 01 06 02 08 b1 06 02 08 b1 06 02 08     ................
 8020410:	b1 06 02 08 b1 06 02 08 b1 06 02 08 00 00 00 00     ................
	...
 802042c:	b1 06 02 08 b1 06 02 08 00 00 00 00 b1 06 02 08     ................
 802043c:	21 8f 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     !...............
 802044c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802045c:	b1 06 02 08 b1 06 02 08 00 00 00 00 00 00 00 00     ................
 802046c:	00 00 00 00 b1 06 02 08 00 00 00 00 31 20 02 08     ............1 ..
 802047c:	b1 06 02 08 8d ac 02 08 b1 06 02 08 b1 06 02 08     ................
 802048c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802049c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204ac:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204bc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204cc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204dc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204ec:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80204fc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802050c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802051c:	b1 06 02 08 2d ac 02 08 4d ac 02 08 95 30 02 08     ....-...M....0..
 802052c:	75 30 02 08 89 0b 00 10 b1 06 02 08 b1 06 02 08     u0..............
 802053c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802054c:	b1 06 02 08 29 0d 00 10 f5 0d 00 10 b1 06 02 08     ....)...........
 802055c:	b1 06 02 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
 802056c:	00 00 00 00 b9 3e 02 08 dd ac 02 08 05 ae 02 08     .....>..........
 802057c:	dd 3d 02 08 b1 06 02 08 39 3e 02 08 e9 3c 02 08     .=......9>...<..
 802058c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 802059c:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205ac:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205bc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205cc:	b1 06 02 08 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205dc:	00 00 00 00 b1 06 02 08 b1 06 02 08 b1 06 02 08     ................
 80205ec:	b1 06 02 08 b1 06 02 08 00 00 00 00 b1 06 02 08     ................
 80205fc:	00 00 00 00                                         ....

08020600 <Reset_Handler>:
/* Reset Handler */
    .thumb_func
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler:
    ldr sp,=__initial_sp
 8020600:	f8df d08c 	ldr.w	sp, [pc, #140]	; 8020690 <__zero_table_end__>

#ifndef __SKIP_SYSTEM_INIT
    ldr  r0, =SystemInit
 8020604:	4823      	ldr	r0, [pc, #140]	; (8020694 <__zero_table_end__+0x4>)
    blx  r0
 8020606:	4780      	blx	r0
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r4, =__copy_table_start__
 8020608:	4c23      	ldr	r4, [pc, #140]	; (8020698 <__zero_table_end__+0x8>)
	ldr	r5, =__copy_table_end__
 802060a:	4d24      	ldr	r5, [pc, #144]	; (802069c <__zero_table_end__+0xc>)

.L_loop0:
	cmp	r4, r5
 802060c:	42ac      	cmp	r4, r5
	bge	.L_loop0_done
 802060e:	da09      	bge.n	8020624 <Reset_Handler+0x24>
	ldr	r1, [r4]
 8020610:	6821      	ldr	r1, [r4, #0]
	ldr	r2, [r4, #4]
 8020612:	6862      	ldr	r2, [r4, #4]
	ldr	r3, [r4, #8]
 8020614:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
	subs	r3, #4
 8020616:	3b04      	subs	r3, #4
	ittt	ge
 8020618:	bfa2      	ittt	ge
	ldrge	r0, [r1, r3]
 802061a:	58c8      	ldrge	r0, [r1, r3]
	strge	r0, [r2, r3]
 802061c:	50d0      	strge	r0, [r2, r3]
	bge	.L_loop0_0
 802061e:	e7fa      	bge.n	8020616 <Reset_Handler+0x16>

	adds	r4, #12
 8020620:	340c      	adds	r4, #12
	b	.L_loop0
 8020622:	e7f3      	b.n	802060c <Reset_Handler+0xc>
 *    offset 4: Size of this BSS section. Must be multiply of 4
 *
 *  Define __SKIP_BSS_CLEAR to disable zeroing uninitialzed data in startup.
 */    
#ifndef __SKIP_BSS_CLEAR
	ldr	r3, =__zero_table_start__
 8020624:	4b1e      	ldr	r3, [pc, #120]	; (80206a0 <__zero_table_end__+0x10>)
	ldr	r4, =__zero_table_end__
 8020626:	4c1f      	ldr	r4, [pc, #124]	; (80206a4 <__zero_table_end__+0x14>)

.L_loop2:
	cmp	r3, r4
 8020628:	42a3      	cmp	r3, r4
	bge	.L_loop2_done
 802062a:	da08      	bge.n	802063e <Reset_Handler+0x3e>
	ldr	r1, [r3]
 802062c:	6819      	ldr	r1, [r3, #0]
	ldr	r2, [r3, #4]
 802062e:	685a      	ldr	r2, [r3, #4]
	movs	r0, 0
 8020630:	2000      	movs	r0, #0

.L_loop2_0:
	subs	r2, #4
 8020632:	3a04      	subs	r2, #4
	itt	ge
 8020634:	bfa4      	itt	ge
	strge	r0, [r1, r2]
 8020636:	5088      	strge	r0, [r1, r2]
	bge	.L_loop2_0
 8020638:	e7fb      	bge.n	8020632 <Reset_Handler+0x32>

	adds	r3, #8
 802063a:	3308      	adds	r3, #8
	b	.L_loop2
 802063c:	e7f4      	b.n	8020628 <Reset_Handler+0x28>
.L_loop2_done:    
#endif /* __SKIP_BSS_CLEAR */
   
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
 802063e:	481a      	ldr	r0, [pc, #104]	; (80206a8 <__zero_table_end__+0x18>)
    blx  r0
 8020640:	4780      	blx	r0
#endif

    ldr  r0, =main
 8020642:	481a      	ldr	r0, [pc, #104]	; (80206ac <__zero_table_end__+0x1c>)
    blx  r0
 8020644:	4780      	blx	r0
	...

08020648 <__copy_table_start__>:
 8020648:	0c02c21c 	.word	0x0c02c21c
 802064c:	20000000 	.word	0x20000000
 8020650:	000005f8 	.word	0x000005f8
 8020654:	0c02c814 	.word	0x0c02c814
 8020658:	30000000 	.word	0x30000000
 802065c:	00000000 	.word	0x00000000
 8020660:	0c02c21c 	.word	0x0c02c21c
 8020664:	100011c0 	.word	0x100011c0
 8020668:	00000000 	.word	0x00000000
 802066c:	0c02b85c 	.word	0x0c02b85c
 8020670:	10000800 	.word	0x10000800
 8020674:	000009c0 	.word	0x000009c0

08020678 <__copy_table_end__>:
 8020678:	200005f8 	.word	0x200005f8
 802067c:	00000b10 	.word	0x00000b10
 8020680:	30000000 	.word	0x30000000
 8020684:	00000000 	.word	0x00000000
 8020688:	100011c0 	.word	0x100011c0
 802068c:	00000000 	.word	0x00000000

08020690 <__zero_table_end__>:
    ldr sp,=__initial_sp
 8020690:	10000800 	.word	0x10000800
    ldr  r0, =SystemInit
 8020694:	080206b5 	.word	0x080206b5
	ldr	r4, =__copy_table_start__
 8020698:	08020648 	.word	0x08020648
	ldr	r5, =__copy_table_end__
 802069c:	08020678 	.word	0x08020678
	ldr	r3, =__zero_table_start__
 80206a0:	08020678 	.word	0x08020678
	ldr	r4, =__zero_table_end__
 80206a4:	08020690 	.word	0x08020690
    ldr  r0, =__libc_init_array
 80206a8:	0802af31 	.word	0x0802af31
    ldr  r0, =main
 80206ac:	0802ae99 	.word	0x0802ae99

080206b0 <BusFault_Handler>:
	.align	1
    .thumb_func
    .weak Default_Handler
    .type Default_Handler, %function
Default_Handler:
    b .
 80206b0:	e7fe      	b.n	80206b0 <BusFault_Handler>
	...

080206b4 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 80206b4:	b598      	push	{r3, r4, r7, lr}
 80206b6:	af00      	add	r7, sp, #0
  memcpy(g_chipid, CHIPID_LOC, 16);
 80206b8:	4a06      	ldr	r2, [pc, #24]	; (80206d4 <SystemInit+0x20>)
 80206ba:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80206be:	4614      	mov	r4, r2
 80206c0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80206c2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  SystemCoreSetup();
 80206c6:	f009 fa83 	bl	8029bd0 <SystemCoreSetup>
  SystemCoreClockSetup(); 
 80206ca:	f009 faef 	bl	8029cac <SystemCoreClockSetup>
}
 80206ce:	bf00      	nop
 80206d0:	bd98      	pop	{r3, r4, r7, pc}
 80206d2:	bf00      	nop
 80206d4:	2000ffc4 	.word	0x2000ffc4

080206d8 <SystemCoreClockUpdate>:

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 80206d8:	b580      	push	{r7, lr}
 80206da:	b084      	sub	sp, #16
 80206dc:	af00      	add	r7, sp, #0
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80206de:	4b2f      	ldr	r3, [pc, #188]	; (802079c <SystemCoreClockUpdate+0xc4>)
 80206e0:	68db      	ldr	r3, [r3, #12]
 80206e2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80206e6:	2b00      	cmp	r3, #0
 80206e8:	d03e      	beq.n	8020768 <SystemCoreClockUpdate+0x90>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 80206ea:	4b2d      	ldr	r3, [pc, #180]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 80206ec:	68db      	ldr	r3, [r3, #12]
 80206ee:	f003 0301 	and.w	r3, r3, #1
 80206f2:	2b00      	cmp	r3, #0
 80206f4:	d002      	beq.n	80206fc <SystemCoreClockUpdate+0x24>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 80206f6:	4b2b      	ldr	r3, [pc, #172]	; (80207a4 <SystemCoreClockUpdate+0xcc>)
 80206f8:	60fb      	str	r3, [r7, #12]
 80206fa:	e002      	b.n	8020702 <SystemCoreClockUpdate+0x2a>
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 80206fc:	f009 facc 	bl	8029c98 <OSCHP_GetFrequency>
 8020700:	60f8      	str	r0, [r7, #12]
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 8020702:	4b27      	ldr	r3, [pc, #156]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 8020704:	681b      	ldr	r3, [r3, #0]
 8020706:	f003 0304 	and.w	r3, r3, #4
 802070a:	2b00      	cmp	r3, #0
 802070c:	d020      	beq.n	8020750 <SystemCoreClockUpdate+0x78>
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 802070e:	4b24      	ldr	r3, [pc, #144]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 8020710:	689b      	ldr	r3, [r3, #8]
 8020712:	0e1b      	lsrs	r3, r3, #24
 8020714:	f003 030f 	and.w	r3, r3, #15
 8020718:	3301      	adds	r3, #1
 802071a:	607b      	str	r3, [r7, #4]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 802071c:	4b20      	ldr	r3, [pc, #128]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 802071e:	689b      	ldr	r3, [r3, #8]
 8020720:	0a1b      	lsrs	r3, r3, #8
 8020722:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020726:	3301      	adds	r3, #1
 8020728:	603b      	str	r3, [r7, #0]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 802072a:	4b1d      	ldr	r3, [pc, #116]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 802072c:	689b      	ldr	r3, [r3, #8]
 802072e:	0c1b      	lsrs	r3, r3, #16
 8020730:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020734:	3301      	adds	r3, #1
 8020736:	60bb      	str	r3, [r7, #8]

      temp = (temp / (pdiv * kdiv)) * ndiv;
 8020738:	687b      	ldr	r3, [r7, #4]
 802073a:	68ba      	ldr	r2, [r7, #8]
 802073c:	fb02 f303 	mul.w	r3, r2, r3
 8020740:	68fa      	ldr	r2, [r7, #12]
 8020742:	fbb2 f2f3 	udiv	r2, r2, r3
 8020746:	683b      	ldr	r3, [r7, #0]
 8020748:	fb02 f303 	mul.w	r3, r2, r3
 802074c:	60fb      	str	r3, [r7, #12]
 802074e:	e00d      	b.n	802076c <SystemCoreClockUpdate+0x94>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 8020750:	4b13      	ldr	r3, [pc, #76]	; (80207a0 <SystemCoreClockUpdate+0xc8>)
 8020752:	689b      	ldr	r3, [r3, #8]
 8020754:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020758:	3301      	adds	r3, #1
 802075a:	60bb      	str	r3, [r7, #8]
      
      temp = (temp / kdiv);
 802075c:	68fa      	ldr	r2, [r7, #12]
 802075e:	68bb      	ldr	r3, [r7, #8]
 8020760:	fbb2 f3f3 	udiv	r3, r2, r3
 8020764:	60fb      	str	r3, [r7, #12]
 8020766:	e001      	b.n	802076c <SystemCoreClockUpdate+0x94>
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 8020768:	4b0e      	ldr	r3, [pc, #56]	; (80207a4 <SystemCoreClockUpdate+0xcc>)
 802076a:	60fb      	str	r3, [r7, #12]
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 802076c:	4b0b      	ldr	r3, [pc, #44]	; (802079c <SystemCoreClockUpdate+0xc4>)
 802076e:	68db      	ldr	r3, [r3, #12]
 8020770:	b2db      	uxtb	r3, r3
 8020772:	3301      	adds	r3, #1
 8020774:	68fa      	ldr	r2, [r7, #12]
 8020776:	fbb2 f3f3 	udiv	r3, r2, r3
 802077a:	60fb      	str	r3, [r7, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 802077c:	4b07      	ldr	r3, [pc, #28]	; (802079c <SystemCoreClockUpdate+0xc4>)
 802077e:	691b      	ldr	r3, [r3, #16]
 8020780:	f003 0301 	and.w	r3, r3, #1
 8020784:	3301      	adds	r3, #1
 8020786:	68fa      	ldr	r2, [r7, #12]
 8020788:	fbb2 f3f3 	udiv	r3, r2, r3
 802078c:	60fb      	str	r3, [r7, #12]

  SystemCoreClock = temp;
 802078e:	4a06      	ldr	r2, [pc, #24]	; (80207a8 <SystemCoreClockUpdate+0xd0>)
 8020790:	68fb      	ldr	r3, [r7, #12]
 8020792:	6013      	str	r3, [r2, #0]
}
 8020794:	bf00      	nop
 8020796:	3710      	adds	r7, #16
 8020798:	46bd      	mov	sp, r7
 802079a:	bd80      	pop	{r7, pc}
 802079c:	50004600 	.word	0x50004600
 80207a0:	50004710 	.word	0x50004710
 80207a4:	016e3600 	.word	0x016e3600
 80207a8:	2000ffc0 	.word	0x2000ffc0

080207ac <XMC_VADC_GROUP_QueueTriggerConversion>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
 80207ac:	b480      	push	{r7}
 80207ae:	b083      	sub	sp, #12
 80207b0:	af00      	add	r7, sp, #0
 80207b2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_TREV_Pos);
 80207b4:	687b      	ldr	r3, [r7, #4]
 80207b6:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80207ba:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 80207be:	687b      	ldr	r3, [r7, #4]
 80207c0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 80207c4:	bf00      	nop
 80207c6:	370c      	adds	r7, #12
 80207c8:	46bd      	mov	sp, r7
 80207ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207ce:	4770      	bx	lr

080207d0 <XMC_VADC_GROUP_QueueInsertChannel>:
 * \par<b>Related APIs:</b><br>
 *  XMC_VADC_GROUP_QueueRemoveChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
    const XMC_VADC_QUEUE_ENTRY_t entry)
{
 80207d0:	b480      	push	{r7}
 80207d2:	b083      	sub	sp, #12
 80207d4:	af00      	add	r7, sp, #0
 80207d6:	6078      	str	r0, [r7, #4]
 80207d8:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 80207da:	683a      	ldr	r2, [r7, #0]
 80207dc:	687b      	ldr	r3, [r7, #4]
 80207de:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 80207e2:	bf00      	nop
 80207e4:	370c      	adds	r7, #12
 80207e6:	46bd      	mov	sp, r7
 80207e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207ec:	4770      	bx	lr

080207ee <XMC_VADC_GROUP_ResultInit>:
 * XMC_VADC_GROUP_AddResultToFifo()<BR> XMC_VADC_GROUP_EnableResultEvent()<br> XMC_VADC_GROUP_DisableResultEvent()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t res_reg_num,
    const XMC_VADC_RESULT_CONFIG_t *config)
{
 80207ee:	b480      	push	{r7}
 80207f0:	b085      	sub	sp, #20
 80207f2:	af00      	add	r7, sp, #0
 80207f4:	60f8      	str	r0, [r7, #12]
 80207f6:	60b9      	str	r1, [r7, #8]
 80207f8:	607a      	str	r2, [r7, #4]
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 80207fa:	687b      	ldr	r3, [r7, #4]
 80207fc:	6819      	ldr	r1, [r3, #0]
 80207fe:	68fb      	ldr	r3, [r7, #12]
 8020800:	68ba      	ldr	r2, [r7, #8]
 8020802:	32a0      	adds	r2, #160	; 0xa0
 8020804:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

}
 8020808:	bf00      	nop
 802080a:	3714      	adds	r7, #20
 802080c:	46bd      	mov	sp, r7
 802080e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020812:	4770      	bx	lr

08020814 <XMC_VADC_GROUP_GetResult>:
 * \par<b>Related APIs:</b><br>
 * XMC_VADC_GROUP_GetDetailedResult().
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t XMC_VADC_GROUP_GetResult(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t res_reg)
{
 8020814:	b480      	push	{r7}
 8020816:	b083      	sub	sp, #12
 8020818:	af00      	add	r7, sp, #0
 802081a:	6078      	str	r0, [r7, #4]
 802081c:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))

  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 802081e:	687b      	ldr	r3, [r7, #4]
 8020820:	683a      	ldr	r2, [r7, #0]
 8020822:	32c0      	adds	r2, #192	; 0xc0
 8020824:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8020828:	b29b      	uxth	r3, r3
}
 802082a:	4618      	mov	r0, r3
 802082c:	370c      	adds	r7, #12
 802082e:	46bd      	mov	sp, r7
 8020830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020834:	4770      	bx	lr

08020836 <VADC_GetResult>:
 *
 * \par<b>Description:</b><br>
 * Returns the VADC conversion result by reading result register from selected group number.
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t VADC_GetResult(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg)
{
 8020836:	b580      	push	{r7, lr}
 8020838:	b084      	sub	sp, #16
 802083a:	af00      	add	r7, sp, #0
 802083c:	6078      	str	r0, [r7, #4]
 802083e:	6039      	str	r1, [r7, #0]
  XMC_VADC_RESULT_SIZE_t result;
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8020840:	6839      	ldr	r1, [r7, #0]
 8020842:	6878      	ldr	r0, [r7, #4]
 8020844:	f7ff ffe6 	bl	8020814 <XMC_VADC_GROUP_GetResult>
 8020848:	4603      	mov	r3, r0
 802084a:	81fb      	strh	r3, [r7, #14]
  return(result);
 802084c:	89fb      	ldrh	r3, [r7, #14]
}
 802084e:	4618      	mov	r0, r3
 8020850:	3710      	adds	r7, #16
 8020852:	46bd      	mov	sp, r7
 8020854:	bd80      	pop	{r7, pc}
	...

08020858 <Motor0_BLDC_SCALAR_Current_Measurment_Init>:
/*********************************************************************************************************************/
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)


void Motor0_BLDC_SCALAR_Current_Measurment_Init(void)
{
 8020858:	b580      	push	{r7, lr}
 802085a:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_OFFSET_DAC == 1U)
  volatile uint32_t delay;       /* DAC settlement delay counter */
  uint32_t dac_settlement_dealy = BLDC_SCALAR_DAC_SETTLEMENT_DELAY;  /* required DAC settlement delay */
#endif
  /* Initialize VADC channel */
  XMC_VADC_GROUP_ChannelInit(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM,
 802085c:	4a0d      	ldr	r2, [pc, #52]	; (8020894 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x3c>)
 802085e:	2105      	movs	r1, #5
 8020860:	480d      	ldr	r0, [pc, #52]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020862:	f008 f88d 	bl	8028980 <XMC_VADC_GROUP_ChannelInit>
      &Motor0_BLDC_SCALAR_VADC_IDCLink_CH_handle);

  /* Initialize VADC result */
  XMC_VADC_GROUP_ResultInit(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM,
 8020866:	4a0d      	ldr	r2, [pc, #52]	; (802089c <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x44>)
 8020868:	2105      	movs	r1, #5
 802086a:	480b      	ldr	r0, [pc, #44]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802086c:	f7ff ffbf 	bl	80207ee <XMC_VADC_GROUP_ResultInit>
      &Motor0_BLDC_SCALAR_VADC_IDCLink_Res_handle);

  /* Request the LLD to insert the channel in queue.*/
  XMC_VADC_GROUP_QueueInsertChannel(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, Motor0_BLDC_SCALAR_VADC_IDCLink_queue_entry);
 8020870:	4b0b      	ldr	r3, [pc, #44]	; (80208a0 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x48>)
 8020872:	6819      	ldr	r1, [r3, #0]
 8020874:	4808      	ldr	r0, [pc, #32]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020876:	f7ff ffab 	bl	80207d0 <XMC_VADC_GROUP_QueueInsertChannel>
  /*Initialize DAC data register for generating amplifier bias voltage of 1.65V*/
  XMC_DAC_CH_Write((XMC_DAC_t  *)(void *)DAC,DAC_CHANNEL_0,BLDC_SCALAR_DAC_VOLTAGE_COUNT);
#endif
  #if((MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U) && (BLDC_SCALAR_IDC_DIRECT_CURRENT == MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE))
  /* If over current protection is enabled then configure group boundaries accordingly and enable interrupt */
   XMC_VADC_GROUP_SetBoundaries(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_OVER_CURRENT_VADC_BOUND0_T,
 802087a:	f641 7205 	movw	r2, #7941	; 0x1f05
 802087e:	2100      	movs	r1, #0
 8020880:	4805      	ldr	r0, [pc, #20]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020882:	f007 ff85 	bl	8028790 <XMC_VADC_GROUP_SetBoundaries>
       MOTOR0_BLDC_SCALAR_OVER_CURRENT_VADC_BOUND1_T);
  /* Bind the channel event to shared service request line */
  XMC_VADC_GROUP_ChannelSetEventInterruptNode(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM,
 8020886:	2204      	movs	r2, #4
 8020888:	2105      	movs	r1, #5
 802088a:	4803      	ldr	r0, [pc, #12]	; (8020898 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802088c:	f008 f8de 	bl	8028a4c <XMC_VADC_GROUP_ChannelSetEventInterruptNode>
      MOTOR0_BLDC_SCALAR_VADC_CHEVT_SR);
  #endif
}
 8020890:	bf00      	nop
 8020892:	bd80      	pop	{r7, pc}
 8020894:	20000080 	.word	0x20000080
 8020898:	40005000 	.word	0x40005000
 802089c:	200005f8 	.word	0x200005f8
 80208a0:	2000007c 	.word	0x2000007c

080208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>:

#if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U))
#if (MOTOR0_BLDC_SCALAR_ENABLE_AMPLIFIER_OFFSET_CALIBRATION == 1U)

void Motor0_BLDC_SCALAR_AmpBiasVoltCalibration(void)
{
 80208a4:	b580      	push	{r7, lr}
 80208a6:	b086      	sub	sp, #24
 80208a8:	af00      	add	r7, sp, #0
  uint32_t amp_offset = 0U;      /* current amplifier offset value */
 80208aa:	2300      	movs	r3, #0
 80208ac:	617b      	str	r3, [r7, #20]
  uint32_t count;                /* for loop count */
  volatile uint32_t delay;       /* ADC conversion delay counter */
  uint32_t vadc_conversion_time_dealy = BLDC_SCALAR_VADC_CONVERSION_DELAY;  /* ADC conversion delay */
 80208ae:	230f      	movs	r3, #15
 80208b0:	60fb      	str	r3, [r7, #12]
  Motor0_BLDC_SCALAR_CurrentMeasurement.avg_dc_amplifier_offset = (int32_t) temp_ampoffset;
#endif  /* end of MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT */

  /* Direct DC link current */
#if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  amp_offset = 0U;
 80208b2:	2300      	movs	r3, #0
 80208b4:	617b      	str	r3, [r7, #20]
  /* SW trigger for direct DC link current channel and measure the amplifier bias voltage */
  /* Calibration is done with average of 16 measurements */
  for (count = 0U; count < BLDC_SCALAR_ADCCAL_COUNT; count++)
 80208b6:	2300      	movs	r3, #0
 80208b8:	613b      	str	r3, [r7, #16]
 80208ba:	e019      	b.n	80208f0 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x4c>
  {
    XMC_VADC_GROUP_QueueTriggerConversion(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP);
 80208bc:	4813      	ldr	r0, [pc, #76]	; (802090c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x68>)
 80208be:	f7ff ff75 	bl	80207ac <XMC_VADC_GROUP_QueueTriggerConversion>
    /* VADC queue measurements conversion time delay */
    for (delay = 0U; delay < vadc_conversion_time_dealy; delay++)
 80208c2:	2300      	movs	r3, #0
 80208c4:	607b      	str	r3, [r7, #4]
 80208c6:	e002      	b.n	80208ce <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x2a>
 80208c8:	687b      	ldr	r3, [r7, #4]
 80208ca:	3301      	adds	r3, #1
 80208cc:	607b      	str	r3, [r7, #4]
 80208ce:	687b      	ldr	r3, [r7, #4]
 80208d0:	68fa      	ldr	r2, [r7, #12]
 80208d2:	429a      	cmp	r2, r3
 80208d4:	d8f8      	bhi.n	80208c8 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x24>
    {

    }
    temp_ampoffset = (uint32_t) (VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM));
 80208d6:	2105      	movs	r1, #5
 80208d8:	480c      	ldr	r0, [pc, #48]	; (802090c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x68>)
 80208da:	f7ff ffac 	bl	8020836 <VADC_GetResult>
 80208de:	4603      	mov	r3, r0
 80208e0:	60bb      	str	r3, [r7, #8]
    amp_offset = amp_offset + temp_ampoffset;
 80208e2:	697a      	ldr	r2, [r7, #20]
 80208e4:	68bb      	ldr	r3, [r7, #8]
 80208e6:	4413      	add	r3, r2
 80208e8:	617b      	str	r3, [r7, #20]
  for (count = 0U; count < BLDC_SCALAR_ADCCAL_COUNT; count++)
 80208ea:	693b      	ldr	r3, [r7, #16]
 80208ec:	3301      	adds	r3, #1
 80208ee:	613b      	str	r3, [r7, #16]
 80208f0:	693b      	ldr	r3, [r7, #16]
 80208f2:	2b0f      	cmp	r3, #15
 80208f4:	d9e2      	bls.n	80208bc <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x18>
  }
  temp_ampoffset = ((uint32_t)amp_offset >> (uint32_t)BLDC_SCALAR_ADCCAL_SHIFT_4);
 80208f6:	697b      	ldr	r3, [r7, #20]
 80208f8:	091b      	lsrs	r3, r3, #4
 80208fa:	60bb      	str	r3, [r7, #8]
  Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset = (int32_t) temp_ampoffset;
 80208fc:	68bb      	ldr	r3, [r7, #8]
 80208fe:	4a04      	ldr	r2, [pc, #16]	; (8020910 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x6c>)
 8020900:	6013      	str	r3, [r2, #0]
#endif /* end of MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT */


}
 8020902:	bf00      	nop
 8020904:	3718      	adds	r7, #24
 8020906:	46bd      	mov	sp, r7
 8020908:	bd80      	pop	{r7, pc}
 802090a:	bf00      	nop
 802090c:	40005000 	.word	0x40005000
 8020910:	20000124 	.word	0x20000124

08020914 <XMC_SCU_SetCcuTriggerLow>:
 * the timer using this API.<BR>
 * \par<b>Related APIs:</b><BR>
 * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerHigh()\n\n\n
 */
__STATIC_INLINE void XMC_SCU_SetCcuTriggerLow(const uint32_t trigger)
{
 8020914:	b480      	push	{r7}
 8020916:	b083      	sub	sp, #12
 8020918:	af00      	add	r7, sp, #0
 802091a:	6078      	str	r0, [r7, #4]
  SCU_GENERAL->CCUCON &= (uint32_t)~trigger;
 802091c:	4b06      	ldr	r3, [pc, #24]	; (8020938 <XMC_SCU_SetCcuTriggerLow+0x24>)
 802091e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8020920:	687b      	ldr	r3, [r7, #4]
 8020922:	43db      	mvns	r3, r3
 8020924:	4904      	ldr	r1, [pc, #16]	; (8020938 <XMC_SCU_SetCcuTriggerLow+0x24>)
 8020926:	4013      	ands	r3, r2
 8020928:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 802092a:	bf00      	nop
 802092c:	370c      	adds	r7, #12
 802092e:	46bd      	mov	sp, r7
 8020930:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020934:	4770      	bx	lr
 8020936:	bf00      	nop
 8020938:	50004000 	.word	0x50004000

0802093c <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 802093c:	b480      	push	{r7}
 802093e:	b083      	sub	sp, #12
 8020940:	af00      	add	r7, sp, #0
 8020942:	6078      	str	r0, [r7, #4]
 8020944:	460b      	mov	r3, r1
 8020946:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8020948:	78fb      	ldrb	r3, [r7, #3]
 802094a:	2201      	movs	r2, #1
 802094c:	409a      	lsls	r2, r3
 802094e:	687b      	ldr	r3, [r7, #4]
 8020950:	605a      	str	r2, [r3, #4]
}
 8020952:	bf00      	nop
 8020954:	370c      	adds	r7, #12
 8020956:	46bd      	mov	sp, r7
 8020958:	f85d 7b04 	ldr.w	r7, [sp], #4
 802095c:	4770      	bx	lr

0802095e <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 802095e:	b480      	push	{r7}
 8020960:	b083      	sub	sp, #12
 8020962:	af00      	add	r7, sp, #0
 8020964:	6078      	str	r0, [r7, #4]
 8020966:	460b      	mov	r3, r1
 8020968:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802096a:	78fb      	ldrb	r3, [r7, #3]
 802096c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8020970:	409a      	lsls	r2, r3
 8020972:	687b      	ldr	r3, [r7, #4]
 8020974:	605a      	str	r2, [r3, #4]
}
 8020976:	bf00      	nop
 8020978:	370c      	adds	r7, #12
 802097a:	46bd      	mov	sp, r7
 802097c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020980:	4770      	bx	lr

08020982 <Motor0_BLDC_SCALAR_CCU8_PWM_Stop>:
 *
 * \par<b>Description:</b><br>
 * Set CCUCON trigger signal to low to stop all slices.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_PWM_Stop(void)
{
 8020982:	b580      	push	{r7, lr}
 8020984:	af00      	add	r7, sp, #0
  /* Pull CCUCON signal to low */
  XMC_SCU_SetCcuTriggerLow((uint32_t)MOTOR0_BLDC_SCALAR_CCU8_SYNC_START);
 8020986:	f44f 7080 	mov.w	r0, #256	; 0x100
 802098a:	f7ff ffc3 	bl	8020914 <XMC_SCU_SetCcuTriggerLow>
}
 802098e:	bf00      	nop
 8020990:	bd80      	pop	{r7, pc}

08020992 <Motor0_BLDC_SCALAR_CCU8_EnableDeadTime>:
 *
 * \par<b>Description:</b><br>
 * Enable the dead time for compare channel and ST path.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(XMC_CCU8_SLICE_t * phase_ptr, const uint8_t channel_mask)
{
 8020992:	b480      	push	{r7}
 8020994:	b083      	sub	sp, #12
 8020996:	af00      	add	r7, sp, #0
 8020998:	6078      	str	r0, [r7, #4]
 802099a:	460b      	mov	r3, r1
 802099c:	70fb      	strb	r3, [r7, #3]
  phase_ptr->DTC |= (uint32_t)channel_mask;
 802099e:	687b      	ldr	r3, [r7, #4]
 80209a0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80209a2:	78fb      	ldrb	r3, [r7, #3]
 80209a4:	431a      	orrs	r2, r3
 80209a6:	687b      	ldr	r3, [r7, #4]
 80209a8:	64da      	str	r2, [r3, #76]	; 0x4c

}
 80209aa:	bf00      	nop
 80209ac:	370c      	adds	r7, #12
 80209ae:	46bd      	mov	sp, r7
 80209b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209b4:	4770      	bx	lr

080209b6 <Motor0_BLDC_SCALAR_CCU8_DisableDeadTime>:
 *
 * \par<b>Description:</b><br>
 * Disable the dead time for compare channel and ST path.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(XMC_CCU8_SLICE_t * phase_ptr, const uint8_t channel_mask)
{
 80209b6:	b480      	push	{r7}
 80209b8:	b083      	sub	sp, #12
 80209ba:	af00      	add	r7, sp, #0
 80209bc:	6078      	str	r0, [r7, #4]
 80209be:	460b      	mov	r3, r1
 80209c0:	70fb      	strb	r3, [r7, #3]
  phase_ptr->DTC &= ~(uint32_t)channel_mask;
 80209c2:	687b      	ldr	r3, [r7, #4]
 80209c4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80209c6:	78fb      	ldrb	r3, [r7, #3]
 80209c8:	43db      	mvns	r3, r3
 80209ca:	401a      	ands	r2, r3
 80209cc:	687b      	ldr	r3, [r7, #4]
 80209ce:	64da      	str	r2, [r3, #76]	; 0x4c
}
 80209d0:	bf00      	nop
 80209d2:	370c      	adds	r7, #12
 80209d4:	46bd      	mov	sp, r7
 80209d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209da:	4770      	bx	lr

080209dc <Motor0_BLDC_SCALAR_PWM_BC_Init>:
 * -Trap pin and
 * -Inverter pin as per user configurations.
 * Initialize the variable ph_cmpval[1] with (period value + 1), Used for 0% duty cycle
 */
void Motor0_BLDC_SCALAR_PWM_BC_Init(void)
{
 80209dc:	b580      	push	{r7, lr}
 80209de:	af00      	add	r7, sp, #0
  /*initialize PWM timer slices*/
  Motor0_BLDC_SCALAR_CCU8_PWM_Init();
 80209e0:	f000 faac 	bl	8020f3c <Motor0_BLDC_SCALAR_CCU8_PWM_Init>
  /*initialize PWM output pins*/
  Motor0_BLDC_SCALAR_GPIO_PWM_Init();
 80209e4:	f000 fae0 	bl	8020fa8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init>
  /*initialize Trap pin*/
  Motor0_BLDC_SCALAR_GPIO_Trap_Init();
#endif
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*initialize Inverter pin*/
  Motor0_BLDC_SCALAR_GPIO_Inverter_Init();
 80209e8:	f000 fb28 	bl	802103c <Motor0_BLDC_SCALAR_GPIO_Inverter_Init>
#endif

  /*configure variable ph_cmpval[1] with 0% duty*/
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[1] = Motor0_BLDC_SCALAR_CCU8_PWM_Config.period + (uint16_t)1;
 80209ec:	4b03      	ldr	r3, [pc, #12]	; (80209fc <Motor0_BLDC_SCALAR_PWM_BC_Init+0x20>)
 80209ee:	8a5b      	ldrh	r3, [r3, #18]
 80209f0:	3301      	adds	r3, #1
 80209f2:	b29a      	uxth	r2, r3
 80209f4:	4b02      	ldr	r3, [pc, #8]	; (8020a00 <Motor0_BLDC_SCALAR_PWM_BC_Init+0x24>)
 80209f6:	841a      	strh	r2, [r3, #32]

}
 80209f8:	bf00      	nop
 80209fa:	bd80      	pop	{r7, pc}
 80209fc:	20000068 	.word	0x20000068
 8020a00:	200000d0 	.word	0x200000d0

08020a04 <Motor0_BLDC_SCALAR_PWM_BC_Stop>:
/*
 * This function reset the inverter pin output level and
 * stop the CCU8 slices.
 */
void  Motor0_BLDC_SCALAR_PWM_BC_Stop(void)
{
 8020a04:	b580      	push	{r7, lr}
 8020a06:	af00      	add	r7, sp, #0
  /*Disable Inverter*/
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  Motor0_BLDC_SCALAR_PWM_BC_InverterDisable();
 8020a08:	f000 f81c 	bl	8020a44 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>
#endif
  /* Stop pwm timers*/
  Motor0_BLDC_SCALAR_CCU8_PWM_Stop();
 8020a0c:	f7ff ffb9 	bl	8020982 <Motor0_BLDC_SCALAR_CCU8_PWM_Stop>
}
 8020a10:	bf00      	nop
 8020a12:	bd80      	pop	{r7, pc}

08020a14 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable>:
/*
 * This function set the inverter pin output level low and high
 * Based on inverter_pin configuration.
 */
void Motor0_BLDC_SCALAR_PWM_BC_InverterEnable(void)
{
 8020a14:	b580      	push	{r7, lr}
 8020a16:	af00      	add	r7, sp, #0
  if (PWM_BC_IPIN_HIGH == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a18:	4b08      	ldr	r3, [pc, #32]	; (8020a3c <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x28>)
 8020a1a:	7b5b      	ldrb	r3, [r3, #13]
 8020a1c:	2b01      	cmp	r3, #1
 8020a1e:	d103      	bne.n	8020a28 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x14>
  {
    XMC_GPIO_SetOutputHigh(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a20:	210b      	movs	r1, #11
 8020a22:	4807      	ldr	r0, [pc, #28]	; (8020a40 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x2c>)
 8020a24:	f7ff ff8a 	bl	802093c <XMC_GPIO_SetOutputHigh>
  }
  if (PWM_BC_IPIN_LOW == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a28:	4b04      	ldr	r3, [pc, #16]	; (8020a3c <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x28>)
 8020a2a:	7b5b      	ldrb	r3, [r3, #13]
 8020a2c:	2b02      	cmp	r3, #2
 8020a2e:	d103      	bne.n	8020a38 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x24>
  {
    XMC_GPIO_SetOutputLow(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a30:	210b      	movs	r1, #11
 8020a32:	4803      	ldr	r0, [pc, #12]	; (8020a40 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x2c>)
 8020a34:	f7ff ff93 	bl	802095e <XMC_GPIO_SetOutputLow>
  }
}
 8020a38:	bf00      	nop
 8020a3a:	bd80      	pop	{r7, pc}
 8020a3c:	200000d0 	.word	0x200000d0
 8020a40:	48028200 	.word	0x48028200

08020a44 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>:
/*
 * This function set the inverter pin output level low
 * if inverter_pin is high and vice versa.
 */
void Motor0_BLDC_SCALAR_PWM_BC_InverterDisable(void)
{
 8020a44:	b580      	push	{r7, lr}
 8020a46:	af00      	add	r7, sp, #0
  if (PWM_BC_IPIN_HIGH == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a48:	4b08      	ldr	r3, [pc, #32]	; (8020a6c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x28>)
 8020a4a:	7b5b      	ldrb	r3, [r3, #13]
 8020a4c:	2b01      	cmp	r3, #1
 8020a4e:	d103      	bne.n	8020a58 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x14>
  {
    XMC_GPIO_SetOutputLow(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a50:	210b      	movs	r1, #11
 8020a52:	4807      	ldr	r0, [pc, #28]	; (8020a70 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x2c>)
 8020a54:	f7ff ff83 	bl	802095e <XMC_GPIO_SetOutputLow>
  }
  if (PWM_BC_IPIN_LOW == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a58:	4b04      	ldr	r3, [pc, #16]	; (8020a6c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x28>)
 8020a5a:	7b5b      	ldrb	r3, [r3, #13]
 8020a5c:	2b02      	cmp	r3, #2
 8020a5e:	d103      	bne.n	8020a68 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x24>
  {
    XMC_GPIO_SetOutputHigh(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a60:	210b      	movs	r1, #11
 8020a62:	4803      	ldr	r0, [pc, #12]	; (8020a70 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x2c>)
 8020a64:	f7ff ff6a 	bl	802093c <XMC_GPIO_SetOutputHigh>
  }
}
 8020a68:	bf00      	nop
 8020a6a:	bd80      	pop	{r7, pc}
 8020a6c:	200000d0 	.word	0x200000d0
 8020a70:	48028200 	.word	0x48028200

08020a74 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8020a74:	b480      	push	{r7}
 8020a76:	b083      	sub	sp, #12
 8020a78:	af00      	add	r7, sp, #0
 8020a7a:	4603      	mov	r3, r0
 8020a7c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8020a7e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8020a82:	2b00      	cmp	r3, #0
 8020a84:	db0c      	blt.n	8020aa0 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8020a86:	79fb      	ldrb	r3, [r7, #7]
 8020a88:	f003 021f 	and.w	r2, r3, #31
 8020a8c:	4907      	ldr	r1, [pc, #28]	; (8020aac <__NVIC_ClearPendingIRQ+0x38>)
 8020a8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8020a92:	095b      	lsrs	r3, r3, #5
 8020a94:	2001      	movs	r0, #1
 8020a96:	fa00 f202 	lsl.w	r2, r0, r2
 8020a9a:	3360      	adds	r3, #96	; 0x60
 8020a9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8020aa0:	bf00      	nop
 8020aa2:	370c      	adds	r7, #12
 8020aa4:	46bd      	mov	sp, r7
 8020aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020aaa:	4770      	bx	lr
 8020aac:	e000e100 	.word	0xe000e100

08020ab0 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020ab0:	b480      	push	{r7}
 8020ab2:	b083      	sub	sp, #12
 8020ab4:	af00      	add	r7, sp, #0
 8020ab6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8020ab8:	687b      	ldr	r3, [r7, #4]
 8020aba:	2201      	movs	r2, #1
 8020abc:	60da      	str	r2, [r3, #12]
}
 8020abe:	bf00      	nop
 8020ac0:	370c      	adds	r7, #12
 8020ac2:	46bd      	mov	sp, r7
 8020ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ac8:	4770      	bx	lr

08020aca <XMC_CCU4_SLICE_StopTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020aca:	b480      	push	{r7}
 8020acc:	b083      	sub	sp, #12
 8020ace:	af00      	add	r7, sp, #0
 8020ad0:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8020ad2:	687b      	ldr	r3, [r7, #4]
 8020ad4:	2201      	movs	r2, #1
 8020ad6:	611a      	str	r2, [r3, #16]
}
 8020ad8:	bf00      	nop
 8020ada:	370c      	adds	r7, #12
 8020adc:	46bd      	mov	sp, r7
 8020ade:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ae2:	4770      	bx	lr

08020ae4 <XMC_CCU4_SLICE_ClearTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020ae4:	b480      	push	{r7}
 8020ae6:	b083      	sub	sp, #12
 8020ae8:	af00      	add	r7, sp, #0
 8020aea:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8020aec:	687b      	ldr	r3, [r7, #4]
 8020aee:	2202      	movs	r2, #2
 8020af0:	611a      	str	r2, [r3, #16]
}
 8020af2:	bf00      	nop
 8020af4:	370c      	adds	r7, #12
 8020af6:	46bd      	mov	sp, r7
 8020af8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020afc:	4770      	bx	lr

08020afe <XMC_POSIF_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_Stop(),XMC_POSIF_IsRunning() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_Start(XMC_POSIF_t *const peripheral)
{
 8020afe:	b480      	push	{r7}
 8020b00:	b083      	sub	sp, #12
 8020b02:	af00      	add	r7, sp, #0
 8020b04:	6078      	str	r0, [r7, #4]
  peripheral->PRUNS = (uint32_t)POSIF_PRUNS_SRB_Msk;
 8020b06:	687b      	ldr	r3, [r7, #4]
 8020b08:	2201      	movs	r2, #1
 8020b0a:	609a      	str	r2, [r3, #8]
}
 8020b0c:	bf00      	nop
 8020b0e:	370c      	adds	r7, #12
 8020b10:	46bd      	mov	sp, r7
 8020b12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b16:	4770      	bx	lr

08020b18 <XMC_POSIF_Stop>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_Start(),XMC_POSIF_IsRunning() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_Stop(XMC_POSIF_t *const peripheral)
{
 8020b18:	b480      	push	{r7}
 8020b1a:	b083      	sub	sp, #12
 8020b1c:	af00      	add	r7, sp, #0
 8020b1e:	6078      	str	r0, [r7, #4]
  peripheral->PRUNC = (uint32_t)(POSIF_PRUNC_CRB_Msk | POSIF_PRUNC_CSM_Msk);
 8020b20:	687b      	ldr	r3, [r7, #4]
 8020b22:	2203      	movs	r2, #3
 8020b24:	60da      	str	r2, [r3, #12]
}
 8020b26:	bf00      	nop
 8020b28:	370c      	adds	r7, #12
 8020b2a:	46bd      	mov	sp, r7
 8020b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b30:	4770      	bx	lr

08020b32 <XMC_GPIO_GetInput>:
 * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 *
 */

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8020b32:	b480      	push	{r7}
 8020b34:	b083      	sub	sp, #12
 8020b36:	af00      	add	r7, sp, #0
 8020b38:	6078      	str	r0, [r7, #4]
 8020b3a:	460b      	mov	r3, r1
 8020b3c:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
 8020b3e:	687b      	ldr	r3, [r7, #4]
 8020b40:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020b42:	78fb      	ldrb	r3, [r7, #3]
 8020b44:	fa22 f303 	lsr.w	r3, r2, r3
 8020b48:	f003 0301 	and.w	r3, r3, #1
}
 8020b4c:	4618      	mov	r0, r3
 8020b4e:	370c      	adds	r7, #12
 8020b50:	46bd      	mov	sp, r7
 8020b52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b56:	4770      	bx	lr

08020b58 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
 *
 * \par<b>Description:</b><br>
 * Resets variables related to speed calculation.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter(void)
{
 8020b58:	b480      	push	{r7}
 8020b5a:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 8020b5c:	4b12      	ldr	r3, [pc, #72]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b5e:	2200      	movs	r2, #0
 8020b60:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 8020b64:	4b10      	ldr	r3, [pc, #64]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b66:	2200      	movs	r2, #0
 8020b68:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 8020b6a:	4b0f      	ldr	r3, [pc, #60]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b6c:	2200      	movs	r2, #0
 8020b6e:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 8020b70:	4b0d      	ldr	r3, [pc, #52]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b72:	2200      	movs	r2, #0
 8020b74:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 8020b76:	4b0c      	ldr	r3, [pc, #48]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b78:	2200      	movs	r2, #0
 8020b7a:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 8020b7c:	4b0a      	ldr	r3, [pc, #40]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b7e:	2200      	movs	r2, #0
 8020b80:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 8020b82:	4b09      	ldr	r3, [pc, #36]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b84:	2200      	movs	r2, #0
 8020b86:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 8020b88:	4b07      	ldr	r3, [pc, #28]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b8a:	2200      	movs	r2, #0
 8020b8c:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 8020b8e:	4b06      	ldr	r3, [pc, #24]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b90:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020b92:	4a05      	ldr	r2, [pc, #20]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b94:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 8020b96:	4b04      	ldr	r3, [pc, #16]	; (8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b98:	2200      	movs	r2, #0
 8020b9a:	621a      	str	r2, [r3, #32]
}
 8020b9c:	bf00      	nop
 8020b9e:	46bd      	mov	sp, r7
 8020ba0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ba4:	4770      	bx	lr
 8020ba6:	bf00      	nop
 8020ba8:	200000f8 	.word	0x200000f8

08020bac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init>:
/*
 * Initialize POSIF and CCU4 peripherals
 * Initialize hall sensor input pins.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init()
{
 8020bac:	b580      	push	{r7, lr}
 8020bae:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_POSIF_3Hall_Init();
 8020bb0:	f000 fb10 	bl	80211d4 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init>
  Motor0_BLDC_SCALAR_CCU4_3Hall_Init();
 8020bb4:	f000 f8c4 	bl	8020d40 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init>
  Motor0_BLDC_SCALAR_GPIO_3Hall_Init();
 8020bb8:	f000 fa28 	bl	802100c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init>
}
 8020bbc:	bf00      	nop
 8020bbe:	bd80      	pop	{r7, pc}

08020bc0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>:

/*
 * Start POSIF and CCU4 timer.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start()
{
 8020bc0:	b580      	push	{r7, lr}
 8020bc2:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8020bc4:	f7ff ffc8 	bl	8020b58 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>

  /*
   * Set RUN bit of the POSIF and
   * CC41 First slice will be started on external start trigger
   */
  XMC_POSIF_Start(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8020bc8:	4806      	ldr	r0, [pc, #24]	; (8020be4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x24>)
 8020bca:	f7ff ff98 	bl	8020afe <XMC_POSIF_Start>

  XMC_CCU4_SLICE_ClearTimer(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE);
 8020bce:	4806      	ldr	r0, [pc, #24]	; (8020be8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x28>)
 8020bd0:	f7ff ff88 	bl	8020ae4 <XMC_CCU4_SLICE_ClearTimer>
  XMC_CCU4_SLICE_ClearTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bd4:	4805      	ldr	r0, [pc, #20]	; (8020bec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x2c>)
 8020bd6:	f7ff ff85 	bl	8020ae4 <XMC_CCU4_SLICE_ClearTimer>

  XMC_CCU4_SLICE_StartTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bda:	4804      	ldr	r0, [pc, #16]	; (8020bec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x2c>)
 8020bdc:	f7ff ff68 	bl	8020ab0 <XMC_CCU4_SLICE_StartTimer>

}
 8020be0:	bf00      	nop
 8020be2:	bd80      	pop	{r7, pc}
 8020be4:	40028000 	.word	0x40028000
 8020be8:	4000c100 	.word	0x4000c100
 8020bec:	4000c200 	.word	0x4000c200

08020bf0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop>:

/*
 * Stop POSIF and CCU4 timer.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop()
{
 8020bf0:	b580      	push	{r7, lr}
 8020bf2:	af00      	add	r7, sp, #0
  XMC_POSIF_Stop(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8020bf4:	4806      	ldr	r0, [pc, #24]	; (8020c10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x20>)
 8020bf6:	f7ff ff8f 	bl	8020b18 <XMC_POSIF_Stop>
  NVIC_ClearPendingIRQ(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE);
 8020bfa:	2044      	movs	r0, #68	; 0x44
 8020bfc:	f7ff ff3a 	bl	8020a74 <__NVIC_ClearPendingIRQ>
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE);
 8020c00:	4804      	ldr	r0, [pc, #16]	; (8020c14 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x24>)
 8020c02:	f7ff ff62 	bl	8020aca <XMC_CCU4_SLICE_StopTimer>
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020c06:	4804      	ldr	r0, [pc, #16]	; (8020c18 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x28>)
 8020c08:	f7ff ff5f 	bl	8020aca <XMC_CCU4_SLICE_StopTimer>
}
 8020c0c:	bf00      	nop
 8020c0e:	bd80      	pop	{r7, pc}
 8020c10:	40028000 	.word	0x40028000
 8020c14:	4000c100 	.word	0x4000c100
 8020c18:	4000c200 	.word	0x4000c200

08020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>:
 * This function will return the current state of the POSIF input pins to
 * which hall sensors are connected. This information is required before
 * starting the motor to know the start position of the motor.
 */
uint32_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition(void)
{
 8020c1c:	b580      	push	{r7, lr}
 8020c1e:	b084      	sub	sp, #16
 8020c20:	af00      	add	r7, sp, #0
  uint32_t hallposition;
  uint32_t hall[3] = { 0U };
 8020c22:	463b      	mov	r3, r7
 8020c24:	2200      	movs	r2, #0
 8020c26:	601a      	str	r2, [r3, #0]
 8020c28:	605a      	str	r2, [r3, #4]
 8020c2a:	609a      	str	r2, [r3, #8]

  /*Read the input pins.*/
  hall[0] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_1);
 8020c2c:	2103      	movs	r1, #3
 8020c2e:	4811      	ldr	r0, [pc, #68]	; (8020c74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c30:	f7ff ff7f 	bl	8020b32 <XMC_GPIO_GetInput>
 8020c34:	4603      	mov	r3, r0
 8020c36:	603b      	str	r3, [r7, #0]
  hall[1] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_2);
 8020c38:	2102      	movs	r1, #2
 8020c3a:	480e      	ldr	r0, [pc, #56]	; (8020c74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c3c:	f7ff ff79 	bl	8020b32 <XMC_GPIO_GetInput>
 8020c40:	4603      	mov	r3, r0
 8020c42:	607b      	str	r3, [r7, #4]
  hallposition = (uint32_t)(hall[0] | ((uint32_t) hall[1] << 1U));
 8020c44:	683a      	ldr	r2, [r7, #0]
 8020c46:	687b      	ldr	r3, [r7, #4]
 8020c48:	005b      	lsls	r3, r3, #1
 8020c4a:	4313      	orrs	r3, r2
 8020c4c:	60fb      	str	r3, [r7, #12]

  hall[2] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_3);
 8020c4e:	2101      	movs	r1, #1
 8020c50:	4808      	ldr	r0, [pc, #32]	; (8020c74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c52:	f7ff ff6e 	bl	8020b32 <XMC_GPIO_GetInput>
 8020c56:	4603      	mov	r3, r0
 8020c58:	60bb      	str	r3, [r7, #8]
  hallposition |= ((uint32_t)(hall[2] << BLDC_SCALAR_SPEED_POS_HALL_2_POS));
 8020c5a:	68bb      	ldr	r3, [r7, #8]
 8020c5c:	009b      	lsls	r3, r3, #2
 8020c5e:	68fa      	ldr	r2, [r7, #12]
 8020c60:	4313      	orrs	r3, r2
 8020c62:	60fb      	str	r3, [r7, #12]


  return ((uint32_t)(hallposition & BLDC_SCALAR_SPEED_POS_HALL_MASK));
 8020c64:	68fb      	ldr	r3, [r7, #12]
 8020c66:	f003 0307 	and.w	r3, r3, #7
}
 8020c6a:	4618      	mov	r0, r3
 8020c6c:	3710      	adds	r7, #16
 8020c6e:	46bd      	mov	sp, r7
 8020c70:	bd80      	pop	{r7, pc}
 8020c72:	bf00      	nop
 8020c74:	48028100 	.word	0x48028100

08020c78 <XMC_CCU4_EnableClock>:
{
 8020c78:	b480      	push	{r7}
 8020c7a:	b083      	sub	sp, #12
 8020c7c:	af00      	add	r7, sp, #0
 8020c7e:	6078      	str	r0, [r7, #4]
 8020c80:	460b      	mov	r3, r1
 8020c82:	70fb      	strb	r3, [r7, #3]
  module->GIDLC = ((uint32_t) 1) << slice_number;
 8020c84:	78fb      	ldrb	r3, [r7, #3]
 8020c86:	2201      	movs	r2, #1
 8020c88:	409a      	lsls	r2, r3
 8020c8a:	687b      	ldr	r3, [r7, #4]
 8020c8c:	60da      	str	r2, [r3, #12]
}
 8020c8e:	bf00      	nop
 8020c90:	370c      	adds	r7, #12
 8020c92:	46bd      	mov	sp, r7
 8020c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020c98:	4770      	bx	lr

08020c9a <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
 8020c9a:	b480      	push	{r7}
 8020c9c:	b083      	sub	sp, #12
 8020c9e:	af00      	add	r7, sp, #0
 8020ca0:	6078      	str	r0, [r7, #4]
 8020ca2:	460b      	mov	r3, r1
 8020ca4:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8020ca6:	887a      	ldrh	r2, [r7, #2]
 8020ca8:	687b      	ldr	r3, [r7, #4]
 8020caa:	635a      	str	r2, [r3, #52]	; 0x34
}
 8020cac:	bf00      	nop
 8020cae:	370c      	adds	r7, #12
 8020cb0:	46bd      	mov	sp, r7
 8020cb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cb6:	4770      	bx	lr

08020cb8 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
 8020cb8:	b480      	push	{r7}
 8020cba:	b083      	sub	sp, #12
 8020cbc:	af00      	add	r7, sp, #0
 8020cbe:	6078      	str	r0, [r7, #4]
 8020cc0:	460b      	mov	r3, r1
 8020cc2:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8020cc4:	887a      	ldrh	r2, [r7, #2]
 8020cc6:	687b      	ldr	r3, [r7, #4]
 8020cc8:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8020cca:	bf00      	nop
 8020ccc:	370c      	adds	r7, #12
 8020cce:	46bd      	mov	sp, r7
 8020cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cd4:	4770      	bx	lr

08020cd6 <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 8020cd6:	b480      	push	{r7}
 8020cd8:	b083      	sub	sp, #12
 8020cda:	af00      	add	r7, sp, #0
 8020cdc:	6078      	str	r0, [r7, #4]
 8020cde:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8020ce0:	687b      	ldr	r3, [r7, #4]
 8020ce2:	683a      	ldr	r2, [r7, #0]
 8020ce4:	611a      	str	r2, [r3, #16]
}
 8020ce6:	bf00      	nop
 8020ce8:	370c      	adds	r7, #12
 8020cea:	46bd      	mov	sp, r7
 8020cec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cf0:	4770      	bx	lr

08020cf2 <XMC_CCU4_SLICE_EnableFloatingPrescaler>:
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue()<BR> XMC_CCU4_SLICE_DisableFloatingPrescaler()<BR>
 *  XMC_CCU4_SLICE_SetPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableFloatingPrescaler(XMC_CCU4_SLICE_t *const slice)
{
 8020cf2:	b480      	push	{r7}
 8020cf4:	b083      	sub	sp, #12
 8020cf6:	af00      	add	r7, sp, #0
 8020cf8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableFloatingPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TC |= (uint32_t) CCU4_CC4_TC_FPE_Msk;
 8020cfa:	687b      	ldr	r3, [r7, #4]
 8020cfc:	695b      	ldr	r3, [r3, #20]
 8020cfe:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8020d02:	687b      	ldr	r3, [r7, #4]
 8020d04:	615a      	str	r2, [r3, #20]
}
 8020d06:	bf00      	nop
 8020d08:	370c      	adds	r7, #12
 8020d0a:	46bd      	mov	sp, r7
 8020d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020d10:	4770      	bx	lr

08020d12 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 8020d12:	b480      	push	{r7}
 8020d14:	b083      	sub	sp, #12
 8020d16:	af00      	add	r7, sp, #0
 8020d18:	6078      	str	r0, [r7, #4]
 8020d1a:	460b      	mov	r3, r1
 8020d1c:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8020d1e:	687b      	ldr	r3, [r7, #4]
 8020d20:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8020d24:	78fb      	ldrb	r3, [r7, #3]
 8020d26:	2101      	movs	r1, #1
 8020d28:	fa01 f303 	lsl.w	r3, r1, r3
 8020d2c:	431a      	orrs	r2, r3
 8020d2e:	687b      	ldr	r3, [r7, #4]
 8020d30:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8020d34:	bf00      	nop
 8020d36:	370c      	adds	r7, #12
 8020d38:	46bd      	mov	sp, r7
 8020d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020d3e:	4770      	bx	lr

08020d40 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init>:
 *
 * \par<b>Description:</b><br>
 * CCU4 slices initialization for 3 hall feedback configuration.
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_Init(void)
{
 8020d40:	b580      	push	{r7, lr}
 8020d42:	af00      	add	r7, sp, #0
  /* Enable CCU4 module */
  XMC_CCU4_Init(MOTOR0_BLDC_SCALAR_CCU4_MODULE,XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
 8020d44:	2100      	movs	r1, #0
 8020d46:	4804      	ldr	r0, [pc, #16]	; (8020d58 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init+0x18>)
 8020d48:	f006 fcb4 	bl	80276b4 <XMC_CCU4_Init>
#if (MOTOR0_BLDC_SCALAR_ENABLE_FAST_SYNCH_CCU4 == 1U)
  /* Enable CCU4 Fast Sync module */
  XMC_CCU4_Init(MOTOR0_BLDC_SCALAR_CCU4_MODULE_FAST_SYNC,XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
#endif
  /*Phase delay slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init();
 8020d4c:	f000 f806 	bl	8020d5c <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init>
  /*Speed capture slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init();
 8020d50:	f000 f83e 	bl	8020dd0 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init>
#if(1U == MOTOR0_BLDC_SCALAR_ENABLE_FAST_SYNCH_CCU4)
  /*Fast sync slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_MCMSync_Init();
#endif
}
 8020d54:	bf00      	nop
 8020d56:	bd80      	pop	{r7, pc}
 8020d58:	4000c000 	.word	0x4000c000

08020d5c <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init>:
 *
 * \par<b>Description:</b><br>
 * Initializes phase delay CCU4 slice for MCM pattern update .
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init(void)
{
 8020d5c:	b580      	push	{r7, lr}
 8020d5e:	af00      	add	r7, sp, #0
  /*Phase delay slice compare timer initiation*/
  XMC_CCU4_SLICE_CompareInit(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d60:	4916      	ldr	r1, [pc, #88]	; (8020dbc <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x60>)
 8020d62:	4817      	ldr	r0, [pc, #92]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d64:	f006 fce1 	bl	802772a <XMC_CCU4_SLICE_CompareInit>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_PhaseDelay_CompareConfig);

  /*Phase delay blanking time configuration*/
  XMC_CCU4_SLICE_SetTimerCompareMatch(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d68:	4b16      	ldr	r3, [pc, #88]	; (8020dc4 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x68>)
 8020d6a:	881b      	ldrh	r3, [r3, #0]
 8020d6c:	4619      	mov	r1, r3
 8020d6e:	4814      	ldr	r0, [pc, #80]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d70:	f7ff ffa2 	bl	8020cb8 <XMC_CCU4_SLICE_SetTimerCompareMatch>
      Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Config.blanking_time);

  /*Phase delay slice period value(phase delay timing) configuration*/
  XMC_CCU4_SLICE_SetTimerPeriodMatch(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d74:	4b13      	ldr	r3, [pc, #76]	; (8020dc4 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x68>)
 8020d76:	885b      	ldrh	r3, [r3, #2]
 8020d78:	4619      	mov	r1, r3
 8020d7a:	4811      	ldr	r0, [pc, #68]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d7c:	f7ff ff8d 	bl	8020c9a <XMC_CCU4_SLICE_SetTimerPeriodMatch>
      Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Config.phase_delay);

  /*enable shadow transfer for compare and period value*/
  XMC_CCU4_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU4_MODULE,MOTOR0_BLDC_SCALAR_CCU4_DELAY_SHADOWTRANSFER);
 8020d80:	2101      	movs	r1, #1
 8020d82:	4811      	ldr	r0, [pc, #68]	; (8020dc8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x6c>)
 8020d84:	f7ff ffa7 	bl	8020cd6 <XMC_CCU4_EnableShadowTransfer>

  /*Configure Event 0 signal for phase delay slice*/
  XMC_CCU4_SLICE_ConfigureEvent(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020d88:	4a10      	ldr	r2, [pc, #64]	; (8020dcc <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x70>)
 8020d8a:	2101      	movs	r1, #1
 8020d8c:	480c      	ldr	r0, [pc, #48]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d8e:	f006 feff 	bl	8027b90 <XMC_CCU4_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_PhaseDelay_StartEventconfig);

  /*Configure Event 0 signal as start signal for phase delay slice*/
  XMC_CCU4_SLICE_StartConfig(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020d92:	2201      	movs	r2, #1
 8020d94:	2101      	movs	r1, #1
 8020d96:	480a      	ldr	r0, [pc, #40]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d98:	f006 fd25 	bl	80277e6 <XMC_CCU4_SLICE_StartConfig>
      XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR);

  /* Clear IDLE mode.*/
  XMC_CCU4_EnableClock(MOTOR0_BLDC_SCALAR_CCU4_MODULE, MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE_NUM);
 8020d9c:	2100      	movs	r1, #0
 8020d9e:	480a      	ldr	r0, [pc, #40]	; (8020dc8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x6c>)
 8020da0:	f7ff ff6a 	bl	8020c78 <XMC_CCU4_EnableClock>

  /*bind interrupt node for period match of phase delay*/
  XMC_CCU4_SLICE_SetInterruptNode(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8020da4:	2200      	movs	r2, #0
 8020da6:	2100      	movs	r1, #0
 8020da8:	4805      	ldr	r0, [pc, #20]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020daa:	f006 ff8b 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_CCU4_PHASE_DELAY_PM_SR);

  /*Enable period match interrupt of slice 0*/
  XMC_CCU4_SLICE_EnableEvent(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8020dae:	2100      	movs	r1, #0
 8020db0:	4803      	ldr	r0, [pc, #12]	; (8020dc0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020db2:	f7ff ffae 	bl	8020d12 <XMC_CCU4_SLICE_EnableEvent>
}
 8020db6:	bf00      	nop
 8020db8:	bd80      	pop	{r7, pc}
 8020dba:	bf00      	nop
 8020dbc:	20000040 	.word	0x20000040
 8020dc0:	4000c100 	.word	0x4000c100
 8020dc4:	2000004c 	.word	0x2000004c
 8020dc8:	4000c000 	.word	0x4000c000
 8020dcc:	20000048 	.word	0x20000048

08020dd0 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init>:
 *
 * \par<b>Description:</b><br>
 * Initializes capture CCU4 slice for motor speed calculations from HALL events.
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init(void)
{
 8020dd0:	b580      	push	{r7, lr}
 8020dd2:	af00      	add	r7, sp, #0
  /*capture slice initiation*/
  XMC_CCU4_SLICE_CaptureInit(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, &Motor0_BLDC_SCALAR_CCU4_3HALL_CaptureConfig);
 8020dd4:	490c      	ldr	r1, [pc, #48]	; (8020e08 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x38>)
 8020dd6:	480d      	ldr	r0, [pc, #52]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020dd8:	f006 fcde 	bl	8027798 <XMC_CCU4_SLICE_CaptureInit>

  /*Set prescaler value*/
  XMC_CCU4_SLICE_SetPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, MOTOR0_BLDC_SCALAR_CCU4_PRESCALER);
 8020ddc:	2105      	movs	r1, #5
 8020dde:	480b      	ldr	r0, [pc, #44]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020de0:	f006 ff52 	bl	8027c88 <XMC_CCU4_SLICE_SetPrescaler>
  /* enable floating prescaler for capture slice*/
  XMC_CCU4_SLICE_EnableFloatingPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020de4:	4809      	ldr	r0, [pc, #36]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020de6:	f7ff ff84 	bl	8020cf2 <XMC_CCU4_SLICE_EnableFloatingPrescaler>

  /* configure Event 0 signal as capture event*/
  XMC_CCU4_SLICE_ConfigureEvent(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020dea:	4a09      	ldr	r2, [pc, #36]	; (8020e10 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x40>)
 8020dec:	2101      	movs	r1, #1
 8020dee:	4807      	ldr	r0, [pc, #28]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020df0:	f006 fece 	bl	8027b90 <XMC_CCU4_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_Capture_ExtCaptureEventConfig);

  /* configure channel for speed capture*/
  XMC_CCU4_SLICE_Capture1Config(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, XMC_CCU4_SLICE_EVENT_0);
 8020df4:	2101      	movs	r1, #1
 8020df6:	4805      	ldr	r0, [pc, #20]	; (8020e0c <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020df8:	f006 fde0 	bl	80279bc <XMC_CCU4_SLICE_Capture1Config>

  /* Clear IDLE mode.*/
  XMC_CCU4_EnableClock(MOTOR0_BLDC_SCALAR_CCU4_MODULE, MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE_NUM);
 8020dfc:	2101      	movs	r1, #1
 8020dfe:	4805      	ldr	r0, [pc, #20]	; (8020e14 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x44>)
 8020e00:	f7ff ff3a 	bl	8020c78 <XMC_CCU4_EnableClock>

}
 8020e04:	bf00      	nop
 8020e06:	bd80      	pop	{r7, pc}
 8020e08:	20000050 	.word	0x20000050
 8020e0c:	4000c200 	.word	0x4000c200
 8020e10:	20000058 	.word	0x20000058
 8020e14:	4000c000 	.word	0x4000c000

08020e18 <XMC_CCU8_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU8_DisableClock()<BR>  XMC_CCU8_EnableMultipleClocks()<BR>  XMC_CCU8_StartPrescaler()<BR>  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
 8020e18:	b480      	push	{r7}
 8020e1a:	b083      	sub	sp, #12
 8020e1c:	af00      	add	r7, sp, #0
 8020e1e:	6078      	str	r0, [r7, #4]
 8020e20:	460b      	mov	r3, r1
 8020e22:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1 << slice_number);
 8020e24:	78fb      	ldrb	r3, [r7, #3]
 8020e26:	2201      	movs	r2, #1
 8020e28:	409a      	lsls	r2, r3
 8020e2a:	687b      	ldr	r3, [r7, #4]
 8020e2c:	60da      	str	r2, [r3, #12]
}
 8020e2e:	bf00      	nop
 8020e30:	370c      	adds	r7, #12
 8020e32:	46bd      	mov	sp, r7
 8020e34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e38:	4770      	bx	lr

08020e3a <XMC_CCU8_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 8020e3a:	b480      	push	{r7}
 8020e3c:	b083      	sub	sp, #12
 8020e3e:	af00      	add	r7, sp, #0
 8020e40:	6078      	str	r0, [r7, #4]
 8020e42:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8020e44:	687b      	ldr	r3, [r7, #4]
 8020e46:	683a      	ldr	r2, [r7, #0]
 8020e48:	611a      	str	r2, [r3, #16]
}
 8020e4a:	bf00      	nop
 8020e4c:	370c      	adds	r7, #12
 8020e4e:	46bd      	mov	sp, r7
 8020e50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e54:	4770      	bx	lr

08020e56 <XMC_CCU8_SLICE_EnableEvent>:
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU8_SLICE_SetInterruptNode()<BR>  XMC_CCU8_SLICE_EnableMultipleEvents()<BR>  XMC_CCU8_SLICE_DisableEvent()<BR>
 *  XMC_CCU8_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
 8020e56:	b480      	push	{r7}
 8020e58:	b083      	sub	sp, #12
 8020e5a:	af00      	add	r7, sp, #0
 8020e5c:	6078      	str	r0, [r7, #4]
 8020e5e:	460b      	mov	r3, r1
 8020e60:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8020e62:	687b      	ldr	r3, [r7, #4]
 8020e64:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8020e68:	78fb      	ldrb	r3, [r7, #3]
 8020e6a:	2101      	movs	r1, #1
 8020e6c:	fa01 f303 	lsl.w	r3, r1, r3
 8020e70:	431a      	orrs	r2, r3
 8020e72:	687b      	ldr	r3, [r7, #4]
 8020e74:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8020e78:	bf00      	nop
 8020e7a:	370c      	adds	r7, #12
 8020e7c:	46bd      	mov	sp, r7
 8020e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e82:	4770      	bx	lr

08020e84 <BLDC_SCALAR_CCU8_Event_Init>:
 *
 * \par<b>Description:</b><br>
 * Initialize CCU8 slice for enable event and SR binding to the node.
 */
static void BLDC_SCALAR_CCU8_Event_Init(XMC_CCU8_SLICE_t* slice_ptr, XMC_CCU8_SLICE_IRQ_ID_t irq_id, XMC_CCU8_SLICE_SR_ID_t sr_id)
{
 8020e84:	b580      	push	{r7, lr}
 8020e86:	b082      	sub	sp, #8
 8020e88:	af00      	add	r7, sp, #0
 8020e8a:	6078      	str	r0, [r7, #4]
 8020e8c:	460b      	mov	r3, r1
 8020e8e:	70fb      	strb	r3, [r7, #3]
 8020e90:	4613      	mov	r3, r2
 8020e92:	70bb      	strb	r3, [r7, #2]
  /*Bind slice event SR(service request) to interrupt node*/
  XMC_CCU8_SLICE_SetInterruptNode(slice_ptr,irq_id,sr_id);
 8020e94:	78ba      	ldrb	r2, [r7, #2]
 8020e96:	78fb      	ldrb	r3, [r7, #3]
 8020e98:	4619      	mov	r1, r3
 8020e9a:	6878      	ldr	r0, [r7, #4]
 8020e9c:	f007 f900 	bl	80280a0 <XMC_CCU8_SLICE_SetInterruptNode>

  /* Enable slice event */
  XMC_CCU8_SLICE_EnableEvent(slice_ptr,irq_id);
 8020ea0:	78fb      	ldrb	r3, [r7, #3]
 8020ea2:	4619      	mov	r1, r3
 8020ea4:	6878      	ldr	r0, [r7, #4]
 8020ea6:	f7ff ffd6 	bl	8020e56 <XMC_CCU8_SLICE_EnableEvent>
}
 8020eaa:	bf00      	nop
 8020eac:	3708      	adds	r7, #8
 8020eae:	46bd      	mov	sp, r7
 8020eb0:	bd80      	pop	{r7, pc}
	...

08020eb4 <Motor0_BLDC_SCALAR_CCU8_Slice_Init>:
 * Initialize CCU8 slice.
 */


static void Motor0_BLDC_SCALAR_CCU8_Slice_Init(uint32_t count)
{
 8020eb4:	b580      	push	{r7, lr}
 8020eb6:	b084      	sub	sp, #16
 8020eb8:	af00      	add	r7, sp, #0
 8020eba:	6078      	str	r0, [r7, #4]
  XMC_CCU8_SLICE_t* const slice_ptr = Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count];
 8020ebc:	4a19      	ldr	r2, [pc, #100]	; (8020f24 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ebe:	687b      	ldr	r3, [r7, #4]
 8020ec0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8020ec4:	60fb      	str	r3, [r7, #12]

  /*Enable clock for slice*/
  XMC_CCU8_EnableClock(MOTOR0_BLDC_SCALAR_CCU8_MODULE,Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_number[count]);
 8020ec6:	4a17      	ldr	r2, [pc, #92]	; (8020f24 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ec8:	687b      	ldr	r3, [r7, #4]
 8020eca:	4413      	add	r3, r2
 8020ecc:	330c      	adds	r3, #12
 8020ece:	781b      	ldrb	r3, [r3, #0]
 8020ed0:	4619      	mov	r1, r3
 8020ed2:	4815      	ldr	r0, [pc, #84]	; (8020f28 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x74>)
 8020ed4:	f7ff ffa0 	bl	8020e18 <XMC_CCU8_EnableClock>

  /* CCU8 Slice configuration */
  XMC_CCU8_SLICE_CompareInit(slice_ptr, &Motor0_BLDC_SCALAR_CCU8CompareConf);
 8020ed8:	4914      	ldr	r1, [pc, #80]	; (8020f2c <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x78>)
 8020eda:	68f8      	ldr	r0, [r7, #12]
 8020edc:	f006 ffbb 	bl	8027e56 <XMC_CCU8_SLICE_CompareInit>
  /* Update CCU8 slice period registers */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(slice_ptr,Motor0_BLDC_SCALAR_CCU8_PWM_Config.period);
 8020ee0:	4b10      	ldr	r3, [pc, #64]	; (8020f24 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ee2:	8a5b      	ldrh	r3, [r3, #18]
 8020ee4:	4619      	mov	r1, r3
 8020ee6:	68f8      	ldr	r0, [r7, #12]
 8020ee8:	f007 f8b3 	bl	8028052 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /*
   * Mapped slice to EVENT-0 (sync start event)
   * External Start Function triggered by Event-0 rising edge
   * Clears the timer and sets run bit.
   */
  XMC_CCU8_SLICE_ConfigureEvent(slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_0,
 8020eec:	4a10      	ldr	r2, [pc, #64]	; (8020f30 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x7c>)
 8020eee:	2101      	movs	r1, #1
 8020ef0:	68f8      	ldr	r0, [r7, #12]
 8020ef2:	f007 f844 	bl	8027f7e <XMC_CCU8_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU8ExtStartEventConf);
  XMC_CCU8_SLICE_StartConfig(slice_ptr,XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
 8020ef6:	2201      	movs	r2, #1
 8020ef8:	2101      	movs	r1, #1
 8020efa:	68f8      	ldr	r0, [r7, #12]
 8020efc:	f006 ffe5 	bl	8027eca <XMC_CCU8_SLICE_StartConfig>
  /*
   * Mapped slice to EVENT-1 (sync stop event)
   * External Stop Function triggered by Event-1 falling edge
   * Clears the timer and run bit
   */
  XMC_CCU8_SLICE_ConfigureEvent(slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_1,
 8020f00:	4a0c      	ldr	r2, [pc, #48]	; (8020f34 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x80>)
 8020f02:	2102      	movs	r1, #2
 8020f04:	68f8      	ldr	r0, [r7, #12]
 8020f06:	f007 f83a 	bl	8027f7e <XMC_CCU8_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU8ExtStopEventConf);
  XMC_CCU8_SLICE_StopConfig(slice_ptr,XMC_CCU8_SLICE_EVENT_1,  XMC_CCU8_SLICE_END_MODE_TIMER_STOP_CLEAR);
 8020f0a:	2202      	movs	r2, #2
 8020f0c:	2102      	movs	r1, #2
 8020f0e:	68f8      	ldr	r0, [r7, #12]
 8020f10:	f007 f809 	bl	8027f26 <XMC_CCU8_SLICE_StopConfig>
      &Motor0_BLDC_SCALAR_CCU8TrapEventConf);
  slice_ptr->CMC |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
  #endif

  /* Configure the dead time value */
  XMC_CCU8_SLICE_DeadTimeInit(slice_ptr,&Motor0_BLDC_SCALAR_CCU8_DeadTimeConfig);
 8020f14:	4908      	ldr	r1, [pc, #32]	; (8020f38 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x84>)
 8020f16:	68f8      	ldr	r0, [r7, #12]
 8020f18:	f007 f92c 	bl	8028174 <XMC_CCU8_SLICE_DeadTimeInit>
}
 8020f1c:	bf00      	nop
 8020f1e:	3710      	adds	r7, #16
 8020f20:	46bd      	mov	sp, r7
 8020f22:	bd80      	pop	{r7, pc}
 8020f24:	20000068 	.word	0x20000068
 8020f28:	40020000 	.word	0x40020000
 8020f2c:	0802afe0 	.word	0x0802afe0
 8020f30:	0802afd8 	.word	0x0802afd8
 8020f34:	0802afdc 	.word	0x0802afdc
 8020f38:	2000005c 	.word	0x2000005c

08020f3c <Motor0_BLDC_SCALAR_CCU8_PWM_Init>:
 *
 * \par<b>Description:</b><br>
 * Initialize CCU8 slice for all 3 phases PWM generation.
 */
void Motor0_BLDC_SCALAR_CCU8_PWM_Init(void)
{
 8020f3c:	b580      	push	{r7, lr}
 8020f3e:	b082      	sub	sp, #8
 8020f40:	af00      	add	r7, sp, #0
  /*
   * Enable CCU8 module
   * Start the pre-scaler
   * Configure multi channel Shadow transfer request
   */
  XMC_CCU8_Init(MOTOR0_BLDC_SCALAR_CCU8_MODULE,XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
 8020f42:	2100      	movs	r1, #0
 8020f44:	4816      	ldr	r0, [pc, #88]	; (8020fa0 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x64>)
 8020f46:	f006 ff67 	bl	8027e18 <XMC_CCU8_Init>

  /*Initialize CCU8 Phase-U, V and W Slice*/
  for (count = 0U; count < CCU8_MAXPHASE_COUNT;count++)
 8020f4a:	2300      	movs	r3, #0
 8020f4c:	607b      	str	r3, [r7, #4]
 8020f4e:	e005      	b.n	8020f5c <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x20>
  {
    Motor0_BLDC_SCALAR_CCU8_Slice_Init(count);
 8020f50:	6878      	ldr	r0, [r7, #4]
 8020f52:	f7ff ffaf 	bl	8020eb4 <Motor0_BLDC_SCALAR_CCU8_Slice_Init>
  for (count = 0U; count < CCU8_MAXPHASE_COUNT;count++)
 8020f56:	687b      	ldr	r3, [r7, #4]
 8020f58:	3301      	adds	r3, #1
 8020f5a:	607b      	str	r3, [r7, #4]
 8020f5c:	687b      	ldr	r3, [r7, #4]
 8020f5e:	2b02      	cmp	r3, #2
 8020f60:	d9f6      	bls.n	8020f50 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x14>

  /*
   * Initialize Phase-U one match event and Bind Phase-U one match event SR(service request)
   * to interrupt node for control loop execution.
   */
  BLDC_SCALAR_CCU8_Event_Init(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[0U],
 8020f62:	4b10      	ldr	r3, [pc, #64]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f64:	681b      	ldr	r3, [r3, #0]
 8020f66:	2200      	movs	r2, #0
 8020f68:	2101      	movs	r1, #1
 8020f6a:	4618      	mov	r0, r3
 8020f6c:	f7ff ff8a 	bl	8020e84 <BLDC_SCALAR_CCU8_Event_Init>
  /*
   * DC link current measurement trigger
   * phase-V compare match 2 down event
   */
  /* Initialize phase-V compare match 2 down event and bind SR to interrupt node for ADC trigger */
  BLDC_SCALAR_CCU8_Event_Init(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[1U],
 8020f70:	4b0c      	ldr	r3, [pc, #48]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f72:	685b      	ldr	r3, [r3, #4]
 8020f74:	2202      	movs	r2, #2
 8020f76:	2105      	movs	r1, #5
 8020f78:	4618      	mov	r0, r3
 8020f7a:	f7ff ff83 	bl	8020e84 <BLDC_SCALAR_CCU8_Event_Init>
   (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2, (XMC_CCU8_SLICE_SR_ID_t)MOTOR0_BLDC_SCALAR_CCU8_COMPMATCH_SR);

  XMC_CCU8_SLICE_SetTimerCompareMatch(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[1U], XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 8020f7e:	4b09      	ldr	r3, [pc, #36]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f80:	685b      	ldr	r3, [r3, #4]
 8020f82:	4a08      	ldr	r2, [pc, #32]	; (8020fa4 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f84:	8a12      	ldrh	r2, [r2, #16]
 8020f86:	2101      	movs	r1, #1
 8020f88:	4618      	mov	r0, r3
 8020f8a:	f007 f871 	bl	8028070 <XMC_CCU8_SLICE_SetTimerCompareMatch>
      Motor0_BLDC_SCALAR_CCU8_PWM_Config.current_trigger);

  /*Enable CCU8 shadow transfer*/
  XMC_CCU8_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU8_MODULE, MOTOR0_BLDC_SCALAR_CCU8_SHADOW_TRANSFER);
 8020f8e:	f240 1111 	movw	r1, #273	; 0x111
 8020f92:	4803      	ldr	r0, [pc, #12]	; (8020fa0 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x64>)
 8020f94:	f7ff ff51 	bl	8020e3a <XMC_CCU8_EnableShadowTransfer>
}
 8020f98:	bf00      	nop
 8020f9a:	3708      	adds	r7, #8
 8020f9c:	46bd      	mov	sp, r7
 8020f9e:	bd80      	pop	{r7, pc}
 8020fa0:	40020000 	.word	0x40020000
 8020fa4:	20000068 	.word	0x20000068

08020fa8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as output pins of CCU8 slices for PWM generation.
 */
void Motor0_BLDC_SCALAR_GPIO_PWM_Init(void)
{
 8020fa8:	b580      	push	{r7, lr}
 8020faa:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_U_HS, &Motor0_BLDC_SCALAR_GPIO_PhU_High_Config);
 8020fac:	4a0f      	ldr	r2, [pc, #60]	; (8020fec <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x44>)
 8020fae:	2109      	movs	r1, #9
 8020fb0:	480f      	ldr	r0, [pc, #60]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fb2:	f005 fa85 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_U_LS, &Motor0_BLDC_SCALAR_GPIO_PhU_Low_Config);
 8020fb6:	4a0f      	ldr	r2, [pc, #60]	; (8020ff4 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x4c>)
 8020fb8:	210e      	movs	r1, #14
 8020fba:	480f      	ldr	r0, [pc, #60]	; (8020ff8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x50>)
 8020fbc:	f005 fa80 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_V_HS, &Motor0_BLDC_SCALAR_GPIO_PhV_High_Config);
 8020fc0:	4a0e      	ldr	r2, [pc, #56]	; (8020ffc <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x54>)
 8020fc2:	210a      	movs	r1, #10
 8020fc4:	480a      	ldr	r0, [pc, #40]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fc6:	f005 fa7b 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_V_LS, &Motor0_BLDC_SCALAR_GPIO_PhV_Low_Config);
 8020fca:	4a0d      	ldr	r2, [pc, #52]	; (8021000 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x58>)
 8020fcc:	210f      	movs	r1, #15
 8020fce:	480a      	ldr	r0, [pc, #40]	; (8020ff8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x50>)
 8020fd0:	f005 fa76 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_W_HS, &Motor0_BLDC_SCALAR_GPIO_PhW_High_Config);
 8020fd4:	4a0b      	ldr	r2, [pc, #44]	; (8021004 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x5c>)
 8020fd6:	210b      	movs	r1, #11
 8020fd8:	4805      	ldr	r0, [pc, #20]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fda:	f005 fa71 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_W_LS, &Motor0_BLDC_SCALAR_GPIO_PhW_Low_Config);
 8020fde:	4a0a      	ldr	r2, [pc, #40]	; (8021008 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x60>)
 8020fe0:	2108      	movs	r1, #8
 8020fe2:	4803      	ldr	r0, [pc, #12]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fe4:	f005 fa6c 	bl	80264c0 <XMC_GPIO_Init>
}
 8020fe8:	bf00      	nop
 8020fea:	bd80      	pop	{r7, pc}
 8020fec:	0802aff0 	.word	0x0802aff0
 8020ff0:	48028500 	.word	0x48028500
 8020ff4:	0802affc 	.word	0x0802affc
 8020ff8:	48028200 	.word	0x48028200
 8020ffc:	0802b008 	.word	0x0802b008
 8021000:	0802b014 	.word	0x0802b014
 8021004:	0802b020 	.word	0x0802b020
 8021008:	0802b02c 	.word	0x0802b02c

0802100c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as input pins to the POSIF to sense HALL feedback.
 */
void Motor0_BLDC_SCALAR_GPIO_3Hall_Init(void)
{
 802100c:	b580      	push	{r7, lr}
 802100e:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_1, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 8021010:	4a08      	ldr	r2, [pc, #32]	; (8021034 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 8021012:	2103      	movs	r1, #3
 8021014:	4808      	ldr	r0, [pc, #32]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8021016:	f005 fa53 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_2, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 802101a:	4a06      	ldr	r2, [pc, #24]	; (8021034 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 802101c:	2102      	movs	r1, #2
 802101e:	4806      	ldr	r0, [pc, #24]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8021020:	f005 fa4e 	bl	80264c0 <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_3, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 8021024:	4a03      	ldr	r2, [pc, #12]	; (8021034 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 8021026:	2101      	movs	r1, #1
 8021028:	4803      	ldr	r0, [pc, #12]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 802102a:	f005 fa49 	bl	80264c0 <XMC_GPIO_Init>
}
 802102e:	bf00      	nop
 8021030:	bd80      	pop	{r7, pc}
 8021032:	bf00      	nop
 8021034:	0802b038 	.word	0x0802b038
 8021038:	48028100 	.word	0x48028100

0802103c <Motor0_BLDC_SCALAR_GPIO_Inverter_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as general purpose output pin for inverter enable.
 */
void Motor0_BLDC_SCALAR_GPIO_Inverter_Init(void)
{
 802103c:	b580      	push	{r7, lr}
 802103e:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE, &Motor0_BLDC_SCALAR_GPIO_Inverter_Config);
 8021040:	4a03      	ldr	r2, [pc, #12]	; (8021050 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init+0x14>)
 8021042:	210b      	movs	r1, #11
 8021044:	4803      	ldr	r0, [pc, #12]	; (8021054 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init+0x18>)
 8021046:	f005 fa3b 	bl	80264c0 <XMC_GPIO_Init>
}
 802104a:	bf00      	nop
 802104c:	bd80      	pop	{r7, pc}
 802104e:	bf00      	nop
 8021050:	0802b044 	.word	0x0802b044
 8021054:	48028200 	.word	0x48028200

08021058 <__NVIC_GetPriorityGrouping>:
{
 8021058:	b480      	push	{r7}
 802105a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802105c:	4b04      	ldr	r3, [pc, #16]	; (8021070 <__NVIC_GetPriorityGrouping+0x18>)
 802105e:	68db      	ldr	r3, [r3, #12]
 8021060:	0a1b      	lsrs	r3, r3, #8
 8021062:	f003 0307 	and.w	r3, r3, #7
}
 8021066:	4618      	mov	r0, r3
 8021068:	46bd      	mov	sp, r7
 802106a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802106e:	4770      	bx	lr
 8021070:	e000ed00 	.word	0xe000ed00

08021074 <__NVIC_EnableIRQ>:
{
 8021074:	b480      	push	{r7}
 8021076:	b083      	sub	sp, #12
 8021078:	af00      	add	r7, sp, #0
 802107a:	4603      	mov	r3, r0
 802107c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802107e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8021082:	2b00      	cmp	r3, #0
 8021084:	db0b      	blt.n	802109e <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8021086:	79fb      	ldrb	r3, [r7, #7]
 8021088:	f003 021f 	and.w	r2, r3, #31
 802108c:	4907      	ldr	r1, [pc, #28]	; (80210ac <__NVIC_EnableIRQ+0x38>)
 802108e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8021092:	095b      	lsrs	r3, r3, #5
 8021094:	2001      	movs	r0, #1
 8021096:	fa00 f202 	lsl.w	r2, r0, r2
 802109a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 802109e:	bf00      	nop
 80210a0:	370c      	adds	r7, #12
 80210a2:	46bd      	mov	sp, r7
 80210a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210a8:	4770      	bx	lr
 80210aa:	bf00      	nop
 80210ac:	e000e100 	.word	0xe000e100

080210b0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80210b0:	b480      	push	{r7}
 80210b2:	b083      	sub	sp, #12
 80210b4:	af00      	add	r7, sp, #0
 80210b6:	4603      	mov	r3, r0
 80210b8:	6039      	str	r1, [r7, #0]
 80210ba:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80210bc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80210c0:	2b00      	cmp	r3, #0
 80210c2:	db0a      	blt.n	80210da <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80210c4:	683b      	ldr	r3, [r7, #0]
 80210c6:	b2da      	uxtb	r2, r3
 80210c8:	490c      	ldr	r1, [pc, #48]	; (80210fc <__NVIC_SetPriority+0x4c>)
 80210ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80210ce:	0092      	lsls	r2, r2, #2
 80210d0:	b2d2      	uxtb	r2, r2
 80210d2:	440b      	add	r3, r1
 80210d4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80210d8:	e00a      	b.n	80210f0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80210da:	683b      	ldr	r3, [r7, #0]
 80210dc:	b2da      	uxtb	r2, r3
 80210de:	4908      	ldr	r1, [pc, #32]	; (8021100 <__NVIC_SetPriority+0x50>)
 80210e0:	79fb      	ldrb	r3, [r7, #7]
 80210e2:	f003 030f 	and.w	r3, r3, #15
 80210e6:	3b04      	subs	r3, #4
 80210e8:	0092      	lsls	r2, r2, #2
 80210ea:	b2d2      	uxtb	r2, r2
 80210ec:	440b      	add	r3, r1
 80210ee:	761a      	strb	r2, [r3, #24]
}
 80210f0:	bf00      	nop
 80210f2:	370c      	adds	r7, #12
 80210f4:	46bd      	mov	sp, r7
 80210f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210fa:	4770      	bx	lr
 80210fc:	e000e100 	.word	0xe000e100
 8021100:	e000ed00 	.word	0xe000ed00

08021104 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8021104:	b480      	push	{r7}
 8021106:	b089      	sub	sp, #36	; 0x24
 8021108:	af00      	add	r7, sp, #0
 802110a:	60f8      	str	r0, [r7, #12]
 802110c:	60b9      	str	r1, [r7, #8]
 802110e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8021110:	68fb      	ldr	r3, [r7, #12]
 8021112:	f003 0307 	and.w	r3, r3, #7
 8021116:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8021118:	69fb      	ldr	r3, [r7, #28]
 802111a:	f1c3 0307 	rsb	r3, r3, #7
 802111e:	2b06      	cmp	r3, #6
 8021120:	bf28      	it	cs
 8021122:	2306      	movcs	r3, #6
 8021124:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8021126:	69fb      	ldr	r3, [r7, #28]
 8021128:	3306      	adds	r3, #6
 802112a:	2b06      	cmp	r3, #6
 802112c:	d902      	bls.n	8021134 <NVIC_EncodePriority+0x30>
 802112e:	69fb      	ldr	r3, [r7, #28]
 8021130:	3b01      	subs	r3, #1
 8021132:	e000      	b.n	8021136 <NVIC_EncodePriority+0x32>
 8021134:	2300      	movs	r3, #0
 8021136:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8021138:	f04f 32ff 	mov.w	r2, #4294967295
 802113c:	69bb      	ldr	r3, [r7, #24]
 802113e:	fa02 f303 	lsl.w	r3, r2, r3
 8021142:	43da      	mvns	r2, r3
 8021144:	68bb      	ldr	r3, [r7, #8]
 8021146:	401a      	ands	r2, r3
 8021148:	697b      	ldr	r3, [r7, #20]
 802114a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802114c:	f04f 31ff 	mov.w	r1, #4294967295
 8021150:	697b      	ldr	r3, [r7, #20]
 8021152:	fa01 f303 	lsl.w	r3, r1, r3
 8021156:	43d9      	mvns	r1, r3
 8021158:	687b      	ldr	r3, [r7, #4]
 802115a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802115c:	4313      	orrs	r3, r2
         );
}
 802115e:	4618      	mov	r0, r3
 8021160:	3724      	adds	r7, #36	; 0x24
 8021162:	46bd      	mov	sp, r7
 8021164:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021168:	4770      	bx	lr

0802116a <BLDC_SCALAR_NVIC_NodeInit>:
 *
 * \par<b>Description:</b><br>
 * Sets the priority of an interrupt and enables the interrupt.
 */
void BLDC_SCALAR_NVIC_NodeInit(IRQn_Type node_id, uint32_t priority, uint32_t sub_priority)
{
 802116a:	b580      	push	{r7, lr}
 802116c:	b084      	sub	sp, #16
 802116e:	af00      	add	r7, sp, #0
 8021170:	4603      	mov	r3, r0
 8021172:	60b9      	str	r1, [r7, #8]
 8021174:	607a      	str	r2, [r7, #4]
 8021176:	73fb      	strb	r3, [r7, #15]
  /*set the priority and sub priority*/
  #if (UC_FAMILY == XMC1)
  NVIC_SetPriority(node_id,priority);
  #else
  NVIC_SetPriority(node_id, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), priority,sub_priority));
 8021178:	f7ff ff6e 	bl	8021058 <__NVIC_GetPriorityGrouping>
 802117c:	4603      	mov	r3, r0
 802117e:	687a      	ldr	r2, [r7, #4]
 8021180:	68b9      	ldr	r1, [r7, #8]
 8021182:	4618      	mov	r0, r3
 8021184:	f7ff ffbe 	bl	8021104 <NVIC_EncodePriority>
 8021188:	4602      	mov	r2, r0
 802118a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802118e:	4611      	mov	r1, r2
 8021190:	4618      	mov	r0, r3
 8021192:	f7ff ff8d 	bl	80210b0 <__NVIC_SetPriority>
  #endif
  /*Enable the IRQ*/
  NVIC_EnableIRQ(node_id);
 8021196:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802119a:	4618      	mov	r0, r3
 802119c:	f7ff ff6a 	bl	8021074 <__NVIC_EnableIRQ>
}
 80211a0:	bf00      	nop
 80211a2:	3710      	adds	r7, #16
 80211a4:	46bd      	mov	sp, r7
 80211a6:	bd80      	pop	{r7, pc}

080211a8 <XMC_POSIF_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_DisableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_EnableEvent(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 80211a8:	b480      	push	{r7}
 80211aa:	b083      	sub	sp, #12
 80211ac:	af00      	add	r7, sp, #0
 80211ae:	6078      	str	r0, [r7, #4]
 80211b0:	460b      	mov	r3, r1
 80211b2:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE |= (uint32_t)1 << (uint8_t)event;
 80211b4:	687b      	ldr	r3, [r7, #4]
 80211b6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80211b8:	78fb      	ldrb	r3, [r7, #3]
 80211ba:	2101      	movs	r1, #1
 80211bc:	fa01 f303 	lsl.w	r3, r1, r3
 80211c0:	431a      	orrs	r2, r3
 80211c2:	687b      	ldr	r3, [r7, #4]
 80211c4:	675a      	str	r2, [r3, #116]	; 0x74
}
 80211c6:	bf00      	nop
 80211c8:	370c      	adds	r7, #12
 80211ca:	46bd      	mov	sp, r7
 80211cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80211d0:	4770      	bx	lr
	...

080211d4 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init>:
 * - Correct hall event,
 * - Wrong hall event,
 * - Multi-channel pattern shadow transfer event
 */
void Motor0_BLDC_SCALAR_POSIF_3Hall_Init()
{
 80211d4:	b580      	push	{r7, lr}
 80211d6:	af00      	add	r7, sp, #0
  XMC_POSIF_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_GLOBAL_Config);
 80211d8:	4914      	ldr	r1, [pc, #80]	; (802122c <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x58>)
 80211da:	4815      	ldr	r0, [pc, #84]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211dc:	f007 f886 	bl	80282ec <XMC_POSIF_Init>
  XMC_POSIF_MCM_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_MCM_Config);
 80211e0:	4914      	ldr	r1, [pc, #80]	; (8021234 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x60>)
 80211e2:	4813      	ldr	r0, [pc, #76]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211e4:	f007 f8b4 	bl	8028350 <XMC_POSIF_MCM_Init>
  XMC_POSIF_HSC_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_HALL_Config);
 80211e8:	4913      	ldr	r1, [pc, #76]	; (8021238 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x64>)
 80211ea:	4811      	ldr	r0, [pc, #68]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211ec:	f007 f891 	bl	8028312 <XMC_POSIF_HSC_Init>

  /*Bind interrupt node*/
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_CHE,
 80211f0:	2200      	movs	r2, #0
 80211f2:	2100      	movs	r1, #0
 80211f4:	480e      	ldr	r0, [pc, #56]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211f6:	f007 f8ca 	bl	802838e <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_HALL_SR);
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_WHE,
 80211fa:	2200      	movs	r2, #0
 80211fc:	2101      	movs	r1, #1
 80211fe:	480c      	ldr	r0, [pc, #48]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021200:	f007 f8c5 	bl	802838e <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_HALL_SR);
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_MCP_SHADOW_TRANSFER,
 8021204:	2201      	movs	r2, #1
 8021206:	2104      	movs	r1, #4
 8021208:	4809      	ldr	r0, [pc, #36]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 802120a:	f007 f8c0 	bl	802838e <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_MCP_SR);

  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_CHE);
 802120e:	2100      	movs	r1, #0
 8021210:	4807      	ldr	r0, [pc, #28]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021212:	f7ff ffc9 	bl	80211a8 <XMC_POSIF_EnableEvent>
  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_WHE);
 8021216:	2101      	movs	r1, #1
 8021218:	4805      	ldr	r0, [pc, #20]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 802121a:	f7ff ffc5 	bl	80211a8 <XMC_POSIF_EnableEvent>
  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_MCP_SHADOW_TRANSFER);
 802121e:	2104      	movs	r1, #4
 8021220:	4803      	ldr	r0, [pc, #12]	; (8021230 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021222:	f7ff ffc1 	bl	80211a8 <XMC_POSIF_EnableEvent>
}
 8021226:	bf00      	nop
 8021228:	bd80      	pop	{r7, pc}
 802122a:	bf00      	nop
 802122c:	0802b054 	.word	0x0802b054
 8021230:	40028000 	.word	0x40028000
 8021234:	0802b058 	.word	0x0802b058
 8021238:	0802b050 	.word	0x0802b050

0802123c <XMC_VADC_GROUP_QueueSetGatingMode>:
{
 802123c:	b480      	push	{r7}
 802123e:	b083      	sub	sp, #12
 8021240:	af00      	add	r7, sp, #0
 8021242:	6078      	str	r0, [r7, #4]
 8021244:	460b      	mov	r3, r1
 8021246:	70fb      	strb	r3, [r7, #3]
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8021248:	687b      	ldr	r3, [r7, #4]
 802124a:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 802124e:	f023 0203 	bic.w	r2, r3, #3
 8021252:	687b      	ldr	r3, [r7, #4]
 8021254:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 8021258:	687b      	ldr	r3, [r7, #4]
 802125a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 802125e:	78fb      	ldrb	r3, [r7, #3]
 8021260:	431a      	orrs	r2, r3
 8021262:	687b      	ldr	r3, [r7, #4]
 8021264:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 8021268:	bf00      	nop
 802126a:	370c      	adds	r7, #12
 802126c:	46bd      	mov	sp, r7
 802126e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021272:	4770      	bx	lr

08021274 <XMC_VADC_GROUP_QueueFlushEntries>:
{
 8021274:	b480      	push	{r7}
 8021276:	b083      	sub	sp, #12
 8021278:	af00      	add	r7, sp, #0
 802127a:	6078      	str	r0, [r7, #4]
  group_ptr->QMR0 |= (uint32_t)VADC_G_QMR0_FLUSH_Msk;
 802127c:	687b      	ldr	r3, [r7, #4]
 802127e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021282:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 8021286:	687b      	ldr	r3, [r7, #4]
 8021288:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  while ( !((group_ptr->QSR0) & (uint32_t)VADC_G_QSR0_EMPTY_Msk))
 802128c:	bf00      	nop
 802128e:	687b      	ldr	r3, [r7, #4]
 8021290:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8021294:	f003 0320 	and.w	r3, r3, #32
 8021298:	2b00      	cmp	r3, #0
 802129a:	d0f8      	beq.n	802128e <XMC_VADC_GROUP_QueueFlushEntries+0x1a>
}
 802129c:	bf00      	nop
 802129e:	bf00      	nop
 80212a0:	370c      	adds	r7, #12
 80212a2:	46bd      	mov	sp, r7
 80212a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80212a8:	4770      	bx	lr
	...

080212ac <Motor0_BLDC_SCALAR_VADC_Init>:
 * \par<b>Description:</b><br>
 * Initializes VADC peripheral and power on the required VADC Group and Queues.
 * Only required converters will be turned on to optimize power consumption.
 */
void Motor0_BLDC_SCALAR_VADC_Init(void)
{
 80212ac:	b580      	push	{r7, lr}
 80212ae:	af00      	add	r7, sp, #0
  /* Initialize an instance of VADC Global hardware */
  XMC_VADC_GLOBAL_Init(VADC, &Motor0_BLDC_SCALAR_VADC_GLOBAL_config);
 80212b0:	490e      	ldr	r1, [pc, #56]	; (80212ec <Motor0_BLDC_SCALAR_VADC_Init+0x40>)
 80212b2:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 80212b6:	f007 f915 	bl	80284e4 <XMC_VADC_GLOBAL_Init>
  /* Switch on the converter of the Group[2]*/
  XMC_VADC_GROUP_SetPowerMode(VADC_G2,XMC_VADC_GROUP_POWERMODE_NORMAL);
  #endif
  #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U)
  /* Switch on the converter of the Group[3]*/
  XMC_VADC_GROUP_SetPowerMode(VADC_G3,XMC_VADC_GROUP_POWERMODE_NORMAL);
 80212ba:	2103      	movs	r1, #3
 80212bc:	480c      	ldr	r0, [pc, #48]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212be:	f007 fa4b 	bl	8028758 <XMC_VADC_GROUP_SetPowerMode>
  XMC_VADC_GROUP_QueueFlushEntries(VADC_G2);
  #endif  /* end of #if(VADC_ENABLE_GROUP_QUEUE_2 == 1U) */

  #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U)
  /* Program the input classes for Group[3] */
  XMC_VADC_GROUP_InputClassInit(VADC_G3,Motor0_BLDC_SCALAR_VADC_GROUP_class0,XMC_VADC_GROUP_CONV_STD,0U);
 80212c2:	490c      	ldr	r1, [pc, #48]	; (80212f4 <Motor0_BLDC_SCALAR_VADC_Init+0x48>)
 80212c4:	2300      	movs	r3, #0
 80212c6:	2200      	movs	r2, #0
 80212c8:	6809      	ldr	r1, [r1, #0]
 80212ca:	4809      	ldr	r0, [pc, #36]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212cc:	f007 f9e7 	bl	802869e <XMC_VADC_GROUP_InputClassInit>
  /* Initialize the Queue3 */
  XMC_VADC_GROUP_QueueInit(VADC_G3,&Motor0_BLDC_SCALAR_VADC_QUEUE_3_cfg);
 80212d0:	4909      	ldr	r1, [pc, #36]	; (80212f8 <Motor0_BLDC_SCALAR_VADC_Init+0x4c>)
 80212d2:	4807      	ldr	r0, [pc, #28]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212d4:	f007 fb06 	bl	80288e4 <XMC_VADC_GROUP_QueueInit>
  /* Configure the gating mode for queue3 */
  XMC_VADC_GROUP_QueueSetGatingMode(VADC_G3, (XMC_VADC_GATEMODE_t)MOTOR0_BLDC_SCALAR_VADC_QUEUE_3_GATING);
 80212d8:	2101      	movs	r1, #1
 80212da:	4805      	ldr	r0, [pc, #20]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212dc:	f7ff ffae 	bl	802123c <XMC_VADC_GROUP_QueueSetGatingMode>
  /* Flush any entries that are currently in the queue3 buffer */
  XMC_VADC_GROUP_QueueFlushEntries(VADC_G3);
 80212e0:	4803      	ldr	r0, [pc, #12]	; (80212f0 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212e2:	f7ff ffc7 	bl	8021274 <XMC_VADC_GROUP_QueueFlushEntries>
  #endif  /* end of #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U) */
}
 80212e6:	bf00      	nop
 80212e8:	bd80      	pop	{r7, pc}
 80212ea:	bf00      	nop
 80212ec:	0802b05c 	.word	0x0802b05c
 80212f0:	40005000 	.word	0x40005000
 80212f4:	0802b074 	.word	0x0802b074
 80212f8:	0802b078 	.word	0x0802b078

080212fc <XMC_CCU8_EnableShadowTransfer>:
{
 80212fc:	b480      	push	{r7}
 80212fe:	b083      	sub	sp, #12
 8021300:	af00      	add	r7, sp, #0
 8021302:	6078      	str	r0, [r7, #4]
 8021304:	6039      	str	r1, [r7, #0]
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8021306:	687b      	ldr	r3, [r7, #4]
 8021308:	683a      	ldr	r2, [r7, #0]
 802130a:	611a      	str	r2, [r3, #16]
}
 802130c:	bf00      	nop
 802130e:	370c      	adds	r7, #12
 8021310:	46bd      	mov	sp, r7
 8021312:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021316:	4770      	bx	lr

08021318 <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021318:	b480      	push	{r7}
 802131a:	b083      	sub	sp, #12
 802131c:	af00      	add	r7, sp, #0
 802131e:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021320:	687b      	ldr	r3, [r7, #4]
 8021322:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021326:	b2db      	uxtb	r3, r3
 8021328:	115b      	asrs	r3, r3, #5
 802132a:	b2db      	uxtb	r3, r3
 802132c:	f003 0307 	and.w	r3, r3, #7
 8021330:	b2db      	uxtb	r3, r3
}
 8021332:	4618      	mov	r0, r3
 8021334:	370c      	adds	r7, #12
 8021336:	46bd      	mov	sp, r7
 8021338:	f85d 7b04 	ldr.w	r7, [sp], #4
 802133c:	4770      	bx	lr

0802133e <XMC_VADC_GROUP_GetResult>:
{
 802133e:	b480      	push	{r7}
 8021340:	b083      	sub	sp, #12
 8021342:	af00      	add	r7, sp, #0
 8021344:	6078      	str	r0, [r7, #4]
 8021346:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8021348:	687b      	ldr	r3, [r7, #4]
 802134a:	683a      	ldr	r2, [r7, #0]
 802134c:	32c0      	adds	r2, #192	; 0xc0
 802134e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8021352:	b29b      	uxth	r3, r3
}
 8021354:	4618      	mov	r0, r3
 8021356:	370c      	adds	r7, #12
 8021358:	46bd      	mov	sp, r7
 802135a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802135e:	4770      	bx	lr

08021360 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate>:
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate
(
  uint16_t dutycycle
)
{
 8021360:	b580      	push	{r7, lr}
 8021362:	b084      	sub	sp, #16
 8021364:	af00      	add	r7, sp, #0
 8021366:	4603      	mov	r3, r0
 8021368:	80fb      	strh	r3, [r7, #6]
  uint16_t duty = (dutycycle * Motor0_BLDC_SCALAR_PWM_BC.amplitude_scale) >> BLDC_SCALAR_PWM_BC_SHIFT_14;
 802136a:	88fb      	ldrh	r3, [r7, #6]
 802136c:	4a1a      	ldr	r2, [pc, #104]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802136e:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 8021370:	fb02 f303 	mul.w	r3, r2, r3
 8021374:	139b      	asrs	r3, r3, #14
 8021376:	81fb      	strh	r3, [r7, #14]
  /* Update compare value for inverted switch*/
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[3] = Motor0_BLDC_SCALAR_PWM_BC.ccu8_handle_ptr->period - duty;
 8021378:	4b17      	ldr	r3, [pc, #92]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802137a:	681b      	ldr	r3, [r3, #0]
 802137c:	8a5a      	ldrh	r2, [r3, #18]
 802137e:	89fb      	ldrh	r3, [r7, #14]
 8021380:	1ad3      	subs	r3, r2, r3
 8021382:	b29a      	uxth	r2, r3
 8021384:	4b14      	ldr	r3, [pc, #80]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021386:	849a      	strh	r2, [r3, #36]	; 0x24
  /* Update compare value for direct switch */
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[2] = duty;
 8021388:	4a13      	ldr	r2, [pc, #76]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802138a:	89fb      	ldrh	r3, [r7, #14]
 802138c:	8453      	strh	r3, [r2, #34]	; 0x22

  /*Load the duty cycle to the channel compare shadow register*/
  (MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[0U]];
 802138e:	4b12      	ldr	r3, [pc, #72]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021390:	7b9b      	ldrb	r3, [r3, #14]
 8021392:	4a11      	ldr	r2, [pc, #68]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021394:	330c      	adds	r3, #12
 8021396:	005b      	lsls	r3, r3, #1
 8021398:	4413      	add	r3, r2
 802139a:	88da      	ldrh	r2, [r3, #6]
 802139c:	4b0f      	ldr	r3, [pc, #60]	; (80213dc <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x7c>)
 802139e:	63da      	str	r2, [r3, #60]	; 0x3c
  (MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[1U]];
 80213a0:	4b0d      	ldr	r3, [pc, #52]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213a2:	7bdb      	ldrb	r3, [r3, #15]
 80213a4:	4a0c      	ldr	r2, [pc, #48]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213a6:	330c      	adds	r3, #12
 80213a8:	005b      	lsls	r3, r3, #1
 80213aa:	4413      	add	r3, r2
 80213ac:	88da      	ldrh	r2, [r3, #6]
 80213ae:	4b0c      	ldr	r3, [pc, #48]	; (80213e0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x80>)
 80213b0:	63da      	str	r2, [r3, #60]	; 0x3c
  (MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[2U]];
 80213b2:	4b09      	ldr	r3, [pc, #36]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213b4:	7c1b      	ldrb	r3, [r3, #16]
 80213b6:	4a08      	ldr	r2, [pc, #32]	; (80213d8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213b8:	330c      	adds	r3, #12
 80213ba:	005b      	lsls	r3, r3, #1
 80213bc:	4413      	add	r3, r2
 80213be:	88da      	ldrh	r2, [r3, #6]
 80213c0:	4b08      	ldr	r3, [pc, #32]	; (80213e4 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x84>)
 80213c2:	63da      	str	r2, [r3, #60]	; 0x3c

  /*Enable the shadow transfer*/
  XMC_CCU8_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU8_MODULE, MOTOR0_BLDC_SCALAR_CCU8_SHADOW_TRANSFER);
 80213c4:	f240 1111 	movw	r1, #273	; 0x111
 80213c8:	4807      	ldr	r0, [pc, #28]	; (80213e8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x88>)
 80213ca:	f7ff ff97 	bl	80212fc <XMC_CCU8_EnableShadowTransfer>
}
 80213ce:	bf00      	nop
 80213d0:	3710      	adds	r7, #16
 80213d2:	46bd      	mov	sp, r7
 80213d4:	bd80      	pop	{r7, pc}
 80213d6:	bf00      	nop
 80213d8:	200000d0 	.word	0x200000d0
 80213dc:	40020300 	.word	0x40020300
 80213e0:	40020200 	.word	0x40020200
 80213e4:	40020100 	.word	0x40020100
 80213e8:	40020000 	.word	0x40020000

080213ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
 *
 * \par<b>Description:</b><br>
 * Resets variables related to speed calculation.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter(void)
{
 80213ec:	b480      	push	{r7}
 80213ee:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 80213f0:	4b12      	ldr	r3, [pc, #72]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213f2:	2200      	movs	r2, #0
 80213f4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 80213f8:	4b10      	ldr	r3, [pc, #64]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213fa:	2200      	movs	r2, #0
 80213fc:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 80213fe:	4b0f      	ldr	r3, [pc, #60]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021400:	2200      	movs	r2, #0
 8021402:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 8021404:	4b0d      	ldr	r3, [pc, #52]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021406:	2200      	movs	r2, #0
 8021408:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 802140a:	4b0c      	ldr	r3, [pc, #48]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802140c:	2200      	movs	r2, #0
 802140e:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 8021410:	4b0a      	ldr	r3, [pc, #40]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021412:	2200      	movs	r2, #0
 8021414:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 8021416:	4b09      	ldr	r3, [pc, #36]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021418:	2200      	movs	r2, #0
 802141a:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 802141c:	4b07      	ldr	r3, [pc, #28]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802141e:	2200      	movs	r2, #0
 8021420:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 8021422:	4b06      	ldr	r3, [pc, #24]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021424:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021426:	4a05      	ldr	r2, [pc, #20]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021428:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 802142a:	4b04      	ldr	r3, [pc, #16]	; (802143c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802142c:	2200      	movs	r2, #0
 802142e:	621a      	str	r2, [r3, #32]
}
 8021430:	bf00      	nop
 8021432:	46bd      	mov	sp, r7
 8021434:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021438:	4770      	bx	lr
 802143a:	bf00      	nop
 802143c:	200000f8 	.word	0x200000f8

08021440 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
 *
 * \par<b>Description</b><br>
 * Returns last sampled hall sensor pattern of \a peripheral.\n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern(void)
{
 8021440:	b580      	push	{r7, lr}
 8021442:	b082      	sub	sp, #8
 8021444:	af00      	add	r7, sp, #0
  uint8_t hall_pattern;
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021446:	4805      	ldr	r0, [pc, #20]	; (802145c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 8021448:	f7ff ff66 	bl	8021318 <XMC_POSIF_HSC_GetLastSampledPattern>
 802144c:	4603      	mov	r3, r0
 802144e:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 8021450:	79fb      	ldrb	r3, [r7, #7]
}
 8021452:	4618      	mov	r0, r3
 8021454:	3708      	adds	r7, #8
 8021456:	46bd      	mov	sp, r7
 8021458:	bd80      	pop	{r7, pc}
 802145a:	bf00      	nop
 802145c:	40028000 	.word	0x40028000

08021460 <VADC_GetResult>:
 *
 * \par<b>Description:</b><br>
 * Returns the VADC conversion result by reading result register from selected group number.
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t VADC_GetResult(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg)
{
 8021460:	b580      	push	{r7, lr}
 8021462:	b084      	sub	sp, #16
 8021464:	af00      	add	r7, sp, #0
 8021466:	6078      	str	r0, [r7, #4]
 8021468:	6039      	str	r1, [r7, #0]
  XMC_VADC_RESULT_SIZE_t result;
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 802146a:	6839      	ldr	r1, [r7, #0]
 802146c:	6878      	ldr	r0, [r7, #4]
 802146e:	f7ff ff66 	bl	802133e <XMC_VADC_GROUP_GetResult>
 8021472:	4603      	mov	r3, r0
 8021474:	81fb      	strh	r3, [r7, #14]
  return(result);
 8021476:	89fb      	ldrh	r3, [r7, #14]
}
 8021478:	4618      	mov	r0, r3
 802147a:	3710      	adds	r7, #16
 802147c:	46bd      	mov	sp, r7
 802147e:	bd80      	pop	{r7, pc}

08021480 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>:
 *
 * \par<b>Description:</b><br>
 * Limits the input value based on higher_limit and lower_limit
 */
__STATIC_INLINE int32_t Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(int32_t input_val, int32_t higher_limit, int32_t lower_limit)
{
 8021480:	b480      	push	{r7}
 8021482:	b087      	sub	sp, #28
 8021484:	af00      	add	r7, sp, #0
 8021486:	60f8      	str	r0, [r7, #12]
 8021488:	60b9      	str	r1, [r7, #8]
 802148a:	607a      	str	r2, [r7, #4]
  int32_t return_val;
  if ( input_val > higher_limit )
 802148c:	68fa      	ldr	r2, [r7, #12]
 802148e:	68bb      	ldr	r3, [r7, #8]
 8021490:	429a      	cmp	r2, r3
 8021492:	dd02      	ble.n	802149a <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x1a>
  {
    return_val = higher_limit;
 8021494:	68bb      	ldr	r3, [r7, #8]
 8021496:	617b      	str	r3, [r7, #20]
 8021498:	e008      	b.n	80214ac <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  }
  else if ( input_val < lower_limit )
 802149a:	68fa      	ldr	r2, [r7, #12]
 802149c:	687b      	ldr	r3, [r7, #4]
 802149e:	429a      	cmp	r2, r3
 80214a0:	da02      	bge.n	80214a8 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x28>
  {
    return_val = lower_limit;
 80214a2:	687b      	ldr	r3, [r7, #4]
 80214a4:	617b      	str	r3, [r7, #20]
 80214a6:	e001      	b.n	80214ac <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  }
  else
  {
    return_val = input_val;
 80214a8:	68fb      	ldr	r3, [r7, #12]
 80214aa:	617b      	str	r3, [r7, #20]
  }
  return return_val;
 80214ac:	697b      	ldr	r3, [r7, #20]
}
 80214ae:	4618      	mov	r0, r3
 80214b0:	371c      	adds	r7, #28
 80214b2:	46bd      	mov	sp, r7
 80214b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80214b8:	4770      	bx	lr

080214ba <Motor0_BLDC_SCALAR_PT1_Filter>:
  * Yn[3,2,1,0] =Yn-1[3,2,1,0] +Z1*(Xn -Yn-1[3,2]) \n
  * Where Z1 is time constant.
  */

__STATIC_INLINE void Motor0_BLDC_SCALAR_PT1_Filter(BLDC_SCALAR_PT1_FILTER_t *handle_ptr, int32_t actual_val)
{
 80214ba:	b590      	push	{r4, r7, lr}
 80214bc:	b083      	sub	sp, #12
 80214be:	af00      	add	r7, sp, #0
 80214c0:	6078      	str	r0, [r7, #4]
 80214c2:	6039      	str	r1, [r7, #0]
  register int32_t temp_buff;

  /* yn+1 = yn + z1*(x - yn) */
  temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16)));
 80214c4:	687b      	ldr	r3, [r7, #4]
 80214c6:	691a      	ldr	r2, [r3, #16]
 80214c8:	687b      	ldr	r3, [r7, #4]
 80214ca:	681b      	ldr	r3, [r3, #0]
 80214cc:	6879      	ldr	r1, [r7, #4]
 80214ce:	6909      	ldr	r1, [r1, #16]
 80214d0:	1409      	asrs	r1, r1, #16
 80214d2:	6838      	ldr	r0, [r7, #0]
 80214d4:	1a41      	subs	r1, r0, r1
 80214d6:	fb01 f303 	mul.w	r3, r1, r3
 80214da:	18d4      	adds	r4, r2, r3
  /* Checking the buffer limits in the range of Ymin to Ymax */
  handle_ptr->pt1_buf = Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(temp_buff, handle_ptr->y_max, handle_ptr->y_min);
 80214dc:	687b      	ldr	r3, [r7, #4]
 80214de:	6899      	ldr	r1, [r3, #8]
 80214e0:	687b      	ldr	r3, [r7, #4]
 80214e2:	68db      	ldr	r3, [r3, #12]
 80214e4:	461a      	mov	r2, r3
 80214e6:	4620      	mov	r0, r4
 80214e8:	f7ff ffca 	bl	8021480 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>
 80214ec:	4602      	mov	r2, r0
 80214ee:	687b      	ldr	r3, [r7, #4]
 80214f0:	611a      	str	r2, [r3, #16]
  handle_ptr->pt1_out_val = (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16);
 80214f2:	687b      	ldr	r3, [r7, #4]
 80214f4:	691b      	ldr	r3, [r3, #16]
 80214f6:	141a      	asrs	r2, r3, #16
 80214f8:	687b      	ldr	r3, [r7, #4]
 80214fa:	615a      	str	r2, [r3, #20]
}
 80214fc:	bf00      	nop
 80214fe:	370c      	adds	r7, #12
 8021500:	46bd      	mov	sp, r7
 8021502:	bd90      	pop	{r4, r7, pc}

08021504 <Motor0_BLDC_SCALAR_GetCurrentValue>:
 * without PT1 filter:                                    <b>0.78 uSec </b>\n
 * with PT1 filter:                                       <b>1.46 uSec </b>\n
 * with filter and with demagnetization blanking enabled: <b>1.6 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetCurrentValue(int32_t *dclink_current)
{
 8021504:	b580      	push	{r7, lr}
 8021506:	b084      	sub	sp, #16
 8021508:	af00      	add	r7, sp, #0
 802150a:	6078      	str	r0, [r7, #4]
  int32_t current_value;
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 802150c:	2105      	movs	r1, #5
 802150e:	4821      	ldr	r0, [pc, #132]	; (8021594 <Motor0_BLDC_SCALAR_GetCurrentValue+0x90>)
 8021510:	f7ff ffa6 	bl	8021460 <VADC_GetResult>
 8021514:	4603      	mov	r3, r0
 8021516:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 8021518:	4b1f      	ldr	r3, [pc, #124]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802151a:	681b      	ldr	r3, [r3, #0]
 802151c:	68fa      	ldr	r2, [r7, #12]
 802151e:	1ad3      	subs	r3, r2, r3
 8021520:	4a1d      	ldr	r2, [pc, #116]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021522:	6892      	ldr	r2, [r2, #8]
 8021524:	fb02 f303 	mul.w	r3, r2, r3
 8021528:	139b      	asrs	r3, r3, #14
 802152a:	60fb      	str	r3, [r7, #12]

  #if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_LINK_CURRENT_FILTER == 1U)
  /* PT1 filter   */
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_DirectCurrent,(int32_t)current_value);
 802152c:	68f9      	ldr	r1, [r7, #12]
 802152e:	481b      	ldr	r0, [pc, #108]	; (802159c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021530:	f7ff ffc3 	bl	80214ba <Motor0_BLDC_SCALAR_PT1_Filter>
  current_value = ((Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_out_val));
 8021534:	4b19      	ldr	r3, [pc, #100]	; (802159c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021536:	695b      	ldr	r3, [r3, #20]
 8021538:	60fb      	str	r3, [r7, #12]
  /*
   * Skip the direct DC link current measurement at commutation point based on de-magnetization count
   * This is required only if the SW filter is disabled
   */
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable == 1U)
 802153a:	4b17      	ldr	r3, [pc, #92]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802153c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8021540:	2b01      	cmp	r3, #1
 8021542:	d11c      	bne.n	802157e <Motor0_BLDC_SCALAR_GetCurrentValue+0x7a>
  {
    Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter++;
 8021544:	4b14      	ldr	r3, [pc, #80]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021546:	69db      	ldr	r3, [r3, #28]
 8021548:	3301      	adds	r3, #1
 802154a:	4a13      	ldr	r2, [pc, #76]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802154c:	61d3      	str	r3, [r2, #28]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 802154e:	4b12      	ldr	r3, [pc, #72]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021550:	69da      	ldr	r2, [r3, #28]
        Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_count)
 8021552:	4b11      	ldr	r3, [pc, #68]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021554:	699b      	ldr	r3, [r3, #24]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021556:	429a      	cmp	r2, r3
 8021558:	d90c      	bls.n	8021574 <Motor0_BLDC_SCALAR_GetCurrentValue+0x70>
    {
      /* De-magnetization blanking time over. Read current and reset the De-magnetization counter */
     *dclink_current = current_value;
 802155a:	687b      	ldr	r3, [r7, #4]
 802155c:	68fa      	ldr	r2, [r7, #12]
 802155e:	601a      	str	r2, [r3, #0]
     Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current = current_value;
 8021560:	4a0d      	ldr	r2, [pc, #52]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021562:	68fb      	ldr	r3, [r7, #12]
 8021564:	6113      	str	r3, [r2, #16]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 8021566:	4b0c      	ldr	r3, [pc, #48]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021568:	2200      	movs	r2, #0
 802156a:	61da      	str	r2, [r3, #28]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 0U;
 802156c:	4b0a      	ldr	r3, [pc, #40]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802156e:	2200      	movs	r2, #0
 8021570:	f883 2020 	strb.w	r2, [r3, #32]
    }
    *dclink_current = Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current;
 8021574:	4b08      	ldr	r3, [pc, #32]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021576:	691a      	ldr	r2, [r3, #16]
 8021578:	687b      	ldr	r3, [r7, #4]
 802157a:	601a      	str	r2, [r3, #0]
    *dclink_current = current_value;
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  }
#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
}
 802157c:	e005      	b.n	802158a <Motor0_BLDC_SCALAR_GetCurrentValue+0x86>
    *dclink_current = current_value;
 802157e:	687b      	ldr	r3, [r7, #4]
 8021580:	68fa      	ldr	r2, [r7, #12]
 8021582:	601a      	str	r2, [r3, #0]
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
 8021584:	4a04      	ldr	r2, [pc, #16]	; (8021598 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021586:	68fb      	ldr	r3, [r7, #12]
 8021588:	6113      	str	r3, [r2, #16]
}
 802158a:	bf00      	nop
 802158c:	3710      	adds	r7, #16
 802158e:	46bd      	mov	sp, r7
 8021590:	bd80      	pop	{r7, pc}
 8021592:	bf00      	nop
 8021594:	40005000 	.word	0x40005000
 8021598:	20000124 	.word	0x20000124
 802159c:	200000a4 	.word	0x200000a4

080215a0 <Motor0_BLDC_SCALAR_GetAverageCurrentValue>:
 * without PT1 filter: <b>0.588 uSec </b> \n
 * with PT1 filter: <b>1.380 uSec </b>\n
 * with filter and with MOTOR0_BLDC_SCALAR_VADC_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK enabled: <b>1.508 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetAverageCurrentValue(int32_t *dclink_average_current)
{
 80215a0:	b580      	push	{r7, lr}
 80215a2:	b084      	sub	sp, #16
 80215a4:	af00      	add	r7, sp, #0
 80215a6:	6078      	str	r0, [r7, #4]
  /* Average current pin */
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_AVERAGE_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_AVERAGE_RES_REG_NUM);
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.avg_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
#else
  /* Average current calculated from DC link current pin */
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 80215a8:	2105      	movs	r1, #5
 80215aa:	480f      	ldr	r0, [pc, #60]	; (80215e8 <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x48>)
 80215ac:	f7ff ff58 	bl	8021460 <VADC_GetResult>
 80215b0:	4603      	mov	r3, r0
 80215b2:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 80215b4:	4b0d      	ldr	r3, [pc, #52]	; (80215ec <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215b6:	681b      	ldr	r3, [r3, #0]
 80215b8:	68fa      	ldr	r2, [r7, #12]
 80215ba:	1ad3      	subs	r3, r2, r3
 80215bc:	4a0b      	ldr	r2, [pc, #44]	; (80215ec <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215be:	6892      	ldr	r2, [r2, #8]
 80215c0:	fb02 f303 	mul.w	r3, r2, r3
 80215c4:	139b      	asrs	r3, r3, #14
 80215c6:	60fb      	str	r3, [r7, #12]
  current_value = (current_value * ((int32_t)*Motor0_BLDC_SCALAR_CurrentMeasurement.amplitude)) >> BLDC_SCALAR_SHIFT_14;
 80215c8:	4b08      	ldr	r3, [pc, #32]	; (80215ec <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215ca:	695b      	ldr	r3, [r3, #20]
 80215cc:	681b      	ldr	r3, [r3, #0]
 80215ce:	461a      	mov	r2, r3
 80215d0:	68fb      	ldr	r3, [r7, #12]
 80215d2:	fb02 f303 	mul.w	r3, r2, r3
 80215d6:	139b      	asrs	r3, r3, #14
 80215d8:	60fb      	str	r3, [r7, #12]
#if (MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U)
  /* PT1 filter is used to remove high frequency noise of average DC link current */
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_AverageCurrent,(int32_t)current_value);
  *dclink_average_current = ((Motor0_BLDC_SCALAR_PT1_AverageCurrent.pt1_out_val));
#else
  *dclink_average_current = current_value;
 80215da:	687b      	ldr	r3, [r7, #4]
 80215dc:	68fa      	ldr	r2, [r7, #12]
 80215de:	601a      	str	r2, [r3, #0]
#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U) */
}
 80215e0:	bf00      	nop
 80215e2:	3710      	adds	r7, #16
 80215e4:	46bd      	mov	sp, r7
 80215e6:	bd80      	pop	{r7, pc}
 80215e8:	40005000 	.word	0x40005000
 80215ec:	20000124 	.word	0x20000124

080215f0 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT>:
 *
 * \par<b>Description:</b><br>
 * Limits the input value based on higher_limit and lower_limit
 */
__STATIC_INLINE int32_t Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT(int32_t input_val, int32_t higher_limit, int32_t lower_limit)
{
 80215f0:	b480      	push	{r7}
 80215f2:	b087      	sub	sp, #28
 80215f4:	af00      	add	r7, sp, #0
 80215f6:	60f8      	str	r0, [r7, #12]
 80215f8:	60b9      	str	r1, [r7, #8]
 80215fa:	607a      	str	r2, [r7, #4]
  int32_t return_val;
  if ( input_val > higher_limit )
 80215fc:	68fa      	ldr	r2, [r7, #12]
 80215fe:	68bb      	ldr	r3, [r7, #8]
 8021600:	429a      	cmp	r2, r3
 8021602:	dd02      	ble.n	802160a <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x1a>
  {
    return_val = higher_limit;
 8021604:	68bb      	ldr	r3, [r7, #8]
 8021606:	617b      	str	r3, [r7, #20]
 8021608:	e008      	b.n	802161c <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x2c>
  }
  else if ( input_val < lower_limit )
 802160a:	68fa      	ldr	r2, [r7, #12]
 802160c:	687b      	ldr	r3, [r7, #4]
 802160e:	429a      	cmp	r2, r3
 8021610:	da02      	bge.n	8021618 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x28>
  {
    return_val = lower_limit;
 8021612:	687b      	ldr	r3, [r7, #4]
 8021614:	617b      	str	r3, [r7, #20]
 8021616:	e001      	b.n	802161c <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x2c>
  }
  else
  {
    return_val = input_val;
 8021618:	68fb      	ldr	r3, [r7, #12]
 802161a:	617b      	str	r3, [r7, #20]
  }
  return return_val;
 802161c:	697b      	ldr	r3, [r7, #20]
}
 802161e:	4618      	mov	r0, r3
 8021620:	371c      	adds	r7, #28
 8021622:	46bd      	mov	sp, r7
 8021624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021628:	4770      	bx	lr

0802162a <Motor0_BLDC_SCALAR_PI_SAT_STATE>:
 *
 * \par<b>Description:</b><br>
 * Checks if PI saturation flag is set
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_PI_SAT_STATE(int32_t input1, int32_t input2)
{
 802162a:	b480      	push	{r7}
 802162c:	b085      	sub	sp, #20
 802162e:	af00      	add	r7, sp, #0
 8021630:	6078      	str	r0, [r7, #4]
 8021632:	6039      	str	r1, [r7, #0]
  uint8_t return_val;
  if (input1 == input2)
 8021634:	687a      	ldr	r2, [r7, #4]
 8021636:	683b      	ldr	r3, [r7, #0]
 8021638:	429a      	cmp	r2, r3
 802163a:	d102      	bne.n	8021642 <Motor0_BLDC_SCALAR_PI_SAT_STATE+0x18>
  {
    return_val = 1U;
 802163c:	2301      	movs	r3, #1
 802163e:	73fb      	strb	r3, [r7, #15]
 8021640:	e001      	b.n	8021646 <Motor0_BLDC_SCALAR_PI_SAT_STATE+0x1c>
  }
  else
  {
    return_val = 0U;
 8021642:	2300      	movs	r3, #0
 8021644:	73fb      	strb	r3, [r7, #15]
  }
  return (return_val);
 8021646:	7bfb      	ldrb	r3, [r7, #15]
}
 8021648:	4618      	mov	r0, r3
 802164a:	3714      	adds	r7, #20
 802164c:	46bd      	mov	sp, r7
 802164e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021652:	4770      	bx	lr

08021654 <Motor0_BLDC_SCALAR_PI_Controller>:
__STATIC_INLINE void Motor0_BLDC_SCALAR_PI_Controller
(
    BLDC_SCALAR_PI_CONTROLLER_t *handle_ptr,
    int32_t error_val
)
{
 8021654:	b590      	push	{r4, r7, lr}
 8021656:	b083      	sub	sp, #12
 8021658:	af00      	add	r7, sp, #0
 802165a:	6078      	str	r0, [r7, #4]
 802165c:	6039      	str	r1, [r7, #0]
  register int32_t u_k;
  register int32_t error = error_val;
 802165e:	683c      	ldr	r4, [r7, #0]

  handle_ptr->ik = (int32_t)(error * (int32_t)handle_ptr->ki * (int32_t)handle_ptr->sat_state) + handle_ptr->ik;              /*Integral output I[k] = I[k-1] + Ki * error[k] */
 8021660:	687b      	ldr	r3, [r7, #4]
 8021662:	8a5b      	ldrh	r3, [r3, #18]
 8021664:	fb04 f303 	mul.w	r3, r4, r3
 8021668:	687a      	ldr	r2, [r7, #4]
 802166a:	7d52      	ldrb	r2, [r2, #21]
 802166c:	fb03 f202 	mul.w	r2, r3, r2
 8021670:	687b      	ldr	r3, [r7, #4]
 8021672:	685b      	ldr	r3, [r3, #4]
 8021674:	441a      	add	r2, r3
 8021676:	687b      	ldr	r3, [r7, #4]
 8021678:	605a      	str	r2, [r3, #4]
  u_k = (( error * (int32_t)handle_ptr->kp) + handle_ptr->ik) >> handle_ptr->scale_kpki;         /*PI output U[k] = Kp * error[k] + I[k]. */
 802167a:	687b      	ldr	r3, [r7, #4]
 802167c:	8a1b      	ldrh	r3, [r3, #16]
 802167e:	fb03 f204 	mul.w	r2, r3, r4
 8021682:	687b      	ldr	r3, [r7, #4]
 8021684:	685b      	ldr	r3, [r3, #4]
 8021686:	4413      	add	r3, r2
 8021688:	687a      	ldr	r2, [r7, #4]
 802168a:	7d12      	ldrb	r2, [r2, #20]
 802168c:	fa43 f402 	asr.w	r4, r3, r2
  handle_ptr->uk = Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT(u_k, handle_ptr->uk_limit_max, handle_ptr->uk_limit_min);  /* Check U[k] output limit. Vq = handle_ptr->Uk. */
 8021690:	687b      	ldr	r3, [r7, #4]
 8021692:	68d9      	ldr	r1, [r3, #12]
 8021694:	687b      	ldr	r3, [r7, #4]
 8021696:	689b      	ldr	r3, [r3, #8]
 8021698:	461a      	mov	r2, r3
 802169a:	4620      	mov	r0, r4
 802169c:	f7ff ffa8 	bl	80215f0 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT>
 80216a0:	4602      	mov	r2, r0
 80216a2:	687b      	ldr	r3, [r7, #4]
 80216a4:	601a      	str	r2, [r3, #0]
  handle_ptr->sat_state = (uint8_t)Motor0_BLDC_SCALAR_PI_SAT_STATE(u_k, handle_ptr->uk);                                   /* Update saturation flag */
 80216a6:	687b      	ldr	r3, [r7, #4]
 80216a8:	681b      	ldr	r3, [r3, #0]
 80216aa:	4619      	mov	r1, r3
 80216ac:	4620      	mov	r0, r4
 80216ae:	f7ff ffbc 	bl	802162a <Motor0_BLDC_SCALAR_PI_SAT_STATE>
 80216b2:	4603      	mov	r3, r0
 80216b4:	461a      	mov	r2, r3
 80216b6:	687b      	ldr	r3, [r7, #4]
 80216b8:	755a      	strb	r2, [r3, #21]
}
 80216ba:	bf00      	nop
 80216bc:	370c      	adds	r7, #12
 80216be:	46bd      	mov	sp, r7
 80216c0:	bd90      	pop	{r4, r7, pc}
	...

080216c4 <Motor0_BLDC_SCALAR_SpeedControlScheme>:
 *
 * \par<b>Execution Time:</b><br>
 * <b>1.820 uSec </b>using O3 optimization level
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SpeedControlScheme(int32_t *output)
{
 80216c4:	b580      	push	{r7, lr}
 80216c6:	b084      	sub	sp, #16
 80216c8:	af00      	add	r7, sp, #0
 80216ca:	6078      	str	r0, [r7, #4]
  int32_t error;
  Motor0_BLDC_SCALAR_SpeedControl.fdbk_speed = Motor0_BLDC_SCALAR.motor_speed;
 80216cc:	4b0c      	ldr	r3, [pc, #48]	; (8021700 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x3c>)
 80216ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80216d0:	4a0c      	ldr	r2, [pc, #48]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216d2:	60d3      	str	r3, [r2, #12]
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR_Ramp.set_value;
 80216d4:	4b0c      	ldr	r3, [pc, #48]	; (8021708 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x44>)
 80216d6:	681b      	ldr	r3, [r3, #0]
 80216d8:	4a0a      	ldr	r2, [pc, #40]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216da:	6093      	str	r3, [r2, #8]
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR.analogip_val;
#else
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
#endif

  error = (int32_t)(Motor0_BLDC_SCALAR_SpeedControl.ref_speed) - (int32_t)(Motor0_BLDC_SCALAR_SpeedControl.fdbk_speed);
 80216dc:	4b09      	ldr	r3, [pc, #36]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216de:	689a      	ldr	r2, [r3, #8]
 80216e0:	4b08      	ldr	r3, [pc, #32]	; (8021704 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216e2:	68db      	ldr	r3, [r3, #12]
 80216e4:	1ad3      	subs	r3, r2, r3
 80216e6:	60fb      	str	r3, [r7, #12]

  /*Speed Control based on PI technique*/
  Motor0_BLDC_SCALAR_PI_Controller(&Motor0_BLDC_SCALAR_SpeedControl_PI,(int32_t)error);
 80216e8:	68f9      	ldr	r1, [r7, #12]
 80216ea:	4808      	ldr	r0, [pc, #32]	; (802170c <Motor0_BLDC_SCALAR_SpeedControlScheme+0x48>)
 80216ec:	f7ff ffb2 	bl	8021654 <Motor0_BLDC_SCALAR_PI_Controller>

  *output = Motor0_BLDC_SCALAR_SpeedControl_PI.uk;
 80216f0:	4b06      	ldr	r3, [pc, #24]	; (802170c <Motor0_BLDC_SCALAR_SpeedControlScheme+0x48>)
 80216f2:	681a      	ldr	r2, [r3, #0]
 80216f4:	687b      	ldr	r3, [r7, #4]
 80216f6:	601a      	str	r2, [r3, #0]
}
 80216f8:	bf00      	nop
 80216fa:	3710      	adds	r7, #16
 80216fc:	46bd      	mov	sp, r7
 80216fe:	bd80      	pop	{r7, pc}
 8021700:	2000018c 	.word	0x2000018c
 8021704:	20000148 	.word	0x20000148
 8021708:	200000bc 	.word	0x200000bc
 802170c:	2000008c 	.word	0x2000008c

08021710 <Motor0_BLDC_SCALAR_DirectionControl>:
 * using O3 optimization level \n
 * without bi-direction control: <b>0.120 uSec</b> \n
 * with bi-direction control (normal operation): <b>0.820 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_DirectionControl(int32_t output, uint32_t *amplitude)
{
 8021710:	b580      	push	{r7, lr}
 8021712:	b084      	sub	sp, #16
 8021714:	af00      	add	r7, sp, #0
 8021716:	6078      	str	r0, [r7, #4]
 8021718:	6039      	str	r1, [r7, #0]

  /*
   * Change the direction when control scheme output is of reverse polarity of the set motor direction
   * Get the absolute value of the amplitude
   */
  if (output < 0)
 802171a:	687b      	ldr	r3, [r7, #4]
 802171c:	2b00      	cmp	r3, #0
 802171e:	da13      	bge.n	8021748 <Motor0_BLDC_SCALAR_DirectionControl+0x38>
  {
    output = -1 * output;
 8021720:	687b      	ldr	r3, [r7, #4]
 8021722:	425b      	negs	r3, r3
 8021724:	607b      	str	r3, [r7, #4]

    if (Motor0_BLDC_SCALAR.motor_set_direction == BLDC_SCALAR_POSITIVE_DIR)
 8021726:	4b25      	ldr	r3, [pc, #148]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021728:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802172a:	2b01      	cmp	r3, #1
 802172c:	d11f      	bne.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 802172e:	4b23      	ldr	r3, [pc, #140]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021730:	f04f 32ff 	mov.w	r2, #4294967295
 8021734:	679a      	str	r2, [r3, #120]	; 0x78
      index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021736:	f7ff fe83 	bl	8021440 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 802173a:	4603      	mov	r3, r0
 802173c:	73fb      	strb	r3, [r7, #15]
      Motor0_BLDC_SCALAR_PatternInitiator(index);
 802173e:	7bfb      	ldrb	r3, [r7, #15]
 8021740:	4618      	mov	r0, r3
 8021742:	f009 fc3d 	bl	802afc0 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
 8021746:	e012      	b.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    }
  }
  else if (output > 0)
 8021748:	687b      	ldr	r3, [r7, #4]
 802174a:	2b00      	cmp	r3, #0
 802174c:	dd0f      	ble.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
  {
    if (Motor0_BLDC_SCALAR.motor_set_direction == BLDC_SCALAR_NEGATIVE_DIR)
 802174e:	4b1b      	ldr	r3, [pc, #108]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021750:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021752:	f1b3 3fff 	cmp.w	r3, #4294967295
 8021756:	d10a      	bne.n	802176e <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 8021758:	4b18      	ldr	r3, [pc, #96]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 802175a:	2201      	movs	r2, #1
 802175c:	679a      	str	r2, [r3, #120]	; 0x78
      index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 802175e:	f7ff fe6f 	bl	8021440 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021762:	4603      	mov	r3, r0
 8021764:	73fb      	strb	r3, [r7, #15]
      Motor0_BLDC_SCALAR_PatternInitiator(index);
 8021766:	7bfb      	ldrb	r3, [r7, #15]
 8021768:	4618      	mov	r0, r3
 802176a:	f009 fc29 	bl	802afc0 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
  }
  else
  {

  }
  *amplitude = (uint32_t)output;
 802176e:	687a      	ldr	r2, [r7, #4]
 8021770:	683b      	ldr	r3, [r7, #0]
 8021772:	601a      	str	r2, [r3, #0]
  /* zero speed handling in speed control with bi-directional control */
  #if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U)
    speed = Motor0_BLDC_SCALAR.analogip_val;
  #else
    speed = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 8021774:	4b12      	ldr	r3, [pc, #72]	; (80217c0 <Motor0_BLDC_SCALAR_DirectionControl+0xb0>)
 8021776:	685b      	ldr	r3, [r3, #4]
 8021778:	60bb      	str	r3, [r7, #8]
  #endif
  if (speed == 0)
 802177a:	68bb      	ldr	r3, [r7, #8]
 802177c:	2b00      	cmp	r3, #0
 802177e:	d119      	bne.n	80217b4 <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
  {
    /* Limiting speed to 0 when motor speed with in the range of 2% */
    if ((Motor0_BLDC_SCALAR.motor_speed < Motor0_BLDC_SCALAR.min_speed) && (Motor0_BLDC_SCALAR.motor_speed > -Motor0_BLDC_SCALAR.min_speed))
 8021780:	4b0e      	ldr	r3, [pc, #56]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021782:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8021784:	4b0d      	ldr	r3, [pc, #52]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021786:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 802178a:	429a      	cmp	r2, r3
 802178c:	da12      	bge.n	80217b4 <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
 802178e:	4b0b      	ldr	r3, [pc, #44]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021790:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8021792:	4b0a      	ldr	r3, [pc, #40]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021794:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8021798:	425b      	negs	r3, r3
 802179a:	429a      	cmp	r2, r3
 802179c:	dd0a      	ble.n	80217b4 <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
    {
      Motor0_BLDC_SCALAR.motor_speed = 0;
 802179e:	4b07      	ldr	r3, [pc, #28]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 80217a0:	2200      	movs	r2, #0
 80217a2:	66da      	str	r2, [r3, #108]	; 0x6c
      Motor0_BLDC_SCALAR.motor_current = 0;
 80217a4:	4b05      	ldr	r3, [pc, #20]	; (80217bc <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 80217a6:	2200      	movs	r2, #0
 80217a8:	671a      	str	r2, [r3, #112]	; 0x70
      Motor0_BLDC_SCALAR_SpeedControl_PI.ik = 0;
 80217aa:	4b06      	ldr	r3, [pc, #24]	; (80217c4 <Motor0_BLDC_SCALAR_DirectionControl+0xb4>)
 80217ac:	2200      	movs	r2, #0
 80217ae:	605a      	str	r2, [r3, #4]

      /* Reset speed calculation related variables */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 80217b0:	f7ff fe1c 	bl	80213ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>
  {
    output = 0;
  }
  *amplitude = (uint32_t) output;
#endif
}
 80217b4:	bf00      	nop
 80217b6:	3710      	adds	r7, #16
 80217b8:	46bd      	mov	sp, r7
 80217ba:	bd80      	pop	{r7, pc}
 80217bc:	2000018c 	.word	0x2000018c
 80217c0:	20000148 	.word	0x20000148
 80217c4:	2000008c 	.word	0x2000008c

080217c8 <XMC_CCU4_StartPrescaler>:
{
 80217c8:	b480      	push	{r7}
 80217ca:	b083      	sub	sp, #12
 80217cc:	af00      	add	r7, sp, #0
 80217ce:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 80217d0:	687b      	ldr	r3, [r7, #4]
 80217d2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217d6:	60da      	str	r2, [r3, #12]
}
 80217d8:	bf00      	nop
 80217da:	370c      	adds	r7, #12
 80217dc:	46bd      	mov	sp, r7
 80217de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217e2:	4770      	bx	lr

080217e4 <XMC_CCU4_StopPrescaler>:
{
 80217e4:	b480      	push	{r7}
 80217e6:	b083      	sub	sp, #12
 80217e8:	af00      	add	r7, sp, #0
 80217ea:	6078      	str	r0, [r7, #4]
  module->GIDLS = (uint32_t) CCU4_GIDLS_CPRB_Msk;
 80217ec:	687b      	ldr	r3, [r7, #4]
 80217ee:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217f2:	609a      	str	r2, [r3, #8]
}
 80217f4:	bf00      	nop
 80217f6:	370c      	adds	r7, #12
 80217f8:	46bd      	mov	sp, r7
 80217fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217fe:	4770      	bx	lr

08021800 <XMC_CCU4_SLICE_StartTimer>:
{
 8021800:	b480      	push	{r7}
 8021802:	b083      	sub	sp, #12
 8021804:	af00      	add	r7, sp, #0
 8021806:	6078      	str	r0, [r7, #4]
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8021808:	687b      	ldr	r3, [r7, #4]
 802180a:	2201      	movs	r2, #1
 802180c:	60da      	str	r2, [r3, #12]
}
 802180e:	bf00      	nop
 8021810:	370c      	adds	r7, #12
 8021812:	46bd      	mov	sp, r7
 8021814:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021818:	4770      	bx	lr

0802181a <XMC_CCU4_SLICE_StopTimer>:
{
 802181a:	b480      	push	{r7}
 802181c:	b083      	sub	sp, #12
 802181e:	af00      	add	r7, sp, #0
 8021820:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8021822:	687b      	ldr	r3, [r7, #4]
 8021824:	2201      	movs	r2, #1
 8021826:	611a      	str	r2, [r3, #16]
}
 8021828:	bf00      	nop
 802182a:	370c      	adds	r7, #12
 802182c:	46bd      	mov	sp, r7
 802182e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021832:	4770      	bx	lr

08021834 <XMC_CCU4_SLICE_GetTimerValue>:
{
 8021834:	b480      	push	{r7}
 8021836:	b083      	sub	sp, #12
 8021838:	af00      	add	r7, sp, #0
 802183a:	6078      	str	r0, [r7, #4]
  return ((uint16_t)slice->TIMER);
 802183c:	687b      	ldr	r3, [r7, #4]
 802183e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8021840:	b29b      	uxth	r3, r3
}
 8021842:	4618      	mov	r0, r3
 8021844:	370c      	adds	r7, #12
 8021846:	46bd      	mov	sp, r7
 8021848:	f85d 7b04 	ldr.w	r7, [sp], #4
 802184c:	4770      	bx	lr

0802184e <XMC_CCU4_SLICE_SetTimerValue>:
{
 802184e:	b480      	push	{r7}
 8021850:	b083      	sub	sp, #12
 8021852:	af00      	add	r7, sp, #0
 8021854:	6078      	str	r0, [r7, #4]
 8021856:	460b      	mov	r3, r1
 8021858:	807b      	strh	r3, [r7, #2]
  slice->TIMER = (uint32_t) timer_val;
 802185a:	887a      	ldrh	r2, [r7, #2]
 802185c:	687b      	ldr	r3, [r7, #4]
 802185e:	671a      	str	r2, [r3, #112]	; 0x70
}
 8021860:	bf00      	nop
 8021862:	370c      	adds	r7, #12
 8021864:	46bd      	mov	sp, r7
 8021866:	f85d 7b04 	ldr.w	r7, [sp], #4
 802186a:	4770      	bx	lr

0802186c <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 802186c:	b480      	push	{r7}
 802186e:	b083      	sub	sp, #12
 8021870:	af00      	add	r7, sp, #0
 8021872:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021874:	687b      	ldr	r3, [r7, #4]
 8021876:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 802187a:	b2db      	uxtb	r3, r3
 802187c:	115b      	asrs	r3, r3, #5
 802187e:	b2db      	uxtb	r3, r3
 8021880:	f003 0307 	and.w	r3, r3, #7
 8021884:	b2db      	uxtb	r3, r3
}
 8021886:	4618      	mov	r0, r3
 8021888:	370c      	adds	r7, #12
 802188a:	46bd      	mov	sp, r7
 802188c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021890:	4770      	bx	lr

08021892 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8021892:	b480      	push	{r7}
 8021894:	b083      	sub	sp, #12
 8021896:	af00      	add	r7, sp, #0
 8021898:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 802189a:	687b      	ldr	r3, [r7, #4]
 802189c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802189e:	08db      	lsrs	r3, r3, #3
 80218a0:	b2db      	uxtb	r3, r3
 80218a2:	f003 0307 	and.w	r3, r3, #7
 80218a6:	b2db      	uxtb	r3, r3
}
 80218a8:	4618      	mov	r0, r3
 80218aa:	370c      	adds	r7, #12
 80218ac:	46bd      	mov	sp, r7
 80218ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218b2:	4770      	bx	lr

080218b4 <XMC_POSIF_HSC_SetHallPatterns>:
{
 80218b4:	b480      	push	{r7}
 80218b6:	b083      	sub	sp, #12
 80218b8:	af00      	add	r7, sp, #0
 80218ba:	6078      	str	r0, [r7, #4]
 80218bc:	460b      	mov	r3, r1
 80218be:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 80218c0:	78fb      	ldrb	r3, [r7, #3]
 80218c2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 80218c6:	687b      	ldr	r3, [r7, #4]
 80218c8:	635a      	str	r2, [r3, #52]	; 0x34
}
 80218ca:	bf00      	nop
 80218cc:	370c      	adds	r7, #12
 80218ce:	46bd      	mov	sp, r7
 80218d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218d4:	4770      	bx	lr

080218d6 <XMC_POSIF_HSC_UpdateHallPattern>:
{
 80218d6:	b480      	push	{r7}
 80218d8:	b083      	sub	sp, #12
 80218da:	af00      	add	r7, sp, #0
 80218dc:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 80218de:	687b      	ldr	r3, [r7, #4]
 80218e0:	2202      	movs	r2, #2
 80218e2:	649a      	str	r2, [r3, #72]	; 0x48
}
 80218e4:	bf00      	nop
 80218e6:	370c      	adds	r7, #12
 80218e8:	46bd      	mov	sp, r7
 80218ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218ee:	4770      	bx	lr

080218f0 <XMC_POSIF_ClearEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_SetEvent() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_ClearEvent(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 80218f0:	b480      	push	{r7}
 80218f2:	b083      	sub	sp, #12
 80218f4:	af00      	add	r7, sp, #0
 80218f6:	6078      	str	r0, [r7, #4]
 80218f8:	460b      	mov	r3, r1
 80218fa:	70fb      	strb	r3, [r7, #3]
  peripheral->RPFLG = (uint32_t)1 << (uint8_t)event;
 80218fc:	78fb      	ldrb	r3, [r7, #3]
 80218fe:	2201      	movs	r2, #1
 8021900:	409a      	lsls	r2, r3
 8021902:	687b      	ldr	r3, [r7, #4]
 8021904:	67da      	str	r2, [r3, #124]	; 0x7c
}
 8021906:	bf00      	nop
 8021908:	370c      	adds	r7, #12
 802190a:	46bd      	mov	sp, r7
 802190c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021910:	4770      	bx	lr

08021912 <XMC_POSIF_GetEventStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_SetEvent(),XMC_POSIF_ClearEvent() \n\n\n
 */
__STATIC_INLINE uint8_t XMC_POSIF_GetEventStatus(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 8021912:	b480      	push	{r7}
 8021914:	b083      	sub	sp, #12
 8021916:	af00      	add	r7, sp, #0
 8021918:	6078      	str	r0, [r7, #4]
 802191a:	460b      	mov	r3, r1
 802191c:	70fb      	strb	r3, [r7, #3]
  return ((uint8_t)((peripheral->PFLG >> (uint8_t)event) & 1U));
 802191e:	687b      	ldr	r3, [r7, #4]
 8021920:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8021922:	78fb      	ldrb	r3, [r7, #3]
 8021924:	fa22 f303 	lsr.w	r3, r2, r3
 8021928:	b2db      	uxtb	r3, r3
 802192a:	f003 0301 	and.w	r3, r3, #1
 802192e:	b2db      	uxtb	r3, r3
}
 8021930:	4618      	mov	r0, r3
 8021932:	370c      	adds	r7, #12
 8021934:	46bd      	mov	sp, r7
 8021936:	f85d 7b04 	ldr.w	r7, [sp], #4
 802193a:	4770      	bx	lr

0802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 802193c:	b580      	push	{r7, lr}
 802193e:	b082      	sub	sp, #8
 8021940:	af00      	add	r7, sp, #0
 8021942:	4603      	mov	r3, r0
 8021944:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021946:	79fb      	ldrb	r3, [r7, #7]
 8021948:	4619      	mov	r1, r3
 802194a:	4803      	ldr	r0, [pc, #12]	; (8021958 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 802194c:	f7ff ffb2 	bl	80218b4 <XMC_POSIF_HSC_SetHallPatterns>
}
 8021950:	bf00      	nop
 8021952:	3708      	adds	r7, #8
 8021954:	46bd      	mov	sp, r7
 8021956:	bd80      	pop	{r7, pc}
 8021958:	40028000 	.word	0x40028000

0802195c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
{
 802195c:	b580      	push	{r7, lr}
 802195e:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021960:	4802      	ldr	r0, [pc, #8]	; (802196c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 8021962:	f7ff ffb8 	bl	80218d6 <XMC_POSIF_HSC_UpdateHallPattern>
}
 8021966:	bf00      	nop
 8021968:	bd80      	pop	{r7, pc}
 802196a:	bf00      	nop
 802196c:	40028000 	.word	0x40028000

08021970 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8021970:	b580      	push	{r7, lr}
 8021972:	b082      	sub	sp, #8
 8021974:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021976:	4805      	ldr	r0, [pc, #20]	; (802198c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8021978:	f7ff ff8b 	bl	8021892 <XMC_POSIF_HSC_GetExpectedPattern>
 802197c:	4603      	mov	r3, r0
 802197e:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8021980:	79fb      	ldrb	r3, [r7, #7]
}
 8021982:	4618      	mov	r0, r3
 8021984:	3708      	adds	r7, #8
 8021986:	46bd      	mov	sp, r7
 8021988:	bd80      	pop	{r7, pc}
 802198a:	bf00      	nop
 802198c:	40028000 	.word	0x40028000

08021990 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>:
{
 8021990:	b580      	push	{r7, lr}
 8021992:	b082      	sub	sp, #8
 8021994:	af00      	add	r7, sp, #0
  period = XMC_CCU4_SLICE_GetCaptureRegisterValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, BLDC_SCALAR_HALL_CAPTURE_REGITSER);
 8021996:	2103      	movs	r1, #3
 8021998:	4804      	ldr	r0, [pc, #16]	; (80219ac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime+0x1c>)
 802199a:	f006 f963 	bl	8027c64 <XMC_CCU4_SLICE_GetCaptureRegisterValue>
 802199e:	6078      	str	r0, [r7, #4]
  return(period);
 80219a0:	687b      	ldr	r3, [r7, #4]
}
 80219a2:	4618      	mov	r0, r3
 80219a4:	3708      	adds	r7, #8
 80219a6:	46bd      	mov	sp, r7
 80219a8:	bd80      	pop	{r7, pc}
 80219aa:	bf00      	nop
 80219ac:	4000c200 	.word	0x4000c200

080219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
{
 80219b0:	b580      	push	{r7, lr}
 80219b2:	b082      	sub	sp, #8
 80219b4:	af00      	add	r7, sp, #0
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 80219b6:	4805      	ldr	r0, [pc, #20]	; (80219cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 80219b8:	f7ff ff58 	bl	802186c <XMC_POSIF_HSC_GetLastSampledPattern>
 80219bc:	4603      	mov	r3, r0
 80219be:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 80219c0:	79fb      	ldrb	r3, [r7, #7]
}
 80219c2:	4618      	mov	r0, r3
 80219c4:	3708      	adds	r7, #8
 80219c6:	46bd      	mov	sp, r7
 80219c8:	bd80      	pop	{r7, pc}
 80219ca:	bf00      	nop
 80219cc:	40028000 	.word	0x40028000

080219d0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler>:
 *
 * \par<b>Description</b><br>
 * Reset the capture timer prescaler value.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler(void)
{
 80219d0:	b580      	push	{r7, lr}
 80219d2:	af00      	add	r7, sp, #0
  /*
   * Stop timer and prescalar.
   * initialize timer and prescalar value and restert the timer
   */
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219d4:	480a      	ldr	r0, [pc, #40]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219d6:	f7ff ff20 	bl	802181a <XMC_CCU4_SLICE_StopTimer>
  XMC_CCU4_StopPrescaler(MOTOR0_BLDC_SCALAR_CCU4_MODULE);
 80219da:	480a      	ldr	r0, [pc, #40]	; (8021a04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x34>)
 80219dc:	f7ff ff02 	bl	80217e4 <XMC_CCU4_StopPrescaler>
  XMC_CCU4_SLICE_SetTimerValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, 0U);
 80219e0:	2100      	movs	r1, #0
 80219e2:	4807      	ldr	r0, [pc, #28]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219e4:	f7ff ff33 	bl	802184e <XMC_CCU4_SLICE_SetTimerValue>
  XMC_CCU4_SLICE_SetPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, MOTOR0_BLDC_SCALAR_CCU4_PRESCALER);
 80219e8:	2105      	movs	r1, #5
 80219ea:	4805      	ldr	r0, [pc, #20]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219ec:	f006 f94c 	bl	8027c88 <XMC_CCU4_SLICE_SetPrescaler>
  XMC_CCU4_StartPrescaler(MOTOR0_BLDC_SCALAR_CCU4_MODULE);
 80219f0:	4804      	ldr	r0, [pc, #16]	; (8021a04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x34>)
 80219f2:	f7ff fee9 	bl	80217c8 <XMC_CCU4_StartPrescaler>
  XMC_CCU4_SLICE_StartTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219f6:	4802      	ldr	r0, [pc, #8]	; (8021a00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219f8:	f7ff ff02 	bl	8021800 <XMC_CCU4_SLICE_StartTimer>
}
 80219fc:	bf00      	nop
 80219fe:	bd80      	pop	{r7, pc}
 8021a00:	4000c200 	.word	0x4000c200
 8021a04:	4000c000 	.word	0x4000c000

08021a08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal>:
 *
 * \par<b>Description</b><br>
 * Return Hall event capture timer current value\n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal(void)
{
 8021a08:	b580      	push	{r7, lr}
 8021a0a:	b082      	sub	sp, #8
 8021a0c:	af00      	add	r7, sp, #0
  uint16_t period;
  period = XMC_CCU4_SLICE_GetTimerValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8021a0e:	4805      	ldr	r0, [pc, #20]	; (8021a24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal+0x1c>)
 8021a10:	f7ff ff10 	bl	8021834 <XMC_CCU4_SLICE_GetTimerValue>
 8021a14:	4603      	mov	r3, r0
 8021a16:	80fb      	strh	r3, [r7, #6]
  return(period);
 8021a18:	88fb      	ldrh	r3, [r7, #6]
}
 8021a1a:	4618      	mov	r0, r3
 8021a1c:	3708      	adds	r7, #8
 8021a1e:	46bd      	mov	sp, r7
 8021a20:	bd80      	pop	{r7, pc}
 8021a22:	bf00      	nop
 8021a24:	4000c200 	.word	0x4000c200

08021a28 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus>:
 *
 * \par<b>Description</b><br>
 * Returns event status of peripheral. \n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus(const XMC_POSIF_IRQ_EVENT_t event)
{
 8021a28:	b580      	push	{r7, lr}
 8021a2a:	b082      	sub	sp, #8
 8021a2c:	af00      	add	r7, sp, #0
 8021a2e:	4603      	mov	r3, r0
 8021a30:	71fb      	strb	r3, [r7, #7]
  return XMC_POSIF_GetEventStatus(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8021a32:	79fb      	ldrb	r3, [r7, #7]
 8021a34:	4619      	mov	r1, r3
 8021a36:	4804      	ldr	r0, [pc, #16]	; (8021a48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus+0x20>)
 8021a38:	f7ff ff6b 	bl	8021912 <XMC_POSIF_GetEventStatus>
 8021a3c:	4603      	mov	r3, r0
}
 8021a3e:	4618      	mov	r0, r3
 8021a40:	3708      	adds	r7, #8
 8021a42:	46bd      	mov	sp, r7
 8021a44:	bd80      	pop	{r7, pc}
 8021a46:	bf00      	nop
 8021a48:	40028000 	.word	0x40028000

08021a4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>:
 *
 * \par<b>Description</b><br>
 * Clears event by acknowledgment of peripheral. \n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 8021a4c:	b580      	push	{r7, lr}
 8021a4e:	b082      	sub	sp, #8
 8021a50:	af00      	add	r7, sp, #0
 8021a52:	4603      	mov	r3, r0
 8021a54:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_ClearEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8021a56:	79fb      	ldrb	r3, [r7, #7]
 8021a58:	4619      	mov	r1, r3
 8021a5a:	4803      	ldr	r0, [pc, #12]	; (8021a68 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent+0x1c>)
 8021a5c:	f7ff ff48 	bl	80218f0 <XMC_POSIF_ClearEvent>
}
 8021a60:	bf00      	nop
 8021a62:	3708      	adds	r7, #8
 8021a64:	46bd      	mov	sp, r7
 8021a66:	bd80      	pop	{r7, pc}
 8021a68:	40028000 	.word	0x40028000

08021a6c <Motor0_BLDC_SCALAR_WrongHallEvent>:
 * Restart capture timer and calculate the speed.
 *
 * if hall failure, stop the motor and change the state to ERROR.
 */
static void Motor0_BLDC_SCALAR_WrongHallEvent(void)
{
 8021a6c:	b580      	push	{r7, lr}
 8021a6e:	b088      	sub	sp, #32
 8021a70:	af00      	add	r7, sp, #0
  uint8_t sampled_pat;      /* Sampled hall pattern */
  uint8_t reverse_pat;      /* Expected reverse direction pattern based on last sample pattern */
  uint8_t correct_pat;      /* Expected correct direction pattern based on last sample pattern */

  /* 0: positive direction, 8: negative direction to access the pattern table */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
 8021a72:	4b59      	ldr	r3, [pc, #356]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021a74:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021a76:	b2db      	uxtb	r3, r3
 8021a78:	f003 0308 	and.w	r3, r3, #8
 8021a7c:	77fb      	strb	r3, [r7, #31]
  int32_t temp_dir  = (-Motor0_BLDC_SCALAR.motor_set_direction);
 8021a7e:	4b56      	ldr	r3, [pc, #344]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021a80:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021a82:	425b      	negs	r3, r3
 8021a84:	61bb      	str	r3, [r7, #24]
  uint8_t rev_direction = ((uint8_t)(temp_dir) & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX);    /* reverse direction */
 8021a86:	69bb      	ldr	r3, [r7, #24]
 8021a88:	b2db      	uxtb	r3, r3
 8021a8a:	f003 0308 	and.w	r3, r3, #8
 8021a8e:	75fb      	strb	r3, [r7, #23]
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
  uint8_t pos;           /* array index variable */
#endif
  uint32_t speed = 0U;     /* electrical speed in RPM */
 8021a90:	2300      	movs	r3, #0
 8021a92:	607b      	str	r3, [r7, #4]
  uint32_t capval;         /* Calculated time between two hall events */

#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  /* To blank the direct DC link current measurement at the commutation point */
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 1U;
 8021a94:	4b51      	ldr	r3, [pc, #324]	; (8021bdc <Motor0_BLDC_SCALAR_WrongHallEvent+0x170>)
 8021a96:	2201      	movs	r2, #1
 8021a98:	f883 2020 	strb.w	r2, [r3, #32]
#if (MOTOR0_BLDC_SCALAR_ENABLE_STALL_DETECTION == 1U)
  /* Reset the stall detection count as hall event is detected for timeout*/
  Motor0_BLDC_SCALAR.stall_detection_counter = 0U;
#endif
  /*Get the sampled hall pattern*/
  sampled_pat = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021a9c:	f7ff ff88 	bl	80219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021aa0:	4603      	mov	r3, r0
 8021aa2:	75bb      	strb	r3, [r7, #22]
  reverse_pat = (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + rev_direction] >> BLDC_SCALAR_HALL_PATTERN_POS);
 8021aa4:	4b4e      	ldr	r3, [pc, #312]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021aa6:	7c5b      	ldrb	r3, [r3, #17]
 8021aa8:	461a      	mov	r2, r3
 8021aaa:	7dfb      	ldrb	r3, [r7, #23]
 8021aac:	4413      	add	r3, r2
 8021aae:	4a4c      	ldr	r2, [pc, #304]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021ab0:	5cd3      	ldrb	r3, [r2, r3]
 8021ab2:	08db      	lsrs	r3, r3, #3
 8021ab4:	757b      	strb	r3, [r7, #21]
  correct_pat = (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + direction] >> BLDC_SCALAR_HALL_PATTERN_POS);
 8021ab6:	4b4a      	ldr	r3, [pc, #296]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021ab8:	7c5b      	ldrb	r3, [r3, #17]
 8021aba:	461a      	mov	r2, r3
 8021abc:	7ffb      	ldrb	r3, [r7, #31]
 8021abe:	4413      	add	r3, r2
 8021ac0:	4a47      	ldr	r2, [pc, #284]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021ac2:	5cd3      	ldrb	r3, [r2, r3]
 8021ac4:	08db      	lsrs	r3, r3, #3
 8021ac6:	753b      	strb	r3, [r7, #20]

  /* Check if the pattern matches the correct or reverse hall pattern */
  if (( reverse_pat == sampled_pat) || ( correct_pat == sampled_pat))
 8021ac8:	7d7a      	ldrb	r2, [r7, #21]
 8021aca:	7dbb      	ldrb	r3, [r7, #22]
 8021acc:	429a      	cmp	r2, r3
 8021ace:	d003      	beq.n	8021ad8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x6c>
 8021ad0:	7d3a      	ldrb	r2, [r7, #20]
 8021ad2:	7dbb      	ldrb	r3, [r7, #22]
 8021ad4:	429a      	cmp	r2, r3
 8021ad6:	d16b      	bne.n	8021bb0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x144>
  {
    /* Reverse hall event detected */

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
    /* BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION  - to get the direction of freely running motor */
    if ((Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U) &&
 8021ad8:	4b42      	ldr	r3, [pc, #264]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021ada:	781b      	ldrb	r3, [r3, #0]
 8021adc:	2b00      	cmp	r3, #0
 8021ade:	d12a      	bne.n	8021b36 <Motor0_BLDC_SCALAR_WrongHallEvent+0xca>
          (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION))
 8021ae0:	4b3d      	ldr	r3, [pc, #244]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ae2:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8021ae6:	b2db      	uxtb	r3, r3
    if ((Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U) &&
 8021ae8:	2b02      	cmp	r3, #2
 8021aea:	d124      	bne.n	8021b36 <Motor0_BLDC_SCALAR_WrongHallEvent+0xca>
    {
      /* Find the direction of rotation if motor is already running */
      Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = (int32_t) (Motor0_BLDC_SCALAR.motor_set_direction * -1);
 8021aec:	4b3a      	ldr	r3, [pc, #232]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021aee:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021af0:	425b      	negs	r3, r3
 8021af2:	4a3c      	ldr	r2, [pc, #240]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021af4:	60d3      	str	r3, [r2, #12]
      direction = (uint8_t) Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 8021af6:	4b3b      	ldr	r3, [pc, #236]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021af8:	68db      	ldr	r3, [r3, #12]
 8021afa:	b2db      	uxtb	r3, r3
 8021afc:	f003 0308 	and.w	r3, r3, #8
 8021b00:	77fb      	strb	r3, [r7, #31]
      Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired = 1U;
 8021b02:	4b38      	ldr	r3, [pc, #224]	; (8021be4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021b04:	2201      	movs	r2, #1
 8021b06:	741a      	strb	r2, [r3, #16]

      /* Update the hall pattern in shadow register and perform immediate transfer */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[((uint8_t) sampled_pat + (uint32_t) direction)]));
 8021b08:	7dba      	ldrb	r2, [r7, #22]
 8021b0a:	7ffb      	ldrb	r3, [r7, #31]
 8021b0c:	4413      	add	r3, r2
 8021b0e:	4a34      	ldr	r2, [pc, #208]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021b10:	5cd3      	ldrb	r3, [r2, r3]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021b12:	4618      	mov	r0, r3
 8021b14:	f7ff ff12 	bl	802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
 8021b18:	f7ff ff20 	bl	802195c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>
      pos =  Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 8021b1c:	f7ff ff28 	bl	8021970 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 8021b20:	4603      	mov	r3, r0
 8021b22:	74fb      	strb	r3, [r7, #19]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
 8021b24:	7cfa      	ldrb	r2, [r7, #19]
 8021b26:	7ffb      	ldrb	r3, [r7, #31]
 8021b28:	4413      	add	r3, r2
 8021b2a:	4a2d      	ldr	r2, [pc, #180]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021b2c:	5cd3      	ldrb	r3, [r2, r3]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021b2e:	4618      	mov	r0, r3
 8021b30:	f7ff ff04 	bl	802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
 8021b34:	e035      	b.n	8021ba2 <Motor0_BLDC_SCALAR_WrongHallEvent+0x136>
    /* Apply hall pattern and multi-channel pattern for intended direction */
    else
    {
#endif
      /* Update actual motor direction */
      Motor0_BLDC_SCALAR.actual_motor_direction = (-Motor0_BLDC_SCALAR.motor_set_direction);
 8021b36:	4b28      	ldr	r3, [pc, #160]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b38:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021b3a:	425b      	negs	r3, r3
 8021b3c:	4a26      	ldr	r2, [pc, #152]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b3e:	67d3      	str	r3, [r2, #124]	; 0x7c

      Motor0_BLDC_SCALAR_PatternInitiator(sampled_pat);
 8021b40:	7dbb      	ldrb	r3, [r7, #22]
 8021b42:	4618      	mov	r0, r3
 8021b44:	f009 fa3c 	bl	802afc0 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>

      /* Restart the capture slice which is used for speed calculation */
      timer = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal();
 8021b48:	f7ff ff5e 	bl	8021a08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal>
 8021b4c:	4603      	mov	r3, r0
 8021b4e:	823b      	strh	r3, [r7, #16]
      curr_psc = ((uint32_t)((uint32_t)MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE->FPC & (uint32_t)CCU4_CC4_FPC_PVAL_Msk) >> (uint32_t)CCU4_CC4_FPC_PVAL_Pos);
 8021b50:	4b25      	ldr	r3, [pc, #148]	; (8021be8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x17c>)
 8021b52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021b54:	0a1b      	lsrs	r3, r3, #8
 8021b56:	f003 030f 	and.w	r3, r3, #15
 8021b5a:	60fb      	str	r3, [r7, #12]

      /* Stop timer and prescaler and restart with reset values*/
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler();
 8021b5c:	f7ff ff38 	bl	80219d0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler>

      /* speed calculation */
      capval = BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021b60:	68fb      	ldr	r3, [r7, #12]
 8021b62:	3b05      	subs	r3, #5
 8021b64:	4a21      	ldr	r2, [pc, #132]	; (8021bec <Motor0_BLDC_SCALAR_WrongHallEvent+0x180>)
 8021b66:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
               (((uint32_t)1 << (uint32_t)(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * timer);
 8021b6a:	8a39      	ldrh	r1, [r7, #16]
 8021b6c:	68fb      	ldr	r3, [r7, #12]
 8021b6e:	3b05      	subs	r3, #5
 8021b70:	fa01 f303 	lsl.w	r3, r1, r3
      capval = BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021b74:	4413      	add	r3, r2
 8021b76:	60bb      	str	r3, [r7, #8]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = capval;
 8021b78:	4a1d      	ldr	r2, [pc, #116]	; (8021bf0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x184>)
 8021b7a:	68bb      	ldr	r3, [r7, #8]
 8021b7c:	6193      	str	r3, [r2, #24]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation(capval, &speed);
 8021b7e:	1d3b      	adds	r3, r7, #4
 8021b80:	4619      	mov	r1, r3
 8021b82:	68b8      	ldr	r0, [r7, #8]
 8021b84:	f009 fa18 	bl	802afb8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer>
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b88:	4b13      	ldr	r3, [pc, #76]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b8a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021b8c:	687a      	ldr	r2, [r7, #4]
 8021b8e:	fb02 f303 	mul.w	r3, r2, r3
                                       (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8021b92:	4a11      	ldr	r2, [pc, #68]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b94:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b98:	fb02 f303 	mul.w	r3, r2, r3
                                       (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8021b9c:	129b      	asrs	r3, r3, #10
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b9e:	4a0e      	ldr	r2, [pc, #56]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ba0:	66d3      	str	r3, [r2, #108]	; 0x6c
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
    }
#endif
    Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021ba2:	f7ff ff05 	bl	80219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021ba6:	4603      	mov	r3, r0
 8021ba8:	461a      	mov	r2, r3
 8021baa:	4b0d      	ldr	r3, [pc, #52]	; (8021be0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021bac:	745a      	strb	r2, [r3, #17]
 8021bae:	e00b      	b.n	8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x15c>

  /* Hall failure - sampled hall pattern does not match with either direction pattern */
  else
  {
    /* wrong hall event */
    Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_WRONGHALL;
 8021bb0:	4b09      	ldr	r3, [pc, #36]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021bb2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8021bb4:	f043 0308 	orr.w	r3, r3, #8
 8021bb8:	4a07      	ldr	r2, [pc, #28]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021bba:	6693      	str	r3, [r2, #104]	; 0x68
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 8021bbc:	4b06      	ldr	r3, [pc, #24]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021bbe:	2208      	movs	r2, #8
 8021bc0:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    Motor0_BLDC_SCALAR_MotorStop();
 8021bc4:	f000 fee8 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
  }
  /* clear wrong hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(XMC_POSIF_IRQ_EVENT_WHE);
 8021bc8:	2001      	movs	r0, #1
 8021bca:	f7ff ff3f 	bl	8021a4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>
}
 8021bce:	bf00      	nop
 8021bd0:	3720      	adds	r7, #32
 8021bd2:	46bd      	mov	sp, r7
 8021bd4:	bd80      	pop	{r7, pc}
 8021bd6:	bf00      	nop
 8021bd8:	2000018c 	.word	0x2000018c
 8021bdc:	20000124 	.word	0x20000124
 8021be0:	20000158 	.word	0x20000158
 8021be4:	2000016c 	.word	0x2000016c
 8021be8:	4000c200 	.word	0x4000c200
 8021bec:	20000000 	.word	0x20000000
 8021bf0:	200000f8 	.word	0x200000f8

08021bf4 <Motor0_BLDC_SCALAR_CorrectHallEvent>:
/*
 * Find the direction of the motor in free running condition.
 * This event is disabled once control is switched to closed loop.
 */
static void Motor0_BLDC_SCALAR_CorrectHallEvent(void)
{
 8021bf4:	b580      	push	{r7, lr}
 8021bf6:	b086      	sub	sp, #24
 8021bf8:	af00      	add	r7, sp, #0
  /* 0: positive direction, 8: negative direction to access the pattern table */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
 8021bfa:	4b34      	ldr	r3, [pc, #208]	; (8021ccc <Motor0_BLDC_SCALAR_CorrectHallEvent+0xd8>)
 8021bfc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021bfe:	b2db      	uxtb	r3, r3
 8021c00:	f003 0308 	and.w	r3, r3, #8
 8021c04:	75fb      	strb	r3, [r7, #23]
  uint8_t pos;          /* Array index variable */
  uint32_t capture_reg;   /* capture register value */
  uint32_t curr_psc;      /* Prescaler value */

  /* Speed is calculated based on last two hall events */
  Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter++;
 8021c06:	4b32      	ldr	r3, [pc, #200]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c08:	695b      	ldr	r3, [r3, #20]
 8021c0a:	3301      	adds	r3, #1
 8021c0c:	4a30      	ldr	r2, [pc, #192]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c0e:	6153      	str	r3, [r2, #20]
  Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter = 0U;
 8021c10:	4b2f      	ldr	r3, [pc, #188]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c12:	2200      	movs	r2, #0
 8021c14:	609a      	str	r2, [r3, #8]
   * if correct hall event is the first event after the state machine has started,
   * identified direction is the intended direction.
   * If wrong hall event is the first event after the state machine has started,
   * identified direction is the reverse direction.
   */
  if ((Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter == 1U) && (Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired == 0U))
 8021c16:	4b2e      	ldr	r3, [pc, #184]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c18:	695b      	ldr	r3, [r3, #20]
 8021c1a:	2b01      	cmp	r3, #1
 8021c1c:	d10a      	bne.n	8021c34 <Motor0_BLDC_SCALAR_CorrectHallEvent+0x40>
 8021c1e:	4b2c      	ldr	r3, [pc, #176]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c20:	7c1b      	ldrb	r3, [r3, #16]
 8021c22:	2b00      	cmp	r3, #0
 8021c24:	d106      	bne.n	8021c34 <Motor0_BLDC_SCALAR_CorrectHallEvent+0x40>
  {
    Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = (int32_t) Motor0_BLDC_SCALAR.motor_set_direction;
 8021c26:	4b29      	ldr	r3, [pc, #164]	; (8021ccc <Motor0_BLDC_SCALAR_CorrectHallEvent+0xd8>)
 8021c28:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021c2a:	4a29      	ldr	r2, [pc, #164]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c2c:	60d3      	str	r3, [r2, #12]
    Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired = 1U;
 8021c2e:	4b28      	ldr	r3, [pc, #160]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c30:	2201      	movs	r2, #1
 8021c32:	741a      	strb	r2, [r3, #16]
  }

  direction = (uint8_t) Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 8021c34:	4b26      	ldr	r3, [pc, #152]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c36:	68db      	ldr	r3, [r3, #12]
 8021c38:	b2db      	uxtb	r3, r3
 8021c3a:	f003 0308 	and.w	r3, r3, #8
 8021c3e:	75fb      	strb	r3, [r7, #23]

  /* Read the captured value */
  capture_reg = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime();
 8021c40:	f7ff fea6 	bl	8021990 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>
 8021c44:	6138      	str	r0, [r7, #16]
  if ((Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter > 1U) && (Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U))
 8021c46:	4b22      	ldr	r3, [pc, #136]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c48:	695b      	ldr	r3, [r3, #20]
 8021c4a:	2b01      	cmp	r3, #1
 8021c4c:	d925      	bls.n	8021c9a <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
 8021c4e:	4b20      	ldr	r3, [pc, #128]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c50:	781b      	ldrb	r3, [r3, #0]
 8021c52:	2b00      	cmp	r3, #0
 8021c54:	d121      	bne.n	8021c9a <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
  {
    capture_reg = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime();
 8021c56:	f7ff fe9b 	bl	8021990 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>
 8021c5a:	6138      	str	r0, [r7, #16]

    capval = (capture_reg & (uint32_t) BLDC_SCALAR_HALL_CAPTURE_MASK);
 8021c5c:	693b      	ldr	r3, [r7, #16]
 8021c5e:	b29b      	uxth	r3, r3
 8021c60:	60fb      	str	r3, [r7, #12]
    curr_psc = (capture_reg & BLDC_SCALAR_HALL_CAPTURE_PRESCALAR_MASK) >> BLDC_SCALAR_HALL_CAPTURE_PRESCALAR_POS;
 8021c62:	693b      	ldr	r3, [r7, #16]
 8021c64:	0c1b      	lsrs	r3, r3, #16
 8021c66:	f003 030f 	and.w	r3, r3, #15
 8021c6a:	60bb      	str	r3, [r7, #8]
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval += BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)]
 8021c6c:	4b18      	ldr	r3, [pc, #96]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c6e:	685a      	ldr	r2, [r3, #4]
 8021c70:	68bb      	ldr	r3, [r7, #8]
 8021c72:	3b05      	subs	r3, #5
 8021c74:	4917      	ldr	r1, [pc, #92]	; (8021cd4 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe0>)
 8021c76:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                                   + (((uint32_t)1 << (uint32_t)(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * capval);
 8021c7a:	68bb      	ldr	r3, [r7, #8]
 8021c7c:	3b05      	subs	r3, #5
 8021c7e:	68f8      	ldr	r0, [r7, #12]
 8021c80:	fa00 f303 	lsl.w	r3, r0, r3
 8021c84:	440b      	add	r3, r1
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval += BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)]
 8021c86:	4413      	add	r3, r2
 8021c88:	4a11      	ldr	r2, [pc, #68]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c8a:	6053      	str	r3, [r2, #4]

    /*
     * STATE_IDENTIFICATION state execution needs three correct hall events. First
     * event is ignored and speed is calculated based on last two events
     */
    if (Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter == BLDC_SCALAR_HALL_CAPTURE_COUNTER)
 8021c8c:	4b10      	ldr	r3, [pc, #64]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c8e:	695b      	ldr	r3, [r3, #20]
 8021c90:	2b03      	cmp	r3, #3
 8021c92:	d102      	bne.n	8021c9a <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
    {
      Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done = 1U;
 8021c94:	4b0e      	ldr	r3, [pc, #56]	; (8021cd0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c96:	2201      	movs	r2, #1
 8021c98:	701a      	strb	r2, [r3, #0]
    }
  }
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021c9a:	f7ff fe89 	bl	80219b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021c9e:	4603      	mov	r3, r0
 8021ca0:	461a      	mov	r2, r3
 8021ca2:	4b0d      	ldr	r3, [pc, #52]	; (8021cd8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe4>)
 8021ca4:	745a      	strb	r2, [r3, #17]
  pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 8021ca6:	f7ff fe63 	bl	8021970 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 8021caa:	4603      	mov	r3, r0
 8021cac:	71fb      	strb	r3, [r7, #7]

  /* next hall pattern in hall shadow register*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
 8021cae:	79fa      	ldrb	r2, [r7, #7]
 8021cb0:	7dfb      	ldrb	r3, [r7, #23]
 8021cb2:	4413      	add	r3, r2
 8021cb4:	4a08      	ldr	r2, [pc, #32]	; (8021cd8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe4>)
 8021cb6:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021cb8:	4618      	mov	r0, r3
 8021cba:	f7ff fe3f 	bl	802193c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>

  /* clear correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8021cbe:	2000      	movs	r0, #0
 8021cc0:	f7ff fec4 	bl	8021a4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>
}
 8021cc4:	bf00      	nop
 8021cc6:	3718      	adds	r7, #24
 8021cc8:	46bd      	mov	sp, r7
 8021cca:	bd80      	pop	{r7, pc}
 8021ccc:	2000018c 	.word	0x2000018c
 8021cd0:	2000016c 	.word	0x2000016c
 8021cd4:	20000000 	.word	0x20000000
 8021cd8:	20000158 	.word	0x20000158

08021cdc <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021cdc:	b480      	push	{r7}
 8021cde:	b083      	sub	sp, #12
 8021ce0:	af00      	add	r7, sp, #0
 8021ce2:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021ce4:	687b      	ldr	r3, [r7, #4]
 8021ce6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021cea:	b2db      	uxtb	r3, r3
 8021cec:	115b      	asrs	r3, r3, #5
 8021cee:	b2db      	uxtb	r3, r3
 8021cf0:	f003 0307 	and.w	r3, r3, #7
 8021cf4:	b2db      	uxtb	r3, r3
}
 8021cf6:	4618      	mov	r0, r3
 8021cf8:	370c      	adds	r7, #12
 8021cfa:	46bd      	mov	sp, r7
 8021cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d00:	4770      	bx	lr

08021d02 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8021d02:	b480      	push	{r7}
 8021d04:	b083      	sub	sp, #12
 8021d06:	af00      	add	r7, sp, #0
 8021d08:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8021d0a:	687b      	ldr	r3, [r7, #4]
 8021d0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021d0e:	08db      	lsrs	r3, r3, #3
 8021d10:	b2db      	uxtb	r3, r3
 8021d12:	f003 0307 	and.w	r3, r3, #7
 8021d16:	b2db      	uxtb	r3, r3
}
 8021d18:	4618      	mov	r0, r3
 8021d1a:	370c      	adds	r7, #12
 8021d1c:	46bd      	mov	sp, r7
 8021d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d22:	4770      	bx	lr

08021d24 <XMC_POSIF_HSC_SetHallPatterns>:
{
 8021d24:	b480      	push	{r7}
 8021d26:	b083      	sub	sp, #12
 8021d28:	af00      	add	r7, sp, #0
 8021d2a:	6078      	str	r0, [r7, #4]
 8021d2c:	460b      	mov	r3, r1
 8021d2e:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8021d30:	78fb      	ldrb	r3, [r7, #3]
 8021d32:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8021d36:	687b      	ldr	r3, [r7, #4]
 8021d38:	635a      	str	r2, [r3, #52]	; 0x34
}
 8021d3a:	bf00      	nop
 8021d3c:	370c      	adds	r7, #12
 8021d3e:	46bd      	mov	sp, r7
 8021d40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d44:	4770      	bx	lr

08021d46 <XMC_POSIF_MCM_SetMultiChannelPattern>:
{
 8021d46:	b480      	push	{r7}
 8021d48:	b083      	sub	sp, #12
 8021d4a:	af00      	add	r7, sp, #0
 8021d4c:	6078      	str	r0, [r7, #4]
 8021d4e:	460b      	mov	r3, r1
 8021d50:	807b      	strh	r3, [r7, #2]
  peripheral->MCSM = pattern;
 8021d52:	887a      	ldrh	r2, [r7, #2]
 8021d54:	687b      	ldr	r3, [r7, #4]
 8021d56:	645a      	str	r2, [r3, #68]	; 0x44
}
 8021d58:	bf00      	nop
 8021d5a:	370c      	adds	r7, #12
 8021d5c:	46bd      	mov	sp, r7
 8021d5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d62:	4770      	bx	lr

08021d64 <XMC_POSIF_MCM_GetMultiChannelPattern>:
{
 8021d64:	b480      	push	{r7}
 8021d66:	b083      	sub	sp, #12
 8021d68:	af00      	add	r7, sp, #0
 8021d6a:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCM & (uint32_t)POSIF_MCM_MCMP_Msk));
 8021d6c:	687b      	ldr	r3, [r7, #4]
 8021d6e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8021d70:	b29b      	uxth	r3, r3
}
 8021d72:	4618      	mov	r0, r3
 8021d74:	370c      	adds	r7, #12
 8021d76:	46bd      	mov	sp, r7
 8021d78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d7c:	4770      	bx	lr

08021d7e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>:
{
 8021d7e:	b480      	push	{r7}
 8021d80:	b083      	sub	sp, #12
 8021d82:	af00      	add	r7, sp, #0
 8021d84:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCSM & (uint32_t)POSIF_MCSM_MCMPS_Msk));
 8021d86:	687b      	ldr	r3, [r7, #4]
 8021d88:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8021d8a:	b29b      	uxth	r3, r3
}
 8021d8c:	4618      	mov	r0, r3
 8021d8e:	370c      	adds	r7, #12
 8021d90:	46bd      	mov	sp, r7
 8021d92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d96:	4770      	bx	lr

08021d98 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue>:
{
 8021d98:	b580      	push	{r7, lr}
 8021d9a:	b086      	sub	sp, #24
 8021d9c:	af00      	add	r7, sp, #0
 8021d9e:	6078      	str	r0, [r7, #4]
  BLDC_SCALAR_SPEED_POS_HALL_STATUS_t status = BLDC_SCALAR_SPEED_POS_HALL_STATUS_FAILURE;  /* return status */
 8021da0:	2301      	movs	r3, #1
 8021da2:	75fb      	strb	r3, [r7, #23]
  temp_capval = (uint32_t)XMC_CCU4_SLICE_GetCaptureRegisterValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, BLDC_SCALAR_HALL_CAPTURE_REGITSER);
 8021da4:	2103      	movs	r1, #3
 8021da6:	4816      	ldr	r0, [pc, #88]	; (8021e00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x68>)
 8021da8:	f005 ff5c 	bl	8027c64 <XMC_CCU4_SLICE_GetCaptureRegisterValue>
 8021dac:	6138      	str	r0, [r7, #16]
  if (((temp_capval & (uint32_t)CCU4_CC4_CV_FFL_Msk) >> CCU4_CC4_CV_FFL_Pos) == 1U)
 8021dae:	693b      	ldr	r3, [r7, #16]
 8021db0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8021db4:	2b00      	cmp	r3, #0
 8021db6:	d01b      	beq.n	8021df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x58>
    curr_psc = ((temp_capval & (uint32_t)CCU4_CC4_CV_FPCV_Msk) >> (uint32_t)CCU4_CC4_CV_FPCV_Pos);
 8021db8:	693b      	ldr	r3, [r7, #16]
 8021dba:	0c1b      	lsrs	r3, r3, #16
 8021dbc:	f003 030f 	and.w	r3, r3, #15
 8021dc0:	60fb      	str	r3, [r7, #12]
    temp_capval = temp_capval & BLDC_SCALAR_SPEED_POS_HALL_CAP_COMP_VAL;
 8021dc2:	693b      	ldr	r3, [r7, #16]
 8021dc4:	b29b      	uxth	r3, r3
 8021dc6:	613b      	str	r3, [r7, #16]
        (uint32_t)(BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021dc8:	68fb      	ldr	r3, [r7, #12]
 8021dca:	3b05      	subs	r3, #5
 8021dcc:	4a0d      	ldr	r2, [pc, #52]	; (8021e04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x6c>)
 8021dce:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
        (((uint32_t)1 << (curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * (uint32_t)temp_capval));
 8021dd2:	68fb      	ldr	r3, [r7, #12]
 8021dd4:	3b05      	subs	r3, #5
 8021dd6:	6939      	ldr	r1, [r7, #16]
 8021dd8:	fa01 f303 	lsl.w	r3, r1, r3
        (uint32_t)(BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021ddc:	4413      	add	r3, r2
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval =
 8021dde:	4a0a      	ldr	r2, [pc, #40]	; (8021e08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x70>)
 8021de0:	6193      	str	r3, [r2, #24]
    *capval = (uint32_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval;
 8021de2:	4b09      	ldr	r3, [pc, #36]	; (8021e08 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x70>)
 8021de4:	699a      	ldr	r2, [r3, #24]
 8021de6:	687b      	ldr	r3, [r7, #4]
 8021de8:	601a      	str	r2, [r3, #0]
    status = BLDC_SCALAR_SPEED_POS_HALL_STATUS_SUCCESS;
 8021dea:	2300      	movs	r3, #0
 8021dec:	75fb      	strb	r3, [r7, #23]
 8021dee:	e002      	b.n	8021df6 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x5e>
    *capval = 0U;
 8021df0:	687b      	ldr	r3, [r7, #4]
 8021df2:	2200      	movs	r2, #0
 8021df4:	601a      	str	r2, [r3, #0]
  return (status);
 8021df6:	7dfb      	ldrb	r3, [r7, #23]
}
 8021df8:	4618      	mov	r0, r3
 8021dfa:	3718      	adds	r7, #24
 8021dfc:	46bd      	mov	sp, r7
 8021dfe:	bd80      	pop	{r7, pc}
 8021e00:	4000c200 	.word	0x4000c200
 8021e04:	20000000 	.word	0x20000000
 8021e08:	200000f8 	.word	0x200000f8

08021e0c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern>:
{
 8021e0c:	b580      	push	{r7, lr}
 8021e0e:	b082      	sub	sp, #8
 8021e10:	af00      	add	r7, sp, #0
 8021e12:	4603      	mov	r3, r0
 8021e14:	80fb      	strh	r3, [r7, #6]
  XMC_POSIF_MCM_SetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021e16:	88fb      	ldrh	r3, [r7, #6]
 8021e18:	4619      	mov	r1, r3
 8021e1a:	4803      	ldr	r0, [pc, #12]	; (8021e28 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern+0x1c>)
 8021e1c:	f7ff ff93 	bl	8021d46 <XMC_POSIF_MCM_SetMultiChannelPattern>
}
 8021e20:	bf00      	nop
 8021e22:	3708      	adds	r7, #8
 8021e24:	46bd      	mov	sp, r7
 8021e26:	bd80      	pop	{r7, pc}
 8021e28:	40028000 	.word	0x40028000

08021e2c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern>:
{
 8021e2c:	b580      	push	{r7, lr}
 8021e2e:	b082      	sub	sp, #8
 8021e30:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_MCM_GetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e32:	4805      	ldr	r0, [pc, #20]	; (8021e48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern+0x1c>)
 8021e34:	f7ff ff96 	bl	8021d64 <XMC_POSIF_MCM_GetMultiChannelPattern>
 8021e38:	4603      	mov	r3, r0
 8021e3a:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8021e3c:	88fb      	ldrh	r3, [r7, #6]
}
 8021e3e:	4618      	mov	r0, r3
 8021e40:	3708      	adds	r7, #8
 8021e42:	46bd      	mov	sp, r7
 8021e44:	bd80      	pop	{r7, pc}
 8021e46:	bf00      	nop
 8021e48:	40028000 	.word	0x40028000

08021e4c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern>:
{
 8021e4c:	b580      	push	{r7, lr}
 8021e4e:	b082      	sub	sp, #8
 8021e50:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_MCM_GetShadowMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e52:	4805      	ldr	r0, [pc, #20]	; (8021e68 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern+0x1c>)
 8021e54:	f7ff ff93 	bl	8021d7e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>
 8021e58:	4603      	mov	r3, r0
 8021e5a:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8021e5c:	88fb      	ldrh	r3, [r7, #6]
}
 8021e5e:	4618      	mov	r0, r3
 8021e60:	3708      	adds	r7, #8
 8021e62:	46bd      	mov	sp, r7
 8021e64:	bd80      	pop	{r7, pc}
 8021e66:	bf00      	nop
 8021e68:	40028000 	.word	0x40028000

08021e6c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8021e6c:	b580      	push	{r7, lr}
 8021e6e:	b082      	sub	sp, #8
 8021e70:	af00      	add	r7, sp, #0
 8021e72:	4603      	mov	r3, r0
 8021e74:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021e76:	79fb      	ldrb	r3, [r7, #7]
 8021e78:	4619      	mov	r1, r3
 8021e7a:	4803      	ldr	r0, [pc, #12]	; (8021e88 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8021e7c:	f7ff ff52 	bl	8021d24 <XMC_POSIF_HSC_SetHallPatterns>
}
 8021e80:	bf00      	nop
 8021e82:	3708      	adds	r7, #8
 8021e84:	46bd      	mov	sp, r7
 8021e86:	bd80      	pop	{r7, pc}
 8021e88:	40028000 	.word	0x40028000

08021e8c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8021e8c:	b580      	push	{r7, lr}
 8021e8e:	b082      	sub	sp, #8
 8021e90:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e92:	4805      	ldr	r0, [pc, #20]	; (8021ea8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8021e94:	f7ff ff35 	bl	8021d02 <XMC_POSIF_HSC_GetExpectedPattern>
 8021e98:	4603      	mov	r3, r0
 8021e9a:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8021e9c:	79fb      	ldrb	r3, [r7, #7]
}
 8021e9e:	4618      	mov	r0, r3
 8021ea0:	3708      	adds	r7, #8
 8021ea2:	46bd      	mov	sp, r7
 8021ea4:	bd80      	pop	{r7, pc}
 8021ea6:	bf00      	nop
 8021ea8:	40028000 	.word	0x40028000

08021eac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
{
 8021eac:	b580      	push	{r7, lr}
 8021eae:	b082      	sub	sp, #8
 8021eb0:	af00      	add	r7, sp, #0
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021eb2:	4805      	ldr	r0, [pc, #20]	; (8021ec8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 8021eb4:	f7ff ff12 	bl	8021cdc <XMC_POSIF_HSC_GetLastSampledPattern>
 8021eb8:	4603      	mov	r3, r0
 8021eba:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 8021ebc:	79fb      	ldrb	r3, [r7, #7]
}
 8021ebe:	4618      	mov	r0, r3
 8021ec0:	3708      	adds	r7, #8
 8021ec2:	46bd      	mov	sp, r7
 8021ec4:	bd80      	pop	{r7, pc}
 8021ec6:	bf00      	nop
 8021ec8:	40028000 	.word	0x40028000

08021ecc <XMC_VADC_GROUP_GetResult>:
{
 8021ecc:	b480      	push	{r7}
 8021ece:	b083      	sub	sp, #12
 8021ed0:	af00      	add	r7, sp, #0
 8021ed2:	6078      	str	r0, [r7, #4]
 8021ed4:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8021ed6:	687b      	ldr	r3, [r7, #4]
 8021ed8:	683a      	ldr	r2, [r7, #0]
 8021eda:	32c0      	adds	r2, #192	; 0xc0
 8021edc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8021ee0:	b29b      	uxth	r3, r3
}
 8021ee2:	4618      	mov	r0, r3
 8021ee4:	370c      	adds	r7, #12
 8021ee6:	46bd      	mov	sp, r7
 8021ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021eec:	4770      	bx	lr

08021eee <VADC_GetResult>:
{
 8021eee:	b580      	push	{r7, lr}
 8021ef0:	b084      	sub	sp, #16
 8021ef2:	af00      	add	r7, sp, #0
 8021ef4:	6078      	str	r0, [r7, #4]
 8021ef6:	6039      	str	r1, [r7, #0]
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8021ef8:	6839      	ldr	r1, [r7, #0]
 8021efa:	6878      	ldr	r0, [r7, #4]
 8021efc:	f7ff ffe6 	bl	8021ecc <XMC_VADC_GROUP_GetResult>
 8021f00:	4603      	mov	r3, r0
 8021f02:	81fb      	strh	r3, [r7, #14]
  return(result);
 8021f04:	89fb      	ldrh	r3, [r7, #14]
}
 8021f06:	4618      	mov	r0, r3
 8021f08:	3710      	adds	r7, #16
 8021f0a:	46bd      	mov	sp, r7
 8021f0c:	bd80      	pop	{r7, pc}

08021f0e <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>:
{
 8021f0e:	b480      	push	{r7}
 8021f10:	b087      	sub	sp, #28
 8021f12:	af00      	add	r7, sp, #0
 8021f14:	60f8      	str	r0, [r7, #12]
 8021f16:	60b9      	str	r1, [r7, #8]
 8021f18:	607a      	str	r2, [r7, #4]
  if ( input_val > higher_limit )
 8021f1a:	68fa      	ldr	r2, [r7, #12]
 8021f1c:	68bb      	ldr	r3, [r7, #8]
 8021f1e:	429a      	cmp	r2, r3
 8021f20:	dd02      	ble.n	8021f28 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x1a>
    return_val = higher_limit;
 8021f22:	68bb      	ldr	r3, [r7, #8]
 8021f24:	617b      	str	r3, [r7, #20]
 8021f26:	e008      	b.n	8021f3a <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  else if ( input_val < lower_limit )
 8021f28:	68fa      	ldr	r2, [r7, #12]
 8021f2a:	687b      	ldr	r3, [r7, #4]
 8021f2c:	429a      	cmp	r2, r3
 8021f2e:	da02      	bge.n	8021f36 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x28>
    return_val = lower_limit;
 8021f30:	687b      	ldr	r3, [r7, #4]
 8021f32:	617b      	str	r3, [r7, #20]
 8021f34:	e001      	b.n	8021f3a <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
    return_val = input_val;
 8021f36:	68fb      	ldr	r3, [r7, #12]
 8021f38:	617b      	str	r3, [r7, #20]
  return return_val;
 8021f3a:	697b      	ldr	r3, [r7, #20]
}
 8021f3c:	4618      	mov	r0, r3
 8021f3e:	371c      	adds	r7, #28
 8021f40:	46bd      	mov	sp, r7
 8021f42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f46:	4770      	bx	lr

08021f48 <Motor0_BLDC_SCALAR_PT1_Filter>:
{
 8021f48:	b590      	push	{r4, r7, lr}
 8021f4a:	b083      	sub	sp, #12
 8021f4c:	af00      	add	r7, sp, #0
 8021f4e:	6078      	str	r0, [r7, #4]
 8021f50:	6039      	str	r1, [r7, #0]
  temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16)));
 8021f52:	687b      	ldr	r3, [r7, #4]
 8021f54:	691a      	ldr	r2, [r3, #16]
 8021f56:	687b      	ldr	r3, [r7, #4]
 8021f58:	681b      	ldr	r3, [r3, #0]
 8021f5a:	6879      	ldr	r1, [r7, #4]
 8021f5c:	6909      	ldr	r1, [r1, #16]
 8021f5e:	1409      	asrs	r1, r1, #16
 8021f60:	6838      	ldr	r0, [r7, #0]
 8021f62:	1a41      	subs	r1, r0, r1
 8021f64:	fb01 f303 	mul.w	r3, r1, r3
 8021f68:	18d4      	adds	r4, r2, r3
  handle_ptr->pt1_buf = Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(temp_buff, handle_ptr->y_max, handle_ptr->y_min);
 8021f6a:	687b      	ldr	r3, [r7, #4]
 8021f6c:	6899      	ldr	r1, [r3, #8]
 8021f6e:	687b      	ldr	r3, [r7, #4]
 8021f70:	68db      	ldr	r3, [r3, #12]
 8021f72:	461a      	mov	r2, r3
 8021f74:	4620      	mov	r0, r4
 8021f76:	f7ff ffca 	bl	8021f0e <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>
 8021f7a:	4602      	mov	r2, r0
 8021f7c:	687b      	ldr	r3, [r7, #4]
 8021f7e:	611a      	str	r2, [r3, #16]
  handle_ptr->pt1_out_val = (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16);
 8021f80:	687b      	ldr	r3, [r7, #4]
 8021f82:	691b      	ldr	r3, [r3, #16]
 8021f84:	141a      	asrs	r2, r3, #16
 8021f86:	687b      	ldr	r3, [r7, #4]
 8021f88:	615a      	str	r2, [r3, #20]
}
 8021f8a:	bf00      	nop
 8021f8c:	370c      	adds	r7, #12
 8021f8e:	46bd      	mov	sp, r7
 8021f90:	bd90      	pop	{r4, r7, pc}
	...

08021f94 <Motor0_BLDC_SCALAR_GetCurrentValue>:
{
 8021f94:	b580      	push	{r7, lr}
 8021f96:	b084      	sub	sp, #16
 8021f98:	af00      	add	r7, sp, #0
 8021f9a:	6078      	str	r0, [r7, #4]
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 8021f9c:	2105      	movs	r1, #5
 8021f9e:	4821      	ldr	r0, [pc, #132]	; (8022024 <Motor0_BLDC_SCALAR_GetCurrentValue+0x90>)
 8021fa0:	f7ff ffa5 	bl	8021eee <VADC_GetResult>
 8021fa4:	4603      	mov	r3, r0
 8021fa6:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 8021fa8:	4b1f      	ldr	r3, [pc, #124]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021faa:	681b      	ldr	r3, [r3, #0]
 8021fac:	68fa      	ldr	r2, [r7, #12]
 8021fae:	1ad3      	subs	r3, r2, r3
 8021fb0:	4a1d      	ldr	r2, [pc, #116]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fb2:	6892      	ldr	r2, [r2, #8]
 8021fb4:	fb02 f303 	mul.w	r3, r2, r3
 8021fb8:	139b      	asrs	r3, r3, #14
 8021fba:	60fb      	str	r3, [r7, #12]
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_DirectCurrent,(int32_t)current_value);
 8021fbc:	68f9      	ldr	r1, [r7, #12]
 8021fbe:	481b      	ldr	r0, [pc, #108]	; (802202c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021fc0:	f7ff ffc2 	bl	8021f48 <Motor0_BLDC_SCALAR_PT1_Filter>
  current_value = ((Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_out_val));
 8021fc4:	4b19      	ldr	r3, [pc, #100]	; (802202c <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021fc6:	695b      	ldr	r3, [r3, #20]
 8021fc8:	60fb      	str	r3, [r7, #12]
  if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable == 1U)
 8021fca:	4b17      	ldr	r3, [pc, #92]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fcc:	f893 3020 	ldrb.w	r3, [r3, #32]
 8021fd0:	2b01      	cmp	r3, #1
 8021fd2:	d11c      	bne.n	802200e <Motor0_BLDC_SCALAR_GetCurrentValue+0x7a>
    Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter++;
 8021fd4:	4b14      	ldr	r3, [pc, #80]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fd6:	69db      	ldr	r3, [r3, #28]
 8021fd8:	3301      	adds	r3, #1
 8021fda:	4a13      	ldr	r2, [pc, #76]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fdc:	61d3      	str	r3, [r2, #28]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021fde:	4b12      	ldr	r3, [pc, #72]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fe0:	69da      	ldr	r2, [r3, #28]
        Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_count)
 8021fe2:	4b11      	ldr	r3, [pc, #68]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fe4:	699b      	ldr	r3, [r3, #24]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021fe6:	429a      	cmp	r2, r3
 8021fe8:	d90c      	bls.n	8022004 <Motor0_BLDC_SCALAR_GetCurrentValue+0x70>
     *dclink_current = current_value;
 8021fea:	687b      	ldr	r3, [r7, #4]
 8021fec:	68fa      	ldr	r2, [r7, #12]
 8021fee:	601a      	str	r2, [r3, #0]
     Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current = current_value;
 8021ff0:	4a0d      	ldr	r2, [pc, #52]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ff2:	68fb      	ldr	r3, [r7, #12]
 8021ff4:	6113      	str	r3, [r2, #16]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 8021ff6:	4b0c      	ldr	r3, [pc, #48]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ff8:	2200      	movs	r2, #0
 8021ffa:	61da      	str	r2, [r3, #28]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 0U;
 8021ffc:	4b0a      	ldr	r3, [pc, #40]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ffe:	2200      	movs	r2, #0
 8022000:	f883 2020 	strb.w	r2, [r3, #32]
    *dclink_current = Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current;
 8022004:	4b08      	ldr	r3, [pc, #32]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8022006:	691a      	ldr	r2, [r3, #16]
 8022008:	687b      	ldr	r3, [r7, #4]
 802200a:	601a      	str	r2, [r3, #0]
}
 802200c:	e005      	b.n	802201a <Motor0_BLDC_SCALAR_GetCurrentValue+0x86>
    *dclink_current = current_value;
 802200e:	687b      	ldr	r3, [r7, #4]
 8022010:	68fa      	ldr	r2, [r7, #12]
 8022012:	601a      	str	r2, [r3, #0]
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
 8022014:	4a04      	ldr	r2, [pc, #16]	; (8022028 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8022016:	68fb      	ldr	r3, [r7, #12]
 8022018:	6113      	str	r3, [r2, #16]
}
 802201a:	bf00      	nop
 802201c:	3710      	adds	r7, #16
 802201e:	46bd      	mov	sp, r7
 8022020:	bd80      	pop	{r7, pc}
 8022022:	bf00      	nop
 8022024:	40005000 	.word	0x40005000
 8022028:	20000124 	.word	0x20000124
 802202c:	200000a4 	.word	0x200000a4

08022030 <VADC0_C0_0_IRQHandler>:
 * Current protection - Global boundary \n
 * Voltage protection - Group specific boundary \n
 */
#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
void Motor0_BLDC_SCALAR_Protection_ISR(void)
{
 8022030:	b580      	push	{r7, lr}
 8022032:	b082      	sub	sp, #8
 8022034:	af00      	add	r7, sp, #0
  int32_t current;   /* ADC value of the current in Q14 */
  /*******************************Current Protection ****************************************************/
  /* Direct DC link current measurement is used for over-current protection */
#if ((MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE == BLDC_SCALAR_IDC_DIRECT_CURRENT) && (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U))
  /* Check whether the interrupt is due to current limit overshoot */
  if ((((MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP->CEFLAG) >> MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM) & 0x1U) == 0x1U)
 8022036:	4b21      	ldr	r3, [pc, #132]	; (80220bc <VADC0_C0_0_IRQHandler+0x8c>)
 8022038:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 802203c:	095b      	lsrs	r3, r3, #5
 802203e:	f003 0301 	and.w	r3, r3, #1
 8022042:	2b01      	cmp	r3, #1
 8022044:	d135      	bne.n	80220b2 <VADC0_C0_0_IRQHandler+0x82>
  {
    /* Read the current value for short-circuit protection */
    Motor0_BLDC_SCALAR_GetCurrentValue(&current);
 8022046:	1d3b      	adds	r3, r7, #4
 8022048:	4618      	mov	r0, r3
 802204a:	f7ff ffa3 	bl	8021f94 <Motor0_BLDC_SCALAR_GetCurrentValue>
    if ((current > Motor0_BLDC_SCALAR_CurrentMeasurement.short_circuit_current) ||
 802204e:	4b1c      	ldr	r3, [pc, #112]	; (80220c0 <VADC0_C0_0_IRQHandler+0x90>)
 8022050:	68da      	ldr	r2, [r3, #12]
 8022052:	687b      	ldr	r3, [r7, #4]
 8022054:	429a      	cmp	r2, r3
 8022056:	db04      	blt.n	8022062 <VADC0_C0_0_IRQHandler+0x32>
        (current > BLDC_SCALAR_VADC_MAX_CURRENT_LIMIT))
 8022058:	687b      	ldr	r3, [r7, #4]
    if ((current > Motor0_BLDC_SCALAR_CurrentMeasurement.short_circuit_current) ||
 802205a:	f643 72d8 	movw	r2, #16344	; 0x3fd8
 802205e:	4293      	cmp	r3, r2
 8022060:	dd0c      	ble.n	802207c <VADC0_C0_0_IRQHandler+0x4c>
    {
      /* Stop the motor immediately if current is greater than configured short circuit current */
      Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_SHORTCIRCUIT;
 8022062:	4b18      	ldr	r3, [pc, #96]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022064:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8022066:	f043 0304 	orr.w	r3, r3, #4
 802206a:	4a16      	ldr	r2, [pc, #88]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802206c:	6693      	str	r3, [r2, #104]	; 0x68
      Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 802206e:	4b15      	ldr	r3, [pc, #84]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022070:	2208      	movs	r2, #8
 8022072:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      Motor0_BLDC_SCALAR_MotorStop();
 8022076:	f000 fc8f 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
      }
    }
  }
#endif /* end of #if (MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE == BLDC_SCALAR_IDC_AVG_CURRENT)*/
#endif
}
 802207a:	e01a      	b.n	80220b2 <VADC0_C0_0_IRQHandler+0x82>
      Motor0_BLDC_SCALAR.overcurrent_counter += 2U;
 802207c:	4b11      	ldr	r3, [pc, #68]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802207e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8022082:	3302      	adds	r3, #2
 8022084:	4a0f      	ldr	r2, [pc, #60]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022086:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
      if (Motor0_BLDC_SCALAR.overcurrent_counter > Motor0_BLDC_SCALAR.overcurrent_count)
 802208a:	4b0e      	ldr	r3, [pc, #56]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802208c:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8022090:	4b0c      	ldr	r3, [pc, #48]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 8022092:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8022096:	429a      	cmp	r2, r3
 8022098:	d90b      	bls.n	80220b2 <VADC0_C0_0_IRQHandler+0x82>
        Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_OVERCURRENT;
 802209a:	4b0a      	ldr	r3, [pc, #40]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 802209c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 802209e:	f043 0302 	orr.w	r3, r3, #2
 80220a2:	4a08      	ldr	r2, [pc, #32]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 80220a4:	6693      	str	r3, [r2, #104]	; 0x68
        Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 80220a6:	4b07      	ldr	r3, [pc, #28]	; (80220c4 <VADC0_C0_0_IRQHandler+0x94>)
 80220a8:	2208      	movs	r2, #8
 80220aa:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
        Motor0_BLDC_SCALAR_MotorStop();
 80220ae:	f000 fc73 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
}
 80220b2:	bf00      	nop
 80220b4:	3708      	adds	r7, #8
 80220b6:	46bd      	mov	sp, r7
 80220b8:	bd80      	pop	{r7, pc}
 80220ba:	bf00      	nop
 80220bc:	40005000 	.word	0x40005000
 80220c0:	20000124 	.word	0x20000124
 80220c4:	2000018c 	.word	0x2000018c

080220c8 <__NVIC_ClearPendingIRQ>:
{
 80220c8:	b480      	push	{r7}
 80220ca:	b083      	sub	sp, #12
 80220cc:	af00      	add	r7, sp, #0
 80220ce:	4603      	mov	r3, r0
 80220d0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80220d2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80220d6:	2b00      	cmp	r3, #0
 80220d8:	db0c      	blt.n	80220f4 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80220da:	79fb      	ldrb	r3, [r7, #7]
 80220dc:	f003 021f 	and.w	r2, r3, #31
 80220e0:	4907      	ldr	r1, [pc, #28]	; (8022100 <__NVIC_ClearPendingIRQ+0x38>)
 80220e2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80220e6:	095b      	lsrs	r3, r3, #5
 80220e8:	2001      	movs	r0, #1
 80220ea:	fa00 f202 	lsl.w	r2, r0, r2
 80220ee:	3360      	adds	r3, #96	; 0x60
 80220f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80220f4:	bf00      	nop
 80220f6:	370c      	adds	r7, #12
 80220f8:	46bd      	mov	sp, r7
 80220fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80220fe:	4770      	bx	lr
 8022100:	e000e100 	.word	0xe000e100

08022104 <XMC_SCU_SetCcuTriggerHigh>:
{
 8022104:	b480      	push	{r7}
 8022106:	b083      	sub	sp, #12
 8022108:	af00      	add	r7, sp, #0
 802210a:	6078      	str	r0, [r7, #4]
  SCU_GENERAL->CCUCON |= (uint32_t)trigger;
 802210c:	4b05      	ldr	r3, [pc, #20]	; (8022124 <XMC_SCU_SetCcuTriggerHigh+0x20>)
 802210e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8022110:	4904      	ldr	r1, [pc, #16]	; (8022124 <XMC_SCU_SetCcuTriggerHigh+0x20>)
 8022112:	687b      	ldr	r3, [r7, #4]
 8022114:	4313      	orrs	r3, r2
 8022116:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 8022118:	bf00      	nop
 802211a:	370c      	adds	r7, #12
 802211c:	46bd      	mov	sp, r7
 802211e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022122:	4770      	bx	lr
 8022124:	50004000 	.word	0x50004000

08022128 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8022128:	b480      	push	{r7}
 802212a:	b083      	sub	sp, #12
 802212c:	af00      	add	r7, sp, #0
 802212e:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8022130:	687b      	ldr	r3, [r7, #4]
 8022132:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022134:	08db      	lsrs	r3, r3, #3
 8022136:	b2db      	uxtb	r3, r3
 8022138:	f003 0307 	and.w	r3, r3, #7
 802213c:	b2db      	uxtb	r3, r3
}
 802213e:	4618      	mov	r0, r3
 8022140:	370c      	adds	r7, #12
 8022142:	46bd      	mov	sp, r7
 8022144:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022148:	4770      	bx	lr

0802214a <XMC_POSIF_HSC_SetHallPatterns>:
{
 802214a:	b480      	push	{r7}
 802214c:	b083      	sub	sp, #12
 802214e:	af00      	add	r7, sp, #0
 8022150:	6078      	str	r0, [r7, #4]
 8022152:	460b      	mov	r3, r1
 8022154:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8022156:	78fb      	ldrb	r3, [r7, #3]
 8022158:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 802215c:	687b      	ldr	r3, [r7, #4]
 802215e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8022160:	bf00      	nop
 8022162:	370c      	adds	r7, #12
 8022164:	46bd      	mov	sp, r7
 8022166:	f85d 7b04 	ldr.w	r7, [sp], #4
 802216a:	4770      	bx	lr

0802216c <XMC_POSIF_HSC_UpdateHallPattern>:
{
 802216c:	b480      	push	{r7}
 802216e:	b083      	sub	sp, #12
 8022170:	af00      	add	r7, sp, #0
 8022172:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 8022174:	687b      	ldr	r3, [r7, #4]
 8022176:	2202      	movs	r2, #2
 8022178:	649a      	str	r2, [r3, #72]	; 0x48
}
 802217a:	bf00      	nop
 802217c:	370c      	adds	r7, #12
 802217e:	46bd      	mov	sp, r7
 8022180:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022184:	4770      	bx	lr

08022186 <XMC_POSIF_DisableEvent>:
{
 8022186:	b480      	push	{r7}
 8022188:	b083      	sub	sp, #12
 802218a:	af00      	add	r7, sp, #0
 802218c:	6078      	str	r0, [r7, #4]
 802218e:	460b      	mov	r3, r1
 8022190:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE &= ~((uint32_t)1 << (uint8_t)event);
 8022192:	687b      	ldr	r3, [r7, #4]
 8022194:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8022196:	78fb      	ldrb	r3, [r7, #3]
 8022198:	2101      	movs	r1, #1
 802219a:	fa01 f303 	lsl.w	r3, r1, r3
 802219e:	43db      	mvns	r3, r3
 80221a0:	401a      	ands	r2, r3
 80221a2:	687b      	ldr	r3, [r7, #4]
 80221a4:	675a      	str	r2, [r3, #116]	; 0x74
}
 80221a6:	bf00      	nop
 80221a8:	370c      	adds	r7, #12
 80221aa:	46bd      	mov	sp, r7
 80221ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80221b0:	4770      	bx	lr

080221b2 <Motor0_BLDC_SCALAR_CCU8_PWM_Start>:
 *
 * \par<b>Description:</b><br>
 * Set CCUCON trigger signal to high to start all slices synchronously.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_PWM_Start(void)
{
 80221b2:	b580      	push	{r7, lr}
 80221b4:	af00      	add	r7, sp, #0
  XMC_SCU_SetCcuTriggerHigh((uint32_t)MOTOR0_BLDC_SCALAR_CCU8_SYNC_START);
 80221b6:	f44f 7080 	mov.w	r0, #256	; 0x100
 80221ba:	f7ff ffa3 	bl	8022104 <XMC_SCU_SetCcuTriggerHigh>
}
 80221be:	bf00      	nop
 80221c0:	bd80      	pop	{r7, pc}
	...

080221c4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
{
 80221c4:	b480      	push	{r7}
 80221c6:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 80221c8:	4b12      	ldr	r3, [pc, #72]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221ca:	2200      	movs	r2, #0
 80221cc:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 80221d0:	4b10      	ldr	r3, [pc, #64]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221d2:	2200      	movs	r2, #0
 80221d4:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 80221d6:	4b0f      	ldr	r3, [pc, #60]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221d8:	2200      	movs	r2, #0
 80221da:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 80221dc:	4b0d      	ldr	r3, [pc, #52]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221de:	2200      	movs	r2, #0
 80221e0:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 80221e2:	4b0c      	ldr	r3, [pc, #48]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221e4:	2200      	movs	r2, #0
 80221e6:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 80221e8:	4b0a      	ldr	r3, [pc, #40]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221ea:	2200      	movs	r2, #0
 80221ec:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 80221ee:	4b09      	ldr	r3, [pc, #36]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221f0:	2200      	movs	r2, #0
 80221f2:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 80221f4:	4b07      	ldr	r3, [pc, #28]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221f6:	2200      	movs	r2, #0
 80221f8:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 80221fa:	4b06      	ldr	r3, [pc, #24]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80221fe:	4a05      	ldr	r2, [pc, #20]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8022200:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 8022202:	4b04      	ldr	r3, [pc, #16]	; (8022214 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8022204:	2200      	movs	r2, #0
 8022206:	621a      	str	r2, [r3, #32]
}
 8022208:	bf00      	nop
 802220a:	46bd      	mov	sp, r7
 802220c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022210:	4770      	bx	lr
 8022212:	bf00      	nop
 8022214:	200000f8 	.word	0x200000f8

08022218 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8022218:	b580      	push	{r7, lr}
 802221a:	b082      	sub	sp, #8
 802221c:	af00      	add	r7, sp, #0
 802221e:	4603      	mov	r3, r0
 8022220:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8022222:	79fb      	ldrb	r3, [r7, #7]
 8022224:	4619      	mov	r1, r3
 8022226:	4803      	ldr	r0, [pc, #12]	; (8022234 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8022228:	f7ff ff8f 	bl	802214a <XMC_POSIF_HSC_SetHallPatterns>
}
 802222c:	bf00      	nop
 802222e:	3708      	adds	r7, #8
 8022230:	46bd      	mov	sp, r7
 8022232:	bd80      	pop	{r7, pc}
 8022234:	40028000 	.word	0x40028000

08022238 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
{
 8022238:	b580      	push	{r7, lr}
 802223a:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802223c:	4802      	ldr	r0, [pc, #8]	; (8022248 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 802223e:	f7ff ff95 	bl	802216c <XMC_POSIF_HSC_UpdateHallPattern>
}
 8022242:	bf00      	nop
 8022244:	bd80      	pop	{r7, pc}
 8022246:	bf00      	nop
 8022248:	40028000 	.word	0x40028000

0802224c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 802224c:	b580      	push	{r7, lr}
 802224e:	b082      	sub	sp, #8
 8022250:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022252:	4805      	ldr	r0, [pc, #20]	; (8022268 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8022254:	f7ff ff68 	bl	8022128 <XMC_POSIF_HSC_GetExpectedPattern>
 8022258:	4603      	mov	r3, r0
 802225a:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 802225c:	79fb      	ldrb	r3, [r7, #7]
}
 802225e:	4618      	mov	r0, r3
 8022260:	3708      	adds	r7, #8
 8022262:	46bd      	mov	sp, r7
 8022264:	bd80      	pop	{r7, pc}
 8022266:	bf00      	nop
 8022268:	40028000 	.word	0x40028000

0802226c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>:
 *
 * \par<b>Description</b><br>
 * Disables event generation of peripheral.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 802226c:	b580      	push	{r7, lr}
 802226e:	b082      	sub	sp, #8
 8022270:	af00      	add	r7, sp, #0
 8022272:	4603      	mov	r3, r0
 8022274:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_DisableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8022276:	79fb      	ldrb	r3, [r7, #7]
 8022278:	4619      	mov	r1, r3
 802227a:	4803      	ldr	r0, [pc, #12]	; (8022288 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent+0x1c>)
 802227c:	f7ff ff83 	bl	8022186 <XMC_POSIF_DisableEvent>
}
 8022280:	bf00      	nop
 8022282:	3708      	adds	r7, #8
 8022284:	46bd      	mov	sp, r7
 8022286:	bd80      	pop	{r7, pc}
 8022288:	40028000 	.word	0x40028000

0802228c <Motor0_BLDC_SCALAR_MSM_START_Func>:
 * Initialize Motor control variables
 * Enable inverter
 * Enable interrupt for ctrap and protection
 */
static void Motor0_BLDC_SCALAR_MSM_START_Func(void)
{
 802228c:	b580      	push	{r7, lr}
 802228e:	af00      	add	r7, sp, #0
  /*Initialize all run time parameters*/
  Motor0_BLDC_SCALAR_MotorParamInit();
 8022290:	f000 fa7a 	bl	8022788 <Motor0_BLDC_SCALAR_MotorParamInit>
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*Enable inverter*/
  Motor0_BLDC_SCALAR_PWM_BC_InverterEnable();
 8022294:	f7fe fbbe 	bl	8020a14 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable>
  /* ISR Init for trap */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_CTRAP_NODE, MOTOR0_BLDC_SCALAR_TRAP_NVIC_PRIO,MOTOR0_BLDC_SCALAR_TRAP_NVIC_SUBPRIO);
#endif
#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  /* ISR Init for VADC channel event handler*/
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NODE, MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NVIC_PRIO,MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NVIC_SUBPRIO);
 8022298:	2200      	movs	r2, #0
 802229a:	213c      	movs	r1, #60	; 0x3c
 802229c:	200e      	movs	r0, #14
 802229e:	f7fe ff64 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
#endif

  Motor0_BLDC_SCALAR_MSM_START_Exit_Func();
 80222a2:	f000 f802 	bl	80222aa <Motor0_BLDC_SCALAR_MSM_START_Exit_Func>
}
 80222a6:	bf00      	nop
 80222a8:	bd80      	pop	{r7, pc}

080222aa <Motor0_BLDC_SCALAR_MSM_START_Exit_Func>:
 * BOOTSTRAP: if catch free running motor feature is disabled and bootstrap feature is enabled
 * HALL_LEARNING: if catch free running motor feature is disabled and bootstrap feature is disabled, and hall learning feature is enabled
 * NORMAL_OPERATION: if catch free running motor, bootstrap and hall learning features are disabled
 */
static void Motor0_BLDC_SCALAR_MSM_START_Exit_Func(void)
{
 80222aa:	b580      	push	{r7, lr}
 80222ac:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
  Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func();
 80222ae:	f000 f881 	bl	80223b4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func>
    Motor0_BLDC_SCALAR_MSM_HALL_LEARNING_Entry_Func();
  #else
    Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
  #endif
#endif  /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U) */
}
 80222b2:	bf00      	nop
 80222b4:	bd80      	pop	{r7, pc}
	...

080222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>:
 * Start the CCU8 for PWM
 * Disable correct hall event
 * Enable wrong hall event, multi-channel pattern shadow transfer event and CCU8 one match event
 */
static void Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func(void)
{
 80222b8:	b580      	push	{r7, lr}
 80222ba:	af00      	add	r7, sp, #0
  /* Disable correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 80222bc:	2000      	movs	r0, #0
 80222be:	f7ff ffd5 	bl	802226c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t) Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 80222c2:	f7fe fcab 	bl	8020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 80222c6:	4603      	mov	r3, r0
 80222c8:	b2da      	uxtb	r2, r3
 80222ca:	4b1a      	ldr	r3, [pc, #104]	; (8022334 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x7c>)
 80222cc:	745a      	strb	r2, [r3, #17]
  Motor0_BLDC_SCALAR_PatternInitiator(Motor0_BLDC_SCALAR_Hall.prev_hall_pos);
 80222ce:	4b19      	ldr	r3, [pc, #100]	; (8022334 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x7c>)
 80222d0:	7c5b      	ldrb	r3, [r3, #17]
 80222d2:	4618      	mov	r0, r3
 80222d4:	f008 fe74 	bl	802afc0 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
  NVIC_ClearPendingIRQ(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE);
 80222d8:	2044      	movs	r0, #68	; 0x44
 80222da:	f7ff fef5 	bl	80220c8 <__NVIC_ClearPendingIRQ>

  /* POSIF is in running mode in MOTOR_STATE_IDENTIFICATION state */
  if (Motor0_BLDC_SCALAR.msm_state != BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION)
 80222de:	4b16      	ldr	r3, [pc, #88]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 80222e0:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 80222e4:	b2db      	uxtb	r3, r3
 80222e6:	2b02      	cmp	r3, #2
 80222e8:	d006      	beq.n	80222f8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x40>
  {
    /* Start POSIF */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start();
 80222ea:	f7fe fc69 	bl	8020bc0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>

    /* ISR Init for wrong hall event*/
    BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE,MOTOR0_BLDC_SCALAR_HALL_NVIC_PRIO,MOTOR0_BLDC_SCALAR_HALL_NVIC_SUBPRIO);
 80222ee:	2200      	movs	r2, #0
 80222f0:	213d      	movs	r1, #61	; 0x3d
 80222f2:	2044      	movs	r0, #68	; 0x44
 80222f4:	f7fe ff39 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
  }

  /* ISR Init for pattern update handler */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NODE, MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NVIC_PRIO, MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NVIC_SUBPRIO);
 80222f8:	2200      	movs	r2, #0
 80222fa:	213d      	movs	r1, #61	; 0x3d
 80222fc:	2045      	movs	r0, #69	; 0x45
 80222fe:	f7fe ff34 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
  /* ISR Init for control loop */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_CTRL_LOOP_NODE, MOTOR0_BLDC_SCALAR_CTRL_LOOP_NVIC_PRIO,MOTOR0_BLDC_SCALAR_CTRL_LOOP_NVIC_SUBPRIO);
 8022302:	2200      	movs	r2, #0
 8022304:	213e      	movs	r1, #62	; 0x3e
 8022306:	203c      	movs	r0, #60	; 0x3c
 8022308:	f7fe ff2f 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>

  if ((Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_START) || (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION))
 802230c:	4b0a      	ldr	r3, [pc, #40]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 802230e:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8022312:	b2db      	uxtb	r3, r3
 8022314:	2b01      	cmp	r3, #1
 8022316:	d005      	beq.n	8022324 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x6c>
 8022318:	4b07      	ldr	r3, [pc, #28]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 802231a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 802231e:	b2db      	uxtb	r3, r3
 8022320:	2b02      	cmp	r3, #2
 8022322:	d101      	bne.n	8022328 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x70>
  {
    /* Start CCU8 */
    Motor0_BLDC_SCALAR_CCU8_PWM_Start();
 8022324:	f7ff ff45 	bl	80221b2 <Motor0_BLDC_SCALAR_CCU8_PWM_Start>
  }
  Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_NORMAL_OPERATION;
 8022328:	4b03      	ldr	r3, [pc, #12]	; (8022338 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 802232a:	2207      	movs	r2, #7
 802232c:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 8022330:	bf00      	nop
 8022332:	bd80      	pop	{r7, pc}
 8022334:	20000158 	.word	0x20000158
 8022338:	2000018c 	.word	0x2000018c

0802233c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func>:
 * Ramp
 * Stall detection
 * zero duty condition handling
 */
static void Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func(void)
{
 802233c:	b580      	push	{r7, lr}
 802233e:	b082      	sub	sp, #8
 8022340:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_AnalogIpMeasurement();
#endif

  /************************** Ramp start**************************/
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  Motor0_BLDC_SCALAR.set_val = Motor0_BLDC_SCALAR_Ramp.set_value;
 8022342:	4b18      	ldr	r3, [pc, #96]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022344:	681b      	ldr	r3, [r3, #0]
 8022346:	4a18      	ldr	r2, [pc, #96]	; (80223a8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 8022348:	6013      	str	r3, [r2, #0]
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR.analogip_val;
#else  /* potentiometer disabled */
  #if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  /* Speed control */
    Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 802234a:	4b18      	ldr	r3, [pc, #96]	; (80223ac <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x70>)
 802234c:	685b      	ldr	r3, [r3, #4]
 802234e:	4a15      	ldr	r2, [pc, #84]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022350:	6053      	str	r3, [r2, #4]
    Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR_VoltageControl.user_voltage_set;
  #endif

#endif /* end of #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U) */

  setval_diff =  ((Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value) *
 8022352:	4b14      	ldr	r3, [pc, #80]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022354:	685a      	ldr	r2, [r3, #4]
 8022356:	4b13      	ldr	r3, [pc, #76]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022358:	681b      	ldr	r3, [r3, #0]
 802235a:	1ad3      	subs	r3, r2, r3
                 Motor0_BLDC_SCALAR.motor_set_direction;
 802235c:	4a12      	ldr	r2, [pc, #72]	; (80223a8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 802235e:	6f92      	ldr	r2, [r2, #120]	; 0x78
  setval_diff =  ((Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value) *
 8022360:	fb02 f303 	mul.w	r3, r2, r3
 8022364:	607b      	str	r3, [r7, #4]

  /* Find whether ramp up or down is required based on set value */
  if (setval_diff < 0)
 8022366:	687b      	ldr	r3, [r7, #4]
 8022368:	2b00      	cmp	r3, #0
 802236a:	da04      	bge.n	8022376 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x3a>
  {
    Motor0_BLDC_SCALAR_Ramp.ramp_rate = Motor0_BLDC_SCALAR_Ramp.ramp_down_rate;
 802236c:	4b0d      	ldr	r3, [pc, #52]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802236e:	691b      	ldr	r3, [r3, #16]
 8022370:	4a0c      	ldr	r2, [pc, #48]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022372:	6093      	str	r3, [r2, #8]
 8022374:	e003      	b.n	802237e <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x42>
  }
  else
  {
    Motor0_BLDC_SCALAR_Ramp.ramp_rate = Motor0_BLDC_SCALAR_Ramp.ramp_up_rate;
 8022376:	4b0b      	ldr	r3, [pc, #44]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022378:	68db      	ldr	r3, [r3, #12]
 802237a:	4a0a      	ldr	r2, [pc, #40]	; (80223a4 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802237c:	6093      	str	r3, [r2, #8]
  {
    Motor0_BLDC_SCALAR_Ramp_Linear();
  }
  #else /* #if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_VDC_LINK_MEASUREMENT == 1U) */

  Motor0_BLDC_SCALAR_Ramp_Linear();
 802237e:	f008 fe23 	bl	802afc8 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer>
    {
      Motor0_BLDC_SCALAR.stall_check = 1U;
    }
#endif
    /* zero speed handling */
    curr_psc = (uint32_t)((uint32_t)MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE->FPC >> BLDC_SCALAR_HALL_CAPVAL_POS);
 8022382:	4b0b      	ldr	r3, [pc, #44]	; (80223b0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x74>)
 8022384:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022386:	0a1b      	lsrs	r3, r3, #8
 8022388:	603b      	str	r3, [r7, #0]
    /* reset the speed calculation related variables when prescaler is greater 11 */
    if (curr_psc > BLDC_SCALAR_PRESCALER_CMP_VALUE)
 802238a:	683b      	ldr	r3, [r7, #0]
 802238c:	2b0b      	cmp	r3, #11
 802238e:	d904      	bls.n	802239a <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x5e>
    {
      /* Reset speed calculation related variables */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8022390:	f7ff ff18 	bl	80221c4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>
      Motor0_BLDC_SCALAR.motor_speed = 0;
 8022394:	4b04      	ldr	r3, [pc, #16]	; (80223a8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 8022396:	2200      	movs	r2, #0
 8022398:	66da      	str	r2, [r3, #108]	; 0x6c
  {
    Motor0_BLDC_SCALAR_MSM_IDLE_Entry_Func();
  }
#endif

}
 802239a:	bf00      	nop
 802239c:	3708      	adds	r7, #8
 802239e:	46bd      	mov	sp, r7
 80223a0:	bd80      	pop	{r7, pc}
 80223a2:	bf00      	nop
 80223a4:	200000bc 	.word	0x200000bc
 80223a8:	2000018c 	.word	0x2000018c
 80223ac:	20000148 	.word	0x20000148
 80223b0:	4000c200 	.word	0x4000c200

080223b4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func>:
 * Enable correct and wrong hall event
 */

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
static void Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func(void)
{
 80223b4:	b580      	push	{r7, lr}
 80223b6:	b082      	sub	sp, #8
 80223b8:	af00      	add	r7, sp, #0
  uint8_t pattern_index;       /* hall pattern index */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 80223ba:	4b1b      	ldr	r3, [pc, #108]	; (8022428 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 80223bc:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80223be:	b2db      	uxtb	r3, r3
 80223c0:	f003 0308 	and.w	r3, r3, #8
 80223c4:	71fb      	strb	r3, [r7, #7]

  Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = Motor0_BLDC_SCALAR.motor_set_direction;
 80223c6:	4b18      	ldr	r3, [pc, #96]	; (8022428 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 80223c8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80223ca:	4a18      	ldr	r2, [pc, #96]	; (802242c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x78>)
 80223cc:	60d3      	str	r3, [r2, #12]

  /* Load initial hall pattern and start the POSIF */
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t) Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 80223ce:	f7fe fc25 	bl	8020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 80223d2:	4603      	mov	r3, r0
 80223d4:	b2da      	uxtb	r2, r3
 80223d6:	4b16      	ldr	r3, [pc, #88]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223d8:	745a      	strb	r2, [r3, #17]

  /* Update the hall pattern in shadow register and perform immediate transfer */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + (uint32_t) direction]));
 80223da:	4b15      	ldr	r3, [pc, #84]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223dc:	7c5b      	ldrb	r3, [r3, #17]
 80223de:	461a      	mov	r2, r3
 80223e0:	79fb      	ldrb	r3, [r7, #7]
 80223e2:	4413      	add	r3, r2
 80223e4:	4a12      	ldr	r2, [pc, #72]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223e6:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 80223e8:	4618      	mov	r0, r3
 80223ea:	f7ff ff15 	bl	8022218 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
 80223ee:	f7ff ff23 	bl	8022238 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>
  /*Get Expected Pattern*/
  pattern_index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 80223f2:	f7ff ff2b 	bl	802224c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 80223f6:	4603      	mov	r3, r0
 80223f8:	71bb      	strb	r3, [r7, #6]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pattern_index + (uint32_t) direction]));
 80223fa:	79ba      	ldrb	r2, [r7, #6]
 80223fc:	79fb      	ldrb	r3, [r7, #7]
 80223fe:	4413      	add	r3, r2
 8022400:	4a0b      	ldr	r2, [pc, #44]	; (8022430 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 8022402:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8022404:	4618      	mov	r0, r3
 8022406:	f7ff ff07 	bl	8022218 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>

  /* Start POSIF */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start();
 802240a:	f7fe fbd9 	bl	8020bc0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>
  /* ISR Init for wrong hall event and correct hall event handler*/
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE, MOTOR0_BLDC_SCALAR_HALL_NVIC_PRIO,MOTOR0_BLDC_SCALAR_HALL_NVIC_SUBPRIO);
 802240e:	2200      	movs	r2, #0
 8022410:	213d      	movs	r1, #61	; 0x3d
 8022412:	2044      	movs	r0, #68	; 0x44
 8022414:	f7fe fea9 	bl	802116a <BLDC_SCALAR_NVIC_NodeInit>
  /*Change Motor Control State to motor state identification */
  Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION;
 8022418:	4b03      	ldr	r3, [pc, #12]	; (8022428 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 802241a:	2202      	movs	r2, #2
 802241c:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 8022420:	bf00      	nop
 8022422:	3708      	adds	r7, #8
 8022424:	46bd      	mov	sp, r7
 8022426:	bd80      	pop	{r7, pc}
 8022428:	2000018c 	.word	0x2000018c
 802242c:	2000016c 	.word	0x2000016c
 8022430:	20000158 	.word	0x20000158

08022434 <Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func>:
/*
 * STATE_IDENTIFICATION state:
 * Wait for detection timeout or state identification flag to be set; whichever is earlier
 */
static void Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func(void)
{
 8022434:	b580      	push	{r7, lr}
 8022436:	af00      	add	r7, sp, #0
  if (BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED == Motor0_BLDC_SCALAR_State_Identification())
 8022438:	f000 f958 	bl	80226ec <Motor0_BLDC_SCALAR_State_Identification>
 802243c:	4603      	mov	r3, r0
 802243e:	2b01      	cmp	r3, #1
 8022440:	d101      	bne.n	8022446 <Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func+0x12>
  {
    Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func();
 8022442:	f000 f803 	bl	802244c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func>
  }
}
 8022446:	bf00      	nop
 8022448:	bd80      	pop	{r7, pc}
	...

0802244c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func>:
 *            if motor is running in reverse direction with speed less than threshold speed and bootstrap is enabled
 * HALL_LEARNING: if motor is freely running in the intended direction with speed less than threshold speed and bootstrap is disabled and hall learning is enabled OR
 *            if motor is running in reverse direction with speed less than threshold speed and bootstrap is disabled and hall learning is enabled
 */
static void Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func(void)
{
 802244c:	b580      	push	{r7, lr}
 802244e:	af00      	add	r7, sp, #0
  /* Disable correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8022450:	2000      	movs	r0, #0
 8022452:	f7ff ff0b 	bl	802226c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>

  /* Motor is freely running in the intended direction */
  if (Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction == Motor0_BLDC_SCALAR.motor_set_direction)
 8022456:	4b20      	ldr	r3, [pc, #128]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022458:	68da      	ldr	r2, [r3, #12]
 802245a:	4b20      	ldr	r3, [pc, #128]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802245c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802245e:	429a      	cmp	r2, r3
 8022460:	d118      	bne.n	8022494 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x48>
        Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
    #endif
    }
#else
    /* if speed is greater than threshold speed, go to closed loop operation */
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022462:	4b1e      	ldr	r3, [pc, #120]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022464:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022466:	4b1c      	ldr	r3, [pc, #112]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022468:	699b      	ldr	r3, [r3, #24]
 802246a:	429a      	cmp	r2, r3
 802246c:	dc06      	bgt.n	802247c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x30>
        (Motor0_BLDC_SCALAR.motor_speed < -Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed))
 802246e:	4b1b      	ldr	r3, [pc, #108]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022470:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022472:	4b19      	ldr	r3, [pc, #100]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022474:	699b      	ldr	r3, [r3, #24]
 8022476:	425b      	negs	r3, r3
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022478:	429a      	cmp	r2, r3
 802247a:	da06      	bge.n	802248a <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x3e>
    {
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) && (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U))
      Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR.motor_speed;
 802247c:	4b17      	ldr	r3, [pc, #92]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802247e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8022480:	4a17      	ldr	r2, [pc, #92]	; (80224e0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x94>)
 8022482:	6013      	str	r3, [r2, #0]
#endif
      /* Normal operation */
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 8022484:	f7ff ff18 	bl	80222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
 8022488:	e023      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
    else
    {
      /*Current amplifier bias voltage calibration*/
    #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U))
    #if (MOTOR0_BLDC_SCALAR_ENABLE_AMPLIFIER_OFFSET_CALIBRATION == 1U)
      Motor0_BLDC_SCALAR_AmpBiasVoltCalibration();
 802248a:	f7fe fa0b 	bl	80208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>
      if (BLDC_SCALAR_HALL_LEARNING_FLAG_DISABLED == Motor0_BLDC_SCALAR_Hall.hall_learning_flag)
      {
        Motor0_BLDC_SCALAR_MSM_HALL_LEARNING_Entry_Func();
      }
    #else
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 802248e:	f7ff ff13 	bl	80222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
    #else
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
    #endif
    }
  }
}
 8022492:	e01e      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022494:	4b11      	ldr	r3, [pc, #68]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022496:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022498:	4b0f      	ldr	r3, [pc, #60]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 802249a:	699b      	ldr	r3, [r3, #24]
 802249c:	429a      	cmp	r2, r3
 802249e:	dc06      	bgt.n	80224ae <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x62>
        (Motor0_BLDC_SCALAR.motor_speed < -Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed))
 80224a0:	4b0e      	ldr	r3, [pc, #56]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224a2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80224a4:	4b0c      	ldr	r3, [pc, #48]	; (80224d8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 80224a6:	699b      	ldr	r3, [r3, #24]
 80224a8:	425b      	negs	r3, r3
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 80224aa:	429a      	cmp	r2, r3
 80224ac:	da0c      	bge.n	80224c8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x7c>
      Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 80224ae:	4b0b      	ldr	r3, [pc, #44]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224b0:	2208      	movs	r2, #8
 80224b2:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_MOTOR_FREE_RUNNING;
 80224b6:	4b09      	ldr	r3, [pc, #36]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80224ba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80224be:	4a07      	ldr	r2, [pc, #28]	; (80224dc <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224c0:	6693      	str	r3, [r2, #104]	; 0x68
      Motor0_BLDC_SCALAR_MotorStop();
 80224c2:	f000 fa69 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
 80224c6:	e004      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
      Motor0_BLDC_SCALAR_AmpBiasVoltCalibration();
 80224c8:	f7fe f9ec 	bl	80208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 80224cc:	f7ff fef4 	bl	80222b8 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
}
 80224d0:	e7ff      	b.n	80224d2 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
 80224d2:	bf00      	nop
 80224d4:	bd80      	pop	{r7, pc}
 80224d6:	bf00      	nop
 80224d8:	2000016c 	.word	0x2000016c
 80224dc:	2000018c 	.word	0x2000018c
 80224e0:	200000bc 	.word	0x200000bc

080224e4 <Motor0_BLDC_SCALAR_MSM_ERROR_Func>:
/*
 * ERROR state:
 * Change the state to STOP when all the errors are cleared
 */
static void Motor0_BLDC_SCALAR_MSM_ERROR_Func(void)
{
 80224e4:	b480      	push	{r7}
 80224e6:	af00      	add	r7, sp, #0
/* Change the state to STOP when all the errors are cleared */
  if (Motor0_BLDC_SCALAR.error_status == 0U)
 80224e8:	4b06      	ldr	r3, [pc, #24]	; (8022504 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x20>)
 80224ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80224ec:	2b00      	cmp	r3, #0
 80224ee:	d103      	bne.n	80224f8 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x14>
  {
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
 80224f0:	4b04      	ldr	r3, [pc, #16]	; (8022504 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x20>)
 80224f2:	2200      	movs	r2, #0
 80224f4:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  }
}
 80224f8:	bf00      	nop
 80224fa:	46bd      	mov	sp, r7
 80224fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022500:	4770      	bx	lr
 8022502:	bf00      	nop
 8022504:	2000018c 	.word	0x2000018c

08022508 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8022508:	b480      	push	{r7}
 802250a:	b083      	sub	sp, #12
 802250c:	af00      	add	r7, sp, #0
 802250e:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8022510:	687b      	ldr	r3, [r7, #4]
 8022512:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022514:	08db      	lsrs	r3, r3, #3
 8022516:	b2db      	uxtb	r3, r3
 8022518:	f003 0307 	and.w	r3, r3, #7
 802251c:	b2db      	uxtb	r3, r3
}
 802251e:	4618      	mov	r0, r3
 8022520:	370c      	adds	r7, #12
 8022522:	46bd      	mov	sp, r7
 8022524:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022528:	4770      	bx	lr

0802252a <XMC_POSIF_HSC_SetHallPatterns>:
{
 802252a:	b480      	push	{r7}
 802252c:	b083      	sub	sp, #12
 802252e:	af00      	add	r7, sp, #0
 8022530:	6078      	str	r0, [r7, #4]
 8022532:	460b      	mov	r3, r1
 8022534:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8022536:	78fb      	ldrb	r3, [r7, #3]
 8022538:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 802253c:	687b      	ldr	r3, [r7, #4]
 802253e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8022540:	bf00      	nop
 8022542:	370c      	adds	r7, #12
 8022544:	46bd      	mov	sp, r7
 8022546:	f85d 7b04 	ldr.w	r7, [sp], #4
 802254a:	4770      	bx	lr

0802254c <XMC_POSIF_HSC_UpdateHallPattern>:
{
 802254c:	b480      	push	{r7}
 802254e:	b083      	sub	sp, #12
 8022550:	af00      	add	r7, sp, #0
 8022552:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 8022554:	687b      	ldr	r3, [r7, #4]
 8022556:	2202      	movs	r2, #2
 8022558:	649a      	str	r2, [r3, #72]	; 0x48
}
 802255a:	bf00      	nop
 802255c:	370c      	adds	r7, #12
 802255e:	46bd      	mov	sp, r7
 8022560:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022564:	4770      	bx	lr

08022566 <XMC_POSIF_MCM_SetMultiChannelPattern>:
{
 8022566:	b480      	push	{r7}
 8022568:	b083      	sub	sp, #12
 802256a:	af00      	add	r7, sp, #0
 802256c:	6078      	str	r0, [r7, #4]
 802256e:	460b      	mov	r3, r1
 8022570:	807b      	strh	r3, [r7, #2]
  peripheral->MCSM = pattern;
 8022572:	887a      	ldrh	r2, [r7, #2]
 8022574:	687b      	ldr	r3, [r7, #4]
 8022576:	645a      	str	r2, [r3, #68]	; 0x44
}
 8022578:	bf00      	nop
 802257a:	370c      	adds	r7, #12
 802257c:	46bd      	mov	sp, r7
 802257e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022582:	4770      	bx	lr

08022584 <XMC_POSIF_MCM_GetMultiChannelPattern>:
{
 8022584:	b480      	push	{r7}
 8022586:	b083      	sub	sp, #12
 8022588:	af00      	add	r7, sp, #0
 802258a:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCM & (uint32_t)POSIF_MCM_MCMP_Msk));
 802258c:	687b      	ldr	r3, [r7, #4]
 802258e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022590:	b29b      	uxth	r3, r3
}
 8022592:	4618      	mov	r0, r3
 8022594:	370c      	adds	r7, #12
 8022596:	46bd      	mov	sp, r7
 8022598:	f85d 7b04 	ldr.w	r7, [sp], #4
 802259c:	4770      	bx	lr

0802259e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>:
{
 802259e:	b480      	push	{r7}
 80225a0:	b083      	sub	sp, #12
 80225a2:	af00      	add	r7, sp, #0
 80225a4:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCSM & (uint32_t)POSIF_MCSM_MCMPS_Msk));
 80225a6:	687b      	ldr	r3, [r7, #4]
 80225a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80225aa:	b29b      	uxth	r3, r3
}
 80225ac:	4618      	mov	r0, r3
 80225ae:	370c      	adds	r7, #12
 80225b0:	46bd      	mov	sp, r7
 80225b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225b6:	4770      	bx	lr

080225b8 <XMC_POSIF_MCM_UpdateMultiChannelPattern>:
{
 80225b8:	b480      	push	{r7}
 80225ba:	b083      	sub	sp, #12
 80225bc:	af00      	add	r7, sp, #0
 80225be:	6078      	str	r0, [r7, #4]
  peripheral->MCMS |= (uint32_t)POSIF_MCMS_STMR_Msk;
 80225c0:	687b      	ldr	r3, [r7, #4]
 80225c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80225c4:	f043 0204 	orr.w	r2, r3, #4
 80225c8:	687b      	ldr	r3, [r7, #4]
 80225ca:	649a      	str	r2, [r3, #72]	; 0x48
}
 80225cc:	bf00      	nop
 80225ce:	370c      	adds	r7, #12
 80225d0:	46bd      	mov	sp, r7
 80225d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225d6:	4770      	bx	lr

080225d8 <XMC_POSIF_DisableEvent>:
{
 80225d8:	b480      	push	{r7}
 80225da:	b083      	sub	sp, #12
 80225dc:	af00      	add	r7, sp, #0
 80225de:	6078      	str	r0, [r7, #4]
 80225e0:	460b      	mov	r3, r1
 80225e2:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE &= ~((uint32_t)1 << (uint8_t)event);
 80225e4:	687b      	ldr	r3, [r7, #4]
 80225e6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80225e8:	78fb      	ldrb	r3, [r7, #3]
 80225ea:	2101      	movs	r1, #1
 80225ec:	fa01 f303 	lsl.w	r3, r1, r3
 80225f0:	43db      	mvns	r3, r3
 80225f2:	401a      	ands	r2, r3
 80225f4:	687b      	ldr	r3, [r7, #4]
 80225f6:	675a      	str	r2, [r3, #116]	; 0x74
}
 80225f8:	bf00      	nop
 80225fa:	370c      	adds	r7, #12
 80225fc:	46bd      	mov	sp, r7
 80225fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022602:	4770      	bx	lr

08022604 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Configures \a MCSM register with Multi-Channel Pattern.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(uint16_t pattern)
{
 8022604:	b580      	push	{r7, lr}
 8022606:	b082      	sub	sp, #8
 8022608:	af00      	add	r7, sp, #0
 802260a:	4603      	mov	r3, r0
 802260c:	80fb      	strh	r3, [r7, #6]

  XMC_POSIF_MCM_SetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 802260e:	88fb      	ldrh	r3, [r7, #6]
 8022610:	4619      	mov	r1, r3
 8022612:	4803      	ldr	r0, [pc, #12]	; (8022620 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern+0x1c>)
 8022614:	f7ff ffa7 	bl	8022566 <XMC_POSIF_MCM_SetMultiChannelPattern>

}
 8022618:	bf00      	nop
 802261a:	3708      	adds	r7, #8
 802261c:	46bd      	mov	sp, r7
 802261e:	bd80      	pop	{r7, pc}
 8022620:	40028000 	.word	0x40028000

08022624 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Performs shadow transfer of the Multi-Channel Pattern register by configuring.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern(void)
{
 8022624:	b580      	push	{r7, lr}
 8022626:	af00      	add	r7, sp, #0
  XMC_POSIF_MCM_UpdateMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022628:	4802      	ldr	r0, [pc, #8]	; (8022634 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern+0x10>)
 802262a:	f7ff ffc5 	bl	80225b8 <XMC_POSIF_MCM_UpdateMultiChannelPattern>
}
 802262e:	bf00      	nop
 8022630:	bd80      	pop	{r7, pc}
 8022632:	bf00      	nop
 8022634:	40028000 	.word	0x40028000

08022638 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Returns configured multi channel pattern of \a peripheral. \n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern(void)
{
 8022638:	b580      	push	{r7, lr}
 802263a:	b082      	sub	sp, #8
 802263c:	af00      	add	r7, sp, #0
  uint16_t pattern;
  pattern = XMC_POSIF_MCM_GetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802263e:	4805      	ldr	r0, [pc, #20]	; (8022654 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern+0x1c>)
 8022640:	f7ff ffa0 	bl	8022584 <XMC_POSIF_MCM_GetMultiChannelPattern>
 8022644:	4603      	mov	r3, r0
 8022646:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8022648:	88fb      	ldrh	r3, [r7, #6]
}
 802264a:	4618      	mov	r0, r3
 802264c:	3708      	adds	r7, #8
 802264e:	46bd      	mov	sp, r7
 8022650:	bd80      	pop	{r7, pc}
 8022652:	bf00      	nop
 8022654:	40028000 	.word	0x40028000

08022658 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Returns configured multi channel pattern in shadow register of \a peripheral. \n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern(void)
{
 8022658:	b580      	push	{r7, lr}
 802265a:	b082      	sub	sp, #8
 802265c:	af00      	add	r7, sp, #0
  uint16_t pattern;
  pattern = XMC_POSIF_MCM_GetShadowMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802265e:	4805      	ldr	r0, [pc, #20]	; (8022674 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern+0x1c>)
 8022660:	f7ff ff9d 	bl	802259e <XMC_POSIF_MCM_GetShadowMultiChannelPattern>
 8022664:	4603      	mov	r3, r0
 8022666:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8022668:	88fb      	ldrh	r3, [r7, #6]
}
 802266a:	4618      	mov	r0, r3
 802266c:	3708      	adds	r7, #8
 802266e:	46bd      	mov	sp, r7
 8022670:	bd80      	pop	{r7, pc}
 8022672:	bf00      	nop
 8022674:	40028000 	.word	0x40028000

08022678 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
 *
 * \par<b>Description</b><br>
 * Configures current and expected hall pattern of \a peripheral. \n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(uint8_t pattern)
{
 8022678:	b580      	push	{r7, lr}
 802267a:	b082      	sub	sp, #8
 802267c:	af00      	add	r7, sp, #0
 802267e:	4603      	mov	r3, r0
 8022680:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8022682:	79fb      	ldrb	r3, [r7, #7]
 8022684:	4619      	mov	r1, r3
 8022686:	4803      	ldr	r0, [pc, #12]	; (8022694 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8022688:	f7ff ff4f 	bl	802252a <XMC_POSIF_HSC_SetHallPatterns>
}
 802268c:	bf00      	nop
 802268e:	3708      	adds	r7, #8
 8022690:	46bd      	mov	sp, r7
 8022692:	bd80      	pop	{r7, pc}
 8022694:	40028000 	.word	0x40028000

08022698 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
 * \par<b>Description</b><br>
 * The transfer of hall sensor pattern shadow registers content to the hall sensor pattern register happens
 * on hardware trigger.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern(void)
{
 8022698:	b580      	push	{r7, lr}
 802269a:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802269c:	4802      	ldr	r0, [pc, #8]	; (80226a8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 802269e:	f7ff ff55 	bl	802254c <XMC_POSIF_HSC_UpdateHallPattern>
}
 80226a2:	bf00      	nop
 80226a4:	bd80      	pop	{r7, pc}
 80226a6:	bf00      	nop
 80226a8:	40028000 	.word	0x40028000

080226ac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
 *
 * \par<b>Description</b><br>
 * Retrieves the expected hall sensor pattern from \a HALP register's \a HEP bit field of \a peripheral.\n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern(void)
{
 80226ac:	b580      	push	{r7, lr}
 80226ae:	b082      	sub	sp, #8
 80226b0:	af00      	add	r7, sp, #0
  uint8_t pattern;
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 80226b2:	4805      	ldr	r0, [pc, #20]	; (80226c8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 80226b4:	f7ff ff28 	bl	8022508 <XMC_POSIF_HSC_GetExpectedPattern>
 80226b8:	4603      	mov	r3, r0
 80226ba:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 80226bc:	79fb      	ldrb	r3, [r7, #7]
}
 80226be:	4618      	mov	r0, r3
 80226c0:	3708      	adds	r7, #8
 80226c2:	46bd      	mov	sp, r7
 80226c4:	bd80      	pop	{r7, pc}
 80226c6:	bf00      	nop
 80226c8:	40028000 	.word	0x40028000

080226cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>:
 *
 * \par<b>Description</b><br>
 * Disables event generation of peripheral.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 80226cc:	b580      	push	{r7, lr}
 80226ce:	b082      	sub	sp, #8
 80226d0:	af00      	add	r7, sp, #0
 80226d2:	4603      	mov	r3, r0
 80226d4:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_DisableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 80226d6:	79fb      	ldrb	r3, [r7, #7]
 80226d8:	4619      	mov	r1, r3
 80226da:	4803      	ldr	r0, [pc, #12]	; (80226e8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent+0x1c>)
 80226dc:	f7ff ff7c 	bl	80225d8 <XMC_POSIF_DisableEvent>
}
 80226e0:	bf00      	nop
 80226e2:	3708      	adds	r7, #8
 80226e4:	46bd      	mov	sp, r7
 80226e6:	bd80      	pop	{r7, pc}
 80226e8:	40028000 	.word	0x40028000

080226ec <Motor0_BLDC_SCALAR_State_Identification>:
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval, mcmshadow);
}

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
BLDC_SCALAR_STATE_IDENTIFICATION_t Motor0_BLDC_SCALAR_State_Identification(void)
{
 80226ec:	b580      	push	{r7, lr}
 80226ee:	b082      	sub	sp, #8
 80226f0:	af00      	add	r7, sp, #0
  BLDC_SCALAR_STATE_IDENTIFICATION_t status = BLDC_SCALAR_STATE_IDENTIFICATION_PROGRESS;
 80226f2:	2300      	movs	r3, #0
 80226f4:	71fb      	strb	r3, [r7, #7]
  uint32_t speed;
  /* 3 hall events are detected */
  if (Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 1U)
 80226f6:	4b21      	ldr	r3, [pc, #132]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 80226f8:	781b      	ldrb	r3, [r3, #0]
 80226fa:	2b01      	cmp	r3, #1
 80226fc:	d125      	bne.n	802274a <Motor0_BLDC_SCALAR_State_Identification+0x5e>
  {
    /* Calculate the speed and change the status */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 80226fe:	2000      	movs	r0, #0
 8022700:	f7ff ffe4 	bl	80226cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval = (Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval >> 1U) * BLDC_SCALAR_HALL_EVENTS_PER_CYCLE;
 8022704:	4b1d      	ldr	r3, [pc, #116]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022706:	685b      	ldr	r3, [r3, #4]
 8022708:	085a      	lsrs	r2, r3, #1
 802270a:	4613      	mov	r3, r2
 802270c:	005b      	lsls	r3, r3, #1
 802270e:	4413      	add	r3, r2
 8022710:	005b      	lsls	r3, r3, #1
 8022712:	461a      	mov	r2, r3
 8022714:	4b19      	ldr	r3, [pc, #100]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022716:	605a      	str	r2, [r3, #4]
    speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant / (Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval));
 8022718:	4b19      	ldr	r3, [pc, #100]	; (8022780 <Motor0_BLDC_SCALAR_State_Identification+0x94>)
 802271a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802271c:	4b17      	ldr	r3, [pc, #92]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802271e:	685b      	ldr	r3, [r3, #4]
 8022720:	fbb2 f3f3 	udiv	r3, r2, r3
 8022724:	603b      	str	r3, [r7, #0]
    speed = ((speed * Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8022726:	4b17      	ldr	r3, [pc, #92]	; (8022784 <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022728:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 802272c:	683a      	ldr	r2, [r7, #0]
 802272e:	fb02 f303 	mul.w	r3, r2, r3
 8022732:	0a9b      	lsrs	r3, r3, #10
 8022734:	603b      	str	r3, [r7, #0]
    Motor0_BLDC_SCALAR.motor_speed = (int32_t)((int32_t)speed * Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction);
 8022736:	4b11      	ldr	r3, [pc, #68]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022738:	68db      	ldr	r3, [r3, #12]
 802273a:	683a      	ldr	r2, [r7, #0]
 802273c:	fb02 f303 	mul.w	r3, r2, r3
 8022740:	4a10      	ldr	r2, [pc, #64]	; (8022784 <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022742:	66d3      	str	r3, [r2, #108]	; 0x6c
    status = BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED;
 8022744:	2301      	movs	r3, #1
 8022746:	71fb      	strb	r3, [r7, #7]
 8022748:	e012      	b.n	8022770 <Motor0_BLDC_SCALAR_State_Identification+0x84>
  }
  else
  {
    /* Wait for timeout */
    Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter++;
 802274a:	4b0c      	ldr	r3, [pc, #48]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802274c:	689b      	ldr	r3, [r3, #8]
 802274e:	3301      	adds	r3, #1
 8022750:	4a0a      	ldr	r2, [pc, #40]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022752:	6093      	str	r3, [r2, #8]
    if (Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter >= Motor0_BLDC_SCALAR_HALL_CatchFree.cf_detection_timeout)
 8022754:	4b09      	ldr	r3, [pc, #36]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022756:	689a      	ldr	r2, [r3, #8]
 8022758:	4b08      	ldr	r3, [pc, #32]	; (802277c <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802275a:	69db      	ldr	r3, [r3, #28]
 802275c:	429a      	cmp	r2, r3
 802275e:	d307      	bcc.n	8022770 <Motor0_BLDC_SCALAR_State_Identification+0x84>
    {
      Motor0_BLDC_SCALAR.motor_speed = 0;
 8022760:	4b08      	ldr	r3, [pc, #32]	; (8022784 <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022762:	2200      	movs	r2, #0
 8022764:	66da      	str	r2, [r3, #108]	; 0x6c
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8022766:	2000      	movs	r0, #0
 8022768:	f7ff ffb0 	bl	80226cc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
      status = BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED;
 802276c:	2301      	movs	r3, #1
 802276e:	71fb      	strb	r3, [r7, #7]
    }
  }
  return status;
 8022770:	79fb      	ldrb	r3, [r7, #7]
}
 8022772:	4618      	mov	r0, r3
 8022774:	3708      	adds	r7, #8
 8022776:	46bd      	mov	sp, r7
 8022778:	bd80      	pop	{r7, pc}
 802277a:	bf00      	nop
 802277c:	2000016c 	.word	0x2000016c
 8022780:	200000f8 	.word	0x200000f8
 8022784:	2000018c 	.word	0x2000018c

08022788 <Motor0_BLDC_SCALAR_MotorParamInit>:
 **********************************************************************************************************************/


/* Reset and Initialize of the motor control parameters */
void Motor0_BLDC_SCALAR_MotorParamInit(void)
{
 8022788:	b480      	push	{r7}
 802278a:	b083      	sub	sp, #12
 802278c:	af00      	add	r7, sp, #0
#endif
#if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U) && (MOTOR0_BLDC_SCALAR_ENABLE_BIDIRECTIONAL_CTRL == 1U))
  volatile uint32_t adc_conversion_delay;  /* wait for the conversion delay */
#endif
  /* Reset runtime control parameters */
  Motor0_BLDC_SCALAR.amplitude               = 0U;
 802278e:	4b2b      	ldr	r3, [pc, #172]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022790:	2200      	movs	r2, #0
 8022792:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  Motor0_BLDC_SCALAR.motor_speed             = 0;
 8022796:	4b29      	ldr	r3, [pc, #164]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022798:	2200      	movs	r2, #0
 802279a:	66da      	str	r2, [r3, #108]	; 0x6c
  Motor0_BLDC_SCALAR.motor_current           = 0;
 802279c:	4b27      	ldr	r3, [pc, #156]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 802279e:	2200      	movs	r2, #0
 80227a0:	671a      	str	r2, [r3, #112]	; 0x70
  Motor0_BLDC_SCALAR.motor_average_current   = 0;
 80227a2:	4b26      	ldr	r3, [pc, #152]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227a4:	2200      	movs	r2, #0
 80227a6:	675a      	str	r2, [r3, #116]	; 0x74
  Motor0_BLDC_SCALAR.dclink_voltage          = 0U;
 80227a8:	4b24      	ldr	r3, [pc, #144]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227aa:	2200      	movs	r2, #0
 80227ac:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  Motor0_BLDC_SCALAR.overcurrent_counter         = 0U;
 80227b0:	4b22      	ldr	r3, [pc, #136]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227b2:	2200      	movs	r2, #0
 80227b4:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#if (MOTOR0_BLDC_SCALAR_ENABLE_UNDER_OVER_VOLTAGE == 1U)
  Motor0_BLDC_SCALAR.over_under_voltage_counter  = 0U;
#endif
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING ==1U)
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 80227b8:	4b21      	ldr	r3, [pc, #132]	; (8022840 <Motor0_BLDC_SCALAR_MotorParamInit+0xb8>)
 80227ba:	2200      	movs	r2, #0
 80227bc:	61da      	str	r2, [r3, #28]
#endif /* if(MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
#if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_LINK_CURRENT_FILTER == 1U)
  Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_buf = 0;          /* Reset PT1 buffer */
 80227be:	4b21      	ldr	r3, [pc, #132]	; (8022844 <Motor0_BLDC_SCALAR_MotorParamInit+0xbc>)
 80227c0:	2200      	movs	r2, #0
 80227c2:	611a      	str	r2, [r3, #16]
#endif /* if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U) */
#endif

#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  start_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 80227c4:	4b20      	ldr	r3, [pc, #128]	; (8022848 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227c6:	681b      	ldr	r3, [r3, #0]
 80227c8:	607b      	str	r3, [r7, #4]
  end_value = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 80227ca:	4b1f      	ldr	r3, [pc, #124]	; (8022848 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227cc:	685b      	ldr	r3, [r3, #4]
 80227ce:	603b      	str	r3, [r7, #0]
    Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
  }
#else
  /* Initialize the rotation direction */
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  if (start_value == (int32_t)0)
 80227d0:	687b      	ldr	r3, [r7, #4]
 80227d2:	2b00      	cmp	r3, #0
 80227d4:	d10b      	bne.n	80227ee <Motor0_BLDC_SCALAR_MotorParamInit+0x66>
  {
    if (end_value >= (int32_t)0)
 80227d6:	683b      	ldr	r3, [r7, #0]
 80227d8:	2b00      	cmp	r3, #0
 80227da:	db03      	blt.n	80227e4 <Motor0_BLDC_SCALAR_MotorParamInit+0x5c>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 80227dc:	4b17      	ldr	r3, [pc, #92]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227de:	2201      	movs	r2, #1
 80227e0:	679a      	str	r2, [r3, #120]	; 0x78
 80227e2:	e00f      	b.n	8022804 <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
    else
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 80227e4:	4b15      	ldr	r3, [pc, #84]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227e6:	f04f 32ff 	mov.w	r2, #4294967295
 80227ea:	679a      	str	r2, [r3, #120]	; 0x78
 80227ec:	e00a      	b.n	8022804 <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
  }
  else
  {
    if (start_value > (int32_t)0)
 80227ee:	687b      	ldr	r3, [r7, #4]
 80227f0:	2b00      	cmp	r3, #0
 80227f2:	dd03      	ble.n	80227fc <Motor0_BLDC_SCALAR_MotorParamInit+0x74>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 80227f4:	4b11      	ldr	r3, [pc, #68]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227f6:	2201      	movs	r2, #1
 80227f8:	679a      	str	r2, [r3, #120]	; 0x78
 80227fa:	e003      	b.n	8022804 <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
    else
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 80227fc:	4b0f      	ldr	r3, [pc, #60]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227fe:	f04f 32ff 	mov.w	r2, #4294967295
 8022802:	679a      	str	r2, [r3, #120]	; 0x78
  {
    Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
  }
#endif
#endif
  Motor0_BLDC_SCALAR.actual_motor_direction = (Motor0_BLDC_SCALAR.motor_set_direction);
 8022804:	4b0d      	ldr	r3, [pc, #52]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022806:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8022808:	4a0c      	ldr	r2, [pc, #48]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 802280a:	67d3      	str	r3, [r2, #124]	; 0x7c
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)

  /* Start the ramp from start value if analog input is disabled */
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 802280c:	4b0e      	ldr	r3, [pc, #56]	; (8022848 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 802280e:	681b      	ldr	r3, [r3, #0]
 8022810:	4a0e      	ldr	r2, [pc, #56]	; (802284c <Motor0_BLDC_SCALAR_MotorParamInit+0xc4>)
 8022812:	6013      	str	r3, [r2, #0]

#endif /* if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U) */

  /* Reset the PI integral buffer */
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_SpeedControl_PI.ik = 0;
 8022814:	4b0e      	ldr	r3, [pc, #56]	; (8022850 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 8022816:	2200      	movs	r2, #0
 8022818:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SpeedControl_PI.uk = 0;
 802281a:	4b0d      	ldr	r3, [pc, #52]	; (8022850 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 802281c:	2200      	movs	r2, #0
 802281e:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SpeedControl_PI.sat_state = 1U;
 8022820:	4b0b      	ldr	r3, [pc, #44]	; (8022850 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 8022822:	2201      	movs	r2, #1
 8022824:	755a      	strb	r2, [r3, #21]
  Motor0_BLDC_SCALAR.speedcontrol_rate_counter = 0U;
 8022826:	4b05      	ldr	r3, [pc, #20]	; (802283c <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022828:	2200      	movs	r2, #0
 802282a:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_CURRENT_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_CurrentControl_PI.ik = 0;
  Motor0_BLDC_SCALAR_CurrentControl_PI.sat_state = 1U;
#endif

}
 802282e:	bf00      	nop
 8022830:	370c      	adds	r7, #12
 8022832:	46bd      	mov	sp, r7
 8022834:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022838:	4770      	bx	lr
 802283a:	bf00      	nop
 802283c:	2000018c 	.word	0x2000018c
 8022840:	20000124 	.word	0x20000124
 8022844:	200000a4 	.word	0x200000a4
 8022848:	20000148 	.word	0x20000148
 802284c:	200000bc 	.word	0x200000bc
 8022850:	2000008c 	.word	0x2000008c

08022854 <Motor0_BLDC_SCALAR_MotorVarInit>:
/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/* One time initialization of the BLDC_SCALAR data structure variables based on configuration */
static void Motor0_BLDC_SCALAR_MotorVarInit(void)
{
 8022854:	b480      	push	{r7}
 8022856:	b083      	sub	sp, #12
 8022858:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)

  /* Start the ramp from start value if analog input is disabled */
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 802285a:	4b31      	ldr	r3, [pc, #196]	; (8022920 <Motor0_BLDC_SCALAR_MotorVarInit+0xcc>)
 802285c:	681b      	ldr	r3, [r3, #0]
 802285e:	4a31      	ldr	r2, [pc, #196]	; (8022924 <Motor0_BLDC_SCALAR_MotorVarInit+0xd0>)
 8022860:	6013      	str	r3, [r2, #0]

#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U) */

/******************start: mc_pattern table*****************************/
  /* multi-channel pattern generation for high side sync modulation */
  for (mcm_index = 0U; mcm_index <= BLDC_SCALAR_MCM_PATTERN_TABLE_SIZE; mcm_index++)
 8022862:	2300      	movs	r3, #0
 8022864:	71fb      	strb	r3, [r7, #7]
 8022866:	e050      	b.n	802290a <Motor0_BLDC_SCALAR_MotorVarInit+0xb6>
  {
    if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM))) ==
 8022868:	79fb      	ldrb	r3, [r7, #7]
 802286a:	4a2f      	ldr	r2, [pc, #188]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 802286c:	3310      	adds	r3, #16
 802286e:	005b      	lsls	r3, r3, #1
 8022870:	4413      	add	r3, r2
 8022872:	889b      	ldrh	r3, [r3, #4]
 8022874:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8022878:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802287c:	d10f      	bne.n	802289e <Motor0_BLDC_SCALAR_MotorVarInit+0x4a>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM))));
 802287e:	79fb      	ldrb	r3, [r7, #7]
 8022880:	4a29      	ldr	r2, [pc, #164]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 8022882:	3310      	adds	r3, #16
 8022884:	005b      	lsls	r3, r3, #1
 8022886:	4413      	add	r3, r2
 8022888:	889a      	ldrh	r2, [r3, #4]
 802288a:	79fb      	ldrb	r3, [r7, #7]
 802288c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8022890:	b291      	uxth	r1, r2
 8022892:	4a25      	ldr	r2, [pc, #148]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 8022894:	005b      	lsls	r3, r3, #1
 8022896:	4413      	add	r3, r2
 8022898:	460a      	mov	r2, r1
 802289a:	809a      	strh	r2, [r3, #4]
 802289c:	e032      	b.n	8022904 <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
    }
    else if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM))) ==
 802289e:	79fb      	ldrb	r3, [r7, #7]
 80228a0:	4a21      	ldr	r2, [pc, #132]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228a2:	3310      	adds	r3, #16
 80228a4:	005b      	lsls	r3, r3, #1
 80228a6:	4413      	add	r3, r2
 80228a8:	889b      	ldrh	r3, [r3, #4]
 80228aa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80228ae:	2b10      	cmp	r3, #16
 80228b0:	d10f      	bne.n	80228d2 <Motor0_BLDC_SCALAR_MotorVarInit+0x7e>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM))));
 80228b2:	79fb      	ldrb	r3, [r7, #7]
 80228b4:	4a1c      	ldr	r2, [pc, #112]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228b6:	3310      	adds	r3, #16
 80228b8:	005b      	lsls	r3, r3, #1
 80228ba:	4413      	add	r3, r2
 80228bc:	889a      	ldrh	r2, [r3, #4]
 80228be:	79fb      	ldrb	r3, [r7, #7]
 80228c0:	f042 0220 	orr.w	r2, r2, #32
 80228c4:	b291      	uxth	r1, r2
 80228c6:	4a18      	ldr	r2, [pc, #96]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228c8:	005b      	lsls	r3, r3, #1
 80228ca:	4413      	add	r3, r2
 80228cc:	460a      	mov	r2, r1
 80228ce:	809a      	strh	r2, [r3, #4]
 80228d0:	e018      	b.n	8022904 <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
    }
    else if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM))) ==
 80228d2:	79fb      	ldrb	r3, [r7, #7]
 80228d4:	4a14      	ldr	r2, [pc, #80]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228d6:	3310      	adds	r3, #16
 80228d8:	005b      	lsls	r3, r3, #1
 80228da:	4413      	add	r3, r2
 80228dc:	889b      	ldrh	r3, [r3, #4]
 80228de:	f003 030f 	and.w	r3, r3, #15
 80228e2:	2b01      	cmp	r3, #1
 80228e4:	d10e      	bne.n	8022904 <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM))));
 80228e6:	79fb      	ldrb	r3, [r7, #7]
 80228e8:	4a0f      	ldr	r2, [pc, #60]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228ea:	3310      	adds	r3, #16
 80228ec:	005b      	lsls	r3, r3, #1
 80228ee:	4413      	add	r3, r2
 80228f0:	889a      	ldrh	r2, [r3, #4]
 80228f2:	79fb      	ldrb	r3, [r7, #7]
 80228f4:	f042 0202 	orr.w	r2, r2, #2
 80228f8:	b291      	uxth	r1, r2
 80228fa:	4a0b      	ldr	r2, [pc, #44]	; (8022928 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228fc:	005b      	lsls	r3, r3, #1
 80228fe:	4413      	add	r3, r2
 8022900:	460a      	mov	r2, r1
 8022902:	809a      	strh	r2, [r3, #4]
  for (mcm_index = 0U; mcm_index <= BLDC_SCALAR_MCM_PATTERN_TABLE_SIZE; mcm_index++)
 8022904:	79fb      	ldrb	r3, [r7, #7]
 8022906:	3301      	adds	r3, #1
 8022908:	71fb      	strb	r3, [r7, #7]
 802290a:	79fb      	ldrb	r3, [r7, #7]
 802290c:	2b0f      	cmp	r3, #15
 802290e:	d9ab      	bls.n	8022868 <Motor0_BLDC_SCALAR_MotorVarInit+0x14>

    }
  }
  /******************end: mc_pattern table*****************************/

}
 8022910:	bf00      	nop
 8022912:	bf00      	nop
 8022914:	370c      	adds	r7, #12
 8022916:	46bd      	mov	sp, r7
 8022918:	f85d 7b04 	ldr.w	r7, [sp], #4
 802291c:	4770      	bx	lr
 802291e:	bf00      	nop
 8022920:	20000148 	.word	0x20000148
 8022924:	200000bc 	.word	0x200000bc
 8022928:	2000018c 	.word	0x2000018c

0802292c <Motor0_BLDC_SCALAR_MeasurementInit>:


static void Motor0_BLDC_SCALAR_MeasurementInit(void)
{
 802292c:	b580      	push	{r7, lr}
 802292e:	af00      	add	r7, sp, #0
  /* Initialize VADC peripheral */
  Motor0_BLDC_SCALAR_VADC_Init();
 8022930:	f7fe fcbc 	bl	80212ac <Motor0_BLDC_SCALAR_VADC_Init>

  /* Channel,Result register and Queue entry configuration for configured channels */
  /* Calling sequence of below functions will decide the Queue entries sequence in corresponding Queues. */
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Current_Measurment_Init();
 8022934:	f7fd ff90 	bl	8020858 <Motor0_BLDC_SCALAR_Current_Measurment_Init>
  #endif

  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_USER_DEF4_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Volt_Userdef4_Init();
  #endif
}
 8022938:	bf00      	nop
 802293a:	bd80      	pop	{r7, pc}

0802293c <Motor0_BLDC_SCALAR_Init>:


/* Initialize the required peripherals, modules and interrupts */
void Motor0_BLDC_SCALAR_Init(void)
{
 802293c:	b580      	push	{r7, lr}
 802293e:	b082      	sub	sp, #8
 8022940:	af00      	add	r7, sp, #0
  volatile uint32_t delay_counter;

  /* Initialization settling period */
  for (delay_counter = 0U; delay_counter < (uint32_t)BLDC_SCALAR_SETTLING_TIME; delay_counter++)
 8022942:	2300      	movs	r3, #0
 8022944:	607b      	str	r3, [r7, #4]
 8022946:	e002      	b.n	802294e <Motor0_BLDC_SCALAR_Init+0x12>
 8022948:	687b      	ldr	r3, [r7, #4]
 802294a:	3301      	adds	r3, #1
 802294c:	607b      	str	r3, [r7, #4]
 802294e:	687b      	ldr	r3, [r7, #4]
 8022950:	4a07      	ldr	r2, [pc, #28]	; (8022970 <Motor0_BLDC_SCALAR_Init+0x34>)
 8022952:	4293      	cmp	r3, r2
 8022954:	d9f8      	bls.n	8022948 <Motor0_BLDC_SCALAR_Init+0xc>
  {

  }

  /* Initializes block commutation module along with the peripherals - CCU8, GPIO */
  Motor0_BLDC_SCALAR_PWM_BC_Init();
 8022956:	f7fe f841 	bl	80209dc <Motor0_BLDC_SCALAR_PWM_BC_Init>

  /* Initializes hall feedback module along with the peripherals - POSIF, CCU4, GPIO */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init();
 802295a:	f7fe f927 	bl	8020bac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init>

  /* Initializes measurement module along with the peripherals - VADC, GPIO */
  Motor0_BLDC_SCALAR_MeasurementInit();
 802295e:	f7ff ffe5 	bl	802292c <Motor0_BLDC_SCALAR_MeasurementInit>

  /* Initializes BLDC_SCALAR data structure elements based on the user configurations */
  Motor0_BLDC_SCALAR_MotorVarInit();
 8022962:	f7ff ff77 	bl	8022854 <Motor0_BLDC_SCALAR_MotorVarInit>

  /* Initializes systick - this will start the statemachine interrupt */
  //BLDC_SCALAR_SYSTICK_TIMER_Init();

}
 8022966:	bf00      	nop
 8022968:	3708      	adds	r7, #8
 802296a:	46bd      	mov	sp, r7
 802296c:	bd80      	pop	{r7, pc}
 802296e:	bf00      	nop
 8022970:	0007fffe 	.word	0x0007fffe

08022974 <Motor0_BLDC_SCALAR_MotorStart>:

void Motor0_BLDC_SCALAR_MotorStart(void)
{
 8022974:	b580      	push	{r7, lr}
 8022976:	af00      	add	r7, sp, #0
  /*
   * Motor State machine should be in STOP state to start the motor.
  * In case of any error, motor start function won't be started
  * until clear all the errors.
  */
  if (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_STOP)
 8022978:	4b06      	ldr	r3, [pc, #24]	; (8022994 <Motor0_BLDC_SCALAR_MotorStart+0x20>)
 802297a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 802297e:	b2db      	uxtb	r3, r3
 8022980:	2b00      	cmp	r3, #0
 8022982:	d105      	bne.n	8022990 <Motor0_BLDC_SCALAR_MotorStart+0x1c>
  {
     Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_START;
 8022984:	4b03      	ldr	r3, [pc, #12]	; (8022994 <Motor0_BLDC_SCALAR_MotorStart+0x20>)
 8022986:	2201      	movs	r2, #1
 8022988:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
     Motor0_BLDC_SCALAR_MSM();
 802298c:	f008 fb20 	bl	802afd0 <__Motor0_BLDC_SCALAR_MSM_veneer>
  }
}
 8022990:	bf00      	nop
 8022992:	bd80      	pop	{r7, pc}
 8022994:	2000018c 	.word	0x2000018c

08022998 <Motor0_BLDC_SCALAR_MotorStop>:

void Motor0_BLDC_SCALAR_MotorStop(void)
{
 8022998:	b580      	push	{r7, lr}
 802299a:	af00      	add	r7, sp, #0
  /*stop pwm bc*/
  Motor0_BLDC_SCALAR_PWM_BC_Stop();
 802299c:	f7fe f832 	bl	8020a04 <Motor0_BLDC_SCALAR_PWM_BC_Stop>

  /*stop posif*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop();
 80229a0:	f7fe f926 	bl	8020bf0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop>

#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*disable inverter*/
  Motor0_BLDC_SCALAR_PWM_BC_InverterDisable();
 80229a4:	f7fe f84e 	bl	8020a44 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>
#endif

  Motor0_BLDC_SCALAR.motor_speed = 0;
 80229a8:	4b0c      	ldr	r3, [pc, #48]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229aa:	2200      	movs	r2, #0
 80229ac:	66da      	str	r2, [r3, #108]	; 0x6c
  Motor0_BLDC_SCALAR.motor_current = 0;
 80229ae:	4b0b      	ldr	r3, [pc, #44]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229b0:	2200      	movs	r2, #0
 80229b2:	671a      	str	r2, [r3, #112]	; 0x70
  Motor0_BLDC_SCALAR.motor_average_current = 0;
 80229b4:	4b09      	ldr	r3, [pc, #36]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229b6:	2200      	movs	r2, #0
 80229b8:	675a      	str	r2, [r3, #116]	; 0x74

  if (Motor0_BLDC_SCALAR.error_status != 0U)
 80229ba:	4b08      	ldr	r3, [pc, #32]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229bc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80229be:	2b00      	cmp	r3, #0
 80229c0:	d006      	beq.n	80229d0 <Motor0_BLDC_SCALAR_MotorStop+0x38>
  {
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 80229c2:	4b06      	ldr	r3, [pc, #24]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229c4:	2208      	movs	r2, #8
 80229c6:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    /*Change motor control state machine to error*/
    Motor0_BLDC_SCALAR_MSM();
 80229ca:	f008 fb01 	bl	802afd0 <__Motor0_BLDC_SCALAR_MSM_veneer>
  else
  {
    /* Change motor control state machine to stop */
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
  }
}
 80229ce:	e003      	b.n	80229d8 <Motor0_BLDC_SCALAR_MotorStop+0x40>
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
 80229d0:	4b02      	ldr	r3, [pc, #8]	; (80229dc <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 80229d2:	2200      	movs	r2, #0
 80229d4:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 80229d8:	bf00      	nop
 80229da:	bd80      	pop	{r7, pc}
 80229dc:	2000018c 	.word	0x2000018c

080229e0 <Motor0_BLDC_SCALAR_GetMotorSpeed>:
 *
 * \par<b>Description:</b><br>
 * Updates the reference variable with the motor mechanical speed in RPM
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetMotorSpeed(int32_t *speed)
{
 80229e0:	b480      	push	{r7}
 80229e2:	b083      	sub	sp, #12
 80229e4:	af00      	add	r7, sp, #0
 80229e6:	6078      	str	r0, [r7, #4]
  *speed = ((Motor0_BLDC_SCALAR.motor_speed * (int32_t)Motor0_BLDC_SCALAR.speed_scale) >> BLDC_SCALAR_15);
 80229e8:	4b07      	ldr	r3, [pc, #28]	; (8022a08 <Motor0_BLDC_SCALAR_GetMotorSpeed+0x28>)
 80229ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80229ec:	4a06      	ldr	r2, [pc, #24]	; (8022a08 <Motor0_BLDC_SCALAR_GetMotorSpeed+0x28>)
 80229ee:	f8d2 20b0 	ldr.w	r2, [r2, #176]	; 0xb0
 80229f2:	fb02 f303 	mul.w	r3, r2, r3
 80229f6:	13da      	asrs	r2, r3, #15
 80229f8:	687b      	ldr	r3, [r7, #4]
 80229fa:	601a      	str	r2, [r3, #0]
}
 80229fc:	bf00      	nop
 80229fe:	370c      	adds	r7, #12
 8022a00:	46bd      	mov	sp, r7
 8022a02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022a06:	4770      	bx	lr
 8022a08:	2000018c 	.word	0x2000018c

08022a0c <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent>:
 *
 * \par<b>Description:</b><br>
 * Updates the reference variable with the motor DC link average current in mA
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent(int32_t *avg_current)
{
 8022a0c:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022a10:	b085      	sub	sp, #20
 8022a12:	af00      	add	r7, sp, #0
 8022a14:	60f8      	str	r0, [r7, #12]
  *avg_current = (int32_t)(((int64_t)BLDC_SCALAR_MILLI * Motor0_BLDC_SCALAR.motor_average_current *
 8022a16:	492a      	ldr	r1, [pc, #168]	; (8022ac0 <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent+0xb4>)
 8022a18:	6f49      	ldr	r1, [r1, #116]	; 0x74
 8022a1a:	17c8      	asrs	r0, r1, #31
 8022a1c:	6039      	str	r1, [r7, #0]
 8022a1e:	6078      	str	r0, [r7, #4]
                 (int32_t)Motor0_BLDC_SCALAR.current_scale) >> BLDC_SCALAR_15);
 8022a20:	4927      	ldr	r1, [pc, #156]	; (8022ac0 <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent+0xb4>)
 8022a22:	f8d1 10b4 	ldr.w	r1, [r1, #180]	; 0xb4
 8022a26:	17c8      	asrs	r0, r1, #31
 8022a28:	468a      	mov	sl, r1
 8022a2a:	4683      	mov	fp, r0
  *avg_current = (int32_t)(((int64_t)BLDC_SCALAR_MILLI * Motor0_BLDC_SCALAR.motor_average_current *
 8022a2c:	6879      	ldr	r1, [r7, #4]
 8022a2e:	fb0a f001 	mul.w	r0, sl, r1
 8022a32:	6839      	ldr	r1, [r7, #0]
 8022a34:	fb01 f10b 	mul.w	r1, r1, fp
 8022a38:	4401      	add	r1, r0
 8022a3a:	6838      	ldr	r0, [r7, #0]
 8022a3c:	fba0 230a 	umull	r2, r3, r0, sl
 8022a40:	4419      	add	r1, r3
 8022a42:	460b      	mov	r3, r1
 8022a44:	4610      	mov	r0, r2
 8022a46:	4619      	mov	r1, r3
 8022a48:	f04f 0a00 	mov.w	sl, #0
 8022a4c:	f04f 0b00 	mov.w	fp, #0
 8022a50:	ea4f 1b41 	mov.w	fp, r1, lsl #5
 8022a54:	ea4b 6bd0 	orr.w	fp, fp, r0, lsr #27
 8022a58:	ea4f 1a40 	mov.w	sl, r0, lsl #5
 8022a5c:	4650      	mov	r0, sl
 8022a5e:	4659      	mov	r1, fp
 8022a60:	1a84      	subs	r4, r0, r2
 8022a62:	eb61 0503 	sbc.w	r5, r1, r3
 8022a66:	f04f 0000 	mov.w	r0, #0
 8022a6a:	f04f 0100 	mov.w	r1, #0
 8022a6e:	00a9      	lsls	r1, r5, #2
 8022a70:	ea41 7194 	orr.w	r1, r1, r4, lsr #30
 8022a74:	00a0      	lsls	r0, r4, #2
 8022a76:	4604      	mov	r4, r0
 8022a78:	460d      	mov	r5, r1
 8022a7a:	eb14 0802 	adds.w	r8, r4, r2
 8022a7e:	eb45 0903 	adc.w	r9, r5, r3
 8022a82:	f04f 0200 	mov.w	r2, #0
 8022a86:	f04f 0300 	mov.w	r3, #0
 8022a8a:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8022a8e:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8022a92:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8022a96:	4690      	mov	r8, r2
 8022a98:	4699      	mov	r9, r3
 8022a9a:	4640      	mov	r0, r8
 8022a9c:	4649      	mov	r1, r9
                 (int32_t)Motor0_BLDC_SCALAR.current_scale) >> BLDC_SCALAR_15);
 8022a9e:	f04f 0200 	mov.w	r2, #0
 8022aa2:	f04f 0300 	mov.w	r3, #0
 8022aa6:	0bc2      	lsrs	r2, r0, #15
 8022aa8:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
 8022aac:	13cb      	asrs	r3, r1, #15
  *avg_current = (int32_t)(((int64_t)BLDC_SCALAR_MILLI * Motor0_BLDC_SCALAR.motor_average_current *
 8022aae:	68fb      	ldr	r3, [r7, #12]
 8022ab0:	601a      	str	r2, [r3, #0]
}
 8022ab2:	bf00      	nop
 8022ab4:	3714      	adds	r7, #20
 8022ab6:	46bd      	mov	sp, r7
 8022ab8:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
 8022abc:	4770      	bx	lr
 8022abe:	bf00      	nop
 8022ac0:	2000018c 	.word	0x2000018c

08022ac4 <Motor0_BLDC_SCALAR_SetSpeedVal>:
 * -# -(MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED) to 0 for BLDC_SCALAR_NEGATIVE_DIR
 * -# 0 to (MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED) for BLDC_SCALAR_POSITIVE_DIR
 *
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedVal(int32_t speed)
{
 8022ac4:	b480      	push	{r7}
 8022ac6:	b085      	sub	sp, #20
 8022ac8:	af00      	add	r7, sp, #0
 8022aca:	6078      	str	r0, [r7, #4]
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022acc:	2302      	movs	r3, #2
 8022ace:	73fb      	strb	r3, [r7, #15]
  if ((speed <= (int32_t)MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED) && (speed >= -(int32_t)MOTOR0_BLDC_SCALAR_MOTOR_NO_LOAD_SPEED))
 8022ad0:	687b      	ldr	r3, [r7, #4]
 8022ad2:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 8022ad6:	dc0e      	bgt.n	8022af6 <Motor0_BLDC_SCALAR_SetSpeedVal+0x32>
 8022ad8:	687b      	ldr	r3, [r7, #4]
 8022ada:	f513 6f96 	cmn.w	r3, #1200	; 0x4b0
 8022ade:	db0a      	blt.n	8022af6 <Motor0_BLDC_SCALAR_SetSpeedVal+0x32>
  {
    Motor0_BLDC_SCALAR_SpeedControl.user_speed_set =
        ((speed << BLDC_SCALAR_15) / (int32_t)Motor0_BLDC_SCALAR.speed_scale);
 8022ae0:	687b      	ldr	r3, [r7, #4]
 8022ae2:	03db      	lsls	r3, r3, #15
 8022ae4:	4a07      	ldr	r2, [pc, #28]	; (8022b04 <Motor0_BLDC_SCALAR_SetSpeedVal+0x40>)
 8022ae6:	f8d2 20b0 	ldr.w	r2, [r2, #176]	; 0xb0
 8022aea:	fb93 f3f2 	sdiv	r3, r3, r2
    Motor0_BLDC_SCALAR_SpeedControl.user_speed_set =
 8022aee:	4a06      	ldr	r2, [pc, #24]	; (8022b08 <Motor0_BLDC_SCALAR_SetSpeedVal+0x44>)
 8022af0:	6053      	str	r3, [r2, #4]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022af2:	2300      	movs	r3, #0
 8022af4:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022af6:	7bfb      	ldrb	r3, [r7, #15]
}
 8022af8:	4618      	mov	r0, r3
 8022afa:	3714      	adds	r7, #20
 8022afc:	46bd      	mov	sp, r7
 8022afe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b02:	4770      	bx	lr
 8022b04:	2000018c 	.word	0x2000018c
 8022b08:	20000148 	.word	0x20000148

08022b0c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain>:
 *
 * \par<b>Description:</b><br>
 * Sets the proportional gain of the speed PI control.
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedProportionalGain(uint16_t kp)
{
 8022b0c:	b480      	push	{r7}
 8022b0e:	b085      	sub	sp, #20
 8022b10:	af00      	add	r7, sp, #0
 8022b12:	4603      	mov	r3, r0
 8022b14:	80fb      	strh	r3, [r7, #6]
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022b16:	2302      	movs	r3, #2
 8022b18:	73fb      	strb	r3, [r7, #15]
  if (kp <= BLDC_SCALAR_POW_15)
 8022b1a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8022b1e:	2b00      	cmp	r3, #0
 8022b20:	db04      	blt.n	8022b2c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain+0x20>
  {
    Motor0_BLDC_SCALAR_SpeedControl_PI.kp = kp;
 8022b22:	4a06      	ldr	r2, [pc, #24]	; (8022b3c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain+0x30>)
 8022b24:	88fb      	ldrh	r3, [r7, #6]
 8022b26:	8213      	strh	r3, [r2, #16]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022b28:	2300      	movs	r3, #0
 8022b2a:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022b2c:	7bfb      	ldrb	r3, [r7, #15]
}
 8022b2e:	4618      	mov	r0, r3
 8022b30:	3714      	adds	r7, #20
 8022b32:	46bd      	mov	sp, r7
 8022b34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b38:	4770      	bx	lr
 8022b3a:	bf00      	nop
 8022b3c:	2000008c 	.word	0x2000008c

08022b40 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain>:
 *
 * \par<b>Description:</b><br>
 * Sets the integral gain of the speed PI control.
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedIntegralGain(uint16_t ki)
{
 8022b40:	b480      	push	{r7}
 8022b42:	b085      	sub	sp, #20
 8022b44:	af00      	add	r7, sp, #0
 8022b46:	4603      	mov	r3, r0
 8022b48:	80fb      	strh	r3, [r7, #6]
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022b4a:	2302      	movs	r3, #2
 8022b4c:	73fb      	strb	r3, [r7, #15]
  if (ki <= BLDC_SCALAR_POW_15)
 8022b4e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8022b52:	2b00      	cmp	r3, #0
 8022b54:	db04      	blt.n	8022b60 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain+0x20>
  {
    Motor0_BLDC_SCALAR_SpeedControl_PI.ki = ki;
 8022b56:	4a06      	ldr	r2, [pc, #24]	; (8022b70 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain+0x30>)
 8022b58:	88fb      	ldrh	r3, [r7, #6]
 8022b5a:	8253      	strh	r3, [r2, #18]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022b5c:	2300      	movs	r3, #0
 8022b5e:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022b60:	7bfb      	ldrb	r3, [r7, #15]
}
 8022b62:	4618      	mov	r0, r3
 8022b64:	3714      	adds	r7, #20
 8022b66:	46bd      	mov	sp, r7
 8022b68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b6c:	4770      	bx	lr
 8022b6e:	bf00      	nop
 8022b70:	2000008c 	.word	0x2000008c

08022b74 <Motor0_BLDC_SCALAR_SetSpeedPILimit>:
 *
 * \par<b>Description:</b><br>
 * Sets the speed PI output limit
 */
__STATIC_INLINE BLDC_SCALAR_STATUS_t Motor0_BLDC_SCALAR_SetSpeedPILimit(uint8_t percentage_limit)
{
 8022b74:	b480      	push	{r7}
 8022b76:	b085      	sub	sp, #20
 8022b78:	af00      	add	r7, sp, #0
 8022b7a:	4603      	mov	r3, r0
 8022b7c:	71fb      	strb	r3, [r7, #7]
  uint32_t limit;
  BLDC_SCALAR_STATUS_t status = BLDC_SCALAR_STATUS_INVALID_PARAM;
 8022b7e:	2302      	movs	r3, #2
 8022b80:	73fb      	strb	r3, [r7, #15]
  if (percentage_limit <= (uint8_t)BLDC_SCALAR_PERCENTAGE)
 8022b82:	79fb      	ldrb	r3, [r7, #7]
 8022b84:	2b64      	cmp	r3, #100	; 0x64
 8022b86:	d811      	bhi.n	8022bac <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x38>
  {
    limit = (BLDC_SCALAR_POW_14 * (uint32_t)percentage_limit) / (uint32_t)BLDC_SCALAR_PERCENTAGE;
 8022b88:	79fa      	ldrb	r2, [r7, #7]
 8022b8a:	4613      	mov	r3, r2
 8022b8c:	039b      	lsls	r3, r3, #14
 8022b8e:	1a9b      	subs	r3, r3, r2
 8022b90:	4a0a      	ldr	r2, [pc, #40]	; (8022bbc <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x48>)
 8022b92:	fba2 2303 	umull	r2, r3, r2, r3
 8022b96:	095b      	lsrs	r3, r3, #5
 8022b98:	60bb      	str	r3, [r7, #8]
    Motor0_BLDC_SCALAR_SpeedControl_PI.uk_limit_max = (int32_t)limit;
 8022b9a:	68bb      	ldr	r3, [r7, #8]
 8022b9c:	4a08      	ldr	r2, [pc, #32]	; (8022bc0 <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x4c>)
 8022b9e:	60d3      	str	r3, [r2, #12]
    Motor0_BLDC_SCALAR_SpeedControl_PI.uk_limit_min = -(int32_t)limit;
 8022ba0:	68bb      	ldr	r3, [r7, #8]
 8022ba2:	425b      	negs	r3, r3
 8022ba4:	4a06      	ldr	r2, [pc, #24]	; (8022bc0 <Motor0_BLDC_SCALAR_SetSpeedPILimit+0x4c>)
 8022ba6:	6093      	str	r3, [r2, #8]
    status = BLDC_SCALAR_STATUS_SUCCESS;
 8022ba8:	2300      	movs	r3, #0
 8022baa:	73fb      	strb	r3, [r7, #15]
  }
  return status;
 8022bac:	7bfb      	ldrb	r3, [r7, #15]
}
 8022bae:	4618      	mov	r0, r3
 8022bb0:	3714      	adds	r7, #20
 8022bb2:	46bd      	mov	sp, r7
 8022bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022bb8:	4770      	bx	lr
 8022bba:	bf00      	nop
 8022bbc:	51eb851f 	.word	0x51eb851f
 8022bc0:	2000008c 	.word	0x2000008c

08022bc4 <Motor0_BLDC_SCALAR_ClearErrorState>:
 *
 * \par<b>Description:</b><br>
 * This API should be called to clear errors before restarting the motor.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_ClearErrorState(void)
{
 8022bc4:	b480      	push	{r7}
 8022bc6:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR.error_status = 0U;
 8022bc8:	4b03      	ldr	r3, [pc, #12]	; (8022bd8 <Motor0_BLDC_SCALAR_ClearErrorState+0x14>)
 8022bca:	2200      	movs	r2, #0
 8022bcc:	669a      	str	r2, [r3, #104]	; 0x68
}
 8022bce:	bf00      	nop
 8022bd0:	46bd      	mov	sp, r7
 8022bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022bd6:	4770      	bx	lr
 8022bd8:	2000018c 	.word	0x2000018c

08022bdc <MotorInit>:
void HallTimerProc(void *args);
void MotorStepProc(void *args);


void MotorInit (void)
{
 8022bdc:	b580      	push	{r7, lr}
 8022bde:	af00      	add	r7, sp, #0
    MotorStepTimer = SYSTIMER_CreateTimer(1000, SYSTIMER_MODE_PERIODIC, MotorStepProc, NULL );
 8022be0:	2300      	movs	r3, #0
 8022be2:	4a11      	ldr	r2, [pc, #68]	; (8022c28 <MotorInit+0x4c>)
 8022be4:	2101      	movs	r1, #1
 8022be6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8022bea:	f006 f9f7 	bl	8028fdc <SYSTIMER_CreateTimer>
 8022bee:	4603      	mov	r3, r0
 8022bf0:	461a      	mov	r2, r3
 8022bf2:	4b0e      	ldr	r3, [pc, #56]	; (8022c2c <MotorInit+0x50>)
 8022bf4:	601a      	str	r2, [r3, #0]
	HallTimer = SYSTIMER_CreateTimer(100, SYSTIMER_MODE_PERIODIC, HallTimerProc, NULL );
 8022bf6:	2300      	movs	r3, #0
 8022bf8:	4a0d      	ldr	r2, [pc, #52]	; (8022c30 <MotorInit+0x54>)
 8022bfa:	2101      	movs	r1, #1
 8022bfc:	2064      	movs	r0, #100	; 0x64
 8022bfe:	f006 f9ed 	bl	8028fdc <SYSTIMER_CreateTimer>
 8022c02:	4603      	mov	r3, r0
 8022c04:	461a      	mov	r2, r3
 8022c06:	4b0b      	ldr	r3, [pc, #44]	; (8022c34 <MotorInit+0x58>)
 8022c08:	601a      	str	r2, [r3, #0]

	SYSTIMER_StartTimer(HallTimer);
 8022c0a:	4b0a      	ldr	r3, [pc, #40]	; (8022c34 <MotorInit+0x58>)
 8022c0c:	681b      	ldr	r3, [r3, #0]
 8022c0e:	4618      	mov	r0, r3
 8022c10:	f006 fa82 	bl	8029118 <SYSTIMER_StartTimer>
	SYSTIMER_StartTimer(MotorStepTimer);
 8022c14:	4b05      	ldr	r3, [pc, #20]	; (8022c2c <MotorInit+0x50>)
 8022c16:	681b      	ldr	r3, [r3, #0]
 8022c18:	4618      	mov	r0, r3
 8022c1a:	f006 fa7d 	bl	8029118 <SYSTIMER_StartTimer>
    Motor0_BLDC_SCALAR_Init();
 8022c1e:	f7ff fe8d 	bl	802293c <Motor0_BLDC_SCALAR_Init>
}
 8022c22:	bf00      	nop
 8022c24:	bd80      	pop	{r7, pc}
 8022c26:	bf00      	nop
 8022c28:	08022e75 	.word	0x08022e75
 8022c2c:	20000618 	.word	0x20000618
 8022c30:	08022d11 	.word	0x08022d11
 8022c34:	2000061c 	.word	0x2000061c

08022c38 <MotorStart>:

void MotorStart(void)
{
 8022c38:	b580      	push	{r7, lr}
 8022c3a:	af00      	add	r7, sp, #0
	Motor0_BLDC_SCALAR_MotorStart();
 8022c3c:	f7ff fe9a 	bl	8022974 <Motor0_BLDC_SCALAR_MotorStart>
}
 8022c40:	bf00      	nop
 8022c42:	bd80      	pop	{r7, pc}

08022c44 <MotorStop>:
void MotorStop(void)
{
 8022c44:	b580      	push	{r7, lr}
 8022c46:	af00      	add	r7, sp, #0
	Motor0_BLDC_SCALAR_MotorStop();
 8022c48:	f7ff fea6 	bl	8022998 <Motor0_BLDC_SCALAR_MotorStop>
}
 8022c4c:	bf00      	nop
 8022c4e:	bd80      	pop	{r7, pc}

08022c50 <MotorSetSpeed>:

void MotorSetSpeed(int32_t speed)
{
 8022c50:	b580      	push	{r7, lr}
 8022c52:	b082      	sub	sp, #8
 8022c54:	af00      	add	r7, sp, #0
 8022c56:	6078      	str	r0, [r7, #4]
	Motor0_BLDC_SCALAR_SetSpeedVal(speed);
 8022c58:	6878      	ldr	r0, [r7, #4]
 8022c5a:	f7ff ff33 	bl	8022ac4 <Motor0_BLDC_SCALAR_SetSpeedVal>
}
 8022c5e:	bf00      	nop
 8022c60:	3708      	adds	r7, #8
 8022c62:	46bd      	mov	sp, r7
 8022c64:	bd80      	pop	{r7, pc}

08022c66 <MotorSetProportionalGain>:
void MotorSetProportionalGain(uint16_t kp)
{
 8022c66:	b580      	push	{r7, lr}
 8022c68:	b082      	sub	sp, #8
 8022c6a:	af00      	add	r7, sp, #0
 8022c6c:	4603      	mov	r3, r0
 8022c6e:	80fb      	strh	r3, [r7, #6]
	Motor0_BLDC_SCALAR_SetSpeedProportionalGain(kp);
 8022c70:	88fb      	ldrh	r3, [r7, #6]
 8022c72:	4618      	mov	r0, r3
 8022c74:	f7ff ff4a 	bl	8022b0c <Motor0_BLDC_SCALAR_SetSpeedProportionalGain>
}
 8022c78:	bf00      	nop
 8022c7a:	3708      	adds	r7, #8
 8022c7c:	46bd      	mov	sp, r7
 8022c7e:	bd80      	pop	{r7, pc}

08022c80 <MotorSetIntegralGain>:
void MotorSetIntegralGain(uint16_t ki)
{
 8022c80:	b580      	push	{r7, lr}
 8022c82:	b082      	sub	sp, #8
 8022c84:	af00      	add	r7, sp, #0
 8022c86:	4603      	mov	r3, r0
 8022c88:	80fb      	strh	r3, [r7, #6]
	Motor0_BLDC_SCALAR_SetSpeedIntegralGain(ki);
 8022c8a:	88fb      	ldrh	r3, [r7, #6]
 8022c8c:	4618      	mov	r0, r3
 8022c8e:	f7ff ff57 	bl	8022b40 <Motor0_BLDC_SCALAR_SetSpeedIntegralGain>
}
 8022c92:	bf00      	nop
 8022c94:	3708      	adds	r7, #8
 8022c96:	46bd      	mov	sp, r7
 8022c98:	bd80      	pop	{r7, pc}

08022c9a <MotorSetPILimit>:
void MotorSetPILimit(uint8_t percent_limit)
{
 8022c9a:	b580      	push	{r7, lr}
 8022c9c:	b082      	sub	sp, #8
 8022c9e:	af00      	add	r7, sp, #0
 8022ca0:	4603      	mov	r3, r0
 8022ca2:	71fb      	strb	r3, [r7, #7]
	Motor0_BLDC_SCALAR_SetSpeedPILimit(percent_limit);
 8022ca4:	79fb      	ldrb	r3, [r7, #7]
 8022ca6:	4618      	mov	r0, r3
 8022ca8:	f7ff ff64 	bl	8022b74 <Motor0_BLDC_SCALAR_SetSpeedPILimit>
}
 8022cac:	bf00      	nop
 8022cae:	3708      	adds	r7, #8
 8022cb0:	46bd      	mov	sp, r7
 8022cb2:	bd80      	pop	{r7, pc}

08022cb4 <MotorClearError>:

void MotorClearError(void)
{
 8022cb4:	b580      	push	{r7, lr}
 8022cb6:	af00      	add	r7, sp, #0
	Motor0_BLDC_SCALAR_ClearErrorState();
 8022cb8:	f7ff ff84 	bl	8022bc4 <Motor0_BLDC_SCALAR_ClearErrorState>
}
 8022cbc:	bf00      	nop
 8022cbe:	bd80      	pop	{r7, pc}

08022cc0 <MotorRead>:

void MotorRead(void)
{
 8022cc0:	b580      	push	{r7, lr}
 8022cc2:	b082      	sub	sp, #8
 8022cc4:	af00      	add	r7, sp, #0
	int32_t Cur,Vel;

	Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent(&drive.RAWCurrent);
 8022cc6:	480f      	ldr	r0, [pc, #60]	; (8022d04 <MotorRead+0x44>)
 8022cc8:	f7ff fea0 	bl	8022a0c <Motor0_BLDC_SCALAR_GetAverageDCLinkCurrent>
	Cur = abs(drive.RAWCurrent);
 8022ccc:	4b0e      	ldr	r3, [pc, #56]	; (8022d08 <MotorRead+0x48>)
 8022cce:	691b      	ldr	r3, [r3, #16]
 8022cd0:	2b00      	cmp	r3, #0
 8022cd2:	bfb8      	it	lt
 8022cd4:	425b      	neglt	r3, r3
 8022cd6:	607b      	str	r3, [r7, #4]
	drive.Current = (uint16_t)Cur;
 8022cd8:	687b      	ldr	r3, [r7, #4]
 8022cda:	b29a      	uxth	r2, r3
 8022cdc:	4b0a      	ldr	r3, [pc, #40]	; (8022d08 <MotorRead+0x48>)
 8022cde:	805a      	strh	r2, [r3, #2]
	Motor0_BLDC_SCALAR_GetMotorSpeed(&drive.RAWVelocity);
 8022ce0:	480a      	ldr	r0, [pc, #40]	; (8022d0c <MotorRead+0x4c>)
 8022ce2:	f7ff fe7d 	bl	80229e0 <Motor0_BLDC_SCALAR_GetMotorSpeed>
	Vel = abs(drive.RAWVelocity);
 8022ce6:	4b08      	ldr	r3, [pc, #32]	; (8022d08 <MotorRead+0x48>)
 8022ce8:	68db      	ldr	r3, [r3, #12]
 8022cea:	2b00      	cmp	r3, #0
 8022cec:	bfb8      	it	lt
 8022cee:	425b      	neglt	r3, r3
 8022cf0:	603b      	str	r3, [r7, #0]
	drive.Velocity = (uint16_t)Vel;
 8022cf2:	683b      	ldr	r3, [r7, #0]
 8022cf4:	b29a      	uxth	r2, r3
 8022cf6:	4b04      	ldr	r3, [pc, #16]	; (8022d08 <MotorRead+0x48>)
 8022cf8:	809a      	strh	r2, [r3, #4]
}
 8022cfa:	bf00      	nop
 8022cfc:	3708      	adds	r7, #8
 8022cfe:	46bd      	mov	sp, r7
 8022d00:	bd80      	pop	{r7, pc}
 8022d02:	bf00      	nop
 8022d04:	20000610 	.word	0x20000610
 8022d08:	20000600 	.word	0x20000600
 8022d0c:	2000060c 	.word	0x2000060c

08022d10 <HallTimerProc>:
void HallTimerProc(void *args)
{
 8022d10:	b580      	push	{r7, lr}
 8022d12:	b084      	sub	sp, #16
 8022d14:	af00      	add	r7, sp, #0
 8022d16:	6078      	str	r0, [r7, #4]
	uint32_t hall  = 0;
 8022d18:	2300      	movs	r3, #0
 8022d1a:	60fb      	str	r3, [r7, #12]
	static uint32_t prev_hall = 0;

	hall = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 8022d1c:	f7fd ff7e 	bl	8020c1c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 8022d20:	60f8      	str	r0, [r7, #12]
	if (hall != prev_hall)
 8022d22:	4b52      	ldr	r3, [pc, #328]	; (8022e6c <HallTimerProc+0x15c>)
 8022d24:	681b      	ldr	r3, [r3, #0]
 8022d26:	68fa      	ldr	r2, [r7, #12]
 8022d28:	429a      	cmp	r2, r3
 8022d2a:	f000 8090 	beq.w	8022e4e <HallTimerProc+0x13e>
	{
		if ((hall == 1) && (prev_hall == 5)) drive.RAWPosition++;
 8022d2e:	68fb      	ldr	r3, [r7, #12]
 8022d30:	2b01      	cmp	r3, #1
 8022d32:	d108      	bne.n	8022d46 <HallTimerProc+0x36>
 8022d34:	4b4d      	ldr	r3, [pc, #308]	; (8022e6c <HallTimerProc+0x15c>)
 8022d36:	681b      	ldr	r3, [r3, #0]
 8022d38:	2b05      	cmp	r3, #5
 8022d3a:	d104      	bne.n	8022d46 <HallTimerProc+0x36>
 8022d3c:	4b4c      	ldr	r3, [pc, #304]	; (8022e70 <HallTimerProc+0x160>)
 8022d3e:	689b      	ldr	r3, [r3, #8]
 8022d40:	3301      	adds	r3, #1
 8022d42:	4a4b      	ldr	r2, [pc, #300]	; (8022e70 <HallTimerProc+0x160>)
 8022d44:	6093      	str	r3, [r2, #8]
		if ((hall == 1) && (prev_hall == 3)) drive.RAWPosition--;
 8022d46:	68fb      	ldr	r3, [r7, #12]
 8022d48:	2b01      	cmp	r3, #1
 8022d4a:	d108      	bne.n	8022d5e <HallTimerProc+0x4e>
 8022d4c:	4b47      	ldr	r3, [pc, #284]	; (8022e6c <HallTimerProc+0x15c>)
 8022d4e:	681b      	ldr	r3, [r3, #0]
 8022d50:	2b03      	cmp	r3, #3
 8022d52:	d104      	bne.n	8022d5e <HallTimerProc+0x4e>
 8022d54:	4b46      	ldr	r3, [pc, #280]	; (8022e70 <HallTimerProc+0x160>)
 8022d56:	689b      	ldr	r3, [r3, #8]
 8022d58:	3b01      	subs	r3, #1
 8022d5a:	4a45      	ldr	r2, [pc, #276]	; (8022e70 <HallTimerProc+0x160>)
 8022d5c:	6093      	str	r3, [r2, #8]

		if ((hall == 3) && (prev_hall == 1)) drive.RAWPosition++;
 8022d5e:	68fb      	ldr	r3, [r7, #12]
 8022d60:	2b03      	cmp	r3, #3
 8022d62:	d108      	bne.n	8022d76 <HallTimerProc+0x66>
 8022d64:	4b41      	ldr	r3, [pc, #260]	; (8022e6c <HallTimerProc+0x15c>)
 8022d66:	681b      	ldr	r3, [r3, #0]
 8022d68:	2b01      	cmp	r3, #1
 8022d6a:	d104      	bne.n	8022d76 <HallTimerProc+0x66>
 8022d6c:	4b40      	ldr	r3, [pc, #256]	; (8022e70 <HallTimerProc+0x160>)
 8022d6e:	689b      	ldr	r3, [r3, #8]
 8022d70:	3301      	adds	r3, #1
 8022d72:	4a3f      	ldr	r2, [pc, #252]	; (8022e70 <HallTimerProc+0x160>)
 8022d74:	6093      	str	r3, [r2, #8]
		if ((hall == 3) && (prev_hall == 2)) drive.RAWPosition--;
 8022d76:	68fb      	ldr	r3, [r7, #12]
 8022d78:	2b03      	cmp	r3, #3
 8022d7a:	d108      	bne.n	8022d8e <HallTimerProc+0x7e>
 8022d7c:	4b3b      	ldr	r3, [pc, #236]	; (8022e6c <HallTimerProc+0x15c>)
 8022d7e:	681b      	ldr	r3, [r3, #0]
 8022d80:	2b02      	cmp	r3, #2
 8022d82:	d104      	bne.n	8022d8e <HallTimerProc+0x7e>
 8022d84:	4b3a      	ldr	r3, [pc, #232]	; (8022e70 <HallTimerProc+0x160>)
 8022d86:	689b      	ldr	r3, [r3, #8]
 8022d88:	3b01      	subs	r3, #1
 8022d8a:	4a39      	ldr	r2, [pc, #228]	; (8022e70 <HallTimerProc+0x160>)
 8022d8c:	6093      	str	r3, [r2, #8]

		if ((hall == 2) && (prev_hall == 3)) drive.RAWPosition++;
 8022d8e:	68fb      	ldr	r3, [r7, #12]
 8022d90:	2b02      	cmp	r3, #2
 8022d92:	d108      	bne.n	8022da6 <HallTimerProc+0x96>
 8022d94:	4b35      	ldr	r3, [pc, #212]	; (8022e6c <HallTimerProc+0x15c>)
 8022d96:	681b      	ldr	r3, [r3, #0]
 8022d98:	2b03      	cmp	r3, #3
 8022d9a:	d104      	bne.n	8022da6 <HallTimerProc+0x96>
 8022d9c:	4b34      	ldr	r3, [pc, #208]	; (8022e70 <HallTimerProc+0x160>)
 8022d9e:	689b      	ldr	r3, [r3, #8]
 8022da0:	3301      	adds	r3, #1
 8022da2:	4a33      	ldr	r2, [pc, #204]	; (8022e70 <HallTimerProc+0x160>)
 8022da4:	6093      	str	r3, [r2, #8]
		if ((hall == 2) && (prev_hall == 6)) drive.RAWPosition--;
 8022da6:	68fb      	ldr	r3, [r7, #12]
 8022da8:	2b02      	cmp	r3, #2
 8022daa:	d108      	bne.n	8022dbe <HallTimerProc+0xae>
 8022dac:	4b2f      	ldr	r3, [pc, #188]	; (8022e6c <HallTimerProc+0x15c>)
 8022dae:	681b      	ldr	r3, [r3, #0]
 8022db0:	2b06      	cmp	r3, #6
 8022db2:	d104      	bne.n	8022dbe <HallTimerProc+0xae>
 8022db4:	4b2e      	ldr	r3, [pc, #184]	; (8022e70 <HallTimerProc+0x160>)
 8022db6:	689b      	ldr	r3, [r3, #8]
 8022db8:	3b01      	subs	r3, #1
 8022dba:	4a2d      	ldr	r2, [pc, #180]	; (8022e70 <HallTimerProc+0x160>)
 8022dbc:	6093      	str	r3, [r2, #8]

		if ((hall == 6) && (prev_hall == 2)) drive.RAWPosition++;
 8022dbe:	68fb      	ldr	r3, [r7, #12]
 8022dc0:	2b06      	cmp	r3, #6
 8022dc2:	d108      	bne.n	8022dd6 <HallTimerProc+0xc6>
 8022dc4:	4b29      	ldr	r3, [pc, #164]	; (8022e6c <HallTimerProc+0x15c>)
 8022dc6:	681b      	ldr	r3, [r3, #0]
 8022dc8:	2b02      	cmp	r3, #2
 8022dca:	d104      	bne.n	8022dd6 <HallTimerProc+0xc6>
 8022dcc:	4b28      	ldr	r3, [pc, #160]	; (8022e70 <HallTimerProc+0x160>)
 8022dce:	689b      	ldr	r3, [r3, #8]
 8022dd0:	3301      	adds	r3, #1
 8022dd2:	4a27      	ldr	r2, [pc, #156]	; (8022e70 <HallTimerProc+0x160>)
 8022dd4:	6093      	str	r3, [r2, #8]
		if ((hall == 6) && (prev_hall == 4)) drive.RAWPosition--;
 8022dd6:	68fb      	ldr	r3, [r7, #12]
 8022dd8:	2b06      	cmp	r3, #6
 8022dda:	d108      	bne.n	8022dee <HallTimerProc+0xde>
 8022ddc:	4b23      	ldr	r3, [pc, #140]	; (8022e6c <HallTimerProc+0x15c>)
 8022dde:	681b      	ldr	r3, [r3, #0]
 8022de0:	2b04      	cmp	r3, #4
 8022de2:	d104      	bne.n	8022dee <HallTimerProc+0xde>
 8022de4:	4b22      	ldr	r3, [pc, #136]	; (8022e70 <HallTimerProc+0x160>)
 8022de6:	689b      	ldr	r3, [r3, #8]
 8022de8:	3b01      	subs	r3, #1
 8022dea:	4a21      	ldr	r2, [pc, #132]	; (8022e70 <HallTimerProc+0x160>)
 8022dec:	6093      	str	r3, [r2, #8]

		if ((hall == 4) && (prev_hall == 6)) drive.RAWPosition++;
 8022dee:	68fb      	ldr	r3, [r7, #12]
 8022df0:	2b04      	cmp	r3, #4
 8022df2:	d108      	bne.n	8022e06 <HallTimerProc+0xf6>
 8022df4:	4b1d      	ldr	r3, [pc, #116]	; (8022e6c <HallTimerProc+0x15c>)
 8022df6:	681b      	ldr	r3, [r3, #0]
 8022df8:	2b06      	cmp	r3, #6
 8022dfa:	d104      	bne.n	8022e06 <HallTimerProc+0xf6>
 8022dfc:	4b1c      	ldr	r3, [pc, #112]	; (8022e70 <HallTimerProc+0x160>)
 8022dfe:	689b      	ldr	r3, [r3, #8]
 8022e00:	3301      	adds	r3, #1
 8022e02:	4a1b      	ldr	r2, [pc, #108]	; (8022e70 <HallTimerProc+0x160>)
 8022e04:	6093      	str	r3, [r2, #8]
		if ((hall == 4) && (prev_hall == 5)) drive.RAWPosition--;
 8022e06:	68fb      	ldr	r3, [r7, #12]
 8022e08:	2b04      	cmp	r3, #4
 8022e0a:	d108      	bne.n	8022e1e <HallTimerProc+0x10e>
 8022e0c:	4b17      	ldr	r3, [pc, #92]	; (8022e6c <HallTimerProc+0x15c>)
 8022e0e:	681b      	ldr	r3, [r3, #0]
 8022e10:	2b05      	cmp	r3, #5
 8022e12:	d104      	bne.n	8022e1e <HallTimerProc+0x10e>
 8022e14:	4b16      	ldr	r3, [pc, #88]	; (8022e70 <HallTimerProc+0x160>)
 8022e16:	689b      	ldr	r3, [r3, #8]
 8022e18:	3b01      	subs	r3, #1
 8022e1a:	4a15      	ldr	r2, [pc, #84]	; (8022e70 <HallTimerProc+0x160>)
 8022e1c:	6093      	str	r3, [r2, #8]

		if ((hall == 5) && (prev_hall == 4)) drive.RAWPosition++;
 8022e1e:	68fb      	ldr	r3, [r7, #12]
 8022e20:	2b05      	cmp	r3, #5
 8022e22:	d108      	bne.n	8022e36 <HallTimerProc+0x126>
 8022e24:	4b11      	ldr	r3, [pc, #68]	; (8022e6c <HallTimerProc+0x15c>)
 8022e26:	681b      	ldr	r3, [r3, #0]
 8022e28:	2b04      	cmp	r3, #4
 8022e2a:	d104      	bne.n	8022e36 <HallTimerProc+0x126>
 8022e2c:	4b10      	ldr	r3, [pc, #64]	; (8022e70 <HallTimerProc+0x160>)
 8022e2e:	689b      	ldr	r3, [r3, #8]
 8022e30:	3301      	adds	r3, #1
 8022e32:	4a0f      	ldr	r2, [pc, #60]	; (8022e70 <HallTimerProc+0x160>)
 8022e34:	6093      	str	r3, [r2, #8]
		if ((hall == 5) && (prev_hall == 1)) drive.RAWPosition--;
 8022e36:	68fb      	ldr	r3, [r7, #12]
 8022e38:	2b05      	cmp	r3, #5
 8022e3a:	d108      	bne.n	8022e4e <HallTimerProc+0x13e>
 8022e3c:	4b0b      	ldr	r3, [pc, #44]	; (8022e6c <HallTimerProc+0x15c>)
 8022e3e:	681b      	ldr	r3, [r3, #0]
 8022e40:	2b01      	cmp	r3, #1
 8022e42:	d104      	bne.n	8022e4e <HallTimerProc+0x13e>
 8022e44:	4b0a      	ldr	r3, [pc, #40]	; (8022e70 <HallTimerProc+0x160>)
 8022e46:	689b      	ldr	r3, [r3, #8]
 8022e48:	3b01      	subs	r3, #1
 8022e4a:	4a09      	ldr	r2, [pc, #36]	; (8022e70 <HallTimerProc+0x160>)
 8022e4c:	6093      	str	r3, [r2, #8]
	}
	prev_hall = hall;
 8022e4e:	4a07      	ldr	r2, [pc, #28]	; (8022e6c <HallTimerProc+0x15c>)
 8022e50:	68fb      	ldr	r3, [r7, #12]
 8022e52:	6013      	str	r3, [r2, #0]
	drive.Position = (uint16_t) abs(drive.RAWPosition);
 8022e54:	4b06      	ldr	r3, [pc, #24]	; (8022e70 <HallTimerProc+0x160>)
 8022e56:	689b      	ldr	r3, [r3, #8]
 8022e58:	2b00      	cmp	r3, #0
 8022e5a:	bfb8      	it	lt
 8022e5c:	425b      	neglt	r3, r3
 8022e5e:	b29a      	uxth	r2, r3
 8022e60:	4b03      	ldr	r3, [pc, #12]	; (8022e70 <HallTimerProc+0x160>)
 8022e62:	801a      	strh	r2, [r3, #0]
}
 8022e64:	bf00      	nop
 8022e66:	3710      	adds	r7, #16
 8022e68:	46bd      	mov	sp, r7
 8022e6a:	bd80      	pop	{r7, pc}
 8022e6c:	20000620 	.word	0x20000620
 8022e70:	20000600 	.word	0x20000600

08022e74 <MotorStepProc>:

void MotorStepProc(void *args)
{
 8022e74:	b580      	push	{r7, lr}
 8022e76:	b082      	sub	sp, #8
 8022e78:	af00      	add	r7, sp, #0
 8022e7a:	6078      	str	r0, [r7, #4]
	Motor0_BLDC_SCALAR_MSM();
 8022e7c:	f008 f8a8 	bl	802afd0 <__Motor0_BLDC_SCALAR_MSM_veneer>
}
 8022e80:	bf00      	nop
 8022e82:	3708      	adds	r7, #8
 8022e84:	46bd      	mov	sp, r7
 8022e86:	bd80      	pop	{r7, pc}

08022e88 <XMC_GPIO_SetOutputHigh>:
{
 8022e88:	b480      	push	{r7}
 8022e8a:	b083      	sub	sp, #12
 8022e8c:	af00      	add	r7, sp, #0
 8022e8e:	6078      	str	r0, [r7, #4]
 8022e90:	460b      	mov	r3, r1
 8022e92:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8022e94:	78fb      	ldrb	r3, [r7, #3]
 8022e96:	2201      	movs	r2, #1
 8022e98:	409a      	lsls	r2, r3
 8022e9a:	687b      	ldr	r3, [r7, #4]
 8022e9c:	605a      	str	r2, [r3, #4]
}
 8022e9e:	bf00      	nop
 8022ea0:	370c      	adds	r7, #12
 8022ea2:	46bd      	mov	sp, r7
 8022ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022ea8:	4770      	bx	lr

08022eaa <XMC_GPIO_SetOutputLow>:
{
 8022eaa:	b480      	push	{r7}
 8022eac:	b083      	sub	sp, #12
 8022eae:	af00      	add	r7, sp, #0
 8022eb0:	6078      	str	r0, [r7, #4]
 8022eb2:	460b      	mov	r3, r1
 8022eb4:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8022eb6:	78fb      	ldrb	r3, [r7, #3]
 8022eb8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8022ebc:	409a      	lsls	r2, r3
 8022ebe:	687b      	ldr	r3, [r7, #4]
 8022ec0:	605a      	str	r2, [r3, #4]
}
 8022ec2:	bf00      	nop
 8022ec4:	370c      	adds	r7, #12
 8022ec6:	46bd      	mov	sp, r7
 8022ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022ecc:	4770      	bx	lr

08022ece <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
 8022ece:	b580      	push	{r7, lr}
 8022ed0:	b082      	sub	sp, #8
 8022ed2:	af00      	add	r7, sp, #0
 8022ed4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8022ed6:	687b      	ldr	r3, [r7, #4]
 8022ed8:	681a      	ldr	r2, [r3, #0]
 8022eda:	687b      	ldr	r3, [r7, #4]
 8022edc:	7c1b      	ldrb	r3, [r3, #16]
 8022ede:	4619      	mov	r1, r3
 8022ee0:	4610      	mov	r0, r2
 8022ee2:	f7ff ffd1 	bl	8022e88 <XMC_GPIO_SetOutputHigh>
}
 8022ee6:	bf00      	nop
 8022ee8:	3708      	adds	r7, #8
 8022eea:	46bd      	mov	sp, r7
 8022eec:	bd80      	pop	{r7, pc}

08022eee <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
 8022eee:	b580      	push	{r7, lr}
 8022ef0:	b082      	sub	sp, #8
 8022ef2:	af00      	add	r7, sp, #0
 8022ef4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8022ef6:	687b      	ldr	r3, [r7, #4]
 8022ef8:	681a      	ldr	r2, [r3, #0]
 8022efa:	687b      	ldr	r3, [r7, #4]
 8022efc:	7c1b      	ldrb	r3, [r3, #16]
 8022efe:	4619      	mov	r1, r3
 8022f00:	4610      	mov	r0, r2
 8022f02:	f7ff ffd2 	bl	8022eaa <XMC_GPIO_SetOutputLow>
}
 8022f06:	bf00      	nop
 8022f08:	3708      	adds	r7, #8
 8022f0a:	46bd      	mov	sp, r7
 8022f0c:	bd80      	pop	{r7, pc}
	...

08022f10 <InitBuzzer>:
#include "MainAlg/presets.h"



void InitBuzzer(int32_t buzzer_type)
{
 8022f10:	b580      	push	{r7, lr}
 8022f12:	b082      	sub	sp, #8
 8022f14:	af00      	add	r7, sp, #0
 8022f16:	6078      	str	r0, [r7, #4]
	PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 440, 1000);
 8022f18:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8022f1c:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
 8022f20:	4807      	ldr	r0, [pc, #28]	; (8022f40 <InitBuzzer+0x30>)
 8022f22:	f006 fc2b 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
	DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8022f26:	4807      	ldr	r0, [pc, #28]	; (8022f44 <InitBuzzer+0x34>)
 8022f28:	f7ff ffd1 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
	DIGITAL_IO_SetOutputLow(&HS_SW_8);
 8022f2c:	4806      	ldr	r0, [pc, #24]	; (8022f48 <InitBuzzer+0x38>)
 8022f2e:	f7ff ffde 	bl	8022eee <DIGITAL_IO_SetOutputLow>
	PWM_CCU4_Stop(&BUZZ_PWM);
 8022f32:	4803      	ldr	r0, [pc, #12]	; (8022f40 <InitBuzzer+0x30>)
 8022f34:	f006 fc03 	bl	802973e <PWM_CCU4_Stop>
}
 8022f38:	bf00      	nop
 8022f3a:	3708      	adds	r7, #8
 8022f3c:	46bd      	mov	sp, r7
 8022f3e:	bd80      	pop	{r7, pc}
 8022f40:	2000028c 	.word	0x2000028c
 8022f44:	0802b294 	.word	0x0802b294
 8022f48:	0802b3ac 	.word	0x0802b3ac

08022f4c <WriteBuzzer>:
void WriteBuzzer(int32_t cmd)
{
 8022f4c:	b580      	push	{r7, lr}
 8022f4e:	b082      	sub	sp, #8
 8022f50:	af00      	add	r7, sp, #0
 8022f52:	6078      	str	r0, [r7, #4]
static int32_t blink = 0;

	if((Presets.BUZZER_TYPE == BUZZER_TYPE_SFM) && (cmd == BUZZER_ON))
 8022f54:	4b42      	ldr	r3, [pc, #264]	; (8023060 <WriteBuzzer+0x114>)
 8022f56:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8022f58:	2b00      	cmp	r3, #0
 8022f5a:	d134      	bne.n	8022fc6 <WriteBuzzer+0x7a>
 8022f5c:	687b      	ldr	r3, [r7, #4]
 8022f5e:	2b01      	cmp	r3, #1
 8022f60:	d131      	bne.n	8022fc6 <WriteBuzzer+0x7a>
	{
		blink++;
 8022f62:	4b40      	ldr	r3, [pc, #256]	; (8023064 <WriteBuzzer+0x118>)
 8022f64:	681b      	ldr	r3, [r3, #0]
 8022f66:	3301      	adds	r3, #1
 8022f68:	4a3e      	ldr	r2, [pc, #248]	; (8023064 <WriteBuzzer+0x118>)
 8022f6a:	6013      	str	r3, [r2, #0]
//
//		if(blink >= 100)
//		{
//			blink = 0;
//		}
		if((blink >= 4) && (blink < 8))
 8022f6c:	4b3d      	ldr	r3, [pc, #244]	; (8023064 <WriteBuzzer+0x118>)
 8022f6e:	681b      	ldr	r3, [r3, #0]
 8022f70:	2b03      	cmp	r3, #3
 8022f72:	dd10      	ble.n	8022f96 <WriteBuzzer+0x4a>
 8022f74:	4b3b      	ldr	r3, [pc, #236]	; (8023064 <WriteBuzzer+0x118>)
 8022f76:	681b      	ldr	r3, [r3, #0]
 8022f78:	2b07      	cmp	r3, #7
 8022f7a:	dc0c      	bgt.n	8022f96 <WriteBuzzer+0x4a>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022f7c:	483a      	ldr	r0, [pc, #232]	; (8023068 <WriteBuzzer+0x11c>)
 8022f7e:	f7ff ffa6 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 830, 2000); // Hz, Duty
 8022f82:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8022f86:	f240 313e 	movw	r1, #830	; 0x33e
 8022f8a:	4838      	ldr	r0, [pc, #224]	; (802306c <WriteBuzzer+0x120>)
 8022f8c:	f006 fbf6 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8022f90:	4836      	ldr	r0, [pc, #216]	; (802306c <WriteBuzzer+0x120>)
 8022f92:	f006 fba9 	bl	80296e8 <PWM_CCU4_Start>
		}
		if(blink < 4)
 8022f96:	4b33      	ldr	r3, [pc, #204]	; (8023064 <WriteBuzzer+0x118>)
 8022f98:	681b      	ldr	r3, [r3, #0]
 8022f9a:	2b03      	cmp	r3, #3
 8022f9c:	dc0c      	bgt.n	8022fb8 <WriteBuzzer+0x6c>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022f9e:	4832      	ldr	r0, [pc, #200]	; (8023068 <WriteBuzzer+0x11c>)
 8022fa0:	f7ff ff95 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 1047, 2000); // Hz, Duty
 8022fa4:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8022fa8:	f240 4117 	movw	r1, #1047	; 0x417
 8022fac:	482f      	ldr	r0, [pc, #188]	; (802306c <WriteBuzzer+0x120>)
 8022fae:	f006 fbe5 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8022fb2:	482e      	ldr	r0, [pc, #184]	; (802306c <WriteBuzzer+0x120>)
 8022fb4:	f006 fb98 	bl	80296e8 <PWM_CCU4_Start>
		}
		if(blink >= 8)
 8022fb8:	4b2a      	ldr	r3, [pc, #168]	; (8023064 <WriteBuzzer+0x118>)
 8022fba:	681b      	ldr	r3, [r3, #0]
 8022fbc:	2b07      	cmp	r3, #7
 8022fbe:	dd02      	ble.n	8022fc6 <WriteBuzzer+0x7a>
		{
			blink = 0;
 8022fc0:	4b28      	ldr	r3, [pc, #160]	; (8023064 <WriteBuzzer+0x118>)
 8022fc2:	2200      	movs	r2, #0
 8022fc4:	601a      	str	r2, [r3, #0]
		}

	}

	if((Presets.BUZZER_TYPE == BUZZER_TYPE_BPT) && (cmd == BUZZER_ON))
 8022fc6:	4b26      	ldr	r3, [pc, #152]	; (8023060 <WriteBuzzer+0x114>)
 8022fc8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8022fca:	2b01      	cmp	r3, #1
 8022fcc:	d134      	bne.n	8023038 <WriteBuzzer+0xec>
 8022fce:	687b      	ldr	r3, [r7, #4]
 8022fd0:	2b01      	cmp	r3, #1
 8022fd2:	d131      	bne.n	8023038 <WriteBuzzer+0xec>
	{
		blink++;
 8022fd4:	4b23      	ldr	r3, [pc, #140]	; (8023064 <WriteBuzzer+0x118>)
 8022fd6:	681b      	ldr	r3, [r3, #0]
 8022fd8:	3301      	adds	r3, #1
 8022fda:	4a22      	ldr	r2, [pc, #136]	; (8023064 <WriteBuzzer+0x118>)
 8022fdc:	6013      	str	r3, [r2, #0]

		if((blink >= 4) && (blink < 8))
 8022fde:	4b21      	ldr	r3, [pc, #132]	; (8023064 <WriteBuzzer+0x118>)
 8022fe0:	681b      	ldr	r3, [r3, #0]
 8022fe2:	2b03      	cmp	r3, #3
 8022fe4:	dd10      	ble.n	8023008 <WriteBuzzer+0xbc>
 8022fe6:	4b1f      	ldr	r3, [pc, #124]	; (8023064 <WriteBuzzer+0x118>)
 8022fe8:	681b      	ldr	r3, [r3, #0]
 8022fea:	2b07      	cmp	r3, #7
 8022fec:	dc0c      	bgt.n	8023008 <WriteBuzzer+0xbc>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8022fee:	481e      	ldr	r0, [pc, #120]	; (8023068 <WriteBuzzer+0x11c>)
 8022ff0:	f7ff ff6d 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 830, 8500); // Hz, Duty
 8022ff4:	f242 1234 	movw	r2, #8500	; 0x2134
 8022ff8:	f240 313e 	movw	r1, #830	; 0x33e
 8022ffc:	481b      	ldr	r0, [pc, #108]	; (802306c <WriteBuzzer+0x120>)
 8022ffe:	f006 fbbd 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8023002:	481a      	ldr	r0, [pc, #104]	; (802306c <WriteBuzzer+0x120>)
 8023004:	f006 fb70 	bl	80296e8 <PWM_CCU4_Start>
		}
		if(blink < 4)
 8023008:	4b16      	ldr	r3, [pc, #88]	; (8023064 <WriteBuzzer+0x118>)
 802300a:	681b      	ldr	r3, [r3, #0]
 802300c:	2b03      	cmp	r3, #3
 802300e:	dc0c      	bgt.n	802302a <WriteBuzzer+0xde>
		{
			DIGITAL_IO_SetOutputHigh(&HS_SW_8);
 8023010:	4815      	ldr	r0, [pc, #84]	; (8023068 <WriteBuzzer+0x11c>)
 8023012:	f7ff ff5c 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
			PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 1047, 8500); // Hz, Duty
 8023016:	f242 1234 	movw	r2, #8500	; 0x2134
 802301a:	f240 4117 	movw	r1, #1047	; 0x417
 802301e:	4813      	ldr	r0, [pc, #76]	; (802306c <WriteBuzzer+0x120>)
 8023020:	f006 fbac 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&BUZZ_PWM);
 8023024:	4811      	ldr	r0, [pc, #68]	; (802306c <WriteBuzzer+0x120>)
 8023026:	f006 fb5f 	bl	80296e8 <PWM_CCU4_Start>
		}
		if(blink >= 8)
 802302a:	4b0e      	ldr	r3, [pc, #56]	; (8023064 <WriteBuzzer+0x118>)
 802302c:	681b      	ldr	r3, [r3, #0]
 802302e:	2b07      	cmp	r3, #7
 8023030:	dd02      	ble.n	8023038 <WriteBuzzer+0xec>
		{
			blink = 0;
 8023032:	4b0c      	ldr	r3, [pc, #48]	; (8023064 <WriteBuzzer+0x118>)
 8023034:	2200      	movs	r2, #0
 8023036:	601a      	str	r2, [r3, #0]
		}
	}
	if((cmd == BUZZER_OFF))
 8023038:	687b      	ldr	r3, [r7, #4]
 802303a:	2b00      	cmp	r3, #0
 802303c:	d10b      	bne.n	8023056 <WriteBuzzer+0x10a>
	{
		DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 802303e:	480c      	ldr	r0, [pc, #48]	; (8023070 <WriteBuzzer+0x124>)
 8023040:	f7ff ff45 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputLow(&HS_SW_8);
 8023044:	4808      	ldr	r0, [pc, #32]	; (8023068 <WriteBuzzer+0x11c>)
 8023046:	f7ff ff52 	bl	8022eee <DIGITAL_IO_SetOutputLow>
		PWM_CCU4_Stop(&BUZZ_PWM);
 802304a:	4808      	ldr	r0, [pc, #32]	; (802306c <WriteBuzzer+0x120>)
 802304c:	f006 fb77 	bl	802973e <PWM_CCU4_Stop>
		blink = 0;
 8023050:	4b04      	ldr	r3, [pc, #16]	; (8023064 <WriteBuzzer+0x118>)
 8023052:	2200      	movs	r2, #0
 8023054:	601a      	str	r2, [r3, #0]
	}
}
 8023056:	bf00      	nop
 8023058:	3708      	adds	r7, #8
 802305a:	46bd      	mov	sp, r7
 802305c:	bd80      	pop	{r7, pc}
 802305e:	bf00      	nop
 8023060:	20000764 	.word	0x20000764
 8023064:	20000624 	.word	0x20000624
 8023068:	0802b3ac 	.word	0x0802b3ac
 802306c:	2000028c 	.word	0x2000028c
 8023070:	0802b294 	.word	0x0802b294

08023074 <CCU43_3_IRQHandler>:


void BuzzerCmpISRHandler (void)
{
 8023074:	b580      	push	{r7, lr}
 8023076:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&BUZZ_PWM,XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 8023078:	2102      	movs	r1, #2
 802307a:	4804      	ldr	r0, [pc, #16]	; (802308c <CCU43_3_IRQHandler+0x18>)
 802307c:	f006 fbe2 	bl	8029844 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputLow(&TRANS_OUT);
 8023080:	4803      	ldr	r0, [pc, #12]	; (8023090 <CCU43_3_IRQHandler+0x1c>)
 8023082:	f7ff ff34 	bl	8022eee <DIGITAL_IO_SetOutputLow>
}
 8023086:	bf00      	nop
 8023088:	bd80      	pop	{r7, pc}
 802308a:	bf00      	nop
 802308c:	2000028c 	.word	0x2000028c
 8023090:	0802b294 	.word	0x0802b294

08023094 <CCU43_2_IRQHandler>:

void BuzzerOvfISRHandler (void)
{
 8023094:	b580      	push	{r7, lr}
 8023096:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&BUZZ_PWM,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8023098:	2100      	movs	r1, #0
 802309a:	4804      	ldr	r0, [pc, #16]	; (80230ac <CCU43_2_IRQHandler+0x18>)
 802309c:	f006 fbd2 	bl	8029844 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 80230a0:	4803      	ldr	r0, [pc, #12]	; (80230b0 <CCU43_2_IRQHandler+0x1c>)
 80230a2:	f7ff ff14 	bl	8022ece <DIGITAL_IO_SetOutputHigh>
}
 80230a6:	bf00      	nop
 80230a8:	bd80      	pop	{r7, pc}
 80230aa:	bf00      	nop
 80230ac:	2000028c 	.word	0x2000028c
 80230b0:	0802b294 	.word	0x0802b294

080230b4 <XMC_GPIO_SetOutputHigh>:
{
 80230b4:	b480      	push	{r7}
 80230b6:	b083      	sub	sp, #12
 80230b8:	af00      	add	r7, sp, #0
 80230ba:	6078      	str	r0, [r7, #4]
 80230bc:	460b      	mov	r3, r1
 80230be:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 80230c0:	78fb      	ldrb	r3, [r7, #3]
 80230c2:	2201      	movs	r2, #1
 80230c4:	409a      	lsls	r2, r3
 80230c6:	687b      	ldr	r3, [r7, #4]
 80230c8:	605a      	str	r2, [r3, #4]
}
 80230ca:	bf00      	nop
 80230cc:	370c      	adds	r7, #12
 80230ce:	46bd      	mov	sp, r7
 80230d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80230d4:	4770      	bx	lr

080230d6 <XMC_GPIO_SetOutputLow>:
{
 80230d6:	b480      	push	{r7}
 80230d8:	b083      	sub	sp, #12
 80230da:	af00      	add	r7, sp, #0
 80230dc:	6078      	str	r0, [r7, #4]
 80230de:	460b      	mov	r3, r1
 80230e0:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 80230e2:	78fb      	ldrb	r3, [r7, #3]
 80230e4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80230e8:	409a      	lsls	r2, r3
 80230ea:	687b      	ldr	r3, [r7, #4]
 80230ec:	605a      	str	r2, [r3, #4]
}
 80230ee:	bf00      	nop
 80230f0:	370c      	adds	r7, #12
 80230f2:	46bd      	mov	sp, r7
 80230f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80230f8:	4770      	bx	lr

080230fa <DIGITAL_IO_SetOutputHigh>:
{
 80230fa:	b580      	push	{r7, lr}
 80230fc:	b082      	sub	sp, #8
 80230fe:	af00      	add	r7, sp, #0
 8023100:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8023102:	687b      	ldr	r3, [r7, #4]
 8023104:	681a      	ldr	r2, [r3, #0]
 8023106:	687b      	ldr	r3, [r7, #4]
 8023108:	7c1b      	ldrb	r3, [r3, #16]
 802310a:	4619      	mov	r1, r3
 802310c:	4610      	mov	r0, r2
 802310e:	f7ff ffd1 	bl	80230b4 <XMC_GPIO_SetOutputHigh>
}
 8023112:	bf00      	nop
 8023114:	3708      	adds	r7, #8
 8023116:	46bd      	mov	sp, r7
 8023118:	bd80      	pop	{r7, pc}

0802311a <DIGITAL_IO_SetOutputLow>:
{
 802311a:	b580      	push	{r7, lr}
 802311c:	b082      	sub	sp, #8
 802311e:	af00      	add	r7, sp, #0
 8023120:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8023122:	687b      	ldr	r3, [r7, #4]
 8023124:	681a      	ldr	r2, [r3, #0]
 8023126:	687b      	ldr	r3, [r7, #4]
 8023128:	7c1b      	ldrb	r3, [r3, #16]
 802312a:	4619      	mov	r1, r3
 802312c:	4610      	mov	r0, r2
 802312e:	f7ff ffd2 	bl	80230d6 <XMC_GPIO_SetOutputLow>
}
 8023132:	bf00      	nop
 8023134:	3708      	adds	r7, #8
 8023136:	46bd      	mov	sp, r7
 8023138:	bd80      	pop	{r7, pc}
	...

0802313c <InitLedRubber>:
int32_t LedPwmTimer = 0;



void InitLedRubber(int32_t mode)
{
 802313c:	b580      	push	{r7, lr}
 802313e:	b082      	sub	sp, #8
 8023140:	af00      	add	r7, sp, #0
 8023142:	6078      	str	r0, [r7, #4]
	if(mode == MODE_ON)
 8023144:	687b      	ldr	r3, [r7, #4]
 8023146:	2b01      	cmp	r3, #1
 8023148:	d118      	bne.n	802317c <InitLedRubber+0x40>
	{
		  LedPwmTimer = SYSTIMER_CreateTimer(100, SYSTIMER_MODE_PERIODIC, LedPwmTimerProc, NULL );
 802314a:	2300      	movs	r3, #0
 802314c:	4a0d      	ldr	r2, [pc, #52]	; (8023184 <InitLedRubber+0x48>)
 802314e:	2101      	movs	r1, #1
 8023150:	2064      	movs	r0, #100	; 0x64
 8023152:	f005 ff43 	bl	8028fdc <SYSTIMER_CreateTimer>
 8023156:	4603      	mov	r3, r0
 8023158:	461a      	mov	r2, r3
 802315a:	4b0b      	ldr	r3, [pc, #44]	; (8023188 <InitLedRubber+0x4c>)
 802315c:	601a      	str	r2, [r3, #0]
		  SYSTIMER_StartTimer(LedPwmTimer);
 802315e:	4b0a      	ldr	r3, [pc, #40]	; (8023188 <InitLedRubber+0x4c>)
 8023160:	681b      	ldr	r3, [r3, #0]
 8023162:	4618      	mov	r0, r3
 8023164:	f005 ffd8 	bl	8029118 <SYSTIMER_StartTimer>
		  DIGITAL_IO_SetOutputHigh(&LED_SW_NRES);
 8023168:	4808      	ldr	r0, [pc, #32]	; (802318c <InitLedRubber+0x50>)
 802316a:	f7ff ffc6 	bl	80230fa <DIGITAL_IO_SetOutputHigh>

		  DIGITAL_IO_SetOutputHigh(&LED_POWER_EN2);
 802316e:	4808      	ldr	r0, [pc, #32]	; (8023190 <InitLedRubber+0x54>)
 8023170:	f7ff ffc3 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		  DIGITAL_IO_SetOutputHigh(&LED_POWER_EN1);
 8023174:	4807      	ldr	r0, [pc, #28]	; (8023194 <InitLedRubber+0x58>)
 8023176:	f7ff ffc0 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
 802317a:	e000      	b.n	802317e <InitLedRubber+0x42>
	}
	else
	{
		return;
 802317c:	bf00      	nop
	}
}
 802317e:	3708      	adds	r7, #8
 8023180:	46bd      	mov	sp, r7
 8023182:	bd80      	pop	{r7, pc}
 8023184:	0802348d 	.word	0x0802348d
 8023188:	20000640 	.word	0x20000640
 802318c:	0802b2bc 	.word	0x0802b2bc
 8023190:	0802b410 	.word	0x0802b410
 8023194:	0802b3fc 	.word	0x0802b3fc

08023198 <WriteRubberLights>:


void WriteRubberLights(uint32_t color, int32_t mode, int32_t time_ms)
{
 8023198:	b480      	push	{r7}
 802319a:	b085      	sub	sp, #20
 802319c:	af00      	add	r7, sp, #0
 802319e:	60f8      	str	r0, [r7, #12]
 80231a0:	60b9      	str	r1, [r7, #8]
 80231a2:	607a      	str	r2, [r7, #4]
static int32_t timer = 0;
static int32_t previous_mode = 0;

	if ((mode == previous_mode)) //    
 80231a4:	4b12      	ldr	r3, [pc, #72]	; (80231f0 <WriteRubberLights+0x58>)
 80231a6:	681b      	ldr	r3, [r3, #0]
 80231a8:	68ba      	ldr	r2, [r7, #8]
 80231aa:	429a      	cmp	r2, r3
 80231ac:	f040 8151 	bne.w	8023452 <WriteRubberLights+0x2ba>
	{
		if (mode == MODE_TIME_ON) //   time_ms,  
 80231b0:	68bb      	ldr	r3, [r7, #8]
 80231b2:	2b03      	cmp	r3, #3
 80231b4:	d169      	bne.n	802328a <WriteRubberLights+0xf2>
		{
			if (timer * MAIN_TIMER_TIME_MS >= time_ms)
 80231b6:	4b0f      	ldr	r3, [pc, #60]	; (80231f4 <WriteRubberLights+0x5c>)
 80231b8:	681a      	ldr	r2, [r3, #0]
 80231ba:	4613      	mov	r3, r2
 80231bc:	009b      	lsls	r3, r3, #2
 80231be:	4413      	add	r3, r2
 80231c0:	005b      	lsls	r3, r3, #1
 80231c2:	461a      	mov	r2, r3
 80231c4:	687b      	ldr	r3, [r7, #4]
 80231c6:	4293      	cmp	r3, r2
 80231c8:	dc18      	bgt.n	80231fc <WriteRubberLights+0x64>
			{
				led_rubber.red_outern = 0;
 80231ca:	4b0b      	ldr	r3, [pc, #44]	; (80231f8 <WriteRubberLights+0x60>)
 80231cc:	2200      	movs	r2, #0
 80231ce:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = 0;
 80231d0:	4b09      	ldr	r3, [pc, #36]	; (80231f8 <WriteRubberLights+0x60>)
 80231d2:	2200      	movs	r2, #0
 80231d4:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 80231d6:	4b08      	ldr	r3, [pc, #32]	; (80231f8 <WriteRubberLights+0x60>)
 80231d8:	2200      	movs	r2, #0
 80231da:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = 0;
 80231dc:	4b06      	ldr	r3, [pc, #24]	; (80231f8 <WriteRubberLights+0x60>)
 80231de:	2200      	movs	r2, #0
 80231e0:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = 0;
 80231e2:	4b05      	ldr	r3, [pc, #20]	; (80231f8 <WriteRubberLights+0x60>)
 80231e4:	2200      	movs	r2, #0
 80231e6:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 80231e8:	4b03      	ldr	r3, [pc, #12]	; (80231f8 <WriteRubberLights+0x60>)
 80231ea:	2200      	movs	r2, #0
 80231ec:	615a      	str	r2, [r3, #20]
 80231ee:	e04c      	b.n	802328a <WriteRubberLights+0xf2>
 80231f0:	20000644 	.word	0x20000644
 80231f4:	20000648 	.word	0x20000648
 80231f8:	20000628 	.word	0x20000628
			}
			else
			{
				timer ++;
 80231fc:	4b98      	ldr	r3, [pc, #608]	; (8023460 <WriteRubberLights+0x2c8>)
 80231fe:	681b      	ldr	r3, [r3, #0]
 8023200:	3301      	adds	r3, #1
 8023202:	4a97      	ldr	r2, [pc, #604]	; (8023460 <WriteRubberLights+0x2c8>)
 8023204:	6013      	str	r3, [r2, #0]
				if (color == CL_RED)
 8023206:	68fb      	ldr	r3, [r7, #12]
 8023208:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 802320c:	d111      	bne.n	8023232 <WriteRubberLights+0x9a>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT;
 802320e:	4b95      	ldr	r3, [pc, #596]	; (8023464 <WriteRubberLights+0x2cc>)
 8023210:	2232      	movs	r2, #50	; 0x32
 8023212:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = 0;
 8023214:	4b93      	ldr	r3, [pc, #588]	; (8023464 <WriteRubberLights+0x2cc>)
 8023216:	2200      	movs	r2, #0
 8023218:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 802321a:	4b92      	ldr	r3, [pc, #584]	; (8023464 <WriteRubberLights+0x2cc>)
 802321c:	2200      	movs	r2, #0
 802321e:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023220:	4b90      	ldr	r3, [pc, #576]	; (8023464 <WriteRubberLights+0x2cc>)
 8023222:	2214      	movs	r2, #20
 8023224:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = 0;
 8023226:	4b8f      	ldr	r3, [pc, #572]	; (8023464 <WriteRubberLights+0x2cc>)
 8023228:	2200      	movs	r2, #0
 802322a:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 802322c:	4b8d      	ldr	r3, [pc, #564]	; (8023464 <WriteRubberLights+0x2cc>)
 802322e:	2200      	movs	r2, #0
 8023230:	615a      	str	r2, [r3, #20]

				}
				if (color == CL_GREEN)
 8023232:	68fb      	ldr	r3, [r7, #12]
 8023234:	f5b3 0f7f 	cmp.w	r3, #16711680	; 0xff0000
 8023238:	d111      	bne.n	802325e <WriteRubberLights+0xc6>
				{
					led_rubber.red_outern = 0;
 802323a:	4b8a      	ldr	r3, [pc, #552]	; (8023464 <WriteRubberLights+0x2cc>)
 802323c:	2200      	movs	r2, #0
 802323e:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT;
 8023240:	4b88      	ldr	r3, [pc, #544]	; (8023464 <WriteRubberLights+0x2cc>)
 8023242:	2232      	movs	r2, #50	; 0x32
 8023244:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 8023246:	4b87      	ldr	r3, [pc, #540]	; (8023464 <WriteRubberLights+0x2cc>)
 8023248:	2200      	movs	r2, #0
 802324a:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = 0;
 802324c:	4b85      	ldr	r3, [pc, #532]	; (8023464 <WriteRubberLights+0x2cc>)
 802324e:	2200      	movs	r2, #0
 8023250:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 8023252:	4b84      	ldr	r3, [pc, #528]	; (8023464 <WriteRubberLights+0x2cc>)
 8023254:	2214      	movs	r2, #20
 8023256:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 8023258:	4b82      	ldr	r3, [pc, #520]	; (8023464 <WriteRubberLights+0x2cc>)
 802325a:	2200      	movs	r2, #0
 802325c:	615a      	str	r2, [r3, #20]

				}
				if (color == CL_YELLOW)
 802325e:	68fb      	ldr	r3, [r7, #12]
 8023260:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8023264:	d111      	bne.n	802328a <WriteRubberLights+0xf2>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT/2;
 8023266:	4b7f      	ldr	r3, [pc, #508]	; (8023464 <WriteRubberLights+0x2cc>)
 8023268:	2219      	movs	r2, #25
 802326a:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT/2;
 802326c:	4b7d      	ldr	r3, [pc, #500]	; (8023464 <WriteRubberLights+0x2cc>)
 802326e:	2219      	movs	r2, #25
 8023270:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 8023272:	4b7c      	ldr	r3, [pc, #496]	; (8023464 <WriteRubberLights+0x2cc>)
 8023274:	2200      	movs	r2, #0
 8023276:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023278:	4b7a      	ldr	r3, [pc, #488]	; (8023464 <WriteRubberLights+0x2cc>)
 802327a:	2214      	movs	r2, #20
 802327c:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 802327e:	4b79      	ldr	r3, [pc, #484]	; (8023464 <WriteRubberLights+0x2cc>)
 8023280:	2214      	movs	r2, #20
 8023282:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 8023284:	4b77      	ldr	r3, [pc, #476]	; (8023464 <WriteRubberLights+0x2cc>)
 8023286:	2200      	movs	r2, #0
 8023288:	615a      	str	r2, [r3, #20]

				}
			}
		}// end mode time on

		if (mode == MODE_BLINK)
 802328a:	68bb      	ldr	r3, [r7, #8]
 802328c:	2b02      	cmp	r3, #2
 802328e:	f040 8086 	bne.w	802339e <WriteRubberLights+0x206>
		{
			timer ++;
 8023292:	4b73      	ldr	r3, [pc, #460]	; (8023460 <WriteRubberLights+0x2c8>)
 8023294:	681b      	ldr	r3, [r3, #0]
 8023296:	3301      	adds	r3, #1
 8023298:	4a71      	ldr	r2, [pc, #452]	; (8023460 <WriteRubberLights+0x2c8>)
 802329a:	6013      	str	r3, [r2, #0]

			if (timer*10 < time_ms) //   
 802329c:	4b70      	ldr	r3, [pc, #448]	; (8023460 <WriteRubberLights+0x2c8>)
 802329e:	681a      	ldr	r2, [r3, #0]
 80232a0:	4613      	mov	r3, r2
 80232a2:	009b      	lsls	r3, r3, #2
 80232a4:	4413      	add	r3, r2
 80232a6:	005b      	lsls	r3, r3, #1
 80232a8:	461a      	mov	r2, r3
 80232aa:	687b      	ldr	r3, [r7, #4]
 80232ac:	4293      	cmp	r3, r2
 80232ae:	dd41      	ble.n	8023334 <WriteRubberLights+0x19c>
			{
				if (color == CL_RED)
 80232b0:	68fb      	ldr	r3, [r7, #12]
 80232b2:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 80232b6:	d111      	bne.n	80232dc <WriteRubberLights+0x144>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT;
 80232b8:	4b6a      	ldr	r3, [pc, #424]	; (8023464 <WriteRubberLights+0x2cc>)
 80232ba:	2232      	movs	r2, #50	; 0x32
 80232bc:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = 0;
 80232be:	4b69      	ldr	r3, [pc, #420]	; (8023464 <WriteRubberLights+0x2cc>)
 80232c0:	2200      	movs	r2, #0
 80232c2:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 80232c4:	4b67      	ldr	r3, [pc, #412]	; (8023464 <WriteRubberLights+0x2cc>)
 80232c6:	2200      	movs	r2, #0
 80232c8:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 80232ca:	4b66      	ldr	r3, [pc, #408]	; (8023464 <WriteRubberLights+0x2cc>)
 80232cc:	2214      	movs	r2, #20
 80232ce:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = 0;
 80232d0:	4b64      	ldr	r3, [pc, #400]	; (8023464 <WriteRubberLights+0x2cc>)
 80232d2:	2200      	movs	r2, #0
 80232d4:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 80232d6:	4b63      	ldr	r3, [pc, #396]	; (8023464 <WriteRubberLights+0x2cc>)
 80232d8:	2200      	movs	r2, #0
 80232da:	615a      	str	r2, [r3, #20]

				}
				if (color == CL_GREEN)
 80232dc:	68fb      	ldr	r3, [r7, #12]
 80232de:	f5b3 0f7f 	cmp.w	r3, #16711680	; 0xff0000
 80232e2:	d111      	bne.n	8023308 <WriteRubberLights+0x170>
				{
					led_rubber.red_outern = 0;
 80232e4:	4b5f      	ldr	r3, [pc, #380]	; (8023464 <WriteRubberLights+0x2cc>)
 80232e6:	2200      	movs	r2, #0
 80232e8:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT;
 80232ea:	4b5e      	ldr	r3, [pc, #376]	; (8023464 <WriteRubberLights+0x2cc>)
 80232ec:	2232      	movs	r2, #50	; 0x32
 80232ee:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 80232f0:	4b5c      	ldr	r3, [pc, #368]	; (8023464 <WriteRubberLights+0x2cc>)
 80232f2:	2200      	movs	r2, #0
 80232f4:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = 0;
 80232f6:	4b5b      	ldr	r3, [pc, #364]	; (8023464 <WriteRubberLights+0x2cc>)
 80232f8:	2200      	movs	r2, #0
 80232fa:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 80232fc:	4b59      	ldr	r3, [pc, #356]	; (8023464 <WriteRubberLights+0x2cc>)
 80232fe:	2214      	movs	r2, #20
 8023300:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 8023302:	4b58      	ldr	r3, [pc, #352]	; (8023464 <WriteRubberLights+0x2cc>)
 8023304:	2200      	movs	r2, #0
 8023306:	615a      	str	r2, [r3, #20]
				}
				if (color == CL_YELLOW)
 8023308:	68fb      	ldr	r3, [r7, #12]
 802330a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 802330e:	d111      	bne.n	8023334 <WriteRubberLights+0x19c>
				{
					led_rubber.red_outern = OUTER_RUBBER_PERCENT/2;
 8023310:	4b54      	ldr	r3, [pc, #336]	; (8023464 <WriteRubberLights+0x2cc>)
 8023312:	2219      	movs	r2, #25
 8023314:	601a      	str	r2, [r3, #0]
					led_rubber.green_outern = OUTER_RUBBER_PERCENT/2;
 8023316:	4b53      	ldr	r3, [pc, #332]	; (8023464 <WriteRubberLights+0x2cc>)
 8023318:	2219      	movs	r2, #25
 802331a:	605a      	str	r2, [r3, #4]
					led_rubber.blue_outern = 0;
 802331c:	4b51      	ldr	r3, [pc, #324]	; (8023464 <WriteRubberLights+0x2cc>)
 802331e:	2200      	movs	r2, #0
 8023320:	609a      	str	r2, [r3, #8]
					led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023322:	4b50      	ldr	r3, [pc, #320]	; (8023464 <WriteRubberLights+0x2cc>)
 8023324:	2214      	movs	r2, #20
 8023326:	60da      	str	r2, [r3, #12]
					led_rubber.green_intern = INTER_RUBBER_PERCENT;
 8023328:	4b4e      	ldr	r3, [pc, #312]	; (8023464 <WriteRubberLights+0x2cc>)
 802332a:	2214      	movs	r2, #20
 802332c:	611a      	str	r2, [r3, #16]
					led_rubber.blue_intern = 0;
 802332e:	4b4d      	ldr	r3, [pc, #308]	; (8023464 <WriteRubberLights+0x2cc>)
 8023330:	2200      	movs	r2, #0
 8023332:	615a      	str	r2, [r3, #20]

				}
			}
			if ((timer*10 < time_ms*2) && (timer*10 >= time_ms)) //      
 8023334:	4b4a      	ldr	r3, [pc, #296]	; (8023460 <WriteRubberLights+0x2c8>)
 8023336:	681a      	ldr	r2, [r3, #0]
 8023338:	4613      	mov	r3, r2
 802333a:	009b      	lsls	r3, r3, #2
 802333c:	4413      	add	r3, r2
 802333e:	005b      	lsls	r3, r3, #1
 8023340:	461a      	mov	r2, r3
 8023342:	687b      	ldr	r3, [r7, #4]
 8023344:	005b      	lsls	r3, r3, #1
 8023346:	429a      	cmp	r2, r3
 8023348:	da1b      	bge.n	8023382 <WriteRubberLights+0x1ea>
 802334a:	4b45      	ldr	r3, [pc, #276]	; (8023460 <WriteRubberLights+0x2c8>)
 802334c:	681a      	ldr	r2, [r3, #0]
 802334e:	4613      	mov	r3, r2
 8023350:	009b      	lsls	r3, r3, #2
 8023352:	4413      	add	r3, r2
 8023354:	005b      	lsls	r3, r3, #1
 8023356:	461a      	mov	r2, r3
 8023358:	687b      	ldr	r3, [r7, #4]
 802335a:	4293      	cmp	r3, r2
 802335c:	dc11      	bgt.n	8023382 <WriteRubberLights+0x1ea>
			{
				led_rubber.red_outern = 0;
 802335e:	4b41      	ldr	r3, [pc, #260]	; (8023464 <WriteRubberLights+0x2cc>)
 8023360:	2200      	movs	r2, #0
 8023362:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = 0;
 8023364:	4b3f      	ldr	r3, [pc, #252]	; (8023464 <WriteRubberLights+0x2cc>)
 8023366:	2200      	movs	r2, #0
 8023368:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 802336a:	4b3e      	ldr	r3, [pc, #248]	; (8023464 <WriteRubberLights+0x2cc>)
 802336c:	2200      	movs	r2, #0
 802336e:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = 0;
 8023370:	4b3c      	ldr	r3, [pc, #240]	; (8023464 <WriteRubberLights+0x2cc>)
 8023372:	2200      	movs	r2, #0
 8023374:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = 0;
 8023376:	4b3b      	ldr	r3, [pc, #236]	; (8023464 <WriteRubberLights+0x2cc>)
 8023378:	2200      	movs	r2, #0
 802337a:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 802337c:	4b39      	ldr	r3, [pc, #228]	; (8023464 <WriteRubberLights+0x2cc>)
 802337e:	2200      	movs	r2, #0
 8023380:	615a      	str	r2, [r3, #20]
			}
			if (timer*10 >= time_ms*2)
 8023382:	4b37      	ldr	r3, [pc, #220]	; (8023460 <WriteRubberLights+0x2c8>)
 8023384:	681a      	ldr	r2, [r3, #0]
 8023386:	4613      	mov	r3, r2
 8023388:	009b      	lsls	r3, r3, #2
 802338a:	4413      	add	r3, r2
 802338c:	005b      	lsls	r3, r3, #1
 802338e:	461a      	mov	r2, r3
 8023390:	687b      	ldr	r3, [r7, #4]
 8023392:	005b      	lsls	r3, r3, #1
 8023394:	429a      	cmp	r2, r3
 8023396:	db02      	blt.n	802339e <WriteRubberLights+0x206>
			{
				timer = 0;
 8023398:	4b31      	ldr	r3, [pc, #196]	; (8023460 <WriteRubberLights+0x2c8>)
 802339a:	2200      	movs	r2, #0
 802339c:	601a      	str	r2, [r3, #0]
			}
		}
		if (mode == MODE_OFF)
 802339e:	68bb      	ldr	r3, [r7, #8]
 80233a0:	2b00      	cmp	r3, #0
 80233a2:	d111      	bne.n	80233c8 <WriteRubberLights+0x230>
		{
			led_rubber.red_outern = 0;
 80233a4:	4b2f      	ldr	r3, [pc, #188]	; (8023464 <WriteRubberLights+0x2cc>)
 80233a6:	2200      	movs	r2, #0
 80233a8:	601a      	str	r2, [r3, #0]
			led_rubber.green_outern = 0;
 80233aa:	4b2e      	ldr	r3, [pc, #184]	; (8023464 <WriteRubberLights+0x2cc>)
 80233ac:	2200      	movs	r2, #0
 80233ae:	605a      	str	r2, [r3, #4]
			led_rubber.blue_outern = 0;
 80233b0:	4b2c      	ldr	r3, [pc, #176]	; (8023464 <WriteRubberLights+0x2cc>)
 80233b2:	2200      	movs	r2, #0
 80233b4:	609a      	str	r2, [r3, #8]
			led_rubber.red_intern = 0;
 80233b6:	4b2b      	ldr	r3, [pc, #172]	; (8023464 <WriteRubberLights+0x2cc>)
 80233b8:	2200      	movs	r2, #0
 80233ba:	60da      	str	r2, [r3, #12]
			led_rubber.green_intern = 0;
 80233bc:	4b29      	ldr	r3, [pc, #164]	; (8023464 <WriteRubberLights+0x2cc>)
 80233be:	2200      	movs	r2, #0
 80233c0:	611a      	str	r2, [r3, #16]
			led_rubber.blue_intern = 0;
 80233c2:	4b28      	ldr	r3, [pc, #160]	; (8023464 <WriteRubberLights+0x2cc>)
 80233c4:	2200      	movs	r2, #0
 80233c6:	615a      	str	r2, [r3, #20]
		}
		if (mode == MODE_ON)
 80233c8:	68bb      	ldr	r3, [r7, #8]
 80233ca:	2b01      	cmp	r3, #1
 80233cc:	d141      	bne.n	8023452 <WriteRubberLights+0x2ba>
		{
			if (color == CL_RED)
 80233ce:	68fb      	ldr	r3, [r7, #12]
 80233d0:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 80233d4:	d111      	bne.n	80233fa <WriteRubberLights+0x262>
			{
				led_rubber.red_outern = OUTER_RUBBER_PERCENT;
 80233d6:	4b23      	ldr	r3, [pc, #140]	; (8023464 <WriteRubberLights+0x2cc>)
 80233d8:	2232      	movs	r2, #50	; 0x32
 80233da:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = 0;
 80233dc:	4b21      	ldr	r3, [pc, #132]	; (8023464 <WriteRubberLights+0x2cc>)
 80233de:	2200      	movs	r2, #0
 80233e0:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 80233e2:	4b20      	ldr	r3, [pc, #128]	; (8023464 <WriteRubberLights+0x2cc>)
 80233e4:	2200      	movs	r2, #0
 80233e6:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = INTER_RUBBER_PERCENT;
 80233e8:	4b1e      	ldr	r3, [pc, #120]	; (8023464 <WriteRubberLights+0x2cc>)
 80233ea:	2214      	movs	r2, #20
 80233ec:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = 0;
 80233ee:	4b1d      	ldr	r3, [pc, #116]	; (8023464 <WriteRubberLights+0x2cc>)
 80233f0:	2200      	movs	r2, #0
 80233f2:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 80233f4:	4b1b      	ldr	r3, [pc, #108]	; (8023464 <WriteRubberLights+0x2cc>)
 80233f6:	2200      	movs	r2, #0
 80233f8:	615a      	str	r2, [r3, #20]

			}
			if (color == CL_GREEN)
 80233fa:	68fb      	ldr	r3, [r7, #12]
 80233fc:	f5b3 0f7f 	cmp.w	r3, #16711680	; 0xff0000
 8023400:	d111      	bne.n	8023426 <WriteRubberLights+0x28e>
			{
				led_rubber.red_outern = 0;
 8023402:	4b18      	ldr	r3, [pc, #96]	; (8023464 <WriteRubberLights+0x2cc>)
 8023404:	2200      	movs	r2, #0
 8023406:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = OUTER_RUBBER_PERCENT;
 8023408:	4b16      	ldr	r3, [pc, #88]	; (8023464 <WriteRubberLights+0x2cc>)
 802340a:	2232      	movs	r2, #50	; 0x32
 802340c:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 802340e:	4b15      	ldr	r3, [pc, #84]	; (8023464 <WriteRubberLights+0x2cc>)
 8023410:	2200      	movs	r2, #0
 8023412:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = 0;
 8023414:	4b13      	ldr	r3, [pc, #76]	; (8023464 <WriteRubberLights+0x2cc>)
 8023416:	2200      	movs	r2, #0
 8023418:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = INTER_RUBBER_PERCENT;
 802341a:	4b12      	ldr	r3, [pc, #72]	; (8023464 <WriteRubberLights+0x2cc>)
 802341c:	2214      	movs	r2, #20
 802341e:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 8023420:	4b10      	ldr	r3, [pc, #64]	; (8023464 <WriteRubberLights+0x2cc>)
 8023422:	2200      	movs	r2, #0
 8023424:	615a      	str	r2, [r3, #20]

			}
			if (color == CL_YELLOW)
 8023426:	68fb      	ldr	r3, [r7, #12]
 8023428:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 802342c:	d111      	bne.n	8023452 <WriteRubberLights+0x2ba>
			{
				led_rubber.red_outern = OUTER_RUBBER_PERCENT/2;
 802342e:	4b0d      	ldr	r3, [pc, #52]	; (8023464 <WriteRubberLights+0x2cc>)
 8023430:	2219      	movs	r2, #25
 8023432:	601a      	str	r2, [r3, #0]
				led_rubber.green_outern = OUTER_RUBBER_PERCENT/2;
 8023434:	4b0b      	ldr	r3, [pc, #44]	; (8023464 <WriteRubberLights+0x2cc>)
 8023436:	2219      	movs	r2, #25
 8023438:	605a      	str	r2, [r3, #4]
				led_rubber.blue_outern = 0;
 802343a:	4b0a      	ldr	r3, [pc, #40]	; (8023464 <WriteRubberLights+0x2cc>)
 802343c:	2200      	movs	r2, #0
 802343e:	609a      	str	r2, [r3, #8]
				led_rubber.red_intern = INTER_RUBBER_PERCENT;
 8023440:	4b08      	ldr	r3, [pc, #32]	; (8023464 <WriteRubberLights+0x2cc>)
 8023442:	2214      	movs	r2, #20
 8023444:	60da      	str	r2, [r3, #12]
				led_rubber.green_intern = INTER_RUBBER_PERCENT;
 8023446:	4b07      	ldr	r3, [pc, #28]	; (8023464 <WriteRubberLights+0x2cc>)
 8023448:	2214      	movs	r2, #20
 802344a:	611a      	str	r2, [r3, #16]
				led_rubber.blue_intern = 0;
 802344c:	4b05      	ldr	r3, [pc, #20]	; (8023464 <WriteRubberLights+0x2cc>)
 802344e:	2200      	movs	r2, #0
 8023450:	615a      	str	r2, [r3, #20]
			}

		}
	} // end_of mode not changed

	if (mode != previous_mode)
 8023452:	4b05      	ldr	r3, [pc, #20]	; (8023468 <WriteRubberLights+0x2d0>)
 8023454:	681b      	ldr	r3, [r3, #0]
 8023456:	68ba      	ldr	r2, [r7, #8]
 8023458:	429a      	cmp	r2, r3
 802345a:	d00a      	beq.n	8023472 <WriteRubberLights+0x2da>
 802345c:	e006      	b.n	802346c <WriteRubberLights+0x2d4>
 802345e:	bf00      	nop
 8023460:	20000648 	.word	0x20000648
 8023464:	20000628 	.word	0x20000628
 8023468:	20000644 	.word	0x20000644
	{
		timer = 0;
 802346c:	4b05      	ldr	r3, [pc, #20]	; (8023484 <WriteRubberLights+0x2ec>)
 802346e:	2200      	movs	r2, #0
 8023470:	601a      	str	r2, [r3, #0]
	}
	previous_mode = mode;
 8023472:	4a05      	ldr	r2, [pc, #20]	; (8023488 <WriteRubberLights+0x2f0>)
 8023474:	68bb      	ldr	r3, [r7, #8]
 8023476:	6013      	str	r3, [r2, #0]

}
 8023478:	bf00      	nop
 802347a:	3714      	adds	r7, #20
 802347c:	46bd      	mov	sp, r7
 802347e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023482:	4770      	bx	lr
 8023484:	20000648 	.word	0x20000648
 8023488:	20000644 	.word	0x20000644

0802348c <LedPwmTimerProc>:
void LedPwmTimerProc(void *args)
{
 802348c:	b580      	push	{r7, lr}
 802348e:	b082      	sub	sp, #8
 8023490:	af00      	add	r7, sp, #0
 8023492:	6078      	str	r0, [r7, #4]
	static int32_t timer = 0;

	if (timer >= 100)
 8023494:	4b39      	ldr	r3, [pc, #228]	; (802357c <LedPwmTimerProc+0xf0>)
 8023496:	681b      	ldr	r3, [r3, #0]
 8023498:	2b63      	cmp	r3, #99	; 0x63
 802349a:	dd02      	ble.n	80234a2 <LedPwmTimerProc+0x16>
	{
		timer = 0;
 802349c:	4b37      	ldr	r3, [pc, #220]	; (802357c <LedPwmTimerProc+0xf0>)
 802349e:	2200      	movs	r2, #0
 80234a0:	601a      	str	r2, [r3, #0]
	}
	if(!timer)
 80234a2:	4b36      	ldr	r3, [pc, #216]	; (802357c <LedPwmTimerProc+0xf0>)
 80234a4:	681b      	ldr	r3, [r3, #0]
 80234a6:	2b00      	cmp	r3, #0
 80234a8:	d129      	bne.n	80234fe <LedPwmTimerProc+0x72>
	{
		if(led_rubber.red_outern)
 80234aa:	4b35      	ldr	r3, [pc, #212]	; (8023580 <LedPwmTimerProc+0xf4>)
 80234ac:	681b      	ldr	r3, [r3, #0]
 80234ae:	2b00      	cmp	r3, #0
 80234b0:	d002      	beq.n	80234b8 <LedPwmTimerProc+0x2c>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_1);
 80234b2:	4834      	ldr	r0, [pc, #208]	; (8023584 <LedPwmTimerProc+0xf8>)
 80234b4:	f7ff fe21 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.green_outern)
 80234b8:	4b31      	ldr	r3, [pc, #196]	; (8023580 <LedPwmTimerProc+0xf4>)
 80234ba:	685b      	ldr	r3, [r3, #4]
 80234bc:	2b00      	cmp	r3, #0
 80234be:	d002      	beq.n	80234c6 <LedPwmTimerProc+0x3a>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_2);
 80234c0:	4831      	ldr	r0, [pc, #196]	; (8023588 <LedPwmTimerProc+0xfc>)
 80234c2:	f7ff fe1a 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.blue_outern)
 80234c6:	4b2e      	ldr	r3, [pc, #184]	; (8023580 <LedPwmTimerProc+0xf4>)
 80234c8:	689b      	ldr	r3, [r3, #8]
 80234ca:	2b00      	cmp	r3, #0
 80234cc:	d002      	beq.n	80234d4 <LedPwmTimerProc+0x48>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_3);
 80234ce:	482f      	ldr	r0, [pc, #188]	; (802358c <LedPwmTimerProc+0x100>)
 80234d0:	f7ff fe13 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.red_intern)
 80234d4:	4b2a      	ldr	r3, [pc, #168]	; (8023580 <LedPwmTimerProc+0xf4>)
 80234d6:	68db      	ldr	r3, [r3, #12]
 80234d8:	2b00      	cmp	r3, #0
 80234da:	d002      	beq.n	80234e2 <LedPwmTimerProc+0x56>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_4);
 80234dc:	482c      	ldr	r0, [pc, #176]	; (8023590 <LedPwmTimerProc+0x104>)
 80234de:	f7ff fe0c 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.green_intern)
 80234e2:	4b27      	ldr	r3, [pc, #156]	; (8023580 <LedPwmTimerProc+0xf4>)
 80234e4:	691b      	ldr	r3, [r3, #16]
 80234e6:	2b00      	cmp	r3, #0
 80234e8:	d002      	beq.n	80234f0 <LedPwmTimerProc+0x64>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_5);
 80234ea:	482a      	ldr	r0, [pc, #168]	; (8023594 <LedPwmTimerProc+0x108>)
 80234ec:	f7ff fe05 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.blue_intern)
 80234f0:	4b23      	ldr	r3, [pc, #140]	; (8023580 <LedPwmTimerProc+0xf4>)
 80234f2:	695b      	ldr	r3, [r3, #20]
 80234f4:	2b00      	cmp	r3, #0
 80234f6:	d002      	beq.n	80234fe <LedPwmTimerProc+0x72>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_6);
 80234f8:	4827      	ldr	r0, [pc, #156]	; (8023598 <LedPwmTimerProc+0x10c>)
 80234fa:	f7ff fdfe 	bl	80230fa <DIGITAL_IO_SetOutputHigh>
		}
	}


	if ((led_rubber.red_outern <= timer))
 80234fe:	4b20      	ldr	r3, [pc, #128]	; (8023580 <LedPwmTimerProc+0xf4>)
 8023500:	681a      	ldr	r2, [r3, #0]
 8023502:	4b1e      	ldr	r3, [pc, #120]	; (802357c <LedPwmTimerProc+0xf0>)
 8023504:	681b      	ldr	r3, [r3, #0]
 8023506:	429a      	cmp	r2, r3
 8023508:	dc02      	bgt.n	8023510 <LedPwmTimerProc+0x84>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_1);
 802350a:	481e      	ldr	r0, [pc, #120]	; (8023584 <LedPwmTimerProc+0xf8>)
 802350c:	f7ff fe05 	bl	802311a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.green_outern <= timer))
 8023510:	4b1b      	ldr	r3, [pc, #108]	; (8023580 <LedPwmTimerProc+0xf4>)
 8023512:	685a      	ldr	r2, [r3, #4]
 8023514:	4b19      	ldr	r3, [pc, #100]	; (802357c <LedPwmTimerProc+0xf0>)
 8023516:	681b      	ldr	r3, [r3, #0]
 8023518:	429a      	cmp	r2, r3
 802351a:	dc02      	bgt.n	8023522 <LedPwmTimerProc+0x96>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_2);
 802351c:	481a      	ldr	r0, [pc, #104]	; (8023588 <LedPwmTimerProc+0xfc>)
 802351e:	f7ff fdfc 	bl	802311a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.blue_outern <= timer))
 8023522:	4b17      	ldr	r3, [pc, #92]	; (8023580 <LedPwmTimerProc+0xf4>)
 8023524:	689a      	ldr	r2, [r3, #8]
 8023526:	4b15      	ldr	r3, [pc, #84]	; (802357c <LedPwmTimerProc+0xf0>)
 8023528:	681b      	ldr	r3, [r3, #0]
 802352a:	429a      	cmp	r2, r3
 802352c:	dc02      	bgt.n	8023534 <LedPwmTimerProc+0xa8>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_3);
 802352e:	4817      	ldr	r0, [pc, #92]	; (802358c <LedPwmTimerProc+0x100>)
 8023530:	f7ff fdf3 	bl	802311a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.red_intern <= timer))
 8023534:	4b12      	ldr	r3, [pc, #72]	; (8023580 <LedPwmTimerProc+0xf4>)
 8023536:	68da      	ldr	r2, [r3, #12]
 8023538:	4b10      	ldr	r3, [pc, #64]	; (802357c <LedPwmTimerProc+0xf0>)
 802353a:	681b      	ldr	r3, [r3, #0]
 802353c:	429a      	cmp	r2, r3
 802353e:	dc02      	bgt.n	8023546 <LedPwmTimerProc+0xba>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_4);
 8023540:	4813      	ldr	r0, [pc, #76]	; (8023590 <LedPwmTimerProc+0x104>)
 8023542:	f7ff fdea 	bl	802311a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.green_intern <= timer))
 8023546:	4b0e      	ldr	r3, [pc, #56]	; (8023580 <LedPwmTimerProc+0xf4>)
 8023548:	691a      	ldr	r2, [r3, #16]
 802354a:	4b0c      	ldr	r3, [pc, #48]	; (802357c <LedPwmTimerProc+0xf0>)
 802354c:	681b      	ldr	r3, [r3, #0]
 802354e:	429a      	cmp	r2, r3
 8023550:	dc02      	bgt.n	8023558 <LedPwmTimerProc+0xcc>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_5);
 8023552:	4810      	ldr	r0, [pc, #64]	; (8023594 <LedPwmTimerProc+0x108>)
 8023554:	f7ff fde1 	bl	802311a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.blue_intern <= timer))
 8023558:	4b09      	ldr	r3, [pc, #36]	; (8023580 <LedPwmTimerProc+0xf4>)
 802355a:	695a      	ldr	r2, [r3, #20]
 802355c:	4b07      	ldr	r3, [pc, #28]	; (802357c <LedPwmTimerProc+0xf0>)
 802355e:	681b      	ldr	r3, [r3, #0]
 8023560:	429a      	cmp	r2, r3
 8023562:	dc02      	bgt.n	802356a <LedPwmTimerProc+0xde>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_6);
 8023564:	480c      	ldr	r0, [pc, #48]	; (8023598 <LedPwmTimerProc+0x10c>)
 8023566:	f7ff fdd8 	bl	802311a <DIGITAL_IO_SetOutputLow>
	}

	timer++;
 802356a:	4b04      	ldr	r3, [pc, #16]	; (802357c <LedPwmTimerProc+0xf0>)
 802356c:	681b      	ldr	r3, [r3, #0]
 802356e:	3301      	adds	r3, #1
 8023570:	4a02      	ldr	r2, [pc, #8]	; (802357c <LedPwmTimerProc+0xf0>)
 8023572:	6013      	str	r3, [r2, #0]
}
 8023574:	bf00      	nop
 8023576:	3708      	adds	r7, #8
 8023578:	46bd      	mov	sp, r7
 802357a:	bd80      	pop	{r7, pc}
 802357c:	2000064c 	.word	0x2000064c
 8023580:	20000628 	.word	0x20000628
 8023584:	0802b438 	.word	0x0802b438
 8023588:	0802b44c 	.word	0x0802b44c
 802358c:	0802b460 	.word	0x0802b460
 8023590:	0802b474 	.word	0x0802b474
 8023594:	0802b488 	.word	0x0802b488
 8023598:	0802b49c 	.word	0x0802b49c

0802359c <XMC_GPIO_SetOutputHigh>:
{
 802359c:	b480      	push	{r7}
 802359e:	b083      	sub	sp, #12
 80235a0:	af00      	add	r7, sp, #0
 80235a2:	6078      	str	r0, [r7, #4]
 80235a4:	460b      	mov	r3, r1
 80235a6:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 80235a8:	78fb      	ldrb	r3, [r7, #3]
 80235aa:	2201      	movs	r2, #1
 80235ac:	409a      	lsls	r2, r3
 80235ae:	687b      	ldr	r3, [r7, #4]
 80235b0:	605a      	str	r2, [r3, #4]
}
 80235b2:	bf00      	nop
 80235b4:	370c      	adds	r7, #12
 80235b6:	46bd      	mov	sp, r7
 80235b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80235bc:	4770      	bx	lr

080235be <XMC_GPIO_SetOutputLow>:
{
 80235be:	b480      	push	{r7}
 80235c0:	b083      	sub	sp, #12
 80235c2:	af00      	add	r7, sp, #0
 80235c4:	6078      	str	r0, [r7, #4]
 80235c6:	460b      	mov	r3, r1
 80235c8:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 80235ca:	78fb      	ldrb	r3, [r7, #3]
 80235cc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80235d0:	409a      	lsls	r2, r3
 80235d2:	687b      	ldr	r3, [r7, #4]
 80235d4:	605a      	str	r2, [r3, #4]
}
 80235d6:	bf00      	nop
 80235d8:	370c      	adds	r7, #12
 80235da:	46bd      	mov	sp, r7
 80235dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80235e0:	4770      	bx	lr

080235e2 <XMC_GPIO_GetInput>:
{
 80235e2:	b480      	push	{r7}
 80235e4:	b083      	sub	sp, #12
 80235e6:	af00      	add	r7, sp, #0
 80235e8:	6078      	str	r0, [r7, #4]
 80235ea:	460b      	mov	r3, r1
 80235ec:	70fb      	strb	r3, [r7, #3]
  return (((port->IN) >> pin) & 0x1U);
 80235ee:	687b      	ldr	r3, [r7, #4]
 80235f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80235f2:	78fb      	ldrb	r3, [r7, #3]
 80235f4:	fa22 f303 	lsr.w	r3, r2, r3
 80235f8:	f003 0301 	and.w	r3, r3, #1
}
 80235fc:	4618      	mov	r0, r3
 80235fe:	370c      	adds	r7, #12
 8023600:	46bd      	mov	sp, r7
 8023602:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023606:	4770      	bx	lr

08023608 <DIGITAL_IO_SetOutputHigh>:
{
 8023608:	b580      	push	{r7, lr}
 802360a:	b082      	sub	sp, #8
 802360c:	af00      	add	r7, sp, #0
 802360e:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8023610:	687b      	ldr	r3, [r7, #4]
 8023612:	681a      	ldr	r2, [r3, #0]
 8023614:	687b      	ldr	r3, [r7, #4]
 8023616:	7c1b      	ldrb	r3, [r3, #16]
 8023618:	4619      	mov	r1, r3
 802361a:	4610      	mov	r0, r2
 802361c:	f7ff ffbe 	bl	802359c <XMC_GPIO_SetOutputHigh>
}
 8023620:	bf00      	nop
 8023622:	3708      	adds	r7, #8
 8023624:	46bd      	mov	sp, r7
 8023626:	bd80      	pop	{r7, pc}

08023628 <DIGITAL_IO_SetOutputLow>:
{
 8023628:	b580      	push	{r7, lr}
 802362a:	b082      	sub	sp, #8
 802362c:	af00      	add	r7, sp, #0
 802362e:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8023630:	687b      	ldr	r3, [r7, #4]
 8023632:	681a      	ldr	r2, [r3, #0]
 8023634:	687b      	ldr	r3, [r7, #4]
 8023636:	7c1b      	ldrb	r3, [r3, #16]
 8023638:	4619      	mov	r1, r3
 802363a:	4610      	mov	r0, r2
 802363c:	f7ff ffbf 	bl	80235be <XMC_GPIO_SetOutputLow>
}
 8023640:	bf00      	nop
 8023642:	3708      	adds	r7, #8
 8023644:	46bd      	mov	sp, r7
 8023646:	bd80      	pop	{r7, pc}

08023648 <DIGITAL_IO_GetInput>:
* }
*  @endcode
*/

__STATIC_INLINE uint32_t DIGITAL_IO_GetInput(const DIGITAL_IO_t *const handler)
{
 8023648:	b580      	push	{r7, lr}
 802364a:	b082      	sub	sp, #8
 802364c:	af00      	add	r7, sp, #0
 802364e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_GetInput: handler null pointer", handler != NULL);
  return XMC_GPIO_GetInput(handler->gpio_port, handler->gpio_pin);
 8023650:	687b      	ldr	r3, [r7, #4]
 8023652:	681a      	ldr	r2, [r3, #0]
 8023654:	687b      	ldr	r3, [r7, #4]
 8023656:	7c1b      	ldrb	r3, [r3, #16]
 8023658:	4619      	mov	r1, r3
 802365a:	4610      	mov	r0, r2
 802365c:	f7ff ffc1 	bl	80235e2 <XMC_GPIO_GetInput>
 8023660:	4603      	mov	r3, r0
}
 8023662:	4618      	mov	r0, r3
 8023664:	3708      	adds	r7, #8
 8023666:	46bd      	mov	sp, r7
 8023668:	bd80      	pop	{r7, pc}
	...

0802366c <DoorPeriphInit>:

INPUT_SIGNALS_t Inputs;


void DoorPeriphInit(void)
{
 802366c:	b580      	push	{r7, lr}
 802366e:	af00      	add	r7, sp, #0

	InitLedRubber(MODE_ON);
 8023670:	2001      	movs	r0, #1
 8023672:	f7ff fd63 	bl	802313c <InitLedRubber>
	InitBuzzer(BUZZER_TYPE_SFM);
 8023676:	2000      	movs	r0, #0
 8023678:	f7ff fc4a 	bl	8022f10 <InitBuzzer>


	DIGITAL_IO_SetOutputHigh(&LS_SW_NRES);
 802367c:	480b      	ldr	r0, [pc, #44]	; (80236ac <DoorPeriphInit+0x40>)
 802367e:	f7ff ffc3 	bl	8023608 <DIGITAL_IO_SetOutputHigh>
	DIGITAL_IO_SetOutputLow(&DI_PNP_EN);
 8023682:	480b      	ldr	r0, [pc, #44]	; (80236b0 <DoorPeriphInit+0x44>)
 8023684:	f7ff ffd0 	bl	8023628 <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputLow(&DI_NPN_EN);
 8023688:	480a      	ldr	r0, [pc, #40]	; (80236b4 <DoorPeriphInit+0x48>)
 802368a:	f7ff ffcd 	bl	8023628 <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputLow(&GROUP_IN_EN);
 802368e:	480a      	ldr	r0, [pc, #40]	; (80236b8 <DoorPeriphInit+0x4c>)
 8023690:	f7ff ffca 	bl	8023628 <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputHigh(&POWER_SWITCH);
 8023694:	4809      	ldr	r0, [pc, #36]	; (80236bc <DoorPeriphInit+0x50>)
 8023696:	f7ff ffb7 	bl	8023608 <DIGITAL_IO_SetOutputHigh>



	PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 2000, 6000); //5200///5600
 802369a:	f241 7270 	movw	r2, #6000	; 0x1770
 802369e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80236a2:	4807      	ldr	r0, [pc, #28]	; (80236c0 <DoorPeriphInit+0x54>)
 80236a4:	f006 f86a 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>


}
 80236a8:	bf00      	nop
 80236aa:	bd80      	pop	{r7, pc}
 80236ac:	0802b3c0 	.word	0x0802b3c0
 80236b0:	0802b3d4 	.word	0x0802b3d4
 80236b4:	0802b3e8 	.word	0x0802b3e8
 80236b8:	0802b2a8 	.word	0x0802b2a8
 80236bc:	0802b424 	.word	0x0802b424
 80236c0:	20000264 	.word	0x20000264

080236c4 <ReadInputs>:




void ReadInputs(void)
{
 80236c4:	b580      	push	{r7, lr}
 80236c6:	af00      	add	r7, sp, #0
	Inputs.PNP = BUS_IO_Read(&DI_PNP);
 80236c8:	4813      	ldr	r0, [pc, #76]	; (8023718 <ReadInputs+0x54>)
 80236ca:	f006 fde1 	bl	802a290 <BUS_IO_Read>
 80236ce:	4603      	mov	r3, r0
 80236d0:	461a      	mov	r2, r3
 80236d2:	4b12      	ldr	r3, [pc, #72]	; (802371c <ReadInputs+0x58>)
 80236d4:	801a      	strh	r2, [r3, #0]
	Inputs.NPN = BUS_IO_Read(&DI_NPN);
 80236d6:	4812      	ldr	r0, [pc, #72]	; (8023720 <ReadInputs+0x5c>)
 80236d8:	f006 fdda 	bl	802a290 <BUS_IO_Read>
 80236dc:	4603      	mov	r3, r0
 80236de:	461a      	mov	r2, r3
 80236e0:	4b0e      	ldr	r3, [pc, #56]	; (802371c <ReadInputs+0x58>)
 80236e2:	805a      	strh	r2, [r3, #2]
	Inputs.IO =  BUS_IO_Read(&GROUP_IN);
 80236e4:	480f      	ldr	r0, [pc, #60]	; (8023724 <ReadInputs+0x60>)
 80236e6:	f006 fdd3 	bl	802a290 <BUS_IO_Read>
 80236ea:	4603      	mov	r3, r0
 80236ec:	461a      	mov	r2, r3
 80236ee:	4b0b      	ldr	r3, [pc, #44]	; (802371c <ReadInputs+0x58>)
 80236f0:	809a      	strh	r2, [r3, #4]

	if (DIGITAL_IO_GetInput(&SERVICE_BUT))
 80236f2:	480d      	ldr	r0, [pc, #52]	; (8023728 <ReadInputs+0x64>)
 80236f4:	f7ff ffa8 	bl	8023648 <DIGITAL_IO_GetInput>
 80236f8:	4603      	mov	r3, r0
 80236fa:	2b00      	cmp	r3, #0
 80236fc:	d003      	beq.n	8023706 <ReadInputs+0x42>
	{
		Inputs.ServiceButton = 0;
 80236fe:	4b07      	ldr	r3, [pc, #28]	; (802371c <ReadInputs+0x58>)
 8023700:	2200      	movs	r2, #0
 8023702:	80da      	strh	r2, [r3, #6]
 8023704:	e002      	b.n	802370c <ReadInputs+0x48>
	}
	else
	{
		Inputs.ServiceButton = 1;
 8023706:	4b05      	ldr	r3, [pc, #20]	; (802371c <ReadInputs+0x58>)
 8023708:	2201      	movs	r2, #1
 802370a:	80da      	strh	r2, [r3, #6]
	}

	ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
 802370c:	4807      	ldr	r0, [pc, #28]	; (802372c <ReadInputs+0x68>)
 802370e:	f006 ffc5 	bl	802a69c <ADC_MEASUREMENT_StartConversion>
}
 8023712:	bf00      	nop
 8023714:	bd80      	pop	{r7, pc}
 8023716:	bf00      	nop
 8023718:	20000548 	.word	0x20000548
 802371c:	20000674 	.word	0x20000674
 8023720:	2000055c 	.word	0x2000055c
 8023724:	20000520 	.word	0x20000520
 8023728:	0802b244 	.word	0x0802b244
 802372c:	200005dc 	.word	0x200005dc

08023730 <ReadOpen1DoorButton>:

void ReadOpen1DoorButton(void)
{
 8023730:	b480      	push	{r7}
 8023732:	af00      	add	r7, sp, #0
	if (Inputs.PNP & 0x0004)
 8023734:	4b08      	ldr	r3, [pc, #32]	; (8023758 <ReadOpen1DoorButton+0x28>)
 8023736:	881b      	ldrh	r3, [r3, #0]
 8023738:	f003 0304 	and.w	r3, r3, #4
 802373c:	2b00      	cmp	r3, #0
 802373e:	d003      	beq.n	8023748 <ReadOpen1DoorButton+0x18>
	{
		Open1DoorBut = 1;
 8023740:	4b06      	ldr	r3, [pc, #24]	; (802375c <ReadOpen1DoorButton+0x2c>)
 8023742:	2201      	movs	r2, #1
 8023744:	601a      	str	r2, [r3, #0]
	}
	else
	{
		Open1DoorBut = 0;
	}
}
 8023746:	e002      	b.n	802374e <ReadOpen1DoorButton+0x1e>
		Open1DoorBut = 0;
 8023748:	4b04      	ldr	r3, [pc, #16]	; (802375c <ReadOpen1DoorButton+0x2c>)
 802374a:	2200      	movs	r2, #0
 802374c:	601a      	str	r2, [r3, #0]
}
 802374e:	bf00      	nop
 8023750:	46bd      	mov	sp, r7
 8023752:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023756:	4770      	bx	lr
 8023758:	20000674 	.word	0x20000674
 802375c:	20000670 	.word	0x20000670

08023760 <ReadCloseSensor>:

void ReadCloseSensor (void)
{
 8023760:	b480      	push	{r7}
 8023762:	af00      	add	r7, sp, #0

	if (Presets.CLOSE_SENSOR_TYPE)
 8023764:	4b11      	ldr	r3, [pc, #68]	; (80237ac <ReadCloseSensor+0x4c>)
 8023766:	685b      	ldr	r3, [r3, #4]
 8023768:	2b00      	cmp	r3, #0
 802376a:	d00d      	beq.n	8023788 <ReadCloseSensor+0x28>
	{
		if (Inputs.PNP & 0x0008)
 802376c:	4b10      	ldr	r3, [pc, #64]	; (80237b0 <ReadCloseSensor+0x50>)
 802376e:	881b      	ldrh	r3, [r3, #0]
 8023770:	f003 0308 	and.w	r3, r3, #8
 8023774:	2b00      	cmp	r3, #0
 8023776:	d003      	beq.n	8023780 <ReadCloseSensor+0x20>
		{
			CloseSensor = 0;
 8023778:	4b0e      	ldr	r3, [pc, #56]	; (80237b4 <ReadCloseSensor+0x54>)
 802377a:	2200      	movs	r2, #0
 802377c:	601a      	str	r2, [r3, #0]
		else
		{
			CloseSensor = 0;
		}
	}
}
 802377e:	e010      	b.n	80237a2 <ReadCloseSensor+0x42>
			CloseSensor = 1;
 8023780:	4b0c      	ldr	r3, [pc, #48]	; (80237b4 <ReadCloseSensor+0x54>)
 8023782:	2201      	movs	r2, #1
 8023784:	601a      	str	r2, [r3, #0]
}
 8023786:	e00c      	b.n	80237a2 <ReadCloseSensor+0x42>
		if (Inputs.PNP & 0x0008)
 8023788:	4b09      	ldr	r3, [pc, #36]	; (80237b0 <ReadCloseSensor+0x50>)
 802378a:	881b      	ldrh	r3, [r3, #0]
 802378c:	f003 0308 	and.w	r3, r3, #8
 8023790:	2b00      	cmp	r3, #0
 8023792:	d003      	beq.n	802379c <ReadCloseSensor+0x3c>
			CloseSensor = 1;
 8023794:	4b07      	ldr	r3, [pc, #28]	; (80237b4 <ReadCloseSensor+0x54>)
 8023796:	2201      	movs	r2, #1
 8023798:	601a      	str	r2, [r3, #0]
}
 802379a:	e002      	b.n	80237a2 <ReadCloseSensor+0x42>
			CloseSensor = 0;
 802379c:	4b05      	ldr	r3, [pc, #20]	; (80237b4 <ReadCloseSensor+0x54>)
 802379e:	2200      	movs	r2, #0
 80237a0:	601a      	str	r2, [r3, #0]
}
 80237a2:	bf00      	nop
 80237a4:	46bd      	mov	sp, r7
 80237a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80237aa:	4770      	bx	lr
 80237ac:	20000764 	.word	0x20000764
 80237b0:	20000674 	.word	0x20000674
 80237b4:	20000654 	.word	0x20000654

080237b8 <ReadServiceButton>:
		PhotoSensor = 1;
	}
}

void ReadServiceButton(void)
{
 80237b8:	b580      	push	{r7, lr}
 80237ba:	af00      	add	r7, sp, #0
	static uint32_t previous_state;

	if (DIGITAL_IO_GetInput(&SERVICE_BUT))
 80237bc:	4811      	ldr	r0, [pc, #68]	; (8023804 <ReadServiceButton+0x4c>)
 80237be:	f7ff ff43 	bl	8023648 <DIGITAL_IO_GetInput>
 80237c2:	4603      	mov	r3, r0
 80237c4:	2b00      	cmp	r3, #0
 80237c6:	d003      	beq.n	80237d0 <ReadServiceButton+0x18>
	{
		ServiceButton = 0;
 80237c8:	4b0f      	ldr	r3, [pc, #60]	; (8023808 <ReadServiceButton+0x50>)
 80237ca:	2200      	movs	r2, #0
 80237cc:	601a      	str	r2, [r3, #0]
 80237ce:	e002      	b.n	80237d6 <ReadServiceButton+0x1e>
		//PassengerButton = 0;
	}
	else
	{
		ServiceButton = 1;
 80237d0:	4b0d      	ldr	r3, [pc, #52]	; (8023808 <ReadServiceButton+0x50>)
 80237d2:	2201      	movs	r2, #1
 80237d4:	601a      	str	r2, [r3, #0]
		//PassengerButton = 1;
	}
	if (ServiceButton && !previous_state)
 80237d6:	4b0c      	ldr	r3, [pc, #48]	; (8023808 <ReadServiceButton+0x50>)
 80237d8:	681b      	ldr	r3, [r3, #0]
 80237da:	2b00      	cmp	r3, #0
 80237dc:	d007      	beq.n	80237ee <ReadServiceButton+0x36>
 80237de:	4b0b      	ldr	r3, [pc, #44]	; (802380c <ReadServiceButton+0x54>)
 80237e0:	681b      	ldr	r3, [r3, #0]
 80237e2:	2b00      	cmp	r3, #0
 80237e4:	d103      	bne.n	80237ee <ReadServiceButton+0x36>
	{
		ServiceButtonFront = 1;
 80237e6:	4b0a      	ldr	r3, [pc, #40]	; (8023810 <ReadServiceButton+0x58>)
 80237e8:	2201      	movs	r2, #1
 80237ea:	601a      	str	r2, [r3, #0]
 80237ec:	e002      	b.n	80237f4 <ReadServiceButton+0x3c>
	}
	else
	{
		ServiceButtonFront = 0;
 80237ee:	4b08      	ldr	r3, [pc, #32]	; (8023810 <ReadServiceButton+0x58>)
 80237f0:	2200      	movs	r2, #0
 80237f2:	601a      	str	r2, [r3, #0]
	}

	previous_state = ServiceButton;
 80237f4:	4b04      	ldr	r3, [pc, #16]	; (8023808 <ReadServiceButton+0x50>)
 80237f6:	681b      	ldr	r3, [r3, #0]
 80237f8:	461a      	mov	r2, r3
 80237fa:	4b04      	ldr	r3, [pc, #16]	; (802380c <ReadServiceButton+0x54>)
 80237fc:	601a      	str	r2, [r3, #0]

}
 80237fe:	bf00      	nop
 8023800:	bd80      	pop	{r7, pc}
 8023802:	bf00      	nop
 8023804:	0802b244 	.word	0x0802b244
 8023808:	20000660 	.word	0x20000660
 802380c:	20000684 	.word	0x20000684
 8023810:	20000664 	.word	0x20000664

08023814 <ReadPassengerButton>:
void ReadPassengerButton(void)
{
 8023814:	b580      	push	{r7, lr}
 8023816:	b082      	sub	sp, #8
 8023818:	af00      	add	r7, sp, #0
	uint16_t Group_inputs = 0;
 802381a:	2300      	movs	r3, #0
 802381c:	80fb      	strh	r3, [r7, #6]

	Group_inputs = BUS_IO_Read(&GROUP_IN);
 802381e:	480a      	ldr	r0, [pc, #40]	; (8023848 <ReadPassengerButton+0x34>)
 8023820:	f006 fd36 	bl	802a290 <BUS_IO_Read>
 8023824:	4603      	mov	r3, r0
 8023826:	80fb      	strh	r3, [r7, #6]

	if ((Group_inputs & 0x0001))
 8023828:	88fb      	ldrh	r3, [r7, #6]
 802382a:	f003 0301 	and.w	r3, r3, #1
 802382e:	2b00      	cmp	r3, #0
 8023830:	d003      	beq.n	802383a <ReadPassengerButton+0x26>
	{
		 PassengerButton = 1;
 8023832:	4b06      	ldr	r3, [pc, #24]	; (802384c <ReadPassengerButton+0x38>)
 8023834:	2201      	movs	r2, #1
 8023836:	601a      	str	r2, [r3, #0]
	else
	{
		 PassengerButton = 0;
	}

}
 8023838:	e002      	b.n	8023840 <ReadPassengerButton+0x2c>
		 PassengerButton = 0;
 802383a:	4b04      	ldr	r3, [pc, #16]	; (802384c <ReadPassengerButton+0x38>)
 802383c:	2200      	movs	r2, #0
 802383e:	601a      	str	r2, [r3, #0]
}
 8023840:	bf00      	nop
 8023842:	3708      	adds	r7, #8
 8023844:	46bd      	mov	sp, r7
 8023846:	bd80      	pop	{r7, pc}
 8023848:	20000520 	.word	0x20000520
 802384c:	20000658 	.word	0x20000658

08023850 <ReadDisabledButton>:

void ReadDisabledButton(void)
{
 8023850:	b580      	push	{r7, lr}
 8023852:	b082      	sub	sp, #8
 8023854:	af00      	add	r7, sp, #0
	uint16_t Group_inputs = 0;
 8023856:	2300      	movs	r3, #0
 8023858:	80fb      	strh	r3, [r7, #6]

	Group_inputs = BUS_IO_Read(&GROUP_IN);
 802385a:	480a      	ldr	r0, [pc, #40]	; (8023884 <ReadDisabledButton+0x34>)
 802385c:	f006 fd18 	bl	802a290 <BUS_IO_Read>
 8023860:	4603      	mov	r3, r0
 8023862:	80fb      	strh	r3, [r7, #6]

	if ((Group_inputs & 0x0002))
 8023864:	88fb      	ldrh	r3, [r7, #6]
 8023866:	f003 0302 	and.w	r3, r3, #2
 802386a:	2b00      	cmp	r3, #0
 802386c:	d003      	beq.n	8023876 <ReadDisabledButton+0x26>
	{
		 DisabledButton = 1;
 802386e:	4b06      	ldr	r3, [pc, #24]	; (8023888 <ReadDisabledButton+0x38>)
 8023870:	2201      	movs	r2, #1
 8023872:	601a      	str	r2, [r3, #0]
	}
	else
	{
		 DisabledButton = 0;
	}
}
 8023874:	e002      	b.n	802387c <ReadDisabledButton+0x2c>
		 DisabledButton = 0;
 8023876:	4b04      	ldr	r3, [pc, #16]	; (8023888 <ReadDisabledButton+0x38>)
 8023878:	2200      	movs	r2, #0
 802387a:	601a      	str	r2, [r3, #0]
}
 802387c:	bf00      	nop
 802387e:	3708      	adds	r7, #8
 8023880:	46bd      	mov	sp, r7
 8023882:	bd80      	pop	{r7, pc}
 8023884:	20000520 	.word	0x20000520
 8023888:	2000065c 	.word	0x2000065c

0802388c <ReadActiveRubber>:

void ReadActiveRubber(void)
{
 802388c:	b480      	push	{r7}
 802388e:	af00      	add	r7, sp, #0
	if(Inputs.ActiveRubberLVal >= Inputs.InputPower)
 8023890:	4b08      	ldr	r3, [pc, #32]	; (80238b4 <ReadActiveRubber+0x28>)
 8023892:	891a      	ldrh	r2, [r3, #8]
 8023894:	4b07      	ldr	r3, [pc, #28]	; (80238b4 <ReadActiveRubber+0x28>)
 8023896:	899b      	ldrh	r3, [r3, #12]
 8023898:	429a      	cmp	r2, r3
 802389a:	d303      	bcc.n	80238a4 <ReadActiveRubber+0x18>
	{
		ActiveRubberL = 1;
 802389c:	4b06      	ldr	r3, [pc, #24]	; (80238b8 <ReadActiveRubber+0x2c>)
 802389e:	2201      	movs	r2, #1
 80238a0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		ActiveRubberL = 0;
	}
}
 80238a2:	e002      	b.n	80238aa <ReadActiveRubber+0x1e>
		ActiveRubberL = 0;
 80238a4:	4b04      	ldr	r3, [pc, #16]	; (80238b8 <ReadActiveRubber+0x2c>)
 80238a6:	2200      	movs	r2, #0
 80238a8:	601a      	str	r2, [r3, #0]
}
 80238aa:	bf00      	nop
 80238ac:	46bd      	mov	sp, r7
 80238ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80238b2:	4770      	bx	lr
 80238b4:	20000674 	.word	0x20000674
 80238b8:	20000650 	.word	0x20000650

080238bc <WriteClutch>:

void WriteClutch(int32_t cmd)
{
 80238bc:	b580      	push	{r7, lr}
 80238be:	b082      	sub	sp, #8
 80238c0:	af00      	add	r7, sp, #0
 80238c2:	6078      	str	r0, [r7, #4]
	static int32_t cmd_prev = 0;
	static int32_t timer = 0;
	static int32_t count_en = 0;

	if(cmd && !cmd_prev)
 80238c4:	687b      	ldr	r3, [r7, #4]
 80238c6:	2b00      	cmp	r3, #0
 80238c8:	d010      	beq.n	80238ec <WriteClutch+0x30>
 80238ca:	4b24      	ldr	r3, [pc, #144]	; (802395c <WriteClutch+0xa0>)
 80238cc:	681b      	ldr	r3, [r3, #0]
 80238ce:	2b00      	cmp	r3, #0
 80238d0:	d10c      	bne.n	80238ec <WriteClutch+0x30>
	{
		PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 400,(10000 - 5000)); //12V
 80238d2:	f241 3288 	movw	r2, #5000	; 0x1388
 80238d6:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80238da:	4821      	ldr	r0, [pc, #132]	; (8023960 <WriteClutch+0xa4>)
 80238dc:	f005 ff4e 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
		PWM_CCU4_Start(&CLUTCH_PWM);
 80238e0:	481f      	ldr	r0, [pc, #124]	; (8023960 <WriteClutch+0xa4>)
 80238e2:	f005 ff01 	bl	80296e8 <PWM_CCU4_Start>
		count_en = 1;
 80238e6:	4b1f      	ldr	r3, [pc, #124]	; (8023964 <WriteClutch+0xa8>)
 80238e8:	2201      	movs	r2, #1
 80238ea:	601a      	str	r2, [r3, #0]
	}

	if(count_en)
 80238ec:	4b1d      	ldr	r3, [pc, #116]	; (8023964 <WriteClutch+0xa8>)
 80238ee:	681b      	ldr	r3, [r3, #0]
 80238f0:	2b00      	cmp	r3, #0
 80238f2:	d018      	beq.n	8023926 <WriteClutch+0x6a>
	{
		timer++;
 80238f4:	4b1c      	ldr	r3, [pc, #112]	; (8023968 <WriteClutch+0xac>)
 80238f6:	681b      	ldr	r3, [r3, #0]
 80238f8:	3301      	adds	r3, #1
 80238fa:	4a1b      	ldr	r2, [pc, #108]	; (8023968 <WriteClutch+0xac>)
 80238fc:	6013      	str	r3, [r2, #0]

		if(timer >= 200)
 80238fe:	4b1a      	ldr	r3, [pc, #104]	; (8023968 <WriteClutch+0xac>)
 8023900:	681b      	ldr	r3, [r3, #0]
 8023902:	2bc7      	cmp	r3, #199	; 0xc7
 8023904:	dd0f      	ble.n	8023926 <WriteClutch+0x6a>
		{
			count_en = 0;
 8023906:	4b17      	ldr	r3, [pc, #92]	; (8023964 <WriteClutch+0xa8>)
 8023908:	2200      	movs	r2, #0
 802390a:	601a      	str	r2, [r3, #0]
			timer = 0;
 802390c:	4b16      	ldr	r3, [pc, #88]	; (8023968 <WriteClutch+0xac>)
 802390e:	2200      	movs	r2, #0
 8023910:	601a      	str	r2, [r3, #0]
			PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 400, (10000 - 2500)); // <15V
 8023912:	f641 524c 	movw	r2, #7500	; 0x1d4c
 8023916:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802391a:	4811      	ldr	r0, [pc, #68]	; (8023960 <WriteClutch+0xa4>)
 802391c:	f005 ff2e 	bl	802977c <PWM_CCU4_SetFreqAndDutyCycle>
			PWM_CCU4_Start(&CLUTCH_PWM);
 8023920:	480f      	ldr	r0, [pc, #60]	; (8023960 <WriteClutch+0xa4>)
 8023922:	f005 fee1 	bl	80296e8 <PWM_CCU4_Start>
		}
	}

	if(cmd)
 8023926:	687b      	ldr	r3, [r7, #4]
 8023928:	2b00      	cmp	r3, #0
 802392a:	d003      	beq.n	8023934 <WriteClutch+0x78>
	{
		PWM_CCU4_Start(&CLUTCH_PWM);
 802392c:	480c      	ldr	r0, [pc, #48]	; (8023960 <WriteClutch+0xa4>)
 802392e:	f005 fedb 	bl	80296e8 <PWM_CCU4_Start>
 8023932:	e00b      	b.n	802394c <WriteClutch+0x90>
	}
	else
	{
		PWM_CCU4_Stop(&CLUTCH_PWM);
 8023934:	480a      	ldr	r0, [pc, #40]	; (8023960 <WriteClutch+0xa4>)
 8023936:	f005 ff02 	bl	802973e <PWM_CCU4_Stop>
		DIGITAL_IO_SetOutputLow(&HS_SW_1);
 802393a:	480c      	ldr	r0, [pc, #48]	; (802396c <WriteClutch+0xb0>)
 802393c:	f7ff fe74 	bl	8023628 <DIGITAL_IO_SetOutputLow>
		//DIGITAL_IO_SetOutputLow(&HS_SW_2);
		count_en = 0;
 8023940:	4b08      	ldr	r3, [pc, #32]	; (8023964 <WriteClutch+0xa8>)
 8023942:	2200      	movs	r2, #0
 8023944:	601a      	str	r2, [r3, #0]
		timer = 0;
 8023946:	4b08      	ldr	r3, [pc, #32]	; (8023968 <WriteClutch+0xac>)
 8023948:	2200      	movs	r2, #0
 802394a:	601a      	str	r2, [r3, #0]
	}
	cmd_prev = cmd;
 802394c:	4a03      	ldr	r2, [pc, #12]	; (802395c <WriteClutch+0xa0>)
 802394e:	687b      	ldr	r3, [r7, #4]
 8023950:	6013      	str	r3, [r2, #0]
}
 8023952:	bf00      	nop
 8023954:	3708      	adds	r7, #8
 8023956:	46bd      	mov	sp, r7
 8023958:	bd80      	pop	{r7, pc}
 802395a:	bf00      	nop
 802395c:	20000688 	.word	0x20000688
 8023960:	20000264 	.word	0x20000264
 8023964:	2000068c 	.word	0x2000068c
 8023968:	20000690 	.word	0x20000690
 802396c:	0802b320 	.word	0x0802b320

08023970 <WritePassengerButton>:
void WritePassengerButton(int32_t cmd)
{
 8023970:	b580      	push	{r7, lr}
 8023972:	b082      	sub	sp, #8
 8023974:	af00      	add	r7, sp, #0
 8023976:	6078      	str	r0, [r7, #4]
	if(cmd)
 8023978:	687b      	ldr	r3, [r7, #4]
 802397a:	2b00      	cmp	r3, #0
 802397c:	d004      	beq.n	8023988 <WritePassengerButton+0x18>
	{
		BUS_IO_Write(&GROUP_OUT, 0xFF);
 802397e:	21ff      	movs	r1, #255	; 0xff
 8023980:	4805      	ldr	r0, [pc, #20]	; (8023998 <WritePassengerButton+0x28>)
 8023982:	f006 fcb2 	bl	802a2ea <BUS_IO_Write>
	}
	else
	{
		BUS_IO_Write(&GROUP_OUT, 0x00);
	}
}
 8023986:	e003      	b.n	8023990 <WritePassengerButton+0x20>
		BUS_IO_Write(&GROUP_OUT, 0x00);
 8023988:	2100      	movs	r1, #0
 802398a:	4803      	ldr	r0, [pc, #12]	; (8023998 <WritePassengerButton+0x28>)
 802398c:	f006 fcad 	bl	802a2ea <BUS_IO_Write>
}
 8023990:	bf00      	nop
 8023992:	3708      	adds	r7, #8
 8023994:	46bd      	mov	sp, r7
 8023996:	bd80      	pop	{r7, pc}
 8023998:	20000534 	.word	0x20000534

0802399c <CAN_NODE_MO_UpdateID>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_UpdateID(const CAN_NODE_LMO_t * const lmo_ptr, const uint32_t id)
{
 802399c:	b580      	push	{r7, lr}
 802399e:	b082      	sub	sp, #8
 80239a0:	af00      	add	r7, sp, #0
 80239a2:	6078      	str	r0, [r7, #4]
 80239a4:	6039      	str	r1, [r7, #0]
  XMC_CAN_MO_SetIdentifier(lmo_ptr->mo_ptr, id);
 80239a6:	687b      	ldr	r3, [r7, #4]
 80239a8:	681b      	ldr	r3, [r3, #0]
 80239aa:	6839      	ldr	r1, [r7, #0]
 80239ac:	4618      	mov	r0, r3
 80239ae:	f003 fc15 	bl	80271dc <XMC_CAN_MO_SetIdentifier>
 }
 80239b2:	bf00      	nop
 80239b4:	3708      	adds	r7, #8
 80239b6:	46bd      	mov	sp, r7
 80239b8:	bd80      	pop	{r7, pc}
	...

080239bc <Can1Tx1Send>:
int32_t CanCmdCloseAll = 0;
int32_t CanCmdEnablePassengersButton = 0;


void Can1Tx1Send(void)
{
 80239bc:	b580      	push	{r7, lr}
 80239be:	af00      	add	r7, sp, #0
	CAN_NODE_MO_UpdateID(&CAN_EXT_LMO_07_Config, (0x100 + Presets.CAN_ADRESS));
 80239c0:	4b08      	ldr	r3, [pc, #32]	; (80239e4 <Can1Tx1Send+0x28>)
 80239c2:	689b      	ldr	r3, [r3, #8]
 80239c4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80239c8:	4619      	mov	r1, r3
 80239ca:	4807      	ldr	r0, [pc, #28]	; (80239e8 <Can1Tx1Send+0x2c>)
 80239cc:	f7ff ffe6 	bl	802399c <CAN_NODE_MO_UpdateID>
	CAN_NODE_MO_UpdateData(&CAN_EXT_LMO_07_Config, &Can1TxData1[0]);
 80239d0:	4906      	ldr	r1, [pc, #24]	; (80239ec <Can1Tx1Send+0x30>)
 80239d2:	4805      	ldr	r0, [pc, #20]	; (80239e8 <Can1Tx1Send+0x2c>)
 80239d4:	f006 fb3c 	bl	802a050 <CAN_NODE_MO_UpdateData>
	CAN_NODE_MO_Transmit(&CAN_EXT_LMO_07_Config);
 80239d8:	4803      	ldr	r0, [pc, #12]	; (80239e8 <Can1Tx1Send+0x2c>)
 80239da:	f006 fb15 	bl	802a008 <CAN_NODE_MO_Transmit>
}
 80239de:	bf00      	nop
 80239e0:	bd80      	pop	{r7, pc}
 80239e2:	bf00      	nop
 80239e4:	20000764 	.word	0x20000764
 80239e8:	0802b580 	.word	0x0802b580
 80239ec:	200006d0 	.word	0x200006d0

080239f0 <Can1Rx1Parce>:

void Can1Rx1Parce(void)
{
 80239f0:	b480      	push	{r7}
 80239f2:	b083      	sub	sp, #12
 80239f4:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 80239f6:	2300      	movs	r3, #0
 80239f8:	71fb      	strb	r3, [r7, #7]
	uint8_t temp2 = 0;
 80239fa:	2300      	movs	r3, #0
 80239fc:	71bb      	strb	r3, [r7, #6]

	temp = Can1Rx1Data[0];
 80239fe:	4b12      	ldr	r3, [pc, #72]	; (8023a48 <Can1Rx1Parce+0x58>)
 8023a00:	781b      	ldrb	r3, [r3, #0]
 8023a02:	71fb      	strb	r3, [r7, #7]

	if(temp & (1<<2))
 8023a04:	79fb      	ldrb	r3, [r7, #7]
 8023a06:	f003 0304 	and.w	r3, r3, #4
 8023a0a:	2b00      	cmp	r3, #0
 8023a0c:	d003      	beq.n	8023a16 <Can1Rx1Parce+0x26>
	{
		CanCmdUnlock = 1;
 8023a0e:	4b0f      	ldr	r3, [pc, #60]	; (8023a4c <Can1Rx1Parce+0x5c>)
 8023a10:	2201      	movs	r2, #1
 8023a12:	601a      	str	r2, [r3, #0]
 8023a14:	e002      	b.n	8023a1c <Can1Rx1Parce+0x2c>
	}
	else
	{
		CanCmdUnlock = 0;
 8023a16:	4b0d      	ldr	r3, [pc, #52]	; (8023a4c <Can1Rx1Parce+0x5c>)
 8023a18:	2200      	movs	r2, #0
 8023a1a:	601a      	str	r2, [r3, #0]
	}
	temp2 = Can1Rx1Data[5];
 8023a1c:	4b0a      	ldr	r3, [pc, #40]	; (8023a48 <Can1Rx1Parce+0x58>)
 8023a1e:	795b      	ldrb	r3, [r3, #5]
 8023a20:	71bb      	strb	r3, [r7, #6]
// Enable open all
	if ((temp & (1<<0)))// && (temp2 & (1<<Presets.CAN_ADRESS)))
 8023a22:	79fb      	ldrb	r3, [r7, #7]
 8023a24:	f003 0301 	and.w	r3, r3, #1
 8023a28:	2b00      	cmp	r3, #0
 8023a2a:	d003      	beq.n	8023a34 <Can1Rx1Parce+0x44>
	{
		CanCmdOpenEnable = 1;
 8023a2c:	4b08      	ldr	r3, [pc, #32]	; (8023a50 <Can1Rx1Parce+0x60>)
 8023a2e:	2201      	movs	r2, #1
 8023a30:	601a      	str	r2, [r3, #0]
	{
		CanCmdOpenEnable = 0;
	}


}
 8023a32:	e002      	b.n	8023a3a <Can1Rx1Parce+0x4a>
		CanCmdOpenEnable = 0;
 8023a34:	4b06      	ldr	r3, [pc, #24]	; (8023a50 <Can1Rx1Parce+0x60>)
 8023a36:	2200      	movs	r2, #0
 8023a38:	601a      	str	r2, [r3, #0]
}
 8023a3a:	bf00      	nop
 8023a3c:	370c      	adds	r7, #12
 8023a3e:	46bd      	mov	sp, r7
 8023a40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023a44:	4770      	bx	lr
 8023a46:	bf00      	nop
 8023a48:	20000694 	.word	0x20000694
 8023a4c:	200006b4 	.word	0x200006b4
 8023a50:	200006b0 	.word	0x200006b0

08023a54 <Can1Rx2Parce>:
void Can1Rx2Parce(void)
{
 8023a54:	b480      	push	{r7}
 8023a56:	b083      	sub	sp, #12
 8023a58:	af00      	add	r7, sp, #0
	uint32_t temp = 0;
 8023a5a:	2300      	movs	r3, #0
 8023a5c:	607b      	str	r3, [r7, #4]
	uint32_t *pt;

	pt = (uint32_t*)(Can1Rx2Data);
 8023a5e:	4b0e      	ldr	r3, [pc, #56]	; (8023a98 <Can1Rx2Parce+0x44>)
 8023a60:	603b      	str	r3, [r7, #0]
	temp = *pt;
 8023a62:	683b      	ldr	r3, [r7, #0]
 8023a64:	681b      	ldr	r3, [r3, #0]
 8023a66:	607b      	str	r3, [r7, #4]

	if(temp & (1<<(Presets.CAN_ADRESS * 4)))
 8023a68:	4b0c      	ldr	r3, [pc, #48]	; (8023a9c <Can1Rx2Parce+0x48>)
 8023a6a:	689b      	ldr	r3, [r3, #8]
 8023a6c:	009b      	lsls	r3, r3, #2
 8023a6e:	2201      	movs	r2, #1
 8023a70:	fa02 f303 	lsl.w	r3, r2, r3
 8023a74:	461a      	mov	r2, r3
 8023a76:	687b      	ldr	r3, [r7, #4]
 8023a78:	4013      	ands	r3, r2
 8023a7a:	2b00      	cmp	r3, #0
 8023a7c:	d003      	beq.n	8023a86 <Can1Rx2Parce+0x32>
	{
		CanCmdOpenCmd = 1;
 8023a7e:	4b08      	ldr	r3, [pc, #32]	; (8023aa0 <Can1Rx2Parce+0x4c>)
 8023a80:	2201      	movs	r2, #1
 8023a82:	601a      	str	r2, [r3, #0]
	}
	else
	{
		CanCmdOpenCmd = 0;
	}
}
 8023a84:	e002      	b.n	8023a8c <Can1Rx2Parce+0x38>
		CanCmdOpenCmd = 0;
 8023a86:	4b06      	ldr	r3, [pc, #24]	; (8023aa0 <Can1Rx2Parce+0x4c>)
 8023a88:	2200      	movs	r2, #0
 8023a8a:	601a      	str	r2, [r3, #0]
}
 8023a8c:	bf00      	nop
 8023a8e:	370c      	adds	r7, #12
 8023a90:	46bd      	mov	sp, r7
 8023a92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023a96:	4770      	bx	lr
 8023a98:	2000069c 	.word	0x2000069c
 8023a9c:	20000764 	.word	0x20000764
 8023aa0:	200006b8 	.word	0x200006b8

08023aa4 <Can1Rx3Parce>:

void Can1Rx3Parce(void)
{
 8023aa4:	b480      	push	{r7}
 8023aa6:	b083      	sub	sp, #12
 8023aa8:	af00      	add	r7, sp, #0
	uint32_t temp = 0;
 8023aaa:	2300      	movs	r3, #0
 8023aac:	607b      	str	r3, [r7, #4]
	uint32_t *pt;

	pt = (uint32_t*)(Can1Rx3Data);
 8023aae:	4b19      	ldr	r3, [pc, #100]	; (8023b14 <Can1Rx3Parce+0x70>)
 8023ab0:	603b      	str	r3, [r7, #0]
	temp = *pt;
 8023ab2:	683b      	ldr	r3, [r7, #0]
 8023ab4:	681b      	ldr	r3, [r3, #0]
 8023ab6:	607b      	str	r3, [r7, #4]

	if(temp & (1<<(Presets.CAN_ADRESS * 4)))
 8023ab8:	4b17      	ldr	r3, [pc, #92]	; (8023b18 <Can1Rx3Parce+0x74>)
 8023aba:	689b      	ldr	r3, [r3, #8]
 8023abc:	009b      	lsls	r3, r3, #2
 8023abe:	2201      	movs	r2, #1
 8023ac0:	fa02 f303 	lsl.w	r3, r2, r3
 8023ac4:	461a      	mov	r2, r3
 8023ac6:	687b      	ldr	r3, [r7, #4]
 8023ac8:	4013      	ands	r3, r2
 8023aca:	2b00      	cmp	r3, #0
 8023acc:	d003      	beq.n	8023ad6 <Can1Rx3Parce+0x32>
	{
		CanCmdCloseCmd = 1;
 8023ace:	4b13      	ldr	r3, [pc, #76]	; (8023b1c <Can1Rx3Parce+0x78>)
 8023ad0:	2201      	movs	r2, #1
 8023ad2:	601a      	str	r2, [r3, #0]
 8023ad4:	e002      	b.n	8023adc <Can1Rx3Parce+0x38>
	}
	else
	{
		CanCmdCloseCmd = 0;
 8023ad6:	4b11      	ldr	r3, [pc, #68]	; (8023b1c <Can1Rx3Parce+0x78>)
 8023ad8:	2200      	movs	r2, #0
 8023ada:	601a      	str	r2, [r3, #0]
	}

	pt = (uint32_t*)(Can1Rx2Data);
 8023adc:	4b10      	ldr	r3, [pc, #64]	; (8023b20 <Can1Rx3Parce+0x7c>)
 8023ade:	603b      	str	r3, [r7, #0]
	//temp = *pt;

	if (!temp && CanCmdOpenEnable && !(*pt)) // 22/04/2022 // need dbg
 8023ae0:	687b      	ldr	r3, [r7, #4]
 8023ae2:	2b00      	cmp	r3, #0
 8023ae4:	d10b      	bne.n	8023afe <Can1Rx3Parce+0x5a>
 8023ae6:	4b0f      	ldr	r3, [pc, #60]	; (8023b24 <Can1Rx3Parce+0x80>)
 8023ae8:	681b      	ldr	r3, [r3, #0]
 8023aea:	2b00      	cmp	r3, #0
 8023aec:	d007      	beq.n	8023afe <Can1Rx3Parce+0x5a>
 8023aee:	683b      	ldr	r3, [r7, #0]
 8023af0:	681b      	ldr	r3, [r3, #0]
 8023af2:	2b00      	cmp	r3, #0
 8023af4:	d103      	bne.n	8023afe <Can1Rx3Parce+0x5a>
	{
		CanCmdEnablePassengersButton = 1;
 8023af6:	4b0c      	ldr	r3, [pc, #48]	; (8023b28 <Can1Rx3Parce+0x84>)
 8023af8:	2201      	movs	r2, #1
 8023afa:	601a      	str	r2, [r3, #0]
 8023afc:	e003      	b.n	8023b06 <Can1Rx3Parce+0x62>
	}
	else
	{
		CanCmdEnablePassengersButton = 0;
 8023afe:	4b0a      	ldr	r3, [pc, #40]	; (8023b28 <Can1Rx3Parce+0x84>)
 8023b00:	2200      	movs	r2, #0
 8023b02:	601a      	str	r2, [r3, #0]
	}

}
 8023b04:	bf00      	nop
 8023b06:	bf00      	nop
 8023b08:	370c      	adds	r7, #12
 8023b0a:	46bd      	mov	sp, r7
 8023b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023b10:	4770      	bx	lr
 8023b12:	bf00      	nop
 8023b14:	200006a4 	.word	0x200006a4
 8023b18:	20000764 	.word	0x20000764
 8023b1c:	200006bc 	.word	0x200006bc
 8023b20:	2000069c 	.word	0x2000069c
 8023b24:	200006b0 	.word	0x200006b0
 8023b28:	200006c4 	.word	0x200006c4

08023b2c <Can1Tx1Prep>:

void Can1Tx1Prep (void)
{
 8023b2c:	b480      	push	{r7}
 8023b2e:	b083      	sub	sp, #12
 8023b30:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 8023b32:	2300      	movs	r3, #0
 8023b34:	71fb      	strb	r3, [r7, #7]

	temp = 0x01;
 8023b36:	2301      	movs	r3, #1
 8023b38:	71fb      	strb	r3, [r7, #7]

	Can1TxData1[0] = temp;
 8023b3a:	4a65      	ldr	r2, [pc, #404]	; (8023cd0 <Can1Tx1Prep+0x1a4>)
 8023b3c:	79fb      	ldrb	r3, [r7, #7]
 8023b3e:	7013      	strb	r3, [r2, #0]

	temp = 0;
 8023b40:	2300      	movs	r3, #0
 8023b42:	71fb      	strb	r3, [r7, #7]

	switch (MainState)
 8023b44:	4b63      	ldr	r3, [pc, #396]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023b46:	681b      	ldr	r3, [r3, #0]
 8023b48:	3b03      	subs	r3, #3
 8023b4a:	2b09      	cmp	r3, #9
 8023b4c:	d833      	bhi.n	8023bb6 <Can1Tx1Prep+0x8a>
 8023b4e:	a201      	add	r2, pc, #4	; (adr r2, 8023b54 <Can1Tx1Prep+0x28>)
 8023b50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8023b54:	08023b7d 	.word	0x08023b7d
 8023b58:	08023b9b 	.word	0x08023b9b
 8023b5c:	08023b91 	.word	0x08023b91
 8023b60:	08023b87 	.word	0x08023b87
 8023b64:	08023bb7 	.word	0x08023bb7
 8023b68:	08023bb7 	.word	0x08023bb7
 8023b6c:	08023bb7 	.word	0x08023bb7
 8023b70:	08023bb7 	.word	0x08023bb7
 8023b74:	08023baf 	.word	0x08023baf
 8023b78:	08023ba5 	.word	0x08023ba5
	{
		case MS_CLOSED:
		{
			temp |= (1<<0);
 8023b7c:	79fb      	ldrb	r3, [r7, #7]
 8023b7e:	f043 0301 	orr.w	r3, r3, #1
 8023b82:	71fb      	strb	r3, [r7, #7]
		}break;
 8023b84:	e017      	b.n	8023bb6 <Can1Tx1Prep+0x8a>
		case MS_CLOSING:
		{
			temp |= (1<<1);
 8023b86:	79fb      	ldrb	r3, [r7, #7]
 8023b88:	f043 0302 	orr.w	r3, r3, #2
 8023b8c:	71fb      	strb	r3, [r7, #7]
		}break;
 8023b8e:	e012      	b.n	8023bb6 <Can1Tx1Prep+0x8a>
		case MS_OPENED:
		{
			temp |= (1<<2);
 8023b90:	79fb      	ldrb	r3, [r7, #7]
 8023b92:	f043 0304 	orr.w	r3, r3, #4
 8023b96:	71fb      	strb	r3, [r7, #7]
		}break;
 8023b98:	e00d      	b.n	8023bb6 <Can1Tx1Prep+0x8a>
		case MS_OPENING:
		{
			temp |= (1<<3);
 8023b9a:	79fb      	ldrb	r3, [r7, #7]
 8023b9c:	f043 0308 	orr.w	r3, r3, #8
 8023ba0:	71fb      	strb	r3, [r7, #7]
		}break;
 8023ba2:	e008      	b.n	8023bb6 <Can1Tx1Prep+0x8a>
		case MS_BLOCKAGE_ALL:
		{
			temp |= (1<<4);
 8023ba4:	79fb      	ldrb	r3, [r7, #7]
 8023ba6:	f043 0310 	orr.w	r3, r3, #16
 8023baa:	71fb      	strb	r3, [r7, #7]
		}break;
 8023bac:	e003      	b.n	8023bb6 <Can1Tx1Prep+0x8a>
		case MS_BLOCKAGE_OPN:
		{
			temp |= (1<<4);
 8023bae:	79fb      	ldrb	r3, [r7, #7]
 8023bb0:	f043 0310 	orr.w	r3, r3, #16
 8023bb4:	71fb      	strb	r3, [r7, #7]
		}
	}
	if (CloseSensor)
 8023bb6:	4b48      	ldr	r3, [pc, #288]	; (8023cd8 <Can1Tx1Prep+0x1ac>)
 8023bb8:	681b      	ldr	r3, [r3, #0]
 8023bba:	2b00      	cmp	r3, #0
 8023bbc:	d003      	beq.n	8023bc6 <Can1Tx1Prep+0x9a>
	{
		temp |= 1;
 8023bbe:	79fb      	ldrb	r3, [r7, #7]
 8023bc0:	f043 0301 	orr.w	r3, r3, #1
 8023bc4:	71fb      	strb	r3, [r7, #7]
	}
//	if(PassengerButton)
//	{
//		temp |= (1<<6);
//	}
	Can1TxData1[1] = temp;
 8023bc6:	4a42      	ldr	r2, [pc, #264]	; (8023cd0 <Can1Tx1Prep+0x1a4>)
 8023bc8:	79fb      	ldrb	r3, [r7, #7]
 8023bca:	7053      	strb	r3, [r2, #1]

	temp = 0;
 8023bcc:	2300      	movs	r3, #0
 8023bce:	71fb      	strb	r3, [r7, #7]
	if(ActiveRubberL)
 8023bd0:	4b42      	ldr	r3, [pc, #264]	; (8023cdc <Can1Tx1Prep+0x1b0>)
 8023bd2:	681b      	ldr	r3, [r3, #0]
 8023bd4:	2b00      	cmp	r3, #0
 8023bd6:	d003      	beq.n	8023be0 <Can1Tx1Prep+0xb4>
	{
		temp |= (1<<0);
 8023bd8:	79fb      	ldrb	r3, [r7, #7]
 8023bda:	f043 0301 	orr.w	r3, r3, #1
 8023bde:	71fb      	strb	r3, [r7, #7]
	}

	if(MainState == MS_BLOCKAGE_CLS)
 8023be0:	4b3c      	ldr	r3, [pc, #240]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023be2:	681b      	ldr	r3, [r3, #0]
 8023be4:	2b0a      	cmp	r3, #10
 8023be6:	d103      	bne.n	8023bf0 <Can1Tx1Prep+0xc4>
	{
		temp |= (1<<1);
 8023be8:	79fb      	ldrb	r3, [r7, #7]
 8023bea:	f043 0302 	orr.w	r3, r3, #2
 8023bee:	71fb      	strb	r3, [r7, #7]
/*	if(PhotoSensor)
	{
		temp |= (1<<2);
	}
*/
	Can1TxData1[2] = temp;
 8023bf0:	4a37      	ldr	r2, [pc, #220]	; (8023cd0 <Can1Tx1Prep+0x1a4>)
 8023bf2:	79fb      	ldrb	r3, [r7, #7]
 8023bf4:	7093      	strb	r3, [r2, #2]

	temp = 0;
 8023bf6:	2300      	movs	r3, #0
 8023bf8:	71fb      	strb	r3, [r7, #7]

	if(DisabledButton)
 8023bfa:	4b39      	ldr	r3, [pc, #228]	; (8023ce0 <Can1Tx1Prep+0x1b4>)
 8023bfc:	681b      	ldr	r3, [r3, #0]
 8023bfe:	2b00      	cmp	r3, #0
 8023c00:	d003      	beq.n	8023c0a <Can1Tx1Prep+0xde>
	{
		temp |= (0x04);
 8023c02:	79fb      	ldrb	r3, [r7, #7]
 8023c04:	f043 0304 	orr.w	r3, r3, #4
 8023c08:	71fb      	strb	r3, [r7, #7]
	}

	Can1TxData1[3] = temp;
 8023c0a:	4a31      	ldr	r2, [pc, #196]	; (8023cd0 <Can1Tx1Prep+0x1a4>)
 8023c0c:	79fb      	ldrb	r3, [r7, #7]
 8023c0e:	70d3      	strb	r3, [r2, #3]

	temp = 0;
 8023c10:	2300      	movs	r3, #0
 8023c12:	71fb      	strb	r3, [r7, #7]
		temp = ((1<<2) || (1<<6));
	}

	Can1TxData1[4] = temp;
*/
	temp = 0;
 8023c14:	2300      	movs	r3, #0
 8023c16:	71fb      	strb	r3, [r7, #7]
	if(MainState == MS_OPENING || MainState == MS_BLOCKAGE_OPN)
 8023c18:	4b2e      	ldr	r3, [pc, #184]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c1a:	681b      	ldr	r3, [r3, #0]
 8023c1c:	2b04      	cmp	r3, #4
 8023c1e:	d003      	beq.n	8023c28 <Can1Tx1Prep+0xfc>
 8023c20:	4b2c      	ldr	r3, [pc, #176]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c22:	681b      	ldr	r3, [r3, #0]
 8023c24:	2b0b      	cmp	r3, #11
 8023c26:	d101      	bne.n	8023c2c <Can1Tx1Prep+0x100>
	{
		temp = 0x40;
 8023c28:	2340      	movs	r3, #64	; 0x40
 8023c2a:	71fb      	strb	r3, [r7, #7]
	}
	if(MainState == MS_OPENED || MainState == MS_CLOSING || MainState == MS_OPENED_BLOCK || MainState == MS_BLOCKAGE_CLS || MainState == MS_HOMING)
 8023c2c:	4b29      	ldr	r3, [pc, #164]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c2e:	681b      	ldr	r3, [r3, #0]
 8023c30:	2b05      	cmp	r3, #5
 8023c32:	d00f      	beq.n	8023c54 <Can1Tx1Prep+0x128>
 8023c34:	4b27      	ldr	r3, [pc, #156]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c36:	681b      	ldr	r3, [r3, #0]
 8023c38:	2b06      	cmp	r3, #6
 8023c3a:	d00b      	beq.n	8023c54 <Can1Tx1Prep+0x128>
 8023c3c:	4b25      	ldr	r3, [pc, #148]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c3e:	681b      	ldr	r3, [r3, #0]
 8023c40:	2b07      	cmp	r3, #7
 8023c42:	d007      	beq.n	8023c54 <Can1Tx1Prep+0x128>
 8023c44:	4b23      	ldr	r3, [pc, #140]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c46:	681b      	ldr	r3, [r3, #0]
 8023c48:	2b0a      	cmp	r3, #10
 8023c4a:	d003      	beq.n	8023c54 <Can1Tx1Prep+0x128>
 8023c4c:	4b21      	ldr	r3, [pc, #132]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c4e:	681b      	ldr	r3, [r3, #0]
 8023c50:	2b02      	cmp	r3, #2
 8023c52:	d101      	bne.n	8023c58 <Can1Tx1Prep+0x12c>
	{
		temp = 0x60;
 8023c54:	2360      	movs	r3, #96	; 0x60
 8023c56:	71fb      	strb	r3, [r7, #7]
	}
	if(MainState == MS_CLOSED)
 8023c58:	4b1e      	ldr	r3, [pc, #120]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c5a:	681b      	ldr	r3, [r3, #0]
 8023c5c:	2b03      	cmp	r3, #3
 8023c5e:	d101      	bne.n	8023c64 <Can1Tx1Prep+0x138>
	{
		temp = 0;
 8023c60:	2300      	movs	r3, #0
 8023c62:	71fb      	strb	r3, [r7, #7]
	}
	if(MainState == MS_BLOCKAGE_ALL || MainState == MS_BLOCKAGE_CLS || MainState == MS_ERROR_MAX_CURRENT || MainState == MS_ERROR_MOV_TIMEOUT)
 8023c64:	4b1b      	ldr	r3, [pc, #108]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c66:	681b      	ldr	r3, [r3, #0]
 8023c68:	2b0c      	cmp	r3, #12
 8023c6a:	d00b      	beq.n	8023c84 <Can1Tx1Prep+0x158>
 8023c6c:	4b19      	ldr	r3, [pc, #100]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c6e:	681b      	ldr	r3, [r3, #0]
 8023c70:	2b0a      	cmp	r3, #10
 8023c72:	d007      	beq.n	8023c84 <Can1Tx1Prep+0x158>
 8023c74:	4b17      	ldr	r3, [pc, #92]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c76:	681b      	ldr	r3, [r3, #0]
 8023c78:	2b16      	cmp	r3, #22
 8023c7a:	d003      	beq.n	8023c84 <Can1Tx1Prep+0x158>
 8023c7c:	4b15      	ldr	r3, [pc, #84]	; (8023cd4 <Can1Tx1Prep+0x1a8>)
 8023c7e:	681b      	ldr	r3, [r3, #0]
 8023c80:	2b15      	cmp	r3, #21
 8023c82:	d103      	bne.n	8023c8c <Can1Tx1Prep+0x160>
	{
		temp |= 0x01;
 8023c84:	79fb      	ldrb	r3, [r7, #7]
 8023c86:	f043 0301 	orr.w	r3, r3, #1
 8023c8a:	71fb      	strb	r3, [r7, #7]
	}

	Can1TxData1[6] = temp;
 8023c8c:	4a10      	ldr	r2, [pc, #64]	; (8023cd0 <Can1Tx1Prep+0x1a4>)
 8023c8e:	79fb      	ldrb	r3, [r7, #7]
 8023c90:	7193      	strb	r3, [r2, #6]

	if(Presets.CAN_ADRESS == 0)
 8023c92:	4b14      	ldr	r3, [pc, #80]	; (8023ce4 <Can1Tx1Prep+0x1b8>)
 8023c94:	689b      	ldr	r3, [r3, #8]
 8023c96:	2b00      	cmp	r3, #0
 8023c98:	d101      	bne.n	8023c9e <Can1Tx1Prep+0x172>
	{
		temp = 0x86;
 8023c9a:	2386      	movs	r3, #134	; 0x86
 8023c9c:	71fb      	strb	r3, [r7, #7]
	}
	if(Presets.CAN_ADRESS == 5)
 8023c9e:	4b11      	ldr	r3, [pc, #68]	; (8023ce4 <Can1Tx1Prep+0x1b8>)
 8023ca0:	689b      	ldr	r3, [r3, #8]
 8023ca2:	2b05      	cmp	r3, #5
 8023ca4:	d101      	bne.n	8023caa <Can1Tx1Prep+0x17e>
	{
		temp = 0x87;
 8023ca6:	2387      	movs	r3, #135	; 0x87
 8023ca8:	71fb      	strb	r3, [r7, #7]
	}
	if((Presets.CAN_ADRESS != 0) && (Presets.CAN_ADRESS != 5))
 8023caa:	4b0e      	ldr	r3, [pc, #56]	; (8023ce4 <Can1Tx1Prep+0x1b8>)
 8023cac:	689b      	ldr	r3, [r3, #8]
 8023cae:	2b00      	cmp	r3, #0
 8023cb0:	d005      	beq.n	8023cbe <Can1Tx1Prep+0x192>
 8023cb2:	4b0c      	ldr	r3, [pc, #48]	; (8023ce4 <Can1Tx1Prep+0x1b8>)
 8023cb4:	689b      	ldr	r3, [r3, #8]
 8023cb6:	2b05      	cmp	r3, #5
 8023cb8:	d001      	beq.n	8023cbe <Can1Tx1Prep+0x192>
	{
		temp = 0x96;
 8023cba:	2396      	movs	r3, #150	; 0x96
 8023cbc:	71fb      	strb	r3, [r7, #7]
	}
	Can1TxData1[7] = temp;
 8023cbe:	4a04      	ldr	r2, [pc, #16]	; (8023cd0 <Can1Tx1Prep+0x1a4>)
 8023cc0:	79fb      	ldrb	r3, [r7, #7]
 8023cc2:	71d3      	strb	r3, [r2, #7]
}
 8023cc4:	bf00      	nop
 8023cc6:	370c      	adds	r7, #12
 8023cc8:	46bd      	mov	sp, r7
 8023cca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023cce:	4770      	bx	lr
 8023cd0:	200006d0 	.word	0x200006d0
 8023cd4:	200006f8 	.word	0x200006f8
 8023cd8:	20000654 	.word	0x20000654
 8023cdc:	20000650 	.word	0x20000650
 8023ce0:	2000065c 	.word	0x2000065c
 8023ce4:	20000764 	.word	0x20000764

08023ce8 <CAN0_6_IRQHandler>:



void CAN1RxHandler (void)
{
 8023ce8:	b580      	push	{r7, lr}
 8023cea:	b084      	sub	sp, #16
 8023cec:	af00      	add	r7, sp, #0
	static uint32_t pack_counter = 0;

	//DIGITAL_IO_ToggleOutput(&STATUS_LED_G);

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_01_Config);
 8023cee:	4835      	ldr	r0, [pc, #212]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023cf0:	f006 f99c 	bl	802a02c <CAN_NODE_MO_Receive>

	pack_counter ++; // for ident no link
 8023cf4:	4b34      	ldr	r3, [pc, #208]	; (8023dc8 <CAN0_6_IRQHandler+0xe0>)
 8023cf6:	681b      	ldr	r3, [r3, #0]
 8023cf8:	3301      	adds	r3, #1
 8023cfa:	4a33      	ldr	r2, [pc, #204]	; (8023dc8 <CAN0_6_IRQHandler+0xe0>)
 8023cfc:	6013      	str	r3, [r2, #0]

	if(pack_counter >= 200)
 8023cfe:	4b32      	ldr	r3, [pc, #200]	; (8023dc8 <CAN0_6_IRQHandler+0xe0>)
 8023d00:	681b      	ldr	r3, [r3, #0]
 8023d02:	2bc7      	cmp	r3, #199	; 0xc7
 8023d04:	d902      	bls.n	8023d0c <CAN0_6_IRQHandler+0x24>
	{
		ExtCanOnline = 1;
 8023d06:	4b31      	ldr	r3, [pc, #196]	; (8023dcc <CAN0_6_IRQHandler+0xe4>)
 8023d08:	2201      	movs	r2, #1
 8023d0a:	601a      	str	r2, [r3, #0]
	}


	if (CAN_EXT_LMO_01_Config.mo_ptr->can_identifier == 0x80)
 8023d0c:	4b2d      	ldr	r3, [pc, #180]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023d0e:	681b      	ldr	r3, [r3, #0]
 8023d10:	685b      	ldr	r3, [r3, #4]
 8023d12:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023d16:	2b80      	cmp	r3, #128	; 0x80
 8023d18:	d115      	bne.n	8023d46 <CAN0_6_IRQHandler+0x5e>
	{

		for (int i = 0; i < 8; i++)
 8023d1a:	2300      	movs	r3, #0
 8023d1c:	60fb      	str	r3, [r7, #12]
 8023d1e:	e00d      	b.n	8023d3c <CAN0_6_IRQHandler+0x54>
		{
			Can1Rx1Data[i] = CAN_EXT_LMO_01_Config.mo_ptr->can_data_byte[i];
 8023d20:	4b28      	ldr	r3, [pc, #160]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023d22:	681a      	ldr	r2, [r3, #0]
 8023d24:	68fb      	ldr	r3, [r7, #12]
 8023d26:	4413      	add	r3, r2
 8023d28:	3310      	adds	r3, #16
 8023d2a:	7819      	ldrb	r1, [r3, #0]
 8023d2c:	4a28      	ldr	r2, [pc, #160]	; (8023dd0 <CAN0_6_IRQHandler+0xe8>)
 8023d2e:	68fb      	ldr	r3, [r7, #12]
 8023d30:	4413      	add	r3, r2
 8023d32:	460a      	mov	r2, r1
 8023d34:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 8023d36:	68fb      	ldr	r3, [r7, #12]
 8023d38:	3301      	adds	r3, #1
 8023d3a:	60fb      	str	r3, [r7, #12]
 8023d3c:	68fb      	ldr	r3, [r7, #12]
 8023d3e:	2b07      	cmp	r3, #7
 8023d40:	ddee      	ble.n	8023d20 <CAN0_6_IRQHandler+0x38>
		}

		Can1Rx1Parce();
 8023d42:	f7ff fe55 	bl	80239f0 <Can1Rx1Parce>
	}

	if (CAN_EXT_LMO_01_Config.mo_ptr->can_identifier == 0x81)
 8023d46:	4b1f      	ldr	r3, [pc, #124]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023d48:	681b      	ldr	r3, [r3, #0]
 8023d4a:	685b      	ldr	r3, [r3, #4]
 8023d4c:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023d50:	2b81      	cmp	r3, #129	; 0x81
 8023d52:	d115      	bne.n	8023d80 <CAN0_6_IRQHandler+0x98>
	{

		for (int i = 0; i < 8; i++)
 8023d54:	2300      	movs	r3, #0
 8023d56:	60bb      	str	r3, [r7, #8]
 8023d58:	e00d      	b.n	8023d76 <CAN0_6_IRQHandler+0x8e>
		{
			Can1Rx2Data[i] = CAN_EXT_LMO_01_Config.mo_ptr->can_data_byte[i];
 8023d5a:	4b1a      	ldr	r3, [pc, #104]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023d5c:	681a      	ldr	r2, [r3, #0]
 8023d5e:	68bb      	ldr	r3, [r7, #8]
 8023d60:	4413      	add	r3, r2
 8023d62:	3310      	adds	r3, #16
 8023d64:	7819      	ldrb	r1, [r3, #0]
 8023d66:	4a1b      	ldr	r2, [pc, #108]	; (8023dd4 <CAN0_6_IRQHandler+0xec>)
 8023d68:	68bb      	ldr	r3, [r7, #8]
 8023d6a:	4413      	add	r3, r2
 8023d6c:	460a      	mov	r2, r1
 8023d6e:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 8023d70:	68bb      	ldr	r3, [r7, #8]
 8023d72:	3301      	adds	r3, #1
 8023d74:	60bb      	str	r3, [r7, #8]
 8023d76:	68bb      	ldr	r3, [r7, #8]
 8023d78:	2b07      	cmp	r3, #7
 8023d7a:	ddee      	ble.n	8023d5a <CAN0_6_IRQHandler+0x72>
		}

		Can1Rx2Parce();
 8023d7c:	f7ff fe6a 	bl	8023a54 <Can1Rx2Parce>
	}

	if (CAN_EXT_LMO_01_Config.mo_ptr->can_identifier == 0x82)
 8023d80:	4b10      	ldr	r3, [pc, #64]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023d82:	681b      	ldr	r3, [r3, #0]
 8023d84:	685b      	ldr	r3, [r3, #4]
 8023d86:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023d8a:	2b82      	cmp	r3, #130	; 0x82
 8023d8c:	d115      	bne.n	8023dba <CAN0_6_IRQHandler+0xd2>
	{

		for (int i = 0; i < 8; i++)
 8023d8e:	2300      	movs	r3, #0
 8023d90:	607b      	str	r3, [r7, #4]
 8023d92:	e00d      	b.n	8023db0 <CAN0_6_IRQHandler+0xc8>
		{
			Can1Rx3Data[i] = CAN_EXT_LMO_01_Config.mo_ptr->can_data_byte[i];
 8023d94:	4b0b      	ldr	r3, [pc, #44]	; (8023dc4 <CAN0_6_IRQHandler+0xdc>)
 8023d96:	681a      	ldr	r2, [r3, #0]
 8023d98:	687b      	ldr	r3, [r7, #4]
 8023d9a:	4413      	add	r3, r2
 8023d9c:	3310      	adds	r3, #16
 8023d9e:	7819      	ldrb	r1, [r3, #0]
 8023da0:	4a0d      	ldr	r2, [pc, #52]	; (8023dd8 <CAN0_6_IRQHandler+0xf0>)
 8023da2:	687b      	ldr	r3, [r7, #4]
 8023da4:	4413      	add	r3, r2
 8023da6:	460a      	mov	r2, r1
 8023da8:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 8023daa:	687b      	ldr	r3, [r7, #4]
 8023dac:	3301      	adds	r3, #1
 8023dae:	607b      	str	r3, [r7, #4]
 8023db0:	687b      	ldr	r3, [r7, #4]
 8023db2:	2b07      	cmp	r3, #7
 8023db4:	ddee      	ble.n	8023d94 <CAN0_6_IRQHandler+0xac>
		}

		Can1Rx3Parce();
 8023db6:	f7ff fe75 	bl	8023aa4 <Can1Rx3Parce>
	}
}
 8023dba:	bf00      	nop
 8023dbc:	3710      	adds	r7, #16
 8023dbe:	46bd      	mov	sp, r7
 8023dc0:	bd80      	pop	{r7, pc}
 8023dc2:	bf00      	nop
 8023dc4:	0802b538 	.word	0x0802b538
 8023dc8:	200006c8 	.word	0x200006c8
 8023dcc:	200006ac 	.word	0x200006ac
 8023dd0:	20000694 	.word	0x20000694
 8023dd4:	2000069c 	.word	0x2000069c
 8023dd8:	200006a4 	.word	0x200006a4

08023ddc <CAN0_3_IRQHandler>:

void TrapSensorISRHandler(void)
{
 8023ddc:	b580      	push	{r7, lr}
 8023dde:	b082      	sub	sp, #8
 8023de0:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 8023de2:	2300      	movs	r3, #0
 8023de4:	71fb      	strb	r3, [r7, #7]

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_05_Config);
 8023de6:	4811      	ldr	r0, [pc, #68]	; (8023e2c <CAN0_3_IRQHandler+0x50>)
 8023de8:	f006 f920 	bl	802a02c <CAN_NODE_MO_Receive>

	if (((CAN_EXT_LMO_05_Config.mo_ptr->can_identifier == 0x240000) && (Presets.CAN_ADRESS == 2)))
 8023dec:	4b0f      	ldr	r3, [pc, #60]	; (8023e2c <CAN0_3_IRQHandler+0x50>)
 8023dee:	681b      	ldr	r3, [r3, #0]
 8023df0:	685b      	ldr	r3, [r3, #4]
 8023df2:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023df6:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 8023dfa:	d113      	bne.n	8023e24 <CAN0_3_IRQHandler+0x48>
 8023dfc:	4b0c      	ldr	r3, [pc, #48]	; (8023e30 <CAN0_3_IRQHandler+0x54>)
 8023dfe:	689b      	ldr	r3, [r3, #8]
 8023e00:	2b02      	cmp	r3, #2
 8023e02:	d10f      	bne.n	8023e24 <CAN0_3_IRQHandler+0x48>
	{
		temp = CAN_EXT_LMO_05_Config.mo_ptr->can_data_byte[0];
 8023e04:	4b09      	ldr	r3, [pc, #36]	; (8023e2c <CAN0_3_IRQHandler+0x50>)
 8023e06:	681b      	ldr	r3, [r3, #0]
 8023e08:	7c1b      	ldrb	r3, [r3, #16]
 8023e0a:	71fb      	strb	r3, [r7, #7]

		//DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);

		if(temp & (1<<1)) // trap sensor transmit via CAN in 0x240000[0].1
 8023e0c:	79fb      	ldrb	r3, [r7, #7]
 8023e0e:	f003 0302 	and.w	r3, r3, #2
 8023e12:	2b00      	cmp	r3, #0
 8023e14:	d003      	beq.n	8023e1e <CAN0_3_IRQHandler+0x42>
		{
			TrapSensor = 1;
 8023e16:	4b07      	ldr	r3, [pc, #28]	; (8023e34 <CAN0_3_IRQHandler+0x58>)
 8023e18:	2201      	movs	r2, #1
 8023e1a:	601a      	str	r2, [r3, #0]
		else
		{
			TrapSensor = 0;
		}
	}
}
 8023e1c:	e002      	b.n	8023e24 <CAN0_3_IRQHandler+0x48>
			TrapSensor = 0;
 8023e1e:	4b05      	ldr	r3, [pc, #20]	; (8023e34 <CAN0_3_IRQHandler+0x58>)
 8023e20:	2200      	movs	r2, #0
 8023e22:	601a      	str	r2, [r3, #0]
}
 8023e24:	bf00      	nop
 8023e26:	3708      	adds	r7, #8
 8023e28:	46bd      	mov	sp, r7
 8023e2a:	bd80      	pop	{r7, pc}
 8023e2c:	0802b568 	.word	0x0802b568
 8023e30:	20000764 	.word	0x20000764
 8023e34:	2000066c 	.word	0x2000066c

08023e38 <CAN0_5_IRQHandler>:

void StopButISRHanler (void)
{
 8023e38:	b580      	push	{r7, lr}
 8023e3a:	b082      	sub	sp, #8
 8023e3c:	af00      	add	r7, sp, #0
	uint8_t temp = 0;
 8023e3e:	2300      	movs	r3, #0
 8023e40:	71fb      	strb	r3, [r7, #7]


	CAN_NODE_MO_Receive(&CAN_EXT_LMO_04_Config);
 8023e42:	481a      	ldr	r0, [pc, #104]	; (8023eac <CAN0_5_IRQHandler+0x74>)
 8023e44:	f006 f8f2 	bl	802a02c <CAN_NODE_MO_Receive>

	// In Lionet Stop Buttons transmit via CAN in 0x600000[0].3; 0x602000[0].3; 0x604000[0].3; 0x608000[0].3
	// In Vityaz' Stop Buttons transmit via CAN in 0x600000[0].3; 0x602000[0].3; 0x604000[0].3; 0x60A000[0].3; 0x60C000[0].3; 0x60E000[0].3
	// In Bogatyr' I DON'T KNOW
	if (((Presets.CAN_ADRESS <= 2) && (CAN_EXT_LMO_04_Config.mo_ptr->can_identifier == (0x600000 + (Presets.CAN_ADRESS * 2) * 0x1000))) || ((Presets.CAN_ADRESS == 3) && (CAN_EXT_LMO_04_Config.mo_ptr->can_identifier == 0x608000)))
 8023e48:	4b19      	ldr	r3, [pc, #100]	; (8023eb0 <CAN0_5_IRQHandler+0x78>)
 8023e4a:	689b      	ldr	r3, [r3, #8]
 8023e4c:	2b02      	cmp	r3, #2
 8023e4e:	d80c      	bhi.n	8023e6a <CAN0_5_IRQHandler+0x32>
 8023e50:	4b16      	ldr	r3, [pc, #88]	; (8023eac <CAN0_5_IRQHandler+0x74>)
 8023e52:	681b      	ldr	r3, [r3, #0]
 8023e54:	685b      	ldr	r3, [r3, #4]
 8023e56:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8023e5a:	461a      	mov	r2, r3
 8023e5c:	4b14      	ldr	r3, [pc, #80]	; (8023eb0 <CAN0_5_IRQHandler+0x78>)
 8023e5e:	689b      	ldr	r3, [r3, #8]
 8023e60:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8023e64:	035b      	lsls	r3, r3, #13
 8023e66:	429a      	cmp	r2, r3
 8023e68:	d00b      	beq.n	8023e82 <CAN0_5_IRQHandler+0x4a>
 8023e6a:	4b11      	ldr	r3, [pc, #68]	; (8023eb0 <CAN0_5_IRQHandler+0x78>)
 8023e6c:	689b      	ldr	r3, [r3, #8]
 8023e6e:	2b03      	cmp	r3, #3
 8023e70:	d117      	bne.n	8023ea2 <CAN0_5_IRQHandler+0x6a>
 8023e72:	4b0e      	ldr	r3, [pc, #56]	; (8023eac <CAN0_5_IRQHandler+0x74>)
 8023e74:	681b      	ldr	r3, [r3, #0]
 8023e76:	685b      	ldr	r3, [r3, #4]
 8023e78:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8023e7c:	f5b3 0fc1 	cmp.w	r3, #6324224	; 0x608000
 8023e80:	d10f      	bne.n	8023ea2 <CAN0_5_IRQHandler+0x6a>
	{
		//DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
		temp = CAN_EXT_LMO_04_Config.mo_ptr->can_data_byte[0];
 8023e82:	4b0a      	ldr	r3, [pc, #40]	; (8023eac <CAN0_5_IRQHandler+0x74>)
 8023e84:	681b      	ldr	r3, [r3, #0]
 8023e86:	7c1b      	ldrb	r3, [r3, #16]
 8023e88:	71fb      	strb	r3, [r7, #7]

		if(temp & (1<<3))
 8023e8a:	79fb      	ldrb	r3, [r7, #7]
 8023e8c:	f003 0308 	and.w	r3, r3, #8
 8023e90:	2b00      	cmp	r3, #0
 8023e92:	d003      	beq.n	8023e9c <CAN0_5_IRQHandler+0x64>
		{
			StopButton = 1;
 8023e94:	4b07      	ldr	r3, [pc, #28]	; (8023eb4 <CAN0_5_IRQHandler+0x7c>)
 8023e96:	2201      	movs	r2, #1
 8023e98:	601a      	str	r2, [r3, #0]
		else
		{
			StopButton = 0;
		}
	}
}
 8023e9a:	e002      	b.n	8023ea2 <CAN0_5_IRQHandler+0x6a>
			StopButton = 0;
 8023e9c:	4b05      	ldr	r3, [pc, #20]	; (8023eb4 <CAN0_5_IRQHandler+0x7c>)
 8023e9e:	2200      	movs	r2, #0
 8023ea0:	601a      	str	r2, [r3, #0]
}
 8023ea2:	bf00      	nop
 8023ea4:	3708      	adds	r7, #8
 8023ea6:	46bd      	mov	sp, r7
 8023ea8:	bd80      	pop	{r7, pc}
 8023eaa:	bf00      	nop
 8023eac:	0802b55c 	.word	0x0802b55c
 8023eb0:	20000764 	.word	0x20000764
 8023eb4:	20000668 	.word	0x20000668

08023eb8 <CAN0_0_IRQHandler>:


void CanNodeAllertIsrHandler(void)
{
 8023eb8:	b580      	push	{r7, lr}
 8023eba:	af00      	add	r7, sp, #0
	// If CAN node not OK
	//DIGITAL_IO_ToggleOutput(&STATUS_LED_R);

	if (CAN_NODE_GetStatus(&CAN_EXT))
 8023ebc:	4805      	ldr	r0, [pc, #20]	; (8023ed4 <CAN0_0_IRQHandler+0x1c>)
 8023ebe:	f006 f8e6 	bl	802a08e <CAN_NODE_GetStatus>
 8023ec2:	4603      	mov	r3, r0
 8023ec4:	2b00      	cmp	r3, #0
 8023ec6:	d002      	beq.n	8023ece <CAN0_0_IRQHandler+0x16>
	{
		CAN_NODE_Init(&CAN_EXT); // Reset node
 8023ec8:	4802      	ldr	r0, [pc, #8]	; (8023ed4 <CAN0_0_IRQHandler+0x1c>)
 8023eca:	f006 f8f0 	bl	802a0ae <CAN_NODE_Init>
	}
}
 8023ece:	bf00      	nop
 8023ed0:	bd80      	pop	{r7, pc}
 8023ed2:	bf00      	nop
 8023ed4:	0802b598 	.word	0x0802b598

08023ed8 <XMC_GPIO_SetOutputHigh>:
{
 8023ed8:	b480      	push	{r7}
 8023eda:	b083      	sub	sp, #12
 8023edc:	af00      	add	r7, sp, #0
 8023ede:	6078      	str	r0, [r7, #4]
 8023ee0:	460b      	mov	r3, r1
 8023ee2:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8023ee4:	78fb      	ldrb	r3, [r7, #3]
 8023ee6:	2201      	movs	r2, #1
 8023ee8:	409a      	lsls	r2, r3
 8023eea:	687b      	ldr	r3, [r7, #4]
 8023eec:	605a      	str	r2, [r3, #4]
}
 8023eee:	bf00      	nop
 8023ef0:	370c      	adds	r7, #12
 8023ef2:	46bd      	mov	sp, r7
 8023ef4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ef8:	4770      	bx	lr

08023efa <XMC_GPIO_SetOutputLow>:
{
 8023efa:	b480      	push	{r7}
 8023efc:	b083      	sub	sp, #12
 8023efe:	af00      	add	r7, sp, #0
 8023f00:	6078      	str	r0, [r7, #4]
 8023f02:	460b      	mov	r3, r1
 8023f04:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8023f06:	78fb      	ldrb	r3, [r7, #3]
 8023f08:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8023f0c:	409a      	lsls	r2, r3
 8023f0e:	687b      	ldr	r3, [r7, #4]
 8023f10:	605a      	str	r2, [r3, #4]
}
 8023f12:	bf00      	nop
 8023f14:	370c      	adds	r7, #12
 8023f16:	46bd      	mov	sp, r7
 8023f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023f1c:	4770      	bx	lr

08023f1e <XMC_GPIO_ToggleOutput>:
{
 8023f1e:	b480      	push	{r7}
 8023f20:	b083      	sub	sp, #12
 8023f22:	af00      	add	r7, sp, #0
 8023f24:	6078      	str	r0, [r7, #4]
 8023f26:	460b      	mov	r3, r1
 8023f28:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10001U << pin;
 8023f2a:	78fb      	ldrb	r3, [r7, #3]
 8023f2c:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8023f30:	409a      	lsls	r2, r3
 8023f32:	687b      	ldr	r3, [r7, #4]
 8023f34:	605a      	str	r2, [r3, #4]
}
 8023f36:	bf00      	nop
 8023f38:	370c      	adds	r7, #12
 8023f3a:	46bd      	mov	sp, r7
 8023f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023f40:	4770      	bx	lr

08023f42 <DIGITAL_IO_SetOutputHigh>:
{
 8023f42:	b580      	push	{r7, lr}
 8023f44:	b082      	sub	sp, #8
 8023f46:	af00      	add	r7, sp, #0
 8023f48:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8023f4a:	687b      	ldr	r3, [r7, #4]
 8023f4c:	681a      	ldr	r2, [r3, #0]
 8023f4e:	687b      	ldr	r3, [r7, #4]
 8023f50:	7c1b      	ldrb	r3, [r3, #16]
 8023f52:	4619      	mov	r1, r3
 8023f54:	4610      	mov	r0, r2
 8023f56:	f7ff ffbf 	bl	8023ed8 <XMC_GPIO_SetOutputHigh>
}
 8023f5a:	bf00      	nop
 8023f5c:	3708      	adds	r7, #8
 8023f5e:	46bd      	mov	sp, r7
 8023f60:	bd80      	pop	{r7, pc}

08023f62 <DIGITAL_IO_SetOutputLow>:
{
 8023f62:	b580      	push	{r7, lr}
 8023f64:	b082      	sub	sp, #8
 8023f66:	af00      	add	r7, sp, #0
 8023f68:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8023f6a:	687b      	ldr	r3, [r7, #4]
 8023f6c:	681a      	ldr	r2, [r3, #0]
 8023f6e:	687b      	ldr	r3, [r7, #4]
 8023f70:	7c1b      	ldrb	r3, [r3, #16]
 8023f72:	4619      	mov	r1, r3
 8023f74:	4610      	mov	r0, r2
 8023f76:	f7ff ffc0 	bl	8023efa <XMC_GPIO_SetOutputLow>
}
 8023f7a:	bf00      	nop
 8023f7c:	3708      	adds	r7, #8
 8023f7e:	46bd      	mov	sp, r7
 8023f80:	bd80      	pop	{r7, pc}

08023f82 <DIGITAL_IO_ToggleOutput>:
{
 8023f82:	b580      	push	{r7, lr}
 8023f84:	b082      	sub	sp, #8
 8023f86:	af00      	add	r7, sp, #0
 8023f88:	6078      	str	r0, [r7, #4]
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 8023f8a:	687b      	ldr	r3, [r7, #4]
 8023f8c:	681a      	ldr	r2, [r3, #0]
 8023f8e:	687b      	ldr	r3, [r7, #4]
 8023f90:	7c1b      	ldrb	r3, [r3, #16]
 8023f92:	4619      	mov	r1, r3
 8023f94:	4610      	mov	r0, r2
 8023f96:	f7ff ffc2 	bl	8023f1e <XMC_GPIO_ToggleOutput>
}
 8023f9a:	bf00      	nop
 8023f9c:	3708      	adds	r7, #8
 8023f9e:	46bd      	mov	sp, r7
 8023fa0:	bd80      	pop	{r7, pc}

08023fa2 <CAN_NODE_MO_UpdateID>:
{
 8023fa2:	b580      	push	{r7, lr}
 8023fa4:	b082      	sub	sp, #8
 8023fa6:	af00      	add	r7, sp, #0
 8023fa8:	6078      	str	r0, [r7, #4]
 8023faa:	6039      	str	r1, [r7, #0]
  XMC_CAN_MO_SetIdentifier(lmo_ptr->mo_ptr, id);
 8023fac:	687b      	ldr	r3, [r7, #4]
 8023fae:	681b      	ldr	r3, [r3, #0]
 8023fb0:	6839      	ldr	r1, [r7, #0]
 8023fb2:	4618      	mov	r0, r3
 8023fb4:	f003 f912 	bl	80271dc <XMC_CAN_MO_SetIdentifier>
 }
 8023fb8:	bf00      	nop
 8023fba:	3708      	adds	r7, #8
 8023fbc:	46bd      	mov	sp, r7
 8023fbe:	bd80      	pop	{r7, pc}

08023fc0 <MainAlgInit>:
int32_t serv_from_but = 0;



void MainAlgInit(void)
{
 8023fc0:	b580      	push	{r7, lr}
 8023fc2:	af00      	add	r7, sp, #0

	DoorPeriphInit();
 8023fc4:	f7ff fb52 	bl	802366c <DoorPeriphInit>
	MotorInit();
 8023fc8:	f7fe fe08 	bl	8022bdc <MotorInit>

	MainTimer = SYSTIMER_CreateTimer((MAIN_TIMER_TIME_MS * 1000), SYSTIMER_MODE_PERIODIC, MainProc, NULL );
 8023fcc:	2300      	movs	r3, #0
 8023fce:	4a12      	ldr	r2, [pc, #72]	; (8024018 <MainAlgInit+0x58>)
 8023fd0:	2101      	movs	r1, #1
 8023fd2:	f242 7010 	movw	r0, #10000	; 0x2710
 8023fd6:	f005 f801 	bl	8028fdc <SYSTIMER_CreateTimer>
 8023fda:	4603      	mov	r3, r0
 8023fdc:	461a      	mov	r2, r3
 8023fde:	4b0f      	ldr	r3, [pc, #60]	; (802401c <MainAlgInit+0x5c>)
 8023fe0:	601a      	str	r2, [r3, #0]
	SYSTIMER_StartTimer(MainTimer);
 8023fe2:	4b0e      	ldr	r3, [pc, #56]	; (802401c <MainAlgInit+0x5c>)
 8023fe4:	681b      	ldr	r3, [r3, #0]
 8023fe6:	4618      	mov	r0, r3
 8023fe8:	f005 f896 	bl	8029118 <SYSTIMER_StartTimer>

	SaveTimer = SYSTIMER_CreateTimer((1000*1000), SYSTIMER_MODE_PERIODIC, SaveProc, NULL);
 8023fec:	2300      	movs	r3, #0
 8023fee:	4a0c      	ldr	r2, [pc, #48]	; (8024020 <MainAlgInit+0x60>)
 8023ff0:	2101      	movs	r1, #1
 8023ff2:	480c      	ldr	r0, [pc, #48]	; (8024024 <MainAlgInit+0x64>)
 8023ff4:	f004 fff2 	bl	8028fdc <SYSTIMER_CreateTimer>
 8023ff8:	4603      	mov	r3, r0
 8023ffa:	461a      	mov	r2, r3
 8023ffc:	4b0a      	ldr	r3, [pc, #40]	; (8024028 <MainAlgInit+0x68>)
 8023ffe:	601a      	str	r2, [r3, #0]
	SYSTIMER_StartTimer(SaveTimer);
 8024000:	4b09      	ldr	r3, [pc, #36]	; (8024028 <MainAlgInit+0x68>)
 8024002:	681b      	ldr	r3, [r3, #0]
 8024004:	4618      	mov	r0, r3
 8024006:	f005 f887 	bl	8029118 <SYSTIMER_StartTimer>

	OPEN_DIR = -Presets.CLOSE_DIR;
 802400a:	4b08      	ldr	r3, [pc, #32]	; (802402c <MainAlgInit+0x6c>)
 802400c:	681b      	ldr	r3, [r3, #0]
 802400e:	425b      	negs	r3, r3
 8024010:	4a07      	ldr	r2, [pc, #28]	; (8024030 <MainAlgInit+0x70>)
 8024012:	6013      	str	r3, [r2, #0]

}
 8024014:	bf00      	nop
 8024016:	bd80      	pop	{r7, pc}
 8024018:	08024035 	.word	0x08024035
 802401c:	200006f0 	.word	0x200006f0
 8024020:	080250a1 	.word	0x080250a1
 8024024:	000f4240 	.word	0x000f4240
 8024028:	200006f4 	.word	0x200006f4
 802402c:	20000764 	.word	0x20000764
 8024030:	20000250 	.word	0x20000250

08024034 <MainProc>:

void MainProc (void *args)
{
 8024034:	b580      	push	{r7, lr}
 8024036:	b084      	sub	sp, #16
 8024038:	af00      	add	r7, sp, #0
 802403a:	6078      	str	r0, [r7, #4]
	int32_t temp = 0;
 802403c:	2300      	movs	r3, #0
 802403e:	60fb      	str	r3, [r7, #12]
	static int32_t ClutchGo = 0;

	static int32_t CanCmdOpenEnablePrev = 0;


	ReadInputs();
 8024040:	f7ff fb40 	bl	80236c4 <ReadInputs>
	ReadPeripherials();
 8024044:	f000 ff28 	bl	8024e98 <ReadPeripherials>
	MotorRead();
 8024048:	f7fe fe3a 	bl	8022cc0 <MotorRead>


	if ((Inputs.IO & 0x0008)) // enter to service mode
 802404c:	4b9a      	ldr	r3, [pc, #616]	; (80242b8 <MainProc+0x284>)
 802404e:	889b      	ldrh	r3, [r3, #4]
 8024050:	f003 0308 	and.w	r3, r3, #8
 8024054:	2b00      	cmp	r3, #0
 8024056:	d003      	beq.n	8024060 <MainProc+0x2c>
	{
		ServiceMode = 1;
 8024058:	4b98      	ldr	r3, [pc, #608]	; (80242bc <MainProc+0x288>)
 802405a:	2201      	movs	r2, #1
 802405c:	601a      	str	r2, [r3, #0]
 802405e:	e002      	b.n	8024066 <MainProc+0x32>
	}
	else
	{
		ServiceMode = 0;
 8024060:	4b96      	ldr	r3, [pc, #600]	; (80242bc <MainProc+0x288>)
 8024062:	2200      	movs	r2, #0
 8024064:	601a      	str	r2, [r3, #0]
	}


	if(MainState == MS_CLOSED)
 8024066:	4b96      	ldr	r3, [pc, #600]	; (80242c0 <MainProc+0x28c>)
 8024068:	681b      	ldr	r3, [r3, #0]
 802406a:	2b03      	cmp	r3, #3
 802406c:	d112      	bne.n	8024094 <MainProc+0x60>
	{
		if(!CanCmdEnablePassengersButton)
 802406e:	4b95      	ldr	r3, [pc, #596]	; (80242c4 <MainProc+0x290>)
 8024070:	681b      	ldr	r3, [r3, #0]
 8024072:	2b00      	cmp	r3, #0
 8024074:	d10e      	bne.n	8024094 <MainProc+0x60>
		{
			if(PassengerButton || StopButton || DisabledButton)
 8024076:	4b94      	ldr	r3, [pc, #592]	; (80242c8 <MainProc+0x294>)
 8024078:	681b      	ldr	r3, [r3, #0]
 802407a:	2b00      	cmp	r3, #0
 802407c:	d107      	bne.n	802408e <MainProc+0x5a>
 802407e:	4b93      	ldr	r3, [pc, #588]	; (80242cc <MainProc+0x298>)
 8024080:	681b      	ldr	r3, [r3, #0]
 8024082:	2b00      	cmp	r3, #0
 8024084:	d103      	bne.n	802408e <MainProc+0x5a>
 8024086:	4b92      	ldr	r3, [pc, #584]	; (80242d0 <MainProc+0x29c>)
 8024088:	681b      	ldr	r3, [r3, #0]
 802408a:	2b00      	cmp	r3, #0
 802408c:	d002      	beq.n	8024094 <MainProc+0x60>
			{
				PassMemo = 1;
 802408e:	4b91      	ldr	r3, [pc, #580]	; (80242d4 <MainProc+0x2a0>)
 8024090:	2201      	movs	r2, #1
 8024092:	601a      	str	r2, [r3, #0]
			}
		}
	}
	if((CanCmdOpenEnable) && (!PassMemo) && (!ServiceMode))
 8024094:	4b90      	ldr	r3, [pc, #576]	; (80242d8 <MainProc+0x2a4>)
 8024096:	681b      	ldr	r3, [r3, #0]
 8024098:	2b00      	cmp	r3, #0
 802409a:	d00a      	beq.n	80240b2 <MainProc+0x7e>
 802409c:	4b8d      	ldr	r3, [pc, #564]	; (80242d4 <MainProc+0x2a0>)
 802409e:	681b      	ldr	r3, [r3, #0]
 80240a0:	2b00      	cmp	r3, #0
 80240a2:	d106      	bne.n	80240b2 <MainProc+0x7e>
 80240a4:	4b85      	ldr	r3, [pc, #532]	; (80242bc <MainProc+0x288>)
 80240a6:	681b      	ldr	r3, [r3, #0]
 80240a8:	2b00      	cmp	r3, #0
 80240aa:	d102      	bne.n	80240b2 <MainProc+0x7e>
	{
		WritePassengerButton(CMD_ON);
 80240ac:	2001      	movs	r0, #1
 80240ae:	f7ff fc5f 	bl	8023970 <WritePassengerButton>
	}
	if((!CanCmdOpenEnable) && (!PassMemo))
 80240b2:	4b89      	ldr	r3, [pc, #548]	; (80242d8 <MainProc+0x2a4>)
 80240b4:	681b      	ldr	r3, [r3, #0]
 80240b6:	2b00      	cmp	r3, #0
 80240b8:	d106      	bne.n	80240c8 <MainProc+0x94>
 80240ba:	4b86      	ldr	r3, [pc, #536]	; (80242d4 <MainProc+0x2a0>)
 80240bc:	681b      	ldr	r3, [r3, #0]
 80240be:	2b00      	cmp	r3, #0
 80240c0:	d102      	bne.n	80240c8 <MainProc+0x94>
	{
		WritePassengerButton(CMD_OFF);
 80240c2:	2000      	movs	r0, #0
 80240c4:	f7ff fc54 	bl	8023970 <WritePassengerButton>
	}
	//	WriteRubberLights(CL_RED, MODE_ON, 1000);

	if((MainState != MS_CLOSED) && (MainState != MS_START))
 80240c8:	4b7d      	ldr	r3, [pc, #500]	; (80242c0 <MainProc+0x28c>)
 80240ca:	681b      	ldr	r3, [r3, #0]
 80240cc:	2b03      	cmp	r3, #3
 80240ce:	d00a      	beq.n	80240e6 <MainProc+0xb2>
 80240d0:	4b7b      	ldr	r3, [pc, #492]	; (80242c0 <MainProc+0x28c>)
 80240d2:	681b      	ldr	r3, [r3, #0]
 80240d4:	2b00      	cmp	r3, #0
 80240d6:	d006      	beq.n	80240e6 <MainProc+0xb2>
	{
		DIGITAL_IO_SetOutputHigh(&HS_SW_3); // entrance lights
 80240d8:	4880      	ldr	r0, [pc, #512]	; (80242dc <MainProc+0x2a8>)
 80240da:	f7ff ff32 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>
		DIGITAL_IO_SetOutputHigh(&HS_SW_4); // Passengers counter
 80240de:	4880      	ldr	r0, [pc, #512]	; (80242e0 <MainProc+0x2ac>)
 80240e0:	f7ff ff2f 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>
 80240e4:	e005      	b.n	80240f2 <MainProc+0xbe>
	}
	else
	{
		DIGITAL_IO_SetOutputLow(&HS_SW_3);
 80240e6:	487d      	ldr	r0, [pc, #500]	; (80242dc <MainProc+0x2a8>)
 80240e8:	f7ff ff3b 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
		DIGITAL_IO_SetOutputLow(&HS_SW_4);
 80240ec:	487c      	ldr	r0, [pc, #496]	; (80242e0 <MainProc+0x2ac>)
 80240ee:	f7ff ff38 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
//	else
//	{
//		DIGITAL_IO_SetOutputLow(&HS_SW_4);
//	}

	if(PassMemo && !ServiceMode)
 80240f2:	4b78      	ldr	r3, [pc, #480]	; (80242d4 <MainProc+0x2a0>)
 80240f4:	681b      	ldr	r3, [r3, #0]
 80240f6:	2b00      	cmp	r3, #0
 80240f8:	d01d      	beq.n	8024136 <MainProc+0x102>
 80240fa:	4b70      	ldr	r3, [pc, #448]	; (80242bc <MainProc+0x288>)
 80240fc:	681b      	ldr	r3, [r3, #0]
 80240fe:	2b00      	cmp	r3, #0
 8024100:	d119      	bne.n	8024136 <MainProc+0x102>
	{
		butt_blink++;
 8024102:	4b78      	ldr	r3, [pc, #480]	; (80242e4 <MainProc+0x2b0>)
 8024104:	681b      	ldr	r3, [r3, #0]
 8024106:	3301      	adds	r3, #1
 8024108:	4a76      	ldr	r2, [pc, #472]	; (80242e4 <MainProc+0x2b0>)
 802410a:	6013      	str	r3, [r2, #0]
		if(butt_blink <= 100)
 802410c:	4b75      	ldr	r3, [pc, #468]	; (80242e4 <MainProc+0x2b0>)
 802410e:	681b      	ldr	r3, [r3, #0]
 8024110:	2b64      	cmp	r3, #100	; 0x64
 8024112:	dc02      	bgt.n	802411a <MainProc+0xe6>
		{
			WritePassengerButton(CMD_ON);
 8024114:	2001      	movs	r0, #1
 8024116:	f7ff fc2b 	bl	8023970 <WritePassengerButton>
		}
		if(butt_blink > 100)
 802411a:	4b72      	ldr	r3, [pc, #456]	; (80242e4 <MainProc+0x2b0>)
 802411c:	681b      	ldr	r3, [r3, #0]
 802411e:	2b64      	cmp	r3, #100	; 0x64
 8024120:	dd02      	ble.n	8024128 <MainProc+0xf4>
		{
			WritePassengerButton(CMD_OFF);
 8024122:	2000      	movs	r0, #0
 8024124:	f7ff fc24 	bl	8023970 <WritePassengerButton>
		}
		if(butt_blink >= 200)
 8024128:	4b6e      	ldr	r3, [pc, #440]	; (80242e4 <MainProc+0x2b0>)
 802412a:	681b      	ldr	r3, [r3, #0]
 802412c:	2bc7      	cmp	r3, #199	; 0xc7
 802412e:	dd02      	ble.n	8024136 <MainProc+0x102>
		{
			butt_blink = 0;
 8024130:	4b6c      	ldr	r3, [pc, #432]	; (80242e4 <MainProc+0x2b0>)
 8024132:	2200      	movs	r2, #0
 8024134:	601a      	str	r2, [r3, #0]
		}
	}

if (!ServiceMode) // main algorithm from cabine commands
 8024136:	4b61      	ldr	r3, [pc, #388]	; (80242bc <MainProc+0x288>)
 8024138:	681b      	ldr	r3, [r3, #0]
 802413a:	2b00      	cmp	r3, #0
 802413c:	f040 83bb 	bne.w	80248b6 <MainProc+0x882>
{
	switch (MainState)
 8024140:	4b5f      	ldr	r3, [pc, #380]	; (80242c0 <MainProc+0x28c>)
 8024142:	681b      	ldr	r3, [r3, #0]
 8024144:	2b0b      	cmp	r3, #11
 8024146:	f200 8382 	bhi.w	802484e <MainProc+0x81a>
 802414a:	a201      	add	r2, pc, #4	; (adr r2, 8024150 <MainProc+0x11c>)
 802414c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8024150:	08024181 	.word	0x08024181
 8024154:	080241df 	.word	0x080241df
 8024158:	0802421d 	.word	0x0802421d
 802415c:	08024319 	.word	0x08024319
 8024160:	08024409 	.word	0x08024409
 8024164:	080244f1 	.word	0x080244f1
 8024168:	080245f7 	.word	0x080245f7
 802416c:	08024595 	.word	0x08024595
 8024170:	0802484f 	.word	0x0802484f
 8024174:	0802484f 	.word	0x0802484f
 8024178:	080246b9 	.word	0x080246b9
 802417c:	080247e1 	.word	0x080247e1
	{
		case MS_START:
		{
			wait_timer++;
 8024180:	4b59      	ldr	r3, [pc, #356]	; (80242e8 <MainProc+0x2b4>)
 8024182:	681b      	ldr	r3, [r3, #0]
 8024184:	3301      	adds	r3, #1
 8024186:	4a58      	ldr	r2, [pc, #352]	; (80242e8 <MainProc+0x2b4>)
 8024188:	6013      	str	r3, [r2, #0]
			if(wait_timer >= Presets.STARTUP_TIME)
 802418a:	4b58      	ldr	r3, [pc, #352]	; (80242ec <MainProc+0x2b8>)
 802418c:	69db      	ldr	r3, [r3, #28]
 802418e:	4a56      	ldr	r2, [pc, #344]	; (80242e8 <MainProc+0x2b4>)
 8024190:	6812      	ldr	r2, [r2, #0]
 8024192:	4293      	cmp	r3, r2
 8024194:	d813      	bhi.n	80241be <MainProc+0x18a>
			{
				wait_timer = 0;
 8024196:	4b54      	ldr	r3, [pc, #336]	; (80242e8 <MainProc+0x2b4>)
 8024198:	2200      	movs	r2, #0
 802419a:	601a      	str	r2, [r3, #0]
				WritePassengerButton(CMD_ON);
 802419c:	2001      	movs	r0, #1
 802419e:	f7ff fbe7 	bl	8023970 <WritePassengerButton>

				if(CloseSensor)
 80241a2:	4b53      	ldr	r3, [pc, #332]	; (80242f0 <MainProc+0x2bc>)
 80241a4:	681b      	ldr	r3, [r3, #0]
 80241a6:	2b00      	cmp	r3, #0
 80241a8:	d004      	beq.n	80241b4 <MainProc+0x180>
				{
					MainState = MS_CLOSED;
 80241aa:	4b45      	ldr	r3, [pc, #276]	; (80242c0 <MainProc+0x28c>)
 80241ac:	2203      	movs	r2, #3
 80241ae:	601a      	str	r2, [r3, #0]
//			if(blink >= 4)
//			{
//				blink = 0;
//			}
		}
			break;
 80241b0:	f000 be54 	b.w	8024e5c <MainProc+0xe28>
					MainState = MS_UNKNOWN;
 80241b4:	4b42      	ldr	r3, [pc, #264]	; (80242c0 <MainProc+0x28c>)
 80241b6:	2201      	movs	r2, #1
 80241b8:	601a      	str	r2, [r3, #0]
			break;
 80241ba:	f000 be4f 	b.w	8024e5c <MainProc+0xe28>
				OpenDoor(0);
 80241be:	2000      	movs	r0, #0
 80241c0:	f001 fa3c 	bl	802563c <OpenDoor>
				CloseDoor(0);
 80241c4:	2000      	movs	r0, #0
 80241c6:	f001 f913 	bl	80253f0 <CloseDoor>
				Homing(0);
 80241ca:	2000      	movs	r0, #0
 80241cc:	f000 ff8c 	bl	80250e8 <Homing>
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
 80241d0:	2200      	movs	r2, #0
 80241d2:	2100      	movs	r1, #0
 80241d4:	2000      	movs	r0, #0
 80241d6:	f7fe ffdf 	bl	8023198 <WriteRubberLights>
			break;
 80241da:	f000 be3f 	b.w	8024e5c <MainProc+0xe28>
//			WritePassengerButton(CMD_ON);
			//WriteRubberLights(CL_GREEN, MODE_TIME_ON, 1000);

			//WriteClutch(CLUTCH_LOCK);

			wait_timer ++;
 80241de:	4b42      	ldr	r3, [pc, #264]	; (80242e8 <MainProc+0x2b4>)
 80241e0:	681b      	ldr	r3, [r3, #0]
 80241e2:	3301      	adds	r3, #1
 80241e4:	4a40      	ldr	r2, [pc, #256]	; (80242e8 <MainProc+0x2b4>)
 80241e6:	6013      	str	r3, [r2, #0]
//					MainState = MS_HOMING;
//					wait_timer = 0;				}
//
//			}

			if((CanCmdCloseAll || CanCmdCloseCmd || !CanCmdUnlock) && !TrapSensor)
 80241e8:	4b42      	ldr	r3, [pc, #264]	; (80242f4 <MainProc+0x2c0>)
 80241ea:	681b      	ldr	r3, [r3, #0]
 80241ec:	2b00      	cmp	r3, #0
 80241ee:	d108      	bne.n	8024202 <MainProc+0x1ce>
 80241f0:	4b41      	ldr	r3, [pc, #260]	; (80242f8 <MainProc+0x2c4>)
 80241f2:	681b      	ldr	r3, [r3, #0]
 80241f4:	2b00      	cmp	r3, #0
 80241f6:	d104      	bne.n	8024202 <MainProc+0x1ce>
 80241f8:	4b40      	ldr	r3, [pc, #256]	; (80242fc <MainProc+0x2c8>)
 80241fa:	681b      	ldr	r3, [r3, #0]
 80241fc:	2b00      	cmp	r3, #0
 80241fe:	f040 8612 	bne.w	8024e26 <MainProc+0xdf2>
 8024202:	4b3f      	ldr	r3, [pc, #252]	; (8024300 <MainProc+0x2cc>)
 8024204:	681b      	ldr	r3, [r3, #0]
 8024206:	2b00      	cmp	r3, #0
 8024208:	f040 860d 	bne.w	8024e26 <MainProc+0xdf2>
			{
				MainState = MS_HOMING;
 802420c:	4b2c      	ldr	r3, [pc, #176]	; (80242c0 <MainProc+0x28c>)
 802420e:	2202      	movs	r2, #2
 8024210:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 8024212:	4b35      	ldr	r3, [pc, #212]	; (80242e8 <MainProc+0x2b4>)
 8024214:	2200      	movs	r2, #0
 8024216:	601a      	str	r2, [r3, #0]
//			{
//				MainState = MS_HOMING;
//			}

		}
			break;
 8024218:	f000 be05 	b.w	8024e26 <MainProc+0xdf2>

		case MS_HOMING:
		{
			WriteRubberLights(CL_YELLOW, MODE_BLINK, 1000);
 802421c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8024220:	2102      	movs	r1, #2
 8024222:	4838      	ldr	r0, [pc, #224]	; (8024304 <MainProc+0x2d0>)
 8024224:	f7fe ffb8 	bl	8023198 <WriteRubberLights>


			//WriteClutch(CLUTCH_UNLOCK);
			temp = Homing(1);
 8024228:	2001      	movs	r0, #1
 802422a:	f000 ff5d 	bl	80250e8 <Homing>
 802422e:	60f8      	str	r0, [r7, #12]
			if (temp == 1) // homing done success!
 8024230:	68fb      	ldr	r3, [r7, #12]
 8024232:	2b01      	cmp	r3, #1
 8024234:	d10e      	bne.n	8024254 <MainProc+0x220>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);

				DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8024236:	4834      	ldr	r0, [pc, #208]	; (8024308 <MainProc+0x2d4>)
 8024238:	f7ff fe83 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>
				DIGITAL_IO_SetOutputLow(&HS_SW_8);
 802423c:	4833      	ldr	r0, [pc, #204]	; (802430c <MainProc+0x2d8>)
 802423e:	f7ff fe90 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				PWM_CCU4_Stop(&BUZZ_PWM);
 8024242:	4833      	ldr	r0, [pc, #204]	; (8024310 <MainProc+0x2dc>)
 8024244:	f005 fa7b 	bl	802973e <PWM_CCU4_Stop>

				HomingDone = 1;
 8024248:	4b32      	ldr	r3, [pc, #200]	; (8024314 <MainProc+0x2e0>)
 802424a:	2201      	movs	r2, #1
 802424c:	601a      	str	r2, [r3, #0]
				MainState = MS_CLOSED;
 802424e:	4b1c      	ldr	r3, [pc, #112]	; (80242c0 <MainProc+0x28c>)
 8024250:	2203      	movs	r2, #3
 8024252:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024254:	68fb      	ldr	r3, [r7, #12]
 8024256:	2b00      	cmp	r3, #0
 8024258:	d102      	bne.n	8024260 <MainProc+0x22c>
			{
				WriteBuzzer(BUZZER_ON);
 802425a:	2001      	movs	r0, #1
 802425c:	f7fe fe76 	bl	8022f4c <WriteBuzzer>
			}
			if (temp == -1)
 8024260:	68fb      	ldr	r3, [r7, #12]
 8024262:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024266:	d105      	bne.n	8024274 <MainProc+0x240>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024268:	4b15      	ldr	r3, [pc, #84]	; (80242c0 <MainProc+0x28c>)
 802426a:	2215      	movs	r2, #21
 802426c:	601a      	str	r2, [r3, #0]
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				Homing(0);
 802426e:	2000      	movs	r0, #0
 8024270:	f000 ff3a 	bl	80250e8 <Homing>
			}
			if (temp == -2)
 8024274:	68fb      	ldr	r3, [r7, #12]
 8024276:	f113 0f02 	cmn.w	r3, #2
 802427a:	d105      	bne.n	8024288 <MainProc+0x254>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_MAX_CURRENT;
 802427c:	4b10      	ldr	r3, [pc, #64]	; (80242c0 <MainProc+0x28c>)
 802427e:	2216      	movs	r2, #22
 8024280:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024282:	2000      	movs	r0, #0
 8024284:	f000 ff30 	bl	80250e8 <Homing>
			}
			if (temp == -3)
 8024288:	68fb      	ldr	r3, [r7, #12]
 802428a:	f113 0f03 	cmn.w	r3, #3
 802428e:	d105      	bne.n	802429c <MainProc+0x268>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_BAD_HOMING;
 8024290:	4b0b      	ldr	r3, [pc, #44]	; (80242c0 <MainProc+0x28c>)
 8024292:	2214      	movs	r2, #20
 8024294:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024296:	2000      	movs	r0, #0
 8024298:	f000 ff26 	bl	80250e8 <Homing>
			}
			if (-4 == temp)
 802429c:	68fb      	ldr	r3, [r7, #12]
 802429e:	f113 0f04 	cmn.w	r3, #4
 80242a2:	f040 85c2 	bne.w	8024e2a <MainProc+0xdf6>
			{
				MainState = MS_UNKNOWN;
 80242a6:	4b06      	ldr	r3, [pc, #24]	; (80242c0 <MainProc+0x28c>)
 80242a8:	2201      	movs	r2, #1
 80242aa:	601a      	str	r2, [r3, #0]
				Homing(0);
 80242ac:	2000      	movs	r0, #0
 80242ae:	f000 ff1b 	bl	80250e8 <Homing>
			}
		}
			break;
 80242b2:	f000 bdba 	b.w	8024e2a <MainProc+0xdf6>
 80242b6:	bf00      	nop
 80242b8:	20000674 	.word	0x20000674
 80242bc:	20000fc4 	.word	0x20000fc4
 80242c0:	200006f8 	.word	0x200006f8
 80242c4:	200006c4 	.word	0x200006c4
 80242c8:	20000658 	.word	0x20000658
 80242cc:	20000668 	.word	0x20000668
 80242d0:	2000065c 	.word	0x2000065c
 80242d4:	20000700 	.word	0x20000700
 80242d8:	200006b0 	.word	0x200006b0
 80242dc:	0802b348 	.word	0x0802b348
 80242e0:	0802b35c 	.word	0x0802b35c
 80242e4:	2000070c 	.word	0x2000070c
 80242e8:	20000710 	.word	0x20000710
 80242ec:	20000764 	.word	0x20000764
 80242f0:	20000654 	.word	0x20000654
 80242f4:	200006c0 	.word	0x200006c0
 80242f8:	200006bc 	.word	0x200006bc
 80242fc:	200006b4 	.word	0x200006b4
 8024300:	2000066c 	.word	0x2000066c
 8024304:	ffff0000 	.word	0xffff0000
 8024308:	0802b294 	.word	0x0802b294
 802430c:	0802b3ac 	.word	0x0802b3ac
 8024310:	2000028c 	.word	0x2000028c
 8024314:	200006fc 	.word	0x200006fc

		case MS_CLOSED:
		{
			wait_timer++;
 8024318:	4b8b      	ldr	r3, [pc, #556]	; (8024548 <MainProc+0x514>)
 802431a:	681b      	ldr	r3, [r3, #0]
 802431c:	3301      	adds	r3, #1
 802431e:	4a8a      	ldr	r2, [pc, #552]	; (8024548 <MainProc+0x514>)
 8024320:	6013      	str	r3, [r2, #0]
			//WriteClutch(CLUTCH_LOCK);

			if(wait_timer >= 200)
 8024322:	4b89      	ldr	r3, [pc, #548]	; (8024548 <MainProc+0x514>)
 8024324:	681b      	ldr	r3, [r3, #0]
 8024326:	2bc7      	cmp	r3, #199	; 0xc7
 8024328:	dd01      	ble.n	802432e <MainProc+0x2fa>
			{
				MotorStop();
 802432a:	f7fe fc8b 	bl	8022c44 <MotorStop>
			}

			if(CanCmdUnlock)
 802432e:	4b87      	ldr	r3, [pc, #540]	; (802454c <MainProc+0x518>)
 8024330:	681b      	ldr	r3, [r3, #0]
 8024332:	2b00      	cmp	r3, #0
 8024334:	d003      	beq.n	802433e <MainProc+0x30a>
			{
				DIGITAL_IO_SetOutputLow(&HS_SW_5);
 8024336:	4886      	ldr	r0, [pc, #536]	; (8024550 <MainProc+0x51c>)
 8024338:	f7ff fe13 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
 802433c:	e002      	b.n	8024344 <MainProc+0x310>
				//DIGITAL_IO_SetOutputLow(&HS_SW_2);
			}
			else
			{
				DIGITAL_IO_SetOutputHigh(&HS_SW_5);
 802433e:	4884      	ldr	r0, [pc, #528]	; (8024550 <MainProc+0x51c>)
 8024340:	f7ff fdff 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>
				//DIGITAL_IO_SetOutputHigh(&HS_SW_2);
			}

			if(wait_timer > 50)
 8024344:	4b80      	ldr	r3, [pc, #512]	; (8024548 <MainProc+0x514>)
 8024346:	681b      	ldr	r3, [r3, #0]
 8024348:	2b32      	cmp	r3, #50	; 0x32
 802434a:	dd14      	ble.n	8024376 <MainProc+0x342>
			{
				if(CanCmdUnlock && CanCmdOpenEnable)
 802434c:	4b7f      	ldr	r3, [pc, #508]	; (802454c <MainProc+0x518>)
 802434e:	681b      	ldr	r3, [r3, #0]
 8024350:	2b00      	cmp	r3, #0
 8024352:	d00a      	beq.n	802436a <MainProc+0x336>
 8024354:	4b7f      	ldr	r3, [pc, #508]	; (8024554 <MainProc+0x520>)
 8024356:	681b      	ldr	r3, [r3, #0]
 8024358:	2b00      	cmp	r3, #0
 802435a:	d006      	beq.n	802436a <MainProc+0x336>
				{
					WriteRubberLights(CL_GREEN, MODE_ON, 0);
 802435c:	2200      	movs	r2, #0
 802435e:	2101      	movs	r1, #1
 8024360:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024364:	f7fe ff18 	bl	8023198 <WriteRubberLights>
 8024368:	e00c      	b.n	8024384 <MainProc+0x350>
				}
				else
				{
					WriteRubberLights(CL_BLACK, MODE_OFF, 0);
 802436a:	2200      	movs	r2, #0
 802436c:	2100      	movs	r1, #0
 802436e:	2000      	movs	r0, #0
 8024370:	f7fe ff12 	bl	8023198 <WriteRubberLights>
 8024374:	e006      	b.n	8024384 <MainProc+0x350>
				}
			}
			else
			{
				WriteRubberLights(CL_RED, MODE_TIME_ON, 500);
 8024376:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 802437a:	2103      	movs	r1, #3
 802437c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024380:	f7fe ff0a 	bl	8023198 <WriteRubberLights>
			}

			WriteBuzzer(BUZZER_OFF);
 8024384:	2000      	movs	r0, #0
 8024386:	f7fe fde1 	bl	8022f4c <WriteBuzzer>

			if(CanCmdOpenCmd && CanCmdOpenEnable && CanCmdUnlock)
 802438a:	4b73      	ldr	r3, [pc, #460]	; (8024558 <MainProc+0x524>)
 802438c:	681b      	ldr	r3, [r3, #0]
 802438e:	2b00      	cmp	r3, #0
 8024390:	d013      	beq.n	80243ba <MainProc+0x386>
 8024392:	4b70      	ldr	r3, [pc, #448]	; (8024554 <MainProc+0x520>)
 8024394:	681b      	ldr	r3, [r3, #0]
 8024396:	2b00      	cmp	r3, #0
 8024398:	d00f      	beq.n	80243ba <MainProc+0x386>
 802439a:	4b6c      	ldr	r3, [pc, #432]	; (802454c <MainProc+0x518>)
 802439c:	681b      	ldr	r3, [r3, #0]
 802439e:	2b00      	cmp	r3, #0
 80243a0:	d00b      	beq.n	80243ba <MainProc+0x386>
			{
				MainState = MS_OPENING;
 80243a2:	4b6e      	ldr	r3, [pc, #440]	; (802455c <MainProc+0x528>)
 80243a4:	2204      	movs	r2, #4
 80243a6:	601a      	str	r2, [r3, #0]
				FromCan = 1;
 80243a8:	4b6d      	ldr	r3, [pc, #436]	; (8024560 <MainProc+0x52c>)
 80243aa:	2201      	movs	r2, #1
 80243ac:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 80243ae:	4b6d      	ldr	r3, [pc, #436]	; (8024564 <MainProc+0x530>)
 80243b0:	2200      	movs	r2, #0
 80243b2:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 80243b4:	4b64      	ldr	r3, [pc, #400]	; (8024548 <MainProc+0x514>)
 80243b6:	2200      	movs	r2, #0
 80243b8:	601a      	str	r2, [r3, #0]
			}
			if(((PassengerButton || DisabledButton || PassMemo) && CanCmdEnablePassengersButton && CanCmdUnlock))
 80243ba:	4b6b      	ldr	r3, [pc, #428]	; (8024568 <MainProc+0x534>)
 80243bc:	681b      	ldr	r3, [r3, #0]
 80243be:	2b00      	cmp	r3, #0
 80243c0:	d107      	bne.n	80243d2 <MainProc+0x39e>
 80243c2:	4b6a      	ldr	r3, [pc, #424]	; (802456c <MainProc+0x538>)
 80243c4:	681b      	ldr	r3, [r3, #0]
 80243c6:	2b00      	cmp	r3, #0
 80243c8:	d103      	bne.n	80243d2 <MainProc+0x39e>
 80243ca:	4b69      	ldr	r3, [pc, #420]	; (8024570 <MainProc+0x53c>)
 80243cc:	681b      	ldr	r3, [r3, #0]
 80243ce:	2b00      	cmp	r3, #0
 80243d0:	d010      	beq.n	80243f4 <MainProc+0x3c0>
 80243d2:	4b68      	ldr	r3, [pc, #416]	; (8024574 <MainProc+0x540>)
 80243d4:	681b      	ldr	r3, [r3, #0]
 80243d6:	2b00      	cmp	r3, #0
 80243d8:	d00c      	beq.n	80243f4 <MainProc+0x3c0>
 80243da:	4b5c      	ldr	r3, [pc, #368]	; (802454c <MainProc+0x518>)
 80243dc:	681b      	ldr	r3, [r3, #0]
 80243de:	2b00      	cmp	r3, #0
 80243e0:	d008      	beq.n	80243f4 <MainProc+0x3c0>
			{
				MainState = MS_OPENING;
 80243e2:	4b5e      	ldr	r3, [pc, #376]	; (802455c <MainProc+0x528>)
 80243e4:	2204      	movs	r2, #4
 80243e6:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 80243e8:	4b5e      	ldr	r3, [pc, #376]	; (8024564 <MainProc+0x530>)
 80243ea:	2200      	movs	r2, #0
 80243ec:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 80243ee:	4b56      	ldr	r3, [pc, #344]	; (8024548 <MainProc+0x514>)
 80243f0:	2200      	movs	r2, #0
 80243f2:	601a      	str	r2, [r3, #0]
			}

			if(!CloseSensor)
 80243f4:	4b60      	ldr	r3, [pc, #384]	; (8024578 <MainProc+0x544>)
 80243f6:	681b      	ldr	r3, [r3, #0]
 80243f8:	2b00      	cmp	r3, #0
 80243fa:	f040 8518 	bne.w	8024e2e <MainProc+0xdfa>
			{
				MainState = MS_UNKNOWN;
 80243fe:	4b57      	ldr	r3, [pc, #348]	; (802455c <MainProc+0x528>)
 8024400:	2201      	movs	r2, #1
 8024402:	601a      	str	r2, [r3, #0]
				MainState = MS_OPENING;
			}
*/
//
		}
			break;
 8024404:	f000 bd13 	b.w	8024e2e <MainProc+0xdfa>
		case MS_OPENING:
		{
			WriteRubberLights(CL_GREEN, MODE_BLINK, 500);
 8024408:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 802440c:	2102      	movs	r1, #2
 802440e:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024412:	f7fe fec1 	bl	8023198 <WriteRubberLights>
			WriteBuzzer(BUZZER_OFF);
 8024416:	2000      	movs	r0, #0
 8024418:	f7fe fd98 	bl	8022f4c <WriteBuzzer>
			OpenTime++;
 802441c:	4b51      	ldr	r3, [pc, #324]	; (8024564 <MainProc+0x530>)
 802441e:	881b      	ldrh	r3, [r3, #0]
 8024420:	3301      	adds	r3, #1
 8024422:	b29a      	uxth	r2, r3
 8024424:	4b4f      	ldr	r3, [pc, #316]	; (8024564 <MainProc+0x530>)
 8024426:	801a      	strh	r2, [r3, #0]
			PassMemo = 0;
 8024428:	4b51      	ldr	r3, [pc, #324]	; (8024570 <MainProc+0x53c>)
 802442a:	2200      	movs	r2, #0
 802442c:	601a      	str	r2, [r3, #0]
			butt_blink = 0;
 802442e:	4b53      	ldr	r3, [pc, #332]	; (802457c <MainProc+0x548>)
 8024430:	2200      	movs	r2, #0
 8024432:	601a      	str	r2, [r3, #0]

			temp = OpenDoor(1);
 8024434:	2001      	movs	r0, #1
 8024436:	f001 f901 	bl	802563c <OpenDoor>
 802443a:	60f8      	str	r0, [r7, #12]
			if (temp == 1)
 802443c:	68fb      	ldr	r3, [r7, #12]
 802443e:	2b01      	cmp	r3, #1
 8024440:	d105      	bne.n	802444e <MainProc+0x41a>
			{
				//if(Presets.CYCLES_COUNTER % 200)
				//{
				wait_timer = 0;
 8024442:	4b41      	ldr	r3, [pc, #260]	; (8024548 <MainProc+0x514>)
 8024444:	2200      	movs	r2, #0
 8024446:	601a      	str	r2, [r3, #0]
				MainState = MS_OPENED;
 8024448:	4b44      	ldr	r3, [pc, #272]	; (802455c <MainProc+0x528>)
 802444a:	2205      	movs	r2, #5
 802444c:	601a      	str	r2, [r3, #0]

				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);

			}
			if (temp == 0)
 802444e:	68fb      	ldr	r3, [r7, #12]
 8024450:	2b00      	cmp	r3, #0
 8024452:	d10b      	bne.n	802446c <MainProc+0x438>
			{
				blink++;
 8024454:	4b4a      	ldr	r3, [pc, #296]	; (8024580 <MainProc+0x54c>)
 8024456:	681b      	ldr	r3, [r3, #0]
 8024458:	3301      	adds	r3, #1
 802445a:	4a49      	ldr	r2, [pc, #292]	; (8024580 <MainProc+0x54c>)
 802445c:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 802445e:	4b48      	ldr	r3, [pc, #288]	; (8024580 <MainProc+0x54c>)
 8024460:	681b      	ldr	r3, [r3, #0]
 8024462:	2b31      	cmp	r3, #49	; 0x31
 8024464:	dd02      	ble.n	802446c <MainProc+0x438>
				{
					//DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
//					DIGITAL_IO_ToggleOutput(&TRANS_OUT);
//					DIGITAL_IO_ToggleOutput(&HS_SW_8);
					blink = 0;
 8024466:	4b46      	ldr	r3, [pc, #280]	; (8024580 <MainProc+0x54c>)
 8024468:	2200      	movs	r2, #0
 802446a:	601a      	str	r2, [r3, #0]
				}
			}
			if (temp == -1)
 802446c:	68fb      	ldr	r3, [r7, #12]
 802446e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024472:	d105      	bne.n	8024480 <MainProc+0x44c>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024474:	4b39      	ldr	r3, [pc, #228]	; (802455c <MainProc+0x528>)
 8024476:	2215      	movs	r2, #21
 8024478:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 802447a:	2000      	movs	r0, #0
 802447c:	f001 f8de 	bl	802563c <OpenDoor>
			}
			if (temp == -2)
 8024480:	68fb      	ldr	r3, [r7, #12]
 8024482:	f113 0f02 	cmn.w	r3, #2
 8024486:	d105      	bne.n	8024494 <MainProc+0x460>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024488:	4b34      	ldr	r3, [pc, #208]	; (802455c <MainProc+0x528>)
 802448a:	2216      	movs	r2, #22
 802448c:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 802448e:	2000      	movs	r0, #0
 8024490:	f001 f8d4 	bl	802563c <OpenDoor>
			}
			if (temp == -3)
 8024494:	68fb      	ldr	r3, [r7, #12]
 8024496:	f113 0f03 	cmn.w	r3, #3
 802449a:	d105      	bne.n	80244a8 <MainProc+0x474>
			{
				MainState = MS_ERROR_BAD_STATE;
 802449c:	4b2f      	ldr	r3, [pc, #188]	; (802455c <MainProc+0x528>)
 802449e:	2217      	movs	r2, #23
 80244a0:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 80244a2:	2000      	movs	r0, #0
 80244a4:	f001 f8ca 	bl	802563c <OpenDoor>
			}
			if(-4 == temp)
 80244a8:	68fb      	ldr	r3, [r7, #12]
 80244aa:	f113 0f04 	cmn.w	r3, #4
 80244ae:	d105      	bne.n	80244bc <MainProc+0x488>
			{
				OpenDoor(0);
 80244b0:	2000      	movs	r0, #0
 80244b2:	f001 f8c3 	bl	802563c <OpenDoor>
				MainState = MS_BLOCKAGE_OPN;
 80244b6:	4b29      	ldr	r3, [pc, #164]	; (802455c <MainProc+0x528>)
 80244b8:	220b      	movs	r2, #11
 80244ba:	601a      	str	r2, [r3, #0]
//				OpenDoor(0);
//				wait_timer = 0;
//				MainState = MS_CLOSING;
//			}

			if(CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline))// && !Open1DoorBut))
 80244bc:	4b31      	ldr	r3, [pc, #196]	; (8024584 <MainProc+0x550>)
 80244be:	681b      	ldr	r3, [r3, #0]
 80244c0:	2b00      	cmp	r3, #0
 80244c2:	d10d      	bne.n	80244e0 <MainProc+0x4ac>
 80244c4:	4b30      	ldr	r3, [pc, #192]	; (8024588 <MainProc+0x554>)
 80244c6:	681b      	ldr	r3, [r3, #0]
 80244c8:	2b00      	cmp	r3, #0
 80244ca:	d109      	bne.n	80244e0 <MainProc+0x4ac>
 80244cc:	4b1f      	ldr	r3, [pc, #124]	; (802454c <MainProc+0x518>)
 80244ce:	681b      	ldr	r3, [r3, #0]
 80244d0:	2b00      	cmp	r3, #0
 80244d2:	f040 84ae 	bne.w	8024e32 <MainProc+0xdfe>
 80244d6:	4b2d      	ldr	r3, [pc, #180]	; (802458c <MainProc+0x558>)
 80244d8:	681b      	ldr	r3, [r3, #0]
 80244da:	2b00      	cmp	r3, #0
 80244dc:	f000 84a9 	beq.w	8024e32 <MainProc+0xdfe>
			{
				OpenDoor(0);
 80244e0:	2000      	movs	r0, #0
 80244e2:	f001 f8ab 	bl	802563c <OpenDoor>
				MainState = MS_CLOSING;
 80244e6:	4b1d      	ldr	r3, [pc, #116]	; (802455c <MainProc+0x528>)
 80244e8:	2206      	movs	r2, #6
 80244ea:	601a      	str	r2, [r3, #0]
			}

		}
			break;
 80244ec:	f000 bca1 	b.w	8024e32 <MainProc+0xdfe>
		case MS_OPENED:
		{
			WriteBuzzer(BUZZER_OFF);
 80244f0:	2000      	movs	r0, #0
 80244f2:	f7fe fd2b 	bl	8022f4c <WriteBuzzer>

			WriteRubberLights(CL_GREEN, MODE_ON, 0);
 80244f6:	2200      	movs	r2, #0
 80244f8:	2101      	movs	r1, #1
 80244fa:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 80244fe:	f7fe fe4b 	bl	8023198 <WriteRubberLights>


				if(((CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline))))//&& !Open1DoorBut)))//
 8024502:	4b20      	ldr	r3, [pc, #128]	; (8024584 <MainProc+0x550>)
 8024504:	681b      	ldr	r3, [r3, #0]
 8024506:	2b00      	cmp	r3, #0
 8024508:	d10b      	bne.n	8024522 <MainProc+0x4ee>
 802450a:	4b1f      	ldr	r3, [pc, #124]	; (8024588 <MainProc+0x554>)
 802450c:	681b      	ldr	r3, [r3, #0]
 802450e:	2b00      	cmp	r3, #0
 8024510:	d107      	bne.n	8024522 <MainProc+0x4ee>
 8024512:	4b0e      	ldr	r3, [pc, #56]	; (802454c <MainProc+0x518>)
 8024514:	681b      	ldr	r3, [r3, #0]
 8024516:	2b00      	cmp	r3, #0
 8024518:	d10f      	bne.n	802453a <MainProc+0x506>
 802451a:	4b1c      	ldr	r3, [pc, #112]	; (802458c <MainProc+0x558>)
 802451c:	681b      	ldr	r3, [r3, #0]
 802451e:	2b00      	cmp	r3, #0
 8024520:	d00b      	beq.n	802453a <MainProc+0x506>
				{
					wait_timer = 0;
 8024522:	4b09      	ldr	r3, [pc, #36]	; (8024548 <MainProc+0x514>)
 8024524:	2200      	movs	r2, #0
 8024526:	601a      	str	r2, [r3, #0]
					MainState = MS_CLOSING;
 8024528:	4b0c      	ldr	r3, [pc, #48]	; (802455c <MainProc+0x528>)
 802452a:	2206      	movs	r2, #6
 802452c:	601a      	str	r2, [r3, #0]
					CloseTime = 0;
 802452e:	4b18      	ldr	r3, [pc, #96]	; (8024590 <MainProc+0x55c>)
 8024530:	2200      	movs	r2, #0
 8024532:	801a      	strh	r2, [r3, #0]
					FromCan = 0;
 8024534:	4b0a      	ldr	r3, [pc, #40]	; (8024560 <MainProc+0x52c>)
 8024536:	2200      	movs	r2, #0
 8024538:	601a      	str	r2, [r3, #0]
				}

			wait_timer++;
 802453a:	4b03      	ldr	r3, [pc, #12]	; (8024548 <MainProc+0x514>)
 802453c:	681b      	ldr	r3, [r3, #0]
 802453e:	3301      	adds	r3, #1
 8024540:	4a01      	ldr	r2, [pc, #4]	; (8024548 <MainProc+0x514>)
 8024542:	6013      	str	r3, [r2, #0]
//			{
//				MainState = MS_CLOSING;
//			}

		}
			break;
 8024544:	f000 bc8a 	b.w	8024e5c <MainProc+0xe28>
 8024548:	20000710 	.word	0x20000710
 802454c:	200006b4 	.word	0x200006b4
 8024550:	0802b370 	.word	0x0802b370
 8024554:	200006b0 	.word	0x200006b0
 8024558:	200006b8 	.word	0x200006b8
 802455c:	200006f8 	.word	0x200006f8
 8024560:	20000704 	.word	0x20000704
 8024564:	200006cc 	.word	0x200006cc
 8024568:	20000658 	.word	0x20000658
 802456c:	2000065c 	.word	0x2000065c
 8024570:	20000700 	.word	0x20000700
 8024574:	200006c4 	.word	0x200006c4
 8024578:	20000654 	.word	0x20000654
 802457c:	2000070c 	.word	0x2000070c
 8024580:	20000714 	.word	0x20000714
 8024584:	200006c0 	.word	0x200006c0
 8024588:	200006bc 	.word	0x200006bc
 802458c:	200006ac 	.word	0x200006ac
 8024590:	200006ce 	.word	0x200006ce
		case MS_OPENED_BLOCK:
		{
//			DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
//			DIGITAL_IO_SetOutputLow(&HS_SW_8);
			WriteRubberLights(CL_RED, MODE_BLINK, 500);
 8024594:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024598:	2102      	movs	r1, #2
 802459a:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 802459e:	f7fe fdfb 	bl	8023198 <WriteRubberLights>
//			WriteBuzzer(BUZZER_OFF);

			wait_timer++;
 80245a2:	4b84      	ldr	r3, [pc, #528]	; (80247b4 <MainProc+0x780>)
 80245a4:	681b      	ldr	r3, [r3, #0]
 80245a6:	3301      	adds	r3, #1
 80245a8:	4a82      	ldr	r2, [pc, #520]	; (80247b4 <MainProc+0x780>)
 80245aa:	6013      	str	r3, [r2, #0]

				if(((CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline)) && (wait_timer  >= 2) ))//(((DSC1.DoorCmd == 0x02) || (!DSC1.VelocityIsZero && ExtCanOnline)))// || (wait_timer >= 200))
 80245ac:	4b82      	ldr	r3, [pc, #520]	; (80247b8 <MainProc+0x784>)
 80245ae:	681b      	ldr	r3, [r3, #0]
 80245b0:	2b00      	cmp	r3, #0
 80245b2:	d10b      	bne.n	80245cc <MainProc+0x598>
 80245b4:	4b81      	ldr	r3, [pc, #516]	; (80247bc <MainProc+0x788>)
 80245b6:	681b      	ldr	r3, [r3, #0]
 80245b8:	2b00      	cmp	r3, #0
 80245ba:	d107      	bne.n	80245cc <MainProc+0x598>
 80245bc:	4b80      	ldr	r3, [pc, #512]	; (80247c0 <MainProc+0x78c>)
 80245be:	681b      	ldr	r3, [r3, #0]
 80245c0:	2b00      	cmp	r3, #0
 80245c2:	d113      	bne.n	80245ec <MainProc+0x5b8>
 80245c4:	4b7f      	ldr	r3, [pc, #508]	; (80247c4 <MainProc+0x790>)
 80245c6:	681b      	ldr	r3, [r3, #0]
 80245c8:	2b00      	cmp	r3, #0
 80245ca:	d00f      	beq.n	80245ec <MainProc+0x5b8>
 80245cc:	4b79      	ldr	r3, [pc, #484]	; (80247b4 <MainProc+0x780>)
 80245ce:	681b      	ldr	r3, [r3, #0]
 80245d0:	2b01      	cmp	r3, #1
 80245d2:	dd0b      	ble.n	80245ec <MainProc+0x5b8>
				{
					wait_timer = 0;
 80245d4:	4b77      	ldr	r3, [pc, #476]	; (80247b4 <MainProc+0x780>)
 80245d6:	2200      	movs	r2, #0
 80245d8:	601a      	str	r2, [r3, #0]
					MainState = MS_CLOSING;
 80245da:	4b7b      	ldr	r3, [pc, #492]	; (80247c8 <MainProc+0x794>)
 80245dc:	2206      	movs	r2, #6
 80245de:	601a      	str	r2, [r3, #0]
					CloseTime = 0;
 80245e0:	4b7a      	ldr	r3, [pc, #488]	; (80247cc <MainProc+0x798>)
 80245e2:	2200      	movs	r2, #0
 80245e4:	801a      	strh	r2, [r3, #0]
					//wait_timer = 0;
					blink = 0;
 80245e6:	4b7a      	ldr	r3, [pc, #488]	; (80247d0 <MainProc+0x79c>)
 80245e8:	2200      	movs	r2, #0
 80245ea:	601a      	str	r2, [r3, #0]
//				{
//					MainState = MS_CLOSING;
//					blink = 0;
//				}
//
				WriteBuzzer(BUZZER_ON);
 80245ec:	2001      	movs	r0, #1
 80245ee:	f7fe fcad 	bl	8022f4c <WriteBuzzer>
		}
			break;
 80245f2:	f000 bc33 	b.w	8024e5c <MainProc+0xe28>

		case MS_CLOSING:
		{
			WriteRubberLights(CL_RED, MODE_BLINK, 500);
 80245f6:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80245fa:	2102      	movs	r1, #2
 80245fc:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024600:	f7fe fdca 	bl	8023198 <WriteRubberLights>
			CloseTime++;
 8024604:	4b71      	ldr	r3, [pc, #452]	; (80247cc <MainProc+0x798>)
 8024606:	881b      	ldrh	r3, [r3, #0]
 8024608:	3301      	adds	r3, #1
 802460a:	b29a      	uxth	r2, r3
 802460c:	4b6f      	ldr	r3, [pc, #444]	; (80247cc <MainProc+0x798>)
 802460e:	801a      	strh	r2, [r3, #0]
			temp = CloseDoor(1);
 8024610:	2001      	movs	r0, #1
 8024612:	f000 feed 	bl	80253f0 <CloseDoor>
 8024616:	60f8      	str	r0, [r7, #12]
			if (temp == 1) //
 8024618:	68fb      	ldr	r3, [r7, #12]
 802461a:	2b01      	cmp	r3, #1
 802461c:	d108      	bne.n	8024630 <MainProc+0x5fc>
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
				MainState = MS_CLOSED;
 802461e:	4b6a      	ldr	r3, [pc, #424]	; (80247c8 <MainProc+0x794>)
 8024620:	2203      	movs	r2, #3
 8024622:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 8024624:	4b63      	ldr	r3, [pc, #396]	; (80247b4 <MainProc+0x780>)
 8024626:	2200      	movs	r2, #0
 8024628:	601a      	str	r2, [r3, #0]
				blink = 0;
 802462a:	4b69      	ldr	r3, [pc, #420]	; (80247d0 <MainProc+0x79c>)
 802462c:	2200      	movs	r2, #0
 802462e:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024630:	68fb      	ldr	r3, [r7, #12]
 8024632:	2b00      	cmp	r3, #0
 8024634:	d102      	bne.n	802463c <MainProc+0x608>
			{
				WriteBuzzer(BUZZER_ON);
 8024636:	2001      	movs	r0, #1
 8024638:	f7fe fc88 	bl	8022f4c <WriteBuzzer>
			}
			if (temp == -1)
 802463c:	68fb      	ldr	r3, [r7, #12]
 802463e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024642:	d105      	bne.n	8024650 <MainProc+0x61c>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024644:	4b60      	ldr	r3, [pc, #384]	; (80247c8 <MainProc+0x794>)
 8024646:	2215      	movs	r2, #21
 8024648:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 802464a:	2000      	movs	r0, #0
 802464c:	f000 fed0 	bl	80253f0 <CloseDoor>
			}
			if (temp == -2)
 8024650:	68fb      	ldr	r3, [r7, #12]
 8024652:	f113 0f02 	cmn.w	r3, #2
 8024656:	d105      	bne.n	8024664 <MainProc+0x630>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024658:	4b5b      	ldr	r3, [pc, #364]	; (80247c8 <MainProc+0x794>)
 802465a:	2216      	movs	r2, #22
 802465c:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 802465e:	2000      	movs	r0, #0
 8024660:	f000 fec6 	bl	80253f0 <CloseDoor>
			}
			if (temp == -3)
 8024664:	68fb      	ldr	r3, [r7, #12]
 8024666:	f113 0f03 	cmn.w	r3, #3
 802466a:	d105      	bne.n	8024678 <MainProc+0x644>
			{
				MainState = MS_ERROR_BAD_STATE;
 802466c:	4b56      	ldr	r3, [pc, #344]	; (80247c8 <MainProc+0x794>)
 802466e:	2217      	movs	r2, #23
 8024670:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024672:	2000      	movs	r0, #0
 8024674:	f000 febc 	bl	80253f0 <CloseDoor>
			}
			if(-4 == temp)
 8024678:	68fb      	ldr	r3, [r7, #12]
 802467a:	f113 0f04 	cmn.w	r3, #4
 802467e:	d105      	bne.n	802468c <MainProc+0x658>
			{
				CloseDoor(0);
 8024680:	2000      	movs	r0, #0
 8024682:	f000 feb5 	bl	80253f0 <CloseDoor>
				MainState = MS_BLOCKAGE_CLS;
 8024686:	4b50      	ldr	r3, [pc, #320]	; (80247c8 <MainProc+0x794>)
 8024688:	220a      	movs	r2, #10
 802468a:	601a      	str	r2, [r3, #0]
			}

			if(((CanCmdOpenCmd) && (CanCmdOpenEnable)) && CanCmdUnlock)
 802468c:	4b51      	ldr	r3, [pc, #324]	; (80247d4 <MainProc+0x7a0>)
 802468e:	681b      	ldr	r3, [r3, #0]
 8024690:	2b00      	cmp	r3, #0
 8024692:	f000 83d0 	beq.w	8024e36 <MainProc+0xe02>
 8024696:	4b50      	ldr	r3, [pc, #320]	; (80247d8 <MainProc+0x7a4>)
 8024698:	681b      	ldr	r3, [r3, #0]
 802469a:	2b00      	cmp	r3, #0
 802469c:	f000 83cb 	beq.w	8024e36 <MainProc+0xe02>
 80246a0:	4b47      	ldr	r3, [pc, #284]	; (80247c0 <MainProc+0x78c>)
 80246a2:	681b      	ldr	r3, [r3, #0]
 80246a4:	2b00      	cmp	r3, #0
 80246a6:	f000 83c6 	beq.w	8024e36 <MainProc+0xe02>
			{
				CloseDoor(0);
 80246aa:	2000      	movs	r0, #0
 80246ac:	f000 fea0 	bl	80253f0 <CloseDoor>
				MainState = MS_OPENING;
 80246b0:	4b45      	ldr	r3, [pc, #276]	; (80247c8 <MainProc+0x794>)
 80246b2:	2204      	movs	r2, #4
 80246b4:	601a      	str	r2, [r3, #0]
//				MainState = MS_OPENING;
//			}


		}
			break;
 80246b6:	e3be      	b.n	8024e36 <MainProc+0xe02>

		case MS_BLOCKAGE_CLS:
		{
//			DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
//			DIGITAL_IO_SetOutputLow(&HS_SW_8);
			wait_timer++;
 80246b8:	4b3e      	ldr	r3, [pc, #248]	; (80247b4 <MainProc+0x780>)
 80246ba:	681b      	ldr	r3, [r3, #0]
 80246bc:	3301      	adds	r3, #1
 80246be:	4a3d      	ldr	r2, [pc, #244]	; (80247b4 <MainProc+0x780>)
 80246c0:	6013      	str	r3, [r2, #0]
			pause++;
 80246c2:	4b46      	ldr	r3, [pc, #280]	; (80247dc <MainProc+0x7a8>)
 80246c4:	681b      	ldr	r3, [r3, #0]
 80246c6:	3301      	adds	r3, #1
 80246c8:	4a44      	ldr	r2, [pc, #272]	; (80247dc <MainProc+0x7a8>)
 80246ca:	6013      	str	r3, [r2, #0]
			if (pause >= 50)
 80246cc:	4b43      	ldr	r3, [pc, #268]	; (80247dc <MainProc+0x7a8>)
 80246ce:	681b      	ldr	r3, [r3, #0]
 80246d0:	2b31      	cmp	r3, #49	; 0x31
 80246d2:	dd6b      	ble.n	80247ac <MainProc+0x778>
			{
				temp = OpenAfterBlockage(1);
 80246d4:	2001      	movs	r0, #1
 80246d6:	f001 f9e7 	bl	8025aa8 <OpenAfterBlockage>
 80246da:	60f8      	str	r0, [r7, #12]
				WriteRubberLights(CL_RED, MODE_BLINK, 500);
 80246dc:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80246e0:	2102      	movs	r1, #2
 80246e2:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 80246e6:	f7fe fd57 	bl	8023198 <WriteRubberLights>
				if (temp == 1)
 80246ea:	68fb      	ldr	r3, [r7, #12]
 80246ec:	2b01      	cmp	r3, #1
 80246ee:	d108      	bne.n	8024702 <MainProc+0x6ce>
				{
					MainState = MS_OPENED_BLOCK;
 80246f0:	4b35      	ldr	r3, [pc, #212]	; (80247c8 <MainProc+0x794>)
 80246f2:	2207      	movs	r2, #7
 80246f4:	601a      	str	r2, [r3, #0]
					pause = 0;
 80246f6:	4b39      	ldr	r3, [pc, #228]	; (80247dc <MainProc+0x7a8>)
 80246f8:	2200      	movs	r2, #0
 80246fa:	601a      	str	r2, [r3, #0]
					//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
					//DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
					blink = 0;
 80246fc:	4b34      	ldr	r3, [pc, #208]	; (80247d0 <MainProc+0x79c>)
 80246fe:	2200      	movs	r2, #0
 8024700:	601a      	str	r2, [r3, #0]
				}
				if (temp == 0)
 8024702:	68fb      	ldr	r3, [r7, #12]
 8024704:	2b00      	cmp	r3, #0
 8024706:	d102      	bne.n	802470e <MainProc+0x6da>
				{
					WriteBuzzer(BUZZER_ON);
 8024708:	2001      	movs	r0, #1
 802470a:	f7fe fc1f 	bl	8022f4c <WriteBuzzer>
				}
				if (temp == -1)
 802470e:	68fb      	ldr	r3, [r7, #12]
 8024710:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024714:	d108      	bne.n	8024728 <MainProc+0x6f4>
				{
					pause = 0;
 8024716:	4b31      	ldr	r3, [pc, #196]	; (80247dc <MainProc+0x7a8>)
 8024718:	2200      	movs	r2, #0
 802471a:	601a      	str	r2, [r3, #0]
					MainState = MS_ERROR_MOV_TIMEOUT;
 802471c:	4b2a      	ldr	r3, [pc, #168]	; (80247c8 <MainProc+0x794>)
 802471e:	2215      	movs	r2, #21
 8024720:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 8024722:	2000      	movs	r0, #0
 8024724:	f001 f9c0 	bl	8025aa8 <OpenAfterBlockage>
				}
				if (temp == -2)
 8024728:	68fb      	ldr	r3, [r7, #12]
 802472a:	f113 0f02 	cmn.w	r3, #2
 802472e:	d108      	bne.n	8024742 <MainProc+0x70e>
				{
					pause = 0;
 8024730:	4b2a      	ldr	r3, [pc, #168]	; (80247dc <MainProc+0x7a8>)
 8024732:	2200      	movs	r2, #0
 8024734:	601a      	str	r2, [r3, #0]
					MainState = MS_ERROR_MAX_CURRENT;
 8024736:	4b24      	ldr	r3, [pc, #144]	; (80247c8 <MainProc+0x794>)
 8024738:	2216      	movs	r2, #22
 802473a:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 802473c:	2000      	movs	r0, #0
 802473e:	f001 f9b3 	bl	8025aa8 <OpenAfterBlockage>
				}
				if (temp == -3)
 8024742:	68fb      	ldr	r3, [r7, #12]
 8024744:	f113 0f03 	cmn.w	r3, #3
 8024748:	d108      	bne.n	802475c <MainProc+0x728>
				{
					pause = 0;
 802474a:	4b24      	ldr	r3, [pc, #144]	; (80247dc <MainProc+0x7a8>)
 802474c:	2200      	movs	r2, #0
 802474e:	601a      	str	r2, [r3, #0]
					MainState = MS_ERROR_BAD_STATE;
 8024750:	4b1d      	ldr	r3, [pc, #116]	; (80247c8 <MainProc+0x794>)
 8024752:	2217      	movs	r2, #23
 8024754:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 8024756:	2000      	movs	r0, #0
 8024758:	f001 f9a6 	bl	8025aa8 <OpenAfterBlockage>
				}
				if(-4 == temp)
 802475c:	68fb      	ldr	r3, [r7, #12]
 802475e:	f113 0f04 	cmn.w	r3, #4
 8024762:	d108      	bne.n	8024776 <MainProc+0x742>
				{
					pause = 0;
 8024764:	4b1d      	ldr	r3, [pc, #116]	; (80247dc <MainProc+0x7a8>)
 8024766:	2200      	movs	r2, #0
 8024768:	601a      	str	r2, [r3, #0]
					OpenAfterBlockage(0);
 802476a:	2000      	movs	r0, #0
 802476c:	f001 f99c 	bl	8025aa8 <OpenAfterBlockage>
					MainState = MS_BLOCKAGE_OPN;
 8024770:	4b15      	ldr	r3, [pc, #84]	; (80247c8 <MainProc+0x794>)
 8024772:	220b      	movs	r2, #11
 8024774:	601a      	str	r2, [r3, #0]
				}
 //maybe off
				if((CanCmdCloseAll || CanCmdCloseCmd && (pause >= 150))|| (!CanCmdUnlock))
 8024776:	4b10      	ldr	r3, [pc, #64]	; (80247b8 <MainProc+0x784>)
 8024778:	681b      	ldr	r3, [r3, #0]
 802477a:	2b00      	cmp	r3, #0
 802477c:	d10c      	bne.n	8024798 <MainProc+0x764>
 802477e:	4b0f      	ldr	r3, [pc, #60]	; (80247bc <MainProc+0x788>)
 8024780:	681b      	ldr	r3, [r3, #0]
 8024782:	2b00      	cmp	r3, #0
 8024784:	d003      	beq.n	802478e <MainProc+0x75a>
 8024786:	4b15      	ldr	r3, [pc, #84]	; (80247dc <MainProc+0x7a8>)
 8024788:	681b      	ldr	r3, [r3, #0]
 802478a:	2b95      	cmp	r3, #149	; 0x95
 802478c:	dc04      	bgt.n	8024798 <MainProc+0x764>
 802478e:	4b0c      	ldr	r3, [pc, #48]	; (80247c0 <MainProc+0x78c>)
 8024790:	681b      	ldr	r3, [r3, #0]
 8024792:	2b00      	cmp	r3, #0
 8024794:	f040 8351 	bne.w	8024e3a <MainProc+0xe06>
				{
					OpenAfterBlockage(0);
 8024798:	2000      	movs	r0, #0
 802479a:	f001 f985 	bl	8025aa8 <OpenAfterBlockage>
					MainState = MS_CLOSING;
 802479e:	4b0a      	ldr	r3, [pc, #40]	; (80247c8 <MainProc+0x794>)
 80247a0:	2206      	movs	r2, #6
 80247a2:	601a      	str	r2, [r3, #0]
					pause = 0;
 80247a4:	4b0d      	ldr	r3, [pc, #52]	; (80247dc <MainProc+0x7a8>)
 80247a6:	2200      	movs	r2, #0
 80247a8:	601a      	str	r2, [r3, #0]
			{
				MotorStop();
				//WriteRubberLights(CL_YELLOW, MODE_ON, 100);
			}
		}
			break;
 80247aa:	e346      	b.n	8024e3a <MainProc+0xe06>
				MotorStop();
 80247ac:	f7fe fa4a 	bl	8022c44 <MotorStop>
			break;
 80247b0:	e343      	b.n	8024e3a <MainProc+0xe06>
 80247b2:	bf00      	nop
 80247b4:	20000710 	.word	0x20000710
 80247b8:	200006c0 	.word	0x200006c0
 80247bc:	200006bc 	.word	0x200006bc
 80247c0:	200006b4 	.word	0x200006b4
 80247c4:	200006ac 	.word	0x200006ac
 80247c8:	200006f8 	.word	0x200006f8
 80247cc:	200006ce 	.word	0x200006ce
 80247d0:	20000714 	.word	0x20000714
 80247d4:	200006b8 	.word	0x200006b8
 80247d8:	200006b0 	.word	0x200006b0
 80247dc:	20000718 	.word	0x20000718

		case MS_BLOCKAGE_OPN:
		{
			wait_timer ++;
 80247e0:	4b93      	ldr	r3, [pc, #588]	; (8024a30 <MainProc+0x9fc>)
 80247e2:	681b      	ldr	r3, [r3, #0]
 80247e4:	3301      	adds	r3, #1
 80247e6:	4a92      	ldr	r2, [pc, #584]	; (8024a30 <MainProc+0x9fc>)
 80247e8:	6013      	str	r3, [r2, #0]

			MotorStop();
 80247ea:	f7fe fa2b 	bl	8022c44 <MotorStop>
			WriteBuzzer(BUZZER_OFF);
 80247ee:	2000      	movs	r0, #0
 80247f0:	f7fe fbac 	bl	8022f4c <WriteBuzzer>

			WriteRubberLights(CL_GREEN, MODE_ON, 100);
 80247f4:	2264      	movs	r2, #100	; 0x64
 80247f6:	2101      	movs	r1, #1
 80247f8:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 80247fc:	f7fe fccc 	bl	8023198 <WriteRubberLights>

			if((CanCmdCloseAll || CanCmdCloseCmd || !CanCmdUnlock) && !TrapSensor )//if((DSC1.DoorCmd == 0x02) || (!DSC1.VelocityIsZero && ExtCanOnline))
 8024800:	4b8c      	ldr	r3, [pc, #560]	; (8024a34 <MainProc+0xa00>)
 8024802:	681b      	ldr	r3, [r3, #0]
 8024804:	2b00      	cmp	r3, #0
 8024806:	d107      	bne.n	8024818 <MainProc+0x7e4>
 8024808:	4b8b      	ldr	r3, [pc, #556]	; (8024a38 <MainProc+0xa04>)
 802480a:	681b      	ldr	r3, [r3, #0]
 802480c:	2b00      	cmp	r3, #0
 802480e:	d103      	bne.n	8024818 <MainProc+0x7e4>
 8024810:	4b8a      	ldr	r3, [pc, #552]	; (8024a3c <MainProc+0xa08>)
 8024812:	681b      	ldr	r3, [r3, #0]
 8024814:	2b00      	cmp	r3, #0
 8024816:	d109      	bne.n	802482c <MainProc+0x7f8>
 8024818:	4b89      	ldr	r3, [pc, #548]	; (8024a40 <MainProc+0xa0c>)
 802481a:	681b      	ldr	r3, [r3, #0]
 802481c:	2b00      	cmp	r3, #0
 802481e:	d105      	bne.n	802482c <MainProc+0x7f8>
			{
				//Motor0_BLDC_SCALAR_ClearErrorState();
				MainState = MS_CLOSING;
 8024820:	4b88      	ldr	r3, [pc, #544]	; (8024a44 <MainProc+0xa10>)
 8024822:	2206      	movs	r2, #6
 8024824:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 8024826:	4b82      	ldr	r3, [pc, #520]	; (8024a30 <MainProc+0x9fc>)
 8024828:	2200      	movs	r2, #0
 802482a:	601a      	str	r2, [r3, #0]
//				MainState = MS_CLOSING;
//				wait_timer = 0;
//			}


			if((CanCmdOpenCmd) && CanCmdOpenEnable)
 802482c:	4b86      	ldr	r3, [pc, #536]	; (8024a48 <MainProc+0xa14>)
 802482e:	681b      	ldr	r3, [r3, #0]
 8024830:	2b00      	cmp	r3, #0
 8024832:	f000 8304 	beq.w	8024e3e <MainProc+0xe0a>
 8024836:	4b85      	ldr	r3, [pc, #532]	; (8024a4c <MainProc+0xa18>)
 8024838:	681b      	ldr	r3, [r3, #0]
 802483a:	2b00      	cmp	r3, #0
 802483c:	f000 82ff 	beq.w	8024e3e <MainProc+0xe0a>
			{
				//Motor0_BLDC_SCALAR_ClearErrorState();
				MainState = MS_OPENING;
 8024840:	4b80      	ldr	r3, [pc, #512]	; (8024a44 <MainProc+0xa10>)
 8024842:	2204      	movs	r2, #4
 8024844:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 8024846:	4b7a      	ldr	r3, [pc, #488]	; (8024a30 <MainProc+0x9fc>)
 8024848:	2200      	movs	r2, #0
 802484a:	601a      	str	r2, [r3, #0]
			}
		}
			break;
 802484c:	e2f7      	b.n	8024e3e <MainProc+0xe0a>


		default: // now it is error handler, todo: different errors
		{
//			blink++;
			wait_timer++;
 802484e:	4b78      	ldr	r3, [pc, #480]	; (8024a30 <MainProc+0x9fc>)
 8024850:	681b      	ldr	r3, [r3, #0]
 8024852:	3301      	adds	r3, #1
 8024854:	4a76      	ldr	r2, [pc, #472]	; (8024a30 <MainProc+0x9fc>)
 8024856:	6013      	str	r3, [r2, #0]
			WriteBuzzer(BUZZER_OFF);
 8024858:	2000      	movs	r0, #0
 802485a:	f7fe fb77 	bl	8022f4c <WriteBuzzer>

			MotorStop();
 802485e:	f7fe f9f1 	bl	8022c44 <MotorStop>
//			WritePassengerButton(CMD_OFF);
//			WriteClutch(CLUTCH_LOCK);
			//DIGITAL_IO_SetOutputLow(&HS_SW_1);
			//DIGITAL_ IO_SetOutputLow(&HS_SW_2);
			WriteRubberLights(CL_RED, MODE_BLINK, 200);
 8024862:	22c8      	movs	r2, #200	; 0xc8
 8024864:	2102      	movs	r1, #2
 8024866:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 802486a:	f7fe fc95 	bl	8023198 <WriteRubberLights>
//				MainState = MS_CLOSING;
//				wait_timer = 0;
//			}
//

			if((CanCmdCloseAll || CanCmdCloseCmd || (!CanCmdUnlock && ExtCanOnline)))
 802486e:	4b71      	ldr	r3, [pc, #452]	; (8024a34 <MainProc+0xa00>)
 8024870:	681b      	ldr	r3, [r3, #0]
 8024872:	2b00      	cmp	r3, #0
 8024874:	d10b      	bne.n	802488e <MainProc+0x85a>
 8024876:	4b70      	ldr	r3, [pc, #448]	; (8024a38 <MainProc+0xa04>)
 8024878:	681b      	ldr	r3, [r3, #0]
 802487a:	2b00      	cmp	r3, #0
 802487c:	d107      	bne.n	802488e <MainProc+0x85a>
 802487e:	4b6f      	ldr	r3, [pc, #444]	; (8024a3c <MainProc+0xa08>)
 8024880:	681b      	ldr	r3, [r3, #0]
 8024882:	2b00      	cmp	r3, #0
 8024884:	d106      	bne.n	8024894 <MainProc+0x860>
 8024886:	4b72      	ldr	r3, [pc, #456]	; (8024a50 <MainProc+0xa1c>)
 8024888:	681b      	ldr	r3, [r3, #0]
 802488a:	2b00      	cmp	r3, #0
 802488c:	d002      	beq.n	8024894 <MainProc+0x860>
			{
				MainState = MS_CLOSING;
 802488e:	4b6d      	ldr	r3, [pc, #436]	; (8024a44 <MainProc+0xa10>)
 8024890:	2206      	movs	r2, #6
 8024892:	601a      	str	r2, [r3, #0]
			}
			if((CanCmdOpenCmd) && CanCmdOpenEnable)
 8024894:	4b6c      	ldr	r3, [pc, #432]	; (8024a48 <MainProc+0xa14>)
 8024896:	681b      	ldr	r3, [r3, #0]
 8024898:	2b00      	cmp	r3, #0
 802489a:	f000 82d2 	beq.w	8024e42 <MainProc+0xe0e>
 802489e:	4b6b      	ldr	r3, [pc, #428]	; (8024a4c <MainProc+0xa18>)
 80248a0:	681b      	ldr	r3, [r3, #0]
 80248a2:	2b00      	cmp	r3, #0
 80248a4:	f000 82cd 	beq.w	8024e42 <MainProc+0xe0e>
			{
				MainState = MS_OPENING;
 80248a8:	4b66      	ldr	r3, [pc, #408]	; (8024a44 <MainProc+0xa10>)
 80248aa:	2204      	movs	r2, #4
 80248ac:	601a      	str	r2, [r3, #0]
				blink = 0;
 80248ae:	4b69      	ldr	r3, [pc, #420]	; (8024a54 <MainProc+0xa20>)
 80248b0:	2200      	movs	r2, #0
 80248b2:	601a      	str	r2, [r3, #0]
				DIGITAL_IO_SetOutputLow(&STATUS_LED_R);
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
			}*/
			//DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
		}
		break;
 80248b4:	e2c5      	b.n	8024e42 <MainProc+0xe0e>
	}
}
else
{
	if(ServiceButtonFront)
 80248b6:	4b68      	ldr	r3, [pc, #416]	; (8024a58 <MainProc+0xa24>)
 80248b8:	681b      	ldr	r3, [r3, #0]
 80248ba:	2b00      	cmp	r3, #0
 80248bc:	d00b      	beq.n	80248d6 <MainProc+0x8a2>
	{
		ClutchControl = 1;
 80248be:	4b67      	ldr	r3, [pc, #412]	; (8024a5c <MainProc+0xa28>)
 80248c0:	2201      	movs	r2, #1
 80248c2:	601a      	str	r2, [r3, #0]
		MainState = 0;
 80248c4:	4b5f      	ldr	r3, [pc, #380]	; (8024a44 <MainProc+0xa10>)
 80248c6:	2200      	movs	r2, #0
 80248c8:	601a      	str	r2, [r3, #0]
		//Motor0_BLDC_SCALAR_MotorStop();
		WritePassengerButton(CMD_OFF);
 80248ca:	2000      	movs	r0, #0
 80248cc:	f7ff f850 	bl	8023970 <WritePassengerButton>
		wait_timer = 0;
 80248d0:	4b57      	ldr	r3, [pc, #348]	; (8024a30 <MainProc+0x9fc>)
 80248d2:	2200      	movs	r2, #0
 80248d4:	601a      	str	r2, [r3, #0]
	}
	if(PassengerButton || (Inputs.IO & 0x0004))
 80248d6:	4b62      	ldr	r3, [pc, #392]	; (8024a60 <MainProc+0xa2c>)
 80248d8:	681b      	ldr	r3, [r3, #0]
 80248da:	2b00      	cmp	r3, #0
 80248dc:	d105      	bne.n	80248ea <MainProc+0x8b6>
 80248de:	4b61      	ldr	r3, [pc, #388]	; (8024a64 <MainProc+0xa30>)
 80248e0:	889b      	ldrh	r3, [r3, #4]
 80248e2:	f003 0304 	and.w	r3, r3, #4
 80248e6:	2b00      	cmp	r3, #0
 80248e8:	d008      	beq.n	80248fc <MainProc+0x8c8>
	{
		ClutchControl = 0;
 80248ea:	4b5c      	ldr	r3, [pc, #368]	; (8024a5c <MainProc+0xa28>)
 80248ec:	2200      	movs	r2, #0
 80248ee:	601a      	str	r2, [r3, #0]
		ClutchGo = 0;
 80248f0:	4b5d      	ldr	r3, [pc, #372]	; (8024a68 <MainProc+0xa34>)
 80248f2:	2200      	movs	r2, #0
 80248f4:	601a      	str	r2, [r3, #0]
		WritePassengerButton(CMD_ON);
 80248f6:	2001      	movs	r0, #1
 80248f8:	f7ff f83a 	bl	8023970 <WritePassengerButton>
	}

	if(ClutchControl)
 80248fc:	4b57      	ldr	r3, [pc, #348]	; (8024a5c <MainProc+0xa28>)
 80248fe:	681b      	ldr	r3, [r3, #0]
 8024900:	2b00      	cmp	r3, #0
 8024902:	d04e      	beq.n	80249a2 <MainProc+0x96e>
	{
		switch (ClutchGo)
 8024904:	4b58      	ldr	r3, [pc, #352]	; (8024a68 <MainProc+0xa34>)
 8024906:	681b      	ldr	r3, [r3, #0]
 8024908:	2b04      	cmp	r3, #4
 802490a:	d851      	bhi.n	80249b0 <MainProc+0x97c>
 802490c:	a201      	add	r2, pc, #4	; (adr r2, 8024914 <MainProc+0x8e0>)
 802490e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8024912:	bf00      	nop
 8024914:	08024929 	.word	0x08024929
 8024918:	08024935 	.word	0x08024935
 802491c:	0802494f 	.word	0x0802494f
 8024920:	08024973 	.word	0x08024973
 8024924:	0802498d 	.word	0x0802498d
		{
			case 0:
			{
				ClutchGo++;
 8024928:	4b4f      	ldr	r3, [pc, #316]	; (8024a68 <MainProc+0xa34>)
 802492a:	681b      	ldr	r3, [r3, #0]
 802492c:	3301      	adds	r3, #1
 802492e:	4a4e      	ldr	r2, [pc, #312]	; (8024a68 <MainProc+0xa34>)
 8024930:	6013      	str	r3, [r2, #0]
			}
			break;
 8024932:	e03d      	b.n	80249b0 <MainProc+0x97c>
			case 1:
			{
				if(ServiceButtonFront)
 8024934:	4b48      	ldr	r3, [pc, #288]	; (8024a58 <MainProc+0xa24>)
 8024936:	681b      	ldr	r3, [r3, #0]
 8024938:	2b00      	cmp	r3, #0
 802493a:	d004      	beq.n	8024946 <MainProc+0x912>
				{
					ClutchGo++;
 802493c:	4b4a      	ldr	r3, [pc, #296]	; (8024a68 <MainProc+0xa34>)
 802493e:	681b      	ldr	r3, [r3, #0]
 8024940:	3301      	adds	r3, #1
 8024942:	4a49      	ldr	r2, [pc, #292]	; (8024a68 <MainProc+0xa34>)
 8024944:	6013      	str	r3, [r2, #0]
				}
				WriteBuzzer(BUZZER_OFF);
 8024946:	2000      	movs	r0, #0
 8024948:	f7fe fb00 	bl	8022f4c <WriteBuzzer>
			}
			break;
 802494c:	e030      	b.n	80249b0 <MainProc+0x97c>
			case 2:
			{
				pause++;
 802494e:	4b47      	ldr	r3, [pc, #284]	; (8024a6c <MainProc+0xa38>)
 8024950:	681b      	ldr	r3, [r3, #0]
 8024952:	3301      	adds	r3, #1
 8024954:	4a45      	ldr	r2, [pc, #276]	; (8024a6c <MainProc+0xa38>)
 8024956:	6013      	str	r3, [r2, #0]
//				DIGITAL_IO_SetOutputHigh(&HS_SW_1);
//				DIGITAL_IO_SetOutputHigh(&HS_SW_2);

				if (pause >= 1)
 8024958:	4b44      	ldr	r3, [pc, #272]	; (8024a6c <MainProc+0xa38>)
 802495a:	681b      	ldr	r3, [r3, #0]
 802495c:	2b00      	cmp	r3, #0
 802495e:	dd22      	ble.n	80249a6 <MainProc+0x972>
				{
					ClutchGo++;
 8024960:	4b41      	ldr	r3, [pc, #260]	; (8024a68 <MainProc+0xa34>)
 8024962:	681b      	ldr	r3, [r3, #0]
 8024964:	3301      	adds	r3, #1
 8024966:	4a40      	ldr	r2, [pc, #256]	; (8024a68 <MainProc+0xa34>)
 8024968:	6013      	str	r3, [r2, #0]
					pause = 0;
 802496a:	4b40      	ldr	r3, [pc, #256]	; (8024a6c <MainProc+0xa38>)
 802496c:	2200      	movs	r2, #0
 802496e:	601a      	str	r2, [r3, #0]
				}
			}
			break;
 8024970:	e019      	b.n	80249a6 <MainProc+0x972>
			case 3:
			{
				WriteClutch(CLUTCH_UNLOCK);
 8024972:	2001      	movs	r0, #1
 8024974:	f7fe ffa2 	bl	80238bc <WriteClutch>
				//WriteBuzzer(BUZZER_ON);
				if(ServiceButtonFront)
 8024978:	4b37      	ldr	r3, [pc, #220]	; (8024a58 <MainProc+0xa24>)
 802497a:	681b      	ldr	r3, [r3, #0]
 802497c:	2b00      	cmp	r3, #0
 802497e:	d014      	beq.n	80249aa <MainProc+0x976>
				{
					ClutchGo++;
 8024980:	4b39      	ldr	r3, [pc, #228]	; (8024a68 <MainProc+0xa34>)
 8024982:	681b      	ldr	r3, [r3, #0]
 8024984:	3301      	adds	r3, #1
 8024986:	4a38      	ldr	r2, [pc, #224]	; (8024a68 <MainProc+0xa34>)
 8024988:	6013      	str	r3, [r2, #0]
				}
			}
			break;
 802498a:	e00e      	b.n	80249aa <MainProc+0x976>
			case 4:
			{
				WriteClutch(CLUTCH_LOCK);
 802498c:	2000      	movs	r0, #0
 802498e:	f7fe ff95 	bl	80238bc <WriteClutch>
				//WriteBuzzer(BUZZER_OFF);
				if(ServiceButtonFront)
 8024992:	4b31      	ldr	r3, [pc, #196]	; (8024a58 <MainProc+0xa24>)
 8024994:	681b      	ldr	r3, [r3, #0]
 8024996:	2b00      	cmp	r3, #0
 8024998:	d009      	beq.n	80249ae <MainProc+0x97a>
				{
					ClutchGo = 2;
 802499a:	4b33      	ldr	r3, [pc, #204]	; (8024a68 <MainProc+0xa34>)
 802499c:	2202      	movs	r2, #2
 802499e:	601a      	str	r2, [r3, #0]
				}
			}
			break;
 80249a0:	e005      	b.n	80249ae <MainProc+0x97a>
		}
	}
 80249a2:	bf00      	nop
 80249a4:	e004      	b.n	80249b0 <MainProc+0x97c>
			break;
 80249a6:	bf00      	nop
 80249a8:	e002      	b.n	80249b0 <MainProc+0x97c>
			break;
 80249aa:	bf00      	nop
 80249ac:	e000      	b.n	80249b0 <MainProc+0x97c>
			break;
 80249ae:	bf00      	nop


if(!ClutchControl)
 80249b0:	4b2a      	ldr	r3, [pc, #168]	; (8024a5c <MainProc+0xa28>)
 80249b2:	681b      	ldr	r3, [r3, #0]
 80249b4:	2b00      	cmp	r3, #0
 80249b6:	f040 8246 	bne.w	8024e46 <MainProc+0xe12>
{
	WritePassengerButton(CMD_ON);
 80249ba:	2001      	movs	r0, #1
 80249bc:	f7fe ffd8 	bl	8023970 <WritePassengerButton>

	switch (MainState)
 80249c0:	4b20      	ldr	r3, [pc, #128]	; (8024a44 <MainProc+0xa10>)
 80249c2:	681b      	ldr	r3, [r3, #0]
 80249c4:	2b06      	cmp	r3, #6
 80249c6:	f200 820f 	bhi.w	8024de8 <MainProc+0xdb4>
 80249ca:	a201      	add	r2, pc, #4	; (adr r2, 80249d0 <MainProc+0x99c>)
 80249cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80249d0:	080249ed 	.word	0x080249ed
 80249d4:	08024a75 	.word	0x08024a75
 80249d8:	08024ab5 	.word	0x08024ab5
 80249dc:	08024b75 	.word	0x08024b75
 80249e0:	08024bdf 	.word	0x08024bdf
 80249e4:	08024c9d 	.word	0x08024c9d
 80249e8:	08024d2d 	.word	0x08024d2d
	{
		case MS_START:
		{
			wait_timer++;
 80249ec:	4b10      	ldr	r3, [pc, #64]	; (8024a30 <MainProc+0x9fc>)
 80249ee:	681b      	ldr	r3, [r3, #0]
 80249f0:	3301      	adds	r3, #1
 80249f2:	4a0f      	ldr	r2, [pc, #60]	; (8024a30 <MainProc+0x9fc>)
 80249f4:	6013      	str	r3, [r2, #0]
			if(wait_timer >= Presets.STARTUP_TIME)
 80249f6:	4b1e      	ldr	r3, [pc, #120]	; (8024a70 <MainProc+0xa3c>)
 80249f8:	69db      	ldr	r3, [r3, #28]
 80249fa:	4a0d      	ldr	r2, [pc, #52]	; (8024a30 <MainProc+0x9fc>)
 80249fc:	6812      	ldr	r2, [r2, #0]
 80249fe:	4293      	cmp	r3, r2
 8024a00:	d806      	bhi.n	8024a10 <MainProc+0x9dc>
			{
				wait_timer = 0;
 8024a02:	4b0b      	ldr	r3, [pc, #44]	; (8024a30 <MainProc+0x9fc>)
 8024a04:	2200      	movs	r2, #0
 8024a06:	601a      	str	r2, [r3, #0]
				//	Motor0_BLDC_SCALAR_ClearErrorState();
				//	DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
				//}
				//else
				//{
					MainState = MS_UNKNOWN;
 8024a08:	4b0e      	ldr	r3, [pc, #56]	; (8024a44 <MainProc+0xa10>)
 8024a0a:	2201      	movs	r2, #1
 8024a0c:	601a      	str	r2, [r3, #0]
				Homing(0);
				//Motor0_BLDC_SCALAR_ClearErrorState();
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
			}
		}
			break;
 8024a0e:	e225      	b.n	8024e5c <MainProc+0xe28>
				OpenDoor(0);
 8024a10:	2000      	movs	r0, #0
 8024a12:	f000 fe13 	bl	802563c <OpenDoor>
				CloseDoor(0);
 8024a16:	2000      	movs	r0, #0
 8024a18:	f000 fcea 	bl	80253f0 <CloseDoor>
				Homing(0);
 8024a1c:	2000      	movs	r0, #0
 8024a1e:	f000 fb63 	bl	80250e8 <Homing>
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
 8024a22:	2200      	movs	r2, #0
 8024a24:	2100      	movs	r1, #0
 8024a26:	2000      	movs	r0, #0
 8024a28:	f7fe fbb6 	bl	8023198 <WriteRubberLights>
			break;
 8024a2c:	e216      	b.n	8024e5c <MainProc+0xe28>
 8024a2e:	bf00      	nop
 8024a30:	20000710 	.word	0x20000710
 8024a34:	200006c0 	.word	0x200006c0
 8024a38:	200006bc 	.word	0x200006bc
 8024a3c:	200006b4 	.word	0x200006b4
 8024a40:	2000066c 	.word	0x2000066c
 8024a44:	200006f8 	.word	0x200006f8
 8024a48:	200006b8 	.word	0x200006b8
 8024a4c:	200006b0 	.word	0x200006b0
 8024a50:	200006ac 	.word	0x200006ac
 8024a54:	20000714 	.word	0x20000714
 8024a58:	20000664 	.word	0x20000664
 8024a5c:	2000071c 	.word	0x2000071c
 8024a60:	20000658 	.word	0x20000658
 8024a64:	20000674 	.word	0x20000674
 8024a68:	20000720 	.word	0x20000720
 8024a6c:	20000718 	.word	0x20000718
 8024a70:	20000764 	.word	0x20000764

		case MS_UNKNOWN:
		{
			//WritePassengerButton(CMD_ON);

			wait_timer++;
 8024a74:	4ba1      	ldr	r3, [pc, #644]	; (8024cfc <MainProc+0xcc8>)
 8024a76:	681b      	ldr	r3, [r3, #0]
 8024a78:	3301      	adds	r3, #1
 8024a7a:	4aa0      	ldr	r2, [pc, #640]	; (8024cfc <MainProc+0xcc8>)
 8024a7c:	6013      	str	r3, [r2, #0]

			if((PassengerButton))// || (wait_timer >= Presets.STARTUP_TIME))
 8024a7e:	4ba0      	ldr	r3, [pc, #640]	; (8024d00 <MainProc+0xccc>)
 8024a80:	681b      	ldr	r3, [r3, #0]
 8024a82:	2b00      	cmp	r3, #0
 8024a84:	d005      	beq.n	8024a92 <MainProc+0xa5e>
			{
				MainState = MS_HOMING;
 8024a86:	4b9f      	ldr	r3, [pc, #636]	; (8024d04 <MainProc+0xcd0>)
 8024a88:	2202      	movs	r2, #2
 8024a8a:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 8024a8c:	4b9b      	ldr	r3, [pc, #620]	; (8024cfc <MainProc+0xcc8>)
 8024a8e:	2200      	movs	r2, #0
 8024a90:	601a      	str	r2, [r3, #0]
			}
			if(Inputs.IO & 0x0004)
 8024a92:	4b9d      	ldr	r3, [pc, #628]	; (8024d08 <MainProc+0xcd4>)
 8024a94:	889b      	ldrh	r3, [r3, #4]
 8024a96:	f003 0304 	and.w	r3, r3, #4
 8024a9a:	2b00      	cmp	r3, #0
 8024a9c:	f000 81d5 	beq.w	8024e4a <MainProc+0xe16>
			{
				MainState = MS_HOMING;
 8024aa0:	4b98      	ldr	r3, [pc, #608]	; (8024d04 <MainProc+0xcd0>)
 8024aa2:	2202      	movs	r2, #2
 8024aa4:	601a      	str	r2, [r3, #0]
				wait_timer = 0;
 8024aa6:	4b95      	ldr	r3, [pc, #596]	; (8024cfc <MainProc+0xcc8>)
 8024aa8:	2200      	movs	r2, #0
 8024aaa:	601a      	str	r2, [r3, #0]
				serv_from_but = 1;
 8024aac:	4b97      	ldr	r3, [pc, #604]	; (8024d0c <MainProc+0xcd8>)
 8024aae:	2201      	movs	r2, #1
 8024ab0:	601a      	str	r2, [r3, #0]
			}
		}
			break;
 8024ab2:	e1ca      	b.n	8024e4a <MainProc+0xe16>

		case MS_HOMING:
		{
			WriteRubberLights(CL_YELLOW, MODE_BLINK, 1000);
 8024ab4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8024ab8:	2102      	movs	r1, #2
 8024aba:	4895      	ldr	r0, [pc, #596]	; (8024d10 <MainProc+0xcdc>)
 8024abc:	f7fe fb6c 	bl	8023198 <WriteRubberLights>
			temp = Homing(1);
 8024ac0:	2001      	movs	r0, #1
 8024ac2:	f000 fb11 	bl	80250e8 <Homing>
 8024ac6:	60f8      	str	r0, [r7, #12]
			if (temp == 1) // homing done success!
 8024ac8:	68fb      	ldr	r3, [r7, #12]
 8024aca:	2b01      	cmp	r3, #1
 8024acc:	d10e      	bne.n	8024aec <MainProc+0xab8>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024ace:	4891      	ldr	r0, [pc, #580]	; (8024d14 <MainProc+0xce0>)
 8024ad0:	f7ff fa47 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 8024ad4:	4890      	ldr	r0, [pc, #576]	; (8024d18 <MainProc+0xce4>)
 8024ad6:	f7ff fa34 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>
				HomingDone = 1;
 8024ada:	4b90      	ldr	r3, [pc, #576]	; (8024d1c <MainProc+0xce8>)
 8024adc:	2201      	movs	r2, #1
 8024ade:	601a      	str	r2, [r3, #0]
				MainState = MS_CLOSED;
 8024ae0:	4b88      	ldr	r3, [pc, #544]	; (8024d04 <MainProc+0xcd0>)
 8024ae2:	2203      	movs	r2, #3
 8024ae4:	601a      	str	r2, [r3, #0]
				serv_from_but = 0;
 8024ae6:	4b89      	ldr	r3, [pc, #548]	; (8024d0c <MainProc+0xcd8>)
 8024ae8:	2200      	movs	r2, #0
 8024aea:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024aec:	68fb      	ldr	r3, [r7, #12]
 8024aee:	2b00      	cmp	r3, #0
 8024af0:	d111      	bne.n	8024b16 <MainProc+0xae2>
			{
				blink++;
 8024af2:	4b8b      	ldr	r3, [pc, #556]	; (8024d20 <MainProc+0xcec>)
 8024af4:	681b      	ldr	r3, [r3, #0]
 8024af6:	3301      	adds	r3, #1
 8024af8:	4a89      	ldr	r2, [pc, #548]	; (8024d20 <MainProc+0xcec>)
 8024afa:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 8024afc:	4b88      	ldr	r3, [pc, #544]	; (8024d20 <MainProc+0xcec>)
 8024afe:	681b      	ldr	r3, [r3, #0]
 8024b00:	2b31      	cmp	r3, #49	; 0x31
 8024b02:	dd05      	ble.n	8024b10 <MainProc+0xadc>
				{
					DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 8024b04:	4883      	ldr	r0, [pc, #524]	; (8024d14 <MainProc+0xce0>)
 8024b06:	f7ff fa3c 	bl	8023f82 <DIGITAL_IO_ToggleOutput>
					blink = 0;
 8024b0a:	4b85      	ldr	r3, [pc, #532]	; (8024d20 <MainProc+0xcec>)
 8024b0c:	2200      	movs	r2, #0
 8024b0e:	601a      	str	r2, [r3, #0]
				}
				WriteBuzzer(BUZZER_ON);
 8024b10:	2001      	movs	r0, #1
 8024b12:	f7fe fa1b 	bl	8022f4c <WriteBuzzer>
			}
			if (temp == -1)
 8024b16:	68fb      	ldr	r3, [r7, #12]
 8024b18:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024b1c:	d10b      	bne.n	8024b36 <MainProc+0xb02>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024b1e:	4b79      	ldr	r3, [pc, #484]	; (8024d04 <MainProc+0xcd0>)
 8024b20:	2215      	movs	r2, #21
 8024b22:	601a      	str	r2, [r3, #0]
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024b24:	487b      	ldr	r0, [pc, #492]	; (8024d14 <MainProc+0xce0>)
 8024b26:	f7ff fa1c 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
 8024b2a:	487b      	ldr	r0, [pc, #492]	; (8024d18 <MainProc+0xce4>)
 8024b2c:	f7ff fa19 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				Homing(0);
 8024b30:	2000      	movs	r0, #0
 8024b32:	f000 fad9 	bl	80250e8 <Homing>
			}
			if (temp == -2)
 8024b36:	68fb      	ldr	r3, [r7, #12]
 8024b38:	f113 0f02 	cmn.w	r3, #2
 8024b3c:	d108      	bne.n	8024b50 <MainProc+0xb1c>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024b3e:	4875      	ldr	r0, [pc, #468]	; (8024d14 <MainProc+0xce0>)
 8024b40:	f7ff fa0f 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
				MainState = MS_ERROR_MAX_CURRENT;
 8024b44:	4b6f      	ldr	r3, [pc, #444]	; (8024d04 <MainProc+0xcd0>)
 8024b46:	2216      	movs	r2, #22
 8024b48:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024b4a:	2000      	movs	r0, #0
 8024b4c:	f000 facc 	bl	80250e8 <Homing>
			}
			if (temp == -3)
 8024b50:	68fb      	ldr	r3, [r7, #12]
 8024b52:	f113 0f03 	cmn.w	r3, #3
 8024b56:	f040 817a 	bne.w	8024e4e <MainProc+0xe1a>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024b5a:	486e      	ldr	r0, [pc, #440]	; (8024d14 <MainProc+0xce0>)
 8024b5c:	f7ff fa01 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
 8024b60:	486d      	ldr	r0, [pc, #436]	; (8024d18 <MainProc+0xce4>)
 8024b62:	f7ff f9fe 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				MainState = MS_ERROR_BAD_HOMING;
 8024b66:	4b67      	ldr	r3, [pc, #412]	; (8024d04 <MainProc+0xcd0>)
 8024b68:	2214      	movs	r2, #20
 8024b6a:	601a      	str	r2, [r3, #0]
				Homing(0);
 8024b6c:	2000      	movs	r0, #0
 8024b6e:	f000 fabb 	bl	80250e8 <Homing>
			}
		}
			break;
 8024b72:	e16c      	b.n	8024e4e <MainProc+0xe1a>

		case MS_CLOSED:
		{
			//wait_timer++;
			wait_timer++;
 8024b74:	4b61      	ldr	r3, [pc, #388]	; (8024cfc <MainProc+0xcc8>)
 8024b76:	681b      	ldr	r3, [r3, #0]
 8024b78:	3301      	adds	r3, #1
 8024b7a:	4a60      	ldr	r2, [pc, #384]	; (8024cfc <MainProc+0xcc8>)
 8024b7c:	6013      	str	r3, [r2, #0]
			//WriteClutch(CLUTCH_LOCK);


			if(wait_timer >= 200)
 8024b7e:	4b5f      	ldr	r3, [pc, #380]	; (8024cfc <MainProc+0xcc8>)
 8024b80:	681b      	ldr	r3, [r3, #0]
 8024b82:	2bc7      	cmp	r3, #199	; 0xc7
 8024b84:	dd01      	ble.n	8024b8a <MainProc+0xb56>
			{
				MotorStop();
 8024b86:	f7fe f85d 	bl	8022c44 <MotorStop>
			}

			WriteBuzzer(BUZZER_OFF);
 8024b8a:	2000      	movs	r0, #0
 8024b8c:	f7fe f9de 	bl	8022f4c <WriteBuzzer>
			//
			if((PassengerButton))// || (wait_timer >= 2000))
 8024b90:	4b5b      	ldr	r3, [pc, #364]	; (8024d00 <MainProc+0xccc>)
 8024b92:	681b      	ldr	r3, [r3, #0]
 8024b94:	2b00      	cmp	r3, #0
 8024b96:	d008      	beq.n	8024baa <MainProc+0xb76>
			{
				MainState = MS_OPENING;
 8024b98:	4b5a      	ldr	r3, [pc, #360]	; (8024d04 <MainProc+0xcd0>)
 8024b9a:	2204      	movs	r2, #4
 8024b9c:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 8024b9e:	4b61      	ldr	r3, [pc, #388]	; (8024d24 <MainProc+0xcf0>)
 8024ba0:	2200      	movs	r2, #0
 8024ba2:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024ba4:	4b55      	ldr	r3, [pc, #340]	; (8024cfc <MainProc+0xcc8>)
 8024ba6:	2200      	movs	r2, #0
 8024ba8:	601a      	str	r2, [r3, #0]
			}
			if(Inputs.IO & 0x0004)// || (wait_timer >= 2000))
 8024baa:	4b57      	ldr	r3, [pc, #348]	; (8024d08 <MainProc+0xcd4>)
 8024bac:	889b      	ldrh	r3, [r3, #4]
 8024bae:	f003 0304 	and.w	r3, r3, #4
 8024bb2:	2b00      	cmp	r3, #0
 8024bb4:	d00b      	beq.n	8024bce <MainProc+0xb9a>
			{
				MainState = MS_OPENING;
 8024bb6:	4b53      	ldr	r3, [pc, #332]	; (8024d04 <MainProc+0xcd0>)
 8024bb8:	2204      	movs	r2, #4
 8024bba:	601a      	str	r2, [r3, #0]
				OpenTime = 0;
 8024bbc:	4b59      	ldr	r3, [pc, #356]	; (8024d24 <MainProc+0xcf0>)
 8024bbe:	2200      	movs	r2, #0
 8024bc0:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024bc2:	4b4e      	ldr	r3, [pc, #312]	; (8024cfc <MainProc+0xcc8>)
 8024bc4:	2200      	movs	r2, #0
 8024bc6:	601a      	str	r2, [r3, #0]
				serv_from_but = 1;
 8024bc8:	4b50      	ldr	r3, [pc, #320]	; (8024d0c <MainProc+0xcd8>)
 8024bca:	2201      	movs	r2, #1
 8024bcc:	601a      	str	r2, [r3, #0]
			}

			WriteRubberLights(CL_RED, MODE_TIME_ON, 1000);
 8024bce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8024bd2:	2103      	movs	r1, #3
 8024bd4:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024bd8:	f7fe fade 	bl	8023198 <WriteRubberLights>

		}
			break;
 8024bdc:	e13e      	b.n	8024e5c <MainProc+0xe28>
		case MS_OPENING:
		{
			WriteRubberLights(CL_GREEN, MODE_BLINK, 500);
 8024bde:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024be2:	2102      	movs	r1, #2
 8024be4:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024be8:	f7fe fad6 	bl	8023198 <WriteRubberLights>
			OpenTime++;
 8024bec:	4b4d      	ldr	r3, [pc, #308]	; (8024d24 <MainProc+0xcf0>)
 8024bee:	881b      	ldrh	r3, [r3, #0]
 8024bf0:	3301      	adds	r3, #1
 8024bf2:	b29a      	uxth	r2, r3
 8024bf4:	4b4b      	ldr	r3, [pc, #300]	; (8024d24 <MainProc+0xcf0>)
 8024bf6:	801a      	strh	r2, [r3, #0]
			WriteBuzzer(BUZZER_OFF);
 8024bf8:	2000      	movs	r0, #0
 8024bfa:	f7fe f9a7 	bl	8022f4c <WriteBuzzer>
			temp = OpenDoor(1);
 8024bfe:	2001      	movs	r0, #1
 8024c00:	f000 fd1c 	bl	802563c <OpenDoor>
 8024c04:	60f8      	str	r0, [r7, #12]
			if (temp == 1)
 8024c06:	68fb      	ldr	r3, [r7, #12]
 8024c08:	2b01      	cmp	r3, #1
 8024c0a:	d10b      	bne.n	8024c24 <MainProc+0xbf0>
			{
//				if(Presets.CYCLES_COUNTER % 200)
//				{
					MainState = MS_OPENED;
 8024c0c:	4b3d      	ldr	r3, [pc, #244]	; (8024d04 <MainProc+0xcd0>)
 8024c0e:	2205      	movs	r2, #5
 8024c10:	601a      	str	r2, [r3, #0]
					serv_from_but = 0;
 8024c12:	4b3e      	ldr	r3, [pc, #248]	; (8024d0c <MainProc+0xcd8>)
 8024c14:	2200      	movs	r2, #0
 8024c16:	601a      	str	r2, [r3, #0]
//				else
//				{
//					MainState = MS_START;
//				}
//
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024c18:	483e      	ldr	r0, [pc, #248]	; (8024d14 <MainProc+0xce0>)
 8024c1a:	f7ff f9a2 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 8024c1e:	483e      	ldr	r0, [pc, #248]	; (8024d18 <MainProc+0xce4>)
 8024c20:	f7ff f98f 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>

			}
			if (temp == 0)
 8024c24:	68fb      	ldr	r3, [r7, #12]
 8024c26:	2b00      	cmp	r3, #0
 8024c28:	d10e      	bne.n	8024c48 <MainProc+0xc14>
			{
				blink++;
 8024c2a:	4b3d      	ldr	r3, [pc, #244]	; (8024d20 <MainProc+0xcec>)
 8024c2c:	681b      	ldr	r3, [r3, #0]
 8024c2e:	3301      	adds	r3, #1
 8024c30:	4a3b      	ldr	r2, [pc, #236]	; (8024d20 <MainProc+0xcec>)
 8024c32:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 8024c34:	4b3a      	ldr	r3, [pc, #232]	; (8024d20 <MainProc+0xcec>)
 8024c36:	681b      	ldr	r3, [r3, #0]
 8024c38:	2b31      	cmp	r3, #49	; 0x31
 8024c3a:	dd05      	ble.n	8024c48 <MainProc+0xc14>
				{
					DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 8024c3c:	4835      	ldr	r0, [pc, #212]	; (8024d14 <MainProc+0xce0>)
 8024c3e:	f7ff f9a0 	bl	8023f82 <DIGITAL_IO_ToggleOutput>
					blink = 0;
 8024c42:	4b37      	ldr	r3, [pc, #220]	; (8024d20 <MainProc+0xcec>)
 8024c44:	2200      	movs	r2, #0
 8024c46:	601a      	str	r2, [r3, #0]
				}
			}
			if (temp == -1)
 8024c48:	68fb      	ldr	r3, [r7, #12]
 8024c4a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024c4e:	d105      	bne.n	8024c5c <MainProc+0xc28>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024c50:	4b2c      	ldr	r3, [pc, #176]	; (8024d04 <MainProc+0xcd0>)
 8024c52:	2215      	movs	r2, #21
 8024c54:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024c56:	2000      	movs	r0, #0
 8024c58:	f000 fcf0 	bl	802563c <OpenDoor>
			}
			if (temp == -2)
 8024c5c:	68fb      	ldr	r3, [r7, #12]
 8024c5e:	f113 0f02 	cmn.w	r3, #2
 8024c62:	d105      	bne.n	8024c70 <MainProc+0xc3c>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024c64:	4b27      	ldr	r3, [pc, #156]	; (8024d04 <MainProc+0xcd0>)
 8024c66:	2216      	movs	r2, #22
 8024c68:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024c6a:	2000      	movs	r0, #0
 8024c6c:	f000 fce6 	bl	802563c <OpenDoor>
			}
			if (temp == -3)
 8024c70:	68fb      	ldr	r3, [r7, #12]
 8024c72:	f113 0f03 	cmn.w	r3, #3
 8024c76:	d105      	bne.n	8024c84 <MainProc+0xc50>
			{
				MainState = MS_ERROR_BAD_STATE;
 8024c78:	4b22      	ldr	r3, [pc, #136]	; (8024d04 <MainProc+0xcd0>)
 8024c7a:	2217      	movs	r2, #23
 8024c7c:	601a      	str	r2, [r3, #0]
				OpenDoor(0);
 8024c7e:	2000      	movs	r0, #0
 8024c80:	f000 fcdc 	bl	802563c <OpenDoor>
			}
			if(-4 == temp)
 8024c84:	68fb      	ldr	r3, [r7, #12]
 8024c86:	f113 0f04 	cmn.w	r3, #4
 8024c8a:	f040 80e2 	bne.w	8024e52 <MainProc+0xe1e>
			{
				OpenDoor(0);
 8024c8e:	2000      	movs	r0, #0
 8024c90:	f000 fcd4 	bl	802563c <OpenDoor>
				MainState = MS_CLOSING;
 8024c94:	4b1b      	ldr	r3, [pc, #108]	; (8024d04 <MainProc+0xcd0>)
 8024c96:	2206      	movs	r2, #6
 8024c98:	601a      	str	r2, [r3, #0]
			}

		}
			break;
 8024c9a:	e0da      	b.n	8024e52 <MainProc+0xe1e>
		case MS_OPENED:
		{
			WriteRubberLights(CL_GREEN, MODE_ON, 0);
 8024c9c:	2200      	movs	r2, #0
 8024c9e:	2101      	movs	r1, #1
 8024ca0:	f44f 007f 	mov.w	r0, #16711680	; 0xff0000
 8024ca4:	f7fe fa78 	bl	8023198 <WriteRubberLights>
			WriteBuzzer(BUZZER_OFF);
 8024ca8:	2000      	movs	r0, #0
 8024caa:	f7fe f94f 	bl	8022f4c <WriteBuzzer>
			wait_timer++;
 8024cae:	4b13      	ldr	r3, [pc, #76]	; (8024cfc <MainProc+0xcc8>)
 8024cb0:	681b      	ldr	r3, [r3, #0]
 8024cb2:	3301      	adds	r3, #1
 8024cb4:	4a11      	ldr	r2, [pc, #68]	; (8024cfc <MainProc+0xcc8>)
 8024cb6:	6013      	str	r3, [r2, #0]
			if((PassengerButton))// || (wait_timer >= 200))
 8024cb8:	4b11      	ldr	r3, [pc, #68]	; (8024d00 <MainProc+0xccc>)
 8024cba:	681b      	ldr	r3, [r3, #0]
 8024cbc:	2b00      	cmp	r3, #0
 8024cbe:	d008      	beq.n	8024cd2 <MainProc+0xc9e>
			{
				MainState = MS_CLOSING;
 8024cc0:	4b10      	ldr	r3, [pc, #64]	; (8024d04 <MainProc+0xcd0>)
 8024cc2:	2206      	movs	r2, #6
 8024cc4:	601a      	str	r2, [r3, #0]
				CloseTime = 0;
 8024cc6:	4b18      	ldr	r3, [pc, #96]	; (8024d28 <MainProc+0xcf4>)
 8024cc8:	2200      	movs	r2, #0
 8024cca:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024ccc:	4b0b      	ldr	r3, [pc, #44]	; (8024cfc <MainProc+0xcc8>)
 8024cce:	2200      	movs	r2, #0
 8024cd0:	601a      	str	r2, [r3, #0]
			}
			if((Inputs.IO & 0x0004))// || (wait_timer >= 200))
 8024cd2:	4b0d      	ldr	r3, [pc, #52]	; (8024d08 <MainProc+0xcd4>)
 8024cd4:	889b      	ldrh	r3, [r3, #4]
 8024cd6:	f003 0304 	and.w	r3, r3, #4
 8024cda:	2b00      	cmp	r3, #0
 8024cdc:	f000 80bb 	beq.w	8024e56 <MainProc+0xe22>
			{
				MainState = MS_CLOSING;
 8024ce0:	4b08      	ldr	r3, [pc, #32]	; (8024d04 <MainProc+0xcd0>)
 8024ce2:	2206      	movs	r2, #6
 8024ce4:	601a      	str	r2, [r3, #0]
				CloseTime = 0;
 8024ce6:	4b10      	ldr	r3, [pc, #64]	; (8024d28 <MainProc+0xcf4>)
 8024ce8:	2200      	movs	r2, #0
 8024cea:	801a      	strh	r2, [r3, #0]
				wait_timer = 0;
 8024cec:	4b03      	ldr	r3, [pc, #12]	; (8024cfc <MainProc+0xcc8>)
 8024cee:	2200      	movs	r2, #0
 8024cf0:	601a      	str	r2, [r3, #0]
				serv_from_but = 1;
 8024cf2:	4b06      	ldr	r3, [pc, #24]	; (8024d0c <MainProc+0xcd8>)
 8024cf4:	2201      	movs	r2, #1
 8024cf6:	601a      	str	r2, [r3, #0]
			}

		}
			break;
 8024cf8:	e0ad      	b.n	8024e56 <MainProc+0xe22>
 8024cfa:	bf00      	nop
 8024cfc:	20000710 	.word	0x20000710
 8024d00:	20000658 	.word	0x20000658
 8024d04:	200006f8 	.word	0x200006f8
 8024d08:	20000674 	.word	0x20000674
 8024d0c:	20000708 	.word	0x20000708
 8024d10:	ffff0000 	.word	0xffff0000
 8024d14:	0802b26c 	.word	0x0802b26c
 8024d18:	0802b258 	.word	0x0802b258
 8024d1c:	200006fc 	.word	0x200006fc
 8024d20:	20000714 	.word	0x20000714
 8024d24:	200006cc 	.word	0x200006cc
 8024d28:	200006ce 	.word	0x200006ce
		case MS_CLOSING:
		{
			WriteRubberLights(CL_RED, MODE_BLINK, 500);
 8024d2c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8024d30:	2102      	movs	r1, #2
 8024d32:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024d36:	f7fe fa2f 	bl	8023198 <WriteRubberLights>
			CloseTime++;
 8024d3a:	4b4e      	ldr	r3, [pc, #312]	; (8024e74 <MainProc+0xe40>)
 8024d3c:	881b      	ldrh	r3, [r3, #0]
 8024d3e:	3301      	adds	r3, #1
 8024d40:	b29a      	uxth	r2, r3
 8024d42:	4b4c      	ldr	r3, [pc, #304]	; (8024e74 <MainProc+0xe40>)
 8024d44:	801a      	strh	r2, [r3, #0]
			temp = CloseDoor(1);
 8024d46:	2001      	movs	r0, #1
 8024d48:	f000 fb52 	bl	80253f0 <CloseDoor>
 8024d4c:	60f8      	str	r0, [r7, #12]
			if (temp == 1) //
 8024d4e:	68fb      	ldr	r3, [r7, #12]
 8024d50:	2b01      	cmp	r3, #1
 8024d52:	d10b      	bne.n	8024d6c <MainProc+0xd38>
			{
				DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);
 8024d54:	4848      	ldr	r0, [pc, #288]	; (8024e78 <MainProc+0xe44>)
 8024d56:	f7ff f904 	bl	8023f62 <DIGITAL_IO_SetOutputLow>
				DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 8024d5a:	4848      	ldr	r0, [pc, #288]	; (8024e7c <MainProc+0xe48>)
 8024d5c:	f7ff f8f1 	bl	8023f42 <DIGITAL_IO_SetOutputHigh>
				MainState = MS_CLOSED;
 8024d60:	4b47      	ldr	r3, [pc, #284]	; (8024e80 <MainProc+0xe4c>)
 8024d62:	2203      	movs	r2, #3
 8024d64:	601a      	str	r2, [r3, #0]
				serv_from_but = 0;
 8024d66:	4b47      	ldr	r3, [pc, #284]	; (8024e84 <MainProc+0xe50>)
 8024d68:	2200      	movs	r2, #0
 8024d6a:	601a      	str	r2, [r3, #0]
			}
			if (temp == 0)
 8024d6c:	68fb      	ldr	r3, [r7, #12]
 8024d6e:	2b00      	cmp	r3, #0
 8024d70:	d111      	bne.n	8024d96 <MainProc+0xd62>
			{
				blink++;
 8024d72:	4b45      	ldr	r3, [pc, #276]	; (8024e88 <MainProc+0xe54>)
 8024d74:	681b      	ldr	r3, [r3, #0]
 8024d76:	3301      	adds	r3, #1
 8024d78:	4a43      	ldr	r2, [pc, #268]	; (8024e88 <MainProc+0xe54>)
 8024d7a:	6013      	str	r3, [r2, #0]
				if(blink >= 50)
 8024d7c:	4b42      	ldr	r3, [pc, #264]	; (8024e88 <MainProc+0xe54>)
 8024d7e:	681b      	ldr	r3, [r3, #0]
 8024d80:	2b31      	cmp	r3, #49	; 0x31
 8024d82:	dd05      	ble.n	8024d90 <MainProc+0xd5c>
				{
					DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 8024d84:	483c      	ldr	r0, [pc, #240]	; (8024e78 <MainProc+0xe44>)
 8024d86:	f7ff f8fc 	bl	8023f82 <DIGITAL_IO_ToggleOutput>
					blink = 0;
 8024d8a:	4b3f      	ldr	r3, [pc, #252]	; (8024e88 <MainProc+0xe54>)
 8024d8c:	2200      	movs	r2, #0
 8024d8e:	601a      	str	r2, [r3, #0]
				}
				WriteBuzzer(BUZZER_ON);
 8024d90:	2001      	movs	r0, #1
 8024d92:	f7fe f8db 	bl	8022f4c <WriteBuzzer>
			}
			if (temp == -1)
 8024d96:	68fb      	ldr	r3, [r7, #12]
 8024d98:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024d9c:	d105      	bne.n	8024daa <MainProc+0xd76>
			{
				MainState = MS_ERROR_MOV_TIMEOUT;
 8024d9e:	4b38      	ldr	r3, [pc, #224]	; (8024e80 <MainProc+0xe4c>)
 8024da0:	2215      	movs	r2, #21
 8024da2:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024da4:	2000      	movs	r0, #0
 8024da6:	f000 fb23 	bl	80253f0 <CloseDoor>
			}
			if (temp == -2)
 8024daa:	68fb      	ldr	r3, [r7, #12]
 8024dac:	f113 0f02 	cmn.w	r3, #2
 8024db0:	d105      	bne.n	8024dbe <MainProc+0xd8a>
			{
				MainState = MS_ERROR_MAX_CURRENT;
 8024db2:	4b33      	ldr	r3, [pc, #204]	; (8024e80 <MainProc+0xe4c>)
 8024db4:	2216      	movs	r2, #22
 8024db6:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024db8:	2000      	movs	r0, #0
 8024dba:	f000 fb19 	bl	80253f0 <CloseDoor>
			}
			if (temp == -3)
 8024dbe:	68fb      	ldr	r3, [r7, #12]
 8024dc0:	f113 0f03 	cmn.w	r3, #3
 8024dc4:	d105      	bne.n	8024dd2 <MainProc+0xd9e>
			{
				MainState = MS_ERROR_BAD_STATE;
 8024dc6:	4b2e      	ldr	r3, [pc, #184]	; (8024e80 <MainProc+0xe4c>)
 8024dc8:	2217      	movs	r2, #23
 8024dca:	601a      	str	r2, [r3, #0]
				CloseDoor(0);
 8024dcc:	2000      	movs	r0, #0
 8024dce:	f000 fb0f 	bl	80253f0 <CloseDoor>
			}
			if(-4 == temp)
 8024dd2:	68fb      	ldr	r3, [r7, #12]
 8024dd4:	f113 0f04 	cmn.w	r3, #4
 8024dd8:	d13f      	bne.n	8024e5a <MainProc+0xe26>
			{
				CloseDoor(0);
 8024dda:	2000      	movs	r0, #0
 8024ddc:	f000 fb08 	bl	80253f0 <CloseDoor>
				MainState = MS_OPENING;
 8024de0:	4b27      	ldr	r3, [pc, #156]	; (8024e80 <MainProc+0xe4c>)
 8024de2:	2204      	movs	r2, #4
 8024de4:	601a      	str	r2, [r3, #0]
			}
		}
			break;
 8024de6:	e038      	b.n	8024e5a <MainProc+0xe26>

		default: // now it is error handler, todo: different errors
		{
			blink++;
 8024de8:	4b27      	ldr	r3, [pc, #156]	; (8024e88 <MainProc+0xe54>)
 8024dea:	681b      	ldr	r3, [r3, #0]
 8024dec:	3301      	adds	r3, #1
 8024dee:	4a26      	ldr	r2, [pc, #152]	; (8024e88 <MainProc+0xe54>)
 8024df0:	6013      	str	r3, [r2, #0]
			//DIGITAL_IO_SetOutputLow(&STATUS_LED_G);
			//DIGITAL_IO_SetOutputLow(&STATUS_LED_Y);

			if(blink >= 10)
 8024df2:	4b25      	ldr	r3, [pc, #148]	; (8024e88 <MainProc+0xe54>)
 8024df4:	681b      	ldr	r3, [r3, #0]
 8024df6:	2b09      	cmp	r3, #9
 8024df8:	dd05      	ble.n	8024e06 <MainProc+0xdd2>
			{
				DIGITAL_IO_ToggleOutput(&STATUS_LED_R);
 8024dfa:	4824      	ldr	r0, [pc, #144]	; (8024e8c <MainProc+0xe58>)
 8024dfc:	f7ff f8c1 	bl	8023f82 <DIGITAL_IO_ToggleOutput>
				blink = 0;
 8024e00:	4b21      	ldr	r3, [pc, #132]	; (8024e88 <MainProc+0xe54>)
 8024e02:	2200      	movs	r2, #0
 8024e04:	601a      	str	r2, [r3, #0]
			}
			WriteBuzzer(BUZZER_ON);
 8024e06:	2001      	movs	r0, #1
 8024e08:	f7fe f8a0 	bl	8022f4c <WriteBuzzer>
			//Motor0_BLDC_SCALAR_MotorStop();
			WritePassengerButton(CMD_OFF);
 8024e0c:	2000      	movs	r0, #0
 8024e0e:	f7fe fdaf 	bl	8023970 <WritePassengerButton>
			WriteClutch(CLUTCH_LOCK);
 8024e12:	2000      	movs	r0, #0
 8024e14:	f7fe fd52 	bl	80238bc <WriteClutch>
			//DIGITAL_IO_SetOutputLow(&HS_SW_1);
			//DIGITAL_IO_SetOutputLow(&HS_SW_2);
			WriteRubberLights(CL_RED, MODE_BLINK, 200);
 8024e18:	22c8      	movs	r2, #200	; 0xc8
 8024e1a:	2102      	movs	r1, #2
 8024e1c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
 8024e20:	f7fe f9ba 	bl	8023198 <WriteRubberLights>
				WriteRubberLights(CL_BLACK, MODE_OFF, 0);
			}
			*/
			//DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
		}
		break;
 8024e24:	e01a      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e26:	bf00      	nop
 8024e28:	e018      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e2a:	bf00      	nop
 8024e2c:	e016      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e2e:	bf00      	nop
 8024e30:	e014      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e32:	bf00      	nop
 8024e34:	e012      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e36:	bf00      	nop
 8024e38:	e010      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e3a:	bf00      	nop
 8024e3c:	e00e      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e3e:	bf00      	nop
 8024e40:	e00c      	b.n	8024e5c <MainProc+0xe28>
		break;
 8024e42:	bf00      	nop
 8024e44:	e00a      	b.n	8024e5c <MainProc+0xe28>
	}
	}
 8024e46:	bf00      	nop
 8024e48:	e008      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e4a:	bf00      	nop
 8024e4c:	e006      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e4e:	bf00      	nop
 8024e50:	e004      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e52:	bf00      	nop
 8024e54:	e002      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e56:	bf00      	nop
 8024e58:	e000      	b.n	8024e5c <MainProc+0xe28>
			break;
 8024e5a:	bf00      	nop
}
	SendDiagnostics();
 8024e5c:	f000 f848 	bl	8024ef0 <SendDiagnostics>
	SendExtCan();
 8024e60:	f000 f82a 	bl	8024eb8 <SendExtCan>
	CanCmdOpenEnablePrev = CanCmdOpenEnable;
 8024e64:	4b0a      	ldr	r3, [pc, #40]	; (8024e90 <MainProc+0xe5c>)
 8024e66:	681b      	ldr	r3, [r3, #0]
 8024e68:	4a0a      	ldr	r2, [pc, #40]	; (8024e94 <MainProc+0xe60>)
 8024e6a:	6013      	str	r3, [r2, #0]

}// end_main_proc
 8024e6c:	bf00      	nop
 8024e6e:	3710      	adds	r7, #16
 8024e70:	46bd      	mov	sp, r7
 8024e72:	bd80      	pop	{r7, pc}
 8024e74:	200006ce 	.word	0x200006ce
 8024e78:	0802b26c 	.word	0x0802b26c
 8024e7c:	0802b258 	.word	0x0802b258
 8024e80:	200006f8 	.word	0x200006f8
 8024e84:	20000708 	.word	0x20000708
 8024e88:	20000714 	.word	0x20000714
 8024e8c:	0802b280 	.word	0x0802b280
 8024e90:	200006b0 	.word	0x200006b0
 8024e94:	20000724 	.word	0x20000724

08024e98 <ReadPeripherials>:


void ReadPeripherials (void)
{
 8024e98:	b580      	push	{r7, lr}
 8024e9a:	af00      	add	r7, sp, #0
//	Velocity = abs(Velocity);

	//if (Current > Max_Close_current) Max_Close_current = Current;
	//if (Current > Max_Open_current) Max_Open_current = Current;

	ReadCloseSensor();
 8024e9c:	f7fe fc60 	bl	8023760 <ReadCloseSensor>
	ReadPassengerButton();
 8024ea0:	f7fe fcb8 	bl	8023814 <ReadPassengerButton>
	ReadServiceButton();
 8024ea4:	f7fe fc88 	bl	80237b8 <ReadServiceButton>
	ReadActiveRubber();
 8024ea8:	f7fe fcf0 	bl	802388c <ReadActiveRubber>
//	ReadDisabledButton();
//	ReadPhotoSensor();
	ReadOpen1DoorButton();
 8024eac:	f7fe fc40 	bl	8023730 <ReadOpen1DoorButton>
//	if ((2 == Presets.CAN_ADRESS) || (3 == Presets.CAN_ADRESS) )
//	{
		ReadDisabledButton();
 8024eb0:	f7fe fcce 	bl	8023850 <ReadDisabledButton>
//		ReadTrapSensor();
//	}


}
 8024eb4:	bf00      	nop
 8024eb6:	bd80      	pop	{r7, pc}

08024eb8 <SendExtCan>:

void SendExtCan(void)
{
 8024eb8:	b580      	push	{r7, lr}
 8024eba:	af00      	add	r7, sp, #0

//	int32_t new_data = 0;

	// todo: add OnChange

	edsc1_timer++;
 8024ebc:	4b0a      	ldr	r3, [pc, #40]	; (8024ee8 <SendExtCan+0x30>)
 8024ebe:	681b      	ldr	r3, [r3, #0]
 8024ec0:	3301      	adds	r3, #1
 8024ec2:	4a09      	ldr	r2, [pc, #36]	; (8024ee8 <SendExtCan+0x30>)
 8024ec4:	6013      	str	r3, [r2, #0]
//	for(int32_t i = 0; i < 8; i++)
//	{
//		 PrevCan2TxData2[i] = Can2TxData2[i];
//	}

	if (10 <= edsc1_timer || DisabledButton)
 8024ec6:	4b08      	ldr	r3, [pc, #32]	; (8024ee8 <SendExtCan+0x30>)
 8024ec8:	681b      	ldr	r3, [r3, #0]
 8024eca:	2b09      	cmp	r3, #9
 8024ecc:	dc03      	bgt.n	8024ed6 <SendExtCan+0x1e>
 8024ece:	4b07      	ldr	r3, [pc, #28]	; (8024eec <SendExtCan+0x34>)
 8024ed0:	681b      	ldr	r3, [r3, #0]
 8024ed2:	2b00      	cmp	r3, #0
 8024ed4:	d006      	beq.n	8024ee4 <SendExtCan+0x2c>
	{
		Can1Tx1Prep();
 8024ed6:	f7fe fe29 	bl	8023b2c <Can1Tx1Prep>
		edsc1_timer = 0;
 8024eda:	4b03      	ldr	r3, [pc, #12]	; (8024ee8 <SendExtCan+0x30>)
 8024edc:	2200      	movs	r2, #0
 8024ede:	601a      	str	r2, [r3, #0]
		Can1Tx1Send();
 8024ee0:	f7fe fd6c 	bl	80239bc <Can1Tx1Send>
//	if (100 <= edsc2_timer)
//	{
//		edsc2_timer = 0;
//		Can1Tx2Send();
//	}
}
 8024ee4:	bf00      	nop
 8024ee6:	bd80      	pop	{r7, pc}
 8024ee8:	20000728 	.word	0x20000728
 8024eec:	2000065c 	.word	0x2000065c

08024ef0 <SendDiagnostics>:

void SendDiagnostics(void)
{
 8024ef0:	b580      	push	{r7, lr}
 8024ef2:	b082      	sub	sp, #8
 8024ef4:	af00      	add	r7, sp, #0
	uint16_t temp16;
	uint8_t	temp8;
	uint32_t * p32;
	uint16_t * p16;

	if ((MainState == MS_OPENING) || (MainState == MS_CLOSING) || (MainState == MS_BLOCKAGE_CLS) || (MainState == MS_BLOCKAGE_OPN) || (MainState == MS_HOMING) || ServiceMode )	// only when moving
 8024ef6:	4b55      	ldr	r3, [pc, #340]	; (802504c <SendDiagnostics+0x15c>)
 8024ef8:	681b      	ldr	r3, [r3, #0]
 8024efa:	2b04      	cmp	r3, #4
 8024efc:	d013      	beq.n	8024f26 <SendDiagnostics+0x36>
 8024efe:	4b53      	ldr	r3, [pc, #332]	; (802504c <SendDiagnostics+0x15c>)
 8024f00:	681b      	ldr	r3, [r3, #0]
 8024f02:	2b06      	cmp	r3, #6
 8024f04:	d00f      	beq.n	8024f26 <SendDiagnostics+0x36>
 8024f06:	4b51      	ldr	r3, [pc, #324]	; (802504c <SendDiagnostics+0x15c>)
 8024f08:	681b      	ldr	r3, [r3, #0]
 8024f0a:	2b0a      	cmp	r3, #10
 8024f0c:	d00b      	beq.n	8024f26 <SendDiagnostics+0x36>
 8024f0e:	4b4f      	ldr	r3, [pc, #316]	; (802504c <SendDiagnostics+0x15c>)
 8024f10:	681b      	ldr	r3, [r3, #0]
 8024f12:	2b0b      	cmp	r3, #11
 8024f14:	d007      	beq.n	8024f26 <SendDiagnostics+0x36>
 8024f16:	4b4d      	ldr	r3, [pc, #308]	; (802504c <SendDiagnostics+0x15c>)
 8024f18:	681b      	ldr	r3, [r3, #0]
 8024f1a:	2b02      	cmp	r3, #2
 8024f1c:	d003      	beq.n	8024f26 <SendDiagnostics+0x36>
 8024f1e:	4b4c      	ldr	r3, [pc, #304]	; (8025050 <SendDiagnostics+0x160>)
 8024f20:	681b      	ldr	r3, [r3, #0]
 8024f22:	2b00      	cmp	r3, #0
 8024f24:	d02e      	beq.n	8024f84 <SendDiagnostics+0x94>
	{

		p16 = (uint16_t*)(Can2TxData1 + 0);
 8024f26:	4b4b      	ldr	r3, [pc, #300]	; (8025054 <SendDiagnostics+0x164>)
 8024f28:	607b      	str	r3, [r7, #4]
		*p16 = drive.Current;;
 8024f2a:	4b4b      	ldr	r3, [pc, #300]	; (8025058 <SendDiagnostics+0x168>)
 8024f2c:	885a      	ldrh	r2, [r3, #2]
 8024f2e:	687b      	ldr	r3, [r7, #4]
 8024f30:	801a      	strh	r2, [r3, #0]

		p16 = (uint16_t*)(Can2TxData1 + 2);
 8024f32:	4b4a      	ldr	r3, [pc, #296]	; (802505c <SendDiagnostics+0x16c>)
 8024f34:	607b      	str	r3, [r7, #4]
		*p16 = drive.Velocity;;
 8024f36:	4b48      	ldr	r3, [pc, #288]	; (8025058 <SendDiagnostics+0x168>)
 8024f38:	889a      	ldrh	r2, [r3, #4]
 8024f3a:	687b      	ldr	r3, [r7, #4]
 8024f3c:	801a      	strh	r2, [r3, #0]

		p16 = (uint16_t*)(Can2TxData1 + 4);
 8024f3e:	4b48      	ldr	r3, [pc, #288]	; (8025060 <SendDiagnostics+0x170>)
 8024f40:	607b      	str	r3, [r7, #4]
		*p16 = drive.Position;;
 8024f42:	4b45      	ldr	r3, [pc, #276]	; (8025058 <SendDiagnostics+0x168>)
 8024f44:	881a      	ldrh	r2, [r3, #0]
 8024f46:	687b      	ldr	r3, [r7, #4]
 8024f48:	801a      	strh	r2, [r3, #0]

		temp16 = (uint16_t)CloseSensor * 100;
 8024f4a:	4b46      	ldr	r3, [pc, #280]	; (8025064 <SendDiagnostics+0x174>)
 8024f4c:	681b      	ldr	r3, [r3, #0]
 8024f4e:	b29b      	uxth	r3, r3
 8024f50:	461a      	mov	r2, r3
 8024f52:	0092      	lsls	r2, r2, #2
 8024f54:	4413      	add	r3, r2
 8024f56:	461a      	mov	r2, r3
 8024f58:	0091      	lsls	r1, r2, #2
 8024f5a:	461a      	mov	r2, r3
 8024f5c:	460b      	mov	r3, r1
 8024f5e:	4413      	add	r3, r2
 8024f60:	009b      	lsls	r3, r3, #2
 8024f62:	807b      	strh	r3, [r7, #2]
		p16 = (uint16_t*)(Can2TxData1 + 6);
 8024f64:	4b40      	ldr	r3, [pc, #256]	; (8025068 <SendDiagnostics+0x178>)
 8024f66:	607b      	str	r3, [r7, #4]
		*p16 = temp16;
 8024f68:	687b      	ldr	r3, [r7, #4]
 8024f6a:	887a      	ldrh	r2, [r7, #2]
 8024f6c:	801a      	strh	r2, [r3, #0]

		CAN_NODE_MO_UpdateID(&CAN_INT_LMO_01_Config, 0x64);
 8024f6e:	2164      	movs	r1, #100	; 0x64
 8024f70:	483e      	ldr	r0, [pc, #248]	; (802506c <SendDiagnostics+0x17c>)
 8024f72:	f7ff f816 	bl	8023fa2 <CAN_NODE_MO_UpdateID>
		CAN_NODE_MO_UpdateData(&CAN_INT_LMO_01_Config, &Can2TxData1[0]);
 8024f76:	4937      	ldr	r1, [pc, #220]	; (8025054 <SendDiagnostics+0x164>)
 8024f78:	483c      	ldr	r0, [pc, #240]	; (802506c <SendDiagnostics+0x17c>)
 8024f7a:	f005 f869 	bl	802a050 <CAN_NODE_MO_UpdateData>
		CAN_NODE_MO_Transmit(&CAN_INT_LMO_01_Config);
 8024f7e:	483b      	ldr	r0, [pc, #236]	; (802506c <SendDiagnostics+0x17c>)
 8024f80:	f005 f842 	bl	802a008 <CAN_NODE_MO_Transmit>
	}


	Can2TxData3[0] = (uint8_t)Inputs.PNP;
 8024f84:	4b3a      	ldr	r3, [pc, #232]	; (8025070 <SendDiagnostics+0x180>)
 8024f86:	881b      	ldrh	r3, [r3, #0]
 8024f88:	b2da      	uxtb	r2, r3
 8024f8a:	4b3a      	ldr	r3, [pc, #232]	; (8025074 <SendDiagnostics+0x184>)
 8024f8c:	701a      	strb	r2, [r3, #0]
	Can2TxData3[1] = (uint8_t)Inputs.NPN;
 8024f8e:	4b38      	ldr	r3, [pc, #224]	; (8025070 <SendDiagnostics+0x180>)
 8024f90:	885b      	ldrh	r3, [r3, #2]
 8024f92:	b2da      	uxtb	r2, r3
 8024f94:	4b37      	ldr	r3, [pc, #220]	; (8025074 <SendDiagnostics+0x184>)
 8024f96:	705a      	strb	r2, [r3, #1]
	Can2TxData3[2] = (uint8_t)Inputs.IO;
 8024f98:	4b35      	ldr	r3, [pc, #212]	; (8025070 <SendDiagnostics+0x180>)
 8024f9a:	889b      	ldrh	r3, [r3, #4]
 8024f9c:	b2da      	uxtb	r2, r3
 8024f9e:	4b35      	ldr	r3, [pc, #212]	; (8025074 <SendDiagnostics+0x184>)
 8024fa0:	709a      	strb	r2, [r3, #2]
	Can2TxData3[3] = (uint8_t)Inputs.ServiceButton;
 8024fa2:	4b33      	ldr	r3, [pc, #204]	; (8025070 <SendDiagnostics+0x180>)
 8024fa4:	88db      	ldrh	r3, [r3, #6]
 8024fa6:	b2da      	uxtb	r2, r3
 8024fa8:	4b32      	ldr	r3, [pc, #200]	; (8025074 <SendDiagnostics+0x184>)
 8024faa:	70da      	strb	r2, [r3, #3]
	p16 = (uint16_t*)(Can2TxData3 + 4);
 8024fac:	4b32      	ldr	r3, [pc, #200]	; (8025078 <SendDiagnostics+0x188>)
 8024fae:	607b      	str	r3, [r7, #4]
	*p16 = Inputs.ActiveRubberLVal;
 8024fb0:	4b2f      	ldr	r3, [pc, #188]	; (8025070 <SendDiagnostics+0x180>)
 8024fb2:	891a      	ldrh	r2, [r3, #8]
 8024fb4:	687b      	ldr	r3, [r7, #4]
 8024fb6:	801a      	strh	r2, [r3, #0]

	p16 = (uint16_t*)(Can2TxData3 + 6);
 8024fb8:	4b30      	ldr	r3, [pc, #192]	; (802507c <SendDiagnostics+0x18c>)
 8024fba:	607b      	str	r3, [r7, #4]
	*p16 = (uint16_t)Inputs.InputPower;
 8024fbc:	4b2c      	ldr	r3, [pc, #176]	; (8025070 <SendDiagnostics+0x180>)
 8024fbe:	899a      	ldrh	r2, [r3, #12]
 8024fc0:	687b      	ldr	r3, [r7, #4]
 8024fc2:	801a      	strh	r2, [r3, #0]


	CAN_NODE_MO_UpdateID(&CAN_INT_LMO_03_Config, 0x66);
 8024fc4:	2166      	movs	r1, #102	; 0x66
 8024fc6:	482e      	ldr	r0, [pc, #184]	; (8025080 <SendDiagnostics+0x190>)
 8024fc8:	f7fe ffeb 	bl	8023fa2 <CAN_NODE_MO_UpdateID>
	CAN_NODE_MO_UpdateData(&CAN_INT_LMO_03_Config, &Can2TxData3[0]);
 8024fcc:	4929      	ldr	r1, [pc, #164]	; (8025074 <SendDiagnostics+0x184>)
 8024fce:	482c      	ldr	r0, [pc, #176]	; (8025080 <SendDiagnostics+0x190>)
 8024fd0:	f005 f83e 	bl	802a050 <CAN_NODE_MO_UpdateData>
	CAN_NODE_MO_Transmit(&CAN_INT_LMO_03_Config);
 8024fd4:	482a      	ldr	r0, [pc, #168]	; (8025080 <SendDiagnostics+0x190>)
 8024fd6:	f005 f817 	bl	802a008 <CAN_NODE_MO_Transmit>

	temp16 = OpenTime/10;
 8024fda:	4b2a      	ldr	r3, [pc, #168]	; (8025084 <SendDiagnostics+0x194>)
 8024fdc:	881b      	ldrh	r3, [r3, #0]
 8024fde:	4a2a      	ldr	r2, [pc, #168]	; (8025088 <SendDiagnostics+0x198>)
 8024fe0:	fba2 2303 	umull	r2, r3, r2, r3
 8024fe4:	08db      	lsrs	r3, r3, #3
 8024fe6:	807b      	strh	r3, [r7, #2]
	temp8 = (uint8_t)temp16;
 8024fe8:	887b      	ldrh	r3, [r7, #2]
 8024fea:	707b      	strb	r3, [r7, #1]
	Can2TxData2[0] = temp8;
 8024fec:	4a27      	ldr	r2, [pc, #156]	; (802508c <SendDiagnostics+0x19c>)
 8024fee:	787b      	ldrb	r3, [r7, #1]
 8024ff0:	7013      	strb	r3, [r2, #0]

	temp16 = CloseTime/10;
 8024ff2:	4b27      	ldr	r3, [pc, #156]	; (8025090 <SendDiagnostics+0x1a0>)
 8024ff4:	881b      	ldrh	r3, [r3, #0]
 8024ff6:	4a24      	ldr	r2, [pc, #144]	; (8025088 <SendDiagnostics+0x198>)
 8024ff8:	fba2 2303 	umull	r2, r3, r2, r3
 8024ffc:	08db      	lsrs	r3, r3, #3
 8024ffe:	807b      	strh	r3, [r7, #2]
	temp8 = (uint8_t)temp16;
 8025000:	887b      	ldrh	r3, [r7, #2]
 8025002:	707b      	strb	r3, [r7, #1]
	Can2TxData2[1] = temp8;
 8025004:	4a21      	ldr	r2, [pc, #132]	; (802508c <SendDiagnostics+0x19c>)
 8025006:	787b      	ldrb	r3, [r7, #1]
 8025008:	7053      	strb	r3, [r2, #1]

	p16 = (uint16_t*)(Can2TxData2 + 2);
 802500a:	4b22      	ldr	r3, [pc, #136]	; (8025094 <SendDiagnostics+0x1a4>)
 802500c:	607b      	str	r3, [r7, #4]
	//*p32 = Presets.CYCLES_COUNTER;
	*p16 = Inputs.InputPower;
 802500e:	4b18      	ldr	r3, [pc, #96]	; (8025070 <SendDiagnostics+0x180>)
 8025010:	899a      	ldrh	r2, [r3, #12]
 8025012:	687b      	ldr	r3, [r7, #4]
 8025014:	801a      	strh	r2, [r3, #0]

	CAN_NODE_MO_UpdateID(&CAN_INT_LMO_02_Config, 0x65);
 8025016:	2165      	movs	r1, #101	; 0x65
 8025018:	481f      	ldr	r0, [pc, #124]	; (8025098 <SendDiagnostics+0x1a8>)
 802501a:	f7fe ffc2 	bl	8023fa2 <CAN_NODE_MO_UpdateID>
	CAN_NODE_MO_UpdateData(&CAN_INT_LMO_02_Config, &Can2TxData2[0]);
 802501e:	491b      	ldr	r1, [pc, #108]	; (802508c <SendDiagnostics+0x19c>)
 8025020:	481d      	ldr	r0, [pc, #116]	; (8025098 <SendDiagnostics+0x1a8>)
 8025022:	f005 f815 	bl	802a050 <CAN_NODE_MO_UpdateData>
	CAN_NODE_MO_Transmit(&CAN_INT_LMO_02_Config);
 8025026:	481c      	ldr	r0, [pc, #112]	; (8025098 <SendDiagnostics+0x1a8>)
 8025028:	f004 ffee 	bl	802a008 <CAN_NODE_MO_Transmit>
//	CAN_NODE_MO_UpdateID(&CAN_2_LMO_02_Config, 0x65);
//	CAN_NODE_MO_UpdateData(&CAN_2_LMO_02_Config, &Can2TxData2[0]);
//	CAN_NODE_MO_Transmit(&CAN_2_LMO_02_Config);
//

	send_timer++;
 802502c:	4b1b      	ldr	r3, [pc, #108]	; (802509c <SendDiagnostics+0x1ac>)
 802502e:	681b      	ldr	r3, [r3, #0]
 8025030:	3301      	adds	r3, #1
 8025032:	4a1a      	ldr	r2, [pc, #104]	; (802509c <SendDiagnostics+0x1ac>)
 8025034:	6013      	str	r3, [r2, #0]
	if((send_timer >= 10)) // send 1 message per second
 8025036:	4b19      	ldr	r3, [pc, #100]	; (802509c <SendDiagnostics+0x1ac>)
 8025038:	681b      	ldr	r3, [r3, #0]
 802503a:	2b09      	cmp	r3, #9
 802503c:	dd02      	ble.n	8025044 <SendDiagnostics+0x154>
	{
		send_timer = 0;
 802503e:	4b17      	ldr	r3, [pc, #92]	; (802509c <SendDiagnostics+0x1ac>)
 8025040:	2200      	movs	r2, #0
 8025042:	601a      	str	r2, [r3, #0]
		CAN_NODE_MO_Transmit(&CAN_INT_LMO_02_Config);
*/
	}


}
 8025044:	bf00      	nop
 8025046:	3708      	adds	r7, #8
 8025048:	46bd      	mov	sp, r7
 802504a:	bd80      	pop	{r7, pc}
 802504c:	200006f8 	.word	0x200006f8
 8025050:	20000fc4 	.word	0x20000fc4
 8025054:	200006d8 	.word	0x200006d8
 8025058:	20000600 	.word	0x20000600
 802505c:	200006da 	.word	0x200006da
 8025060:	200006dc 	.word	0x200006dc
 8025064:	20000654 	.word	0x20000654
 8025068:	200006de 	.word	0x200006de
 802506c:	0802b678 	.word	0x0802b678
 8025070:	20000674 	.word	0x20000674
 8025074:	200006e8 	.word	0x200006e8
 8025078:	200006ec 	.word	0x200006ec
 802507c:	200006ee 	.word	0x200006ee
 8025080:	0802b690 	.word	0x0802b690
 8025084:	200006cc 	.word	0x200006cc
 8025088:	cccccccd 	.word	0xcccccccd
 802508c:	200006e0 	.word	0x200006e0
 8025090:	200006ce 	.word	0x200006ce
 8025094:	200006e2 	.word	0x200006e2
 8025098:	0802b684 	.word	0x0802b684
 802509c:	2000072c 	.word	0x2000072c

080250a0 <SaveProc>:


void SaveProc(void *args)
{
 80250a0:	b580      	push	{r7, lr}
 80250a2:	b084      	sub	sp, #16
 80250a4:	af00      	add	r7, sp, #0
 80250a6:	6078      	str	r0, [r7, #4]
	static int32_t count = 0;

	count++;
 80250a8:	4b0c      	ldr	r3, [pc, #48]	; (80250dc <SaveProc+0x3c>)
 80250aa:	681b      	ldr	r3, [r3, #0]
 80250ac:	3301      	adds	r3, #1
 80250ae:	4a0b      	ldr	r2, [pc, #44]	; (80250dc <SaveProc+0x3c>)
 80250b0:	6013      	str	r3, [r2, #0]
	if (count >= 300) // 1 time per 5 minutes
 80250b2:	4b0a      	ldr	r3, [pc, #40]	; (80250dc <SaveProc+0x3c>)
 80250b4:	681b      	ldr	r3, [r3, #0]
 80250b6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80250ba:	db0b      	blt.n	80250d4 <SaveProc+0x34>
	{
		if (MS_CLOSED == MainState)
 80250bc:	4b08      	ldr	r3, [pc, #32]	; (80250e0 <SaveProc+0x40>)
 80250be:	681b      	ldr	r3, [r3, #0]
 80250c0:	2b03      	cmp	r3, #3
 80250c2:	d107      	bne.n	80250d4 <SaveProc+0x34>
			{
				//E_EEPROM_XMC4_STATUS_t status = SaveParameter( &Presets, (pntrParam_t)&Presets.CyclesCounter);
				E_EEPROM_XMC4_STATUS_t status = SaveAllPresets( &Presets);//
 80250c4:	4807      	ldr	r0, [pc, #28]	; (80250e4 <SaveProc+0x44>)
 80250c6:	f000 fe6e 	bl	8025da6 <SaveAllPresets>
 80250ca:	4603      	mov	r3, r0
 80250cc:	73fb      	strb	r3, [r7, #15]
				count = 0;
 80250ce:	4b03      	ldr	r3, [pc, #12]	; (80250dc <SaveProc+0x3c>)
 80250d0:	2200      	movs	r2, #0
 80250d2:	601a      	str	r2, [r3, #0]
			}
	}
}
 80250d4:	bf00      	nop
 80250d6:	3710      	adds	r7, #16
 80250d8:	46bd      	mov	sp, r7
 80250da:	bd80      	pop	{r7, pc}
 80250dc:	20000730 	.word	0x20000730
 80250e0:	200006f8 	.word	0x200006f8
 80250e4:	20000764 	.word	0x20000764

080250e8 <Homing>:
//int32_t Max_Open_current = 0;
//int32_t Max_Velocity = 0;
//int32_t Min_Velocity = 0;
//
int32_t Homing(int32_t cmd)
{
 80250e8:	b580      	push	{r7, lr}
 80250ea:	b084      	sub	sp, #16
 80250ec:	af00      	add	r7, sp, #0
 80250ee:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 80250f0:	2300      	movs	r3, #0
 80250f2:	60fb      	str	r3, [r7, #12]
	static int32_t state = 0;
	static int32_t pause = 0;
	static int32_t tim = 0;

	tim++;
 80250f4:	4ba0      	ldr	r3, [pc, #640]	; (8025378 <Homing+0x290>)
 80250f6:	681b      	ldr	r3, [r3, #0]
 80250f8:	3301      	adds	r3, #1
 80250fa:	4a9f      	ldr	r2, [pc, #636]	; (8025378 <Homing+0x290>)
 80250fc:	6013      	str	r3, [r2, #0]

	if(tim >= 2000)
 80250fe:	4b9e      	ldr	r3, [pc, #632]	; (8025378 <Homing+0x290>)
 8025100:	681b      	ldr	r3, [r3, #0]
 8025102:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8025106:	db0d      	blt.n	8025124 <Homing+0x3c>
	{
		MotorStop();
 8025108:	f7fd fd9c 	bl	8022c44 <MotorStop>
		state = 0;
 802510c:	4b9b      	ldr	r3, [pc, #620]	; (802537c <Homing+0x294>)
 802510e:	2200      	movs	r2, #0
 8025110:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025112:	4b99      	ldr	r3, [pc, #612]	; (8025378 <Homing+0x290>)
 8025114:	2200      	movs	r2, #0
 8025116:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025118:	4b99      	ldr	r3, [pc, #612]	; (8025380 <Homing+0x298>)
 802511a:	2200      	movs	r2, #0
 802511c:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 802511e:	f04f 33ff 	mov.w	r3, #4294967295
 8025122:	e15a      	b.n	80253da <Homing+0x2f2>
	}
	if (drive.Current >= 1500)
 8025124:	4b97      	ldr	r3, [pc, #604]	; (8025384 <Homing+0x29c>)
 8025126:	885b      	ldrh	r3, [r3, #2]
 8025128:	f240 52db 	movw	r2, #1499	; 0x5db
 802512c:	4293      	cmp	r3, r2
 802512e:	d90d      	bls.n	802514c <Homing+0x64>
	{
		MotorStop();
 8025130:	f7fd fd88 	bl	8022c44 <MotorStop>
		state = 0;
 8025134:	4b91      	ldr	r3, [pc, #580]	; (802537c <Homing+0x294>)
 8025136:	2200      	movs	r2, #0
 8025138:	601a      	str	r2, [r3, #0]
		tim = 0;
 802513a:	4b8f      	ldr	r3, [pc, #572]	; (8025378 <Homing+0x290>)
 802513c:	2200      	movs	r2, #0
 802513e:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025140:	4b8f      	ldr	r3, [pc, #572]	; (8025380 <Homing+0x298>)
 8025142:	2200      	movs	r2, #0
 8025144:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 8025146:	f06f 0301 	mvn.w	r3, #1
 802514a:	e146      	b.n	80253da <Homing+0x2f2>
	}


	if(!cmd)
 802514c:	687b      	ldr	r3, [r7, #4]
 802514e:	2b00      	cmp	r3, #0
 8025150:	d10c      	bne.n	802516c <Homing+0x84>
	{
		MotorStop();
 8025152:	f7fd fd77 	bl	8022c44 <MotorStop>
		state = 0;
 8025156:	4b89      	ldr	r3, [pc, #548]	; (802537c <Homing+0x294>)
 8025158:	2200      	movs	r2, #0
 802515a:	601a      	str	r2, [r3, #0]
		tim = 0;
 802515c:	4b86      	ldr	r3, [pc, #536]	; (8025378 <Homing+0x290>)
 802515e:	2200      	movs	r2, #0
 8025160:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025162:	4b87      	ldr	r3, [pc, #540]	; (8025380 <Homing+0x298>)
 8025164:	2200      	movs	r2, #0
 8025166:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8025168:	2300      	movs	r3, #0
 802516a:	e136      	b.n	80253da <Homing+0x2f2>
	}
	else
	{
		switch (state)
 802516c:	4b83      	ldr	r3, [pc, #524]	; (802537c <Homing+0x294>)
 802516e:	681b      	ldr	r3, [r3, #0]
 8025170:	2b05      	cmp	r3, #5
 8025172:	f200 812b 	bhi.w	80253cc <Homing+0x2e4>
 8025176:	a201      	add	r2, pc, #4	; (adr r2, 802517c <Homing+0x94>)
 8025178:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802517c:	08025195 	.word	0x08025195
 8025180:	080251d1 	.word	0x080251d1
 8025184:	080251ef 	.word	0x080251ef
 8025188:	08025253 	.word	0x08025253
 802518c:	08025317 	.word	0x08025317
 8025190:	0802539d 	.word	0x0802539d
		{
		case 0:
		{
			MotorClearError();
 8025194:	f7fd fd8e 	bl	8022cb4 <MotorClearError>
			MotorSetPILimit(40);
 8025198:	2028      	movs	r0, #40	; 0x28
 802519a:	f7fd fd7e 	bl	8022c9a <MotorSetPILimit>
			MotorSetProportionalGain(500);
 802519e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80251a2:	f7fd fd60 	bl	8022c66 <MotorSetProportionalGain>
			MotorSetIntegralGain(10);
 80251a6:	200a      	movs	r0, #10
 80251a8:	f7fd fd6a 	bl	8022c80 <MotorSetIntegralGain>
			MotorSetSpeed(Presets.CLOSE_DIR * 150); //(Presets.CLOSE_DIR));
 80251ac:	4b76      	ldr	r3, [pc, #472]	; (8025388 <Homing+0x2a0>)
 80251ae:	681b      	ldr	r3, [r3, #0]
 80251b0:	2296      	movs	r2, #150	; 0x96
 80251b2:	fb02 f303 	mul.w	r3, r2, r3
 80251b6:	4618      	mov	r0, r3
 80251b8:	f7fd fd4a 	bl	8022c50 <MotorSetSpeed>
			MotorStart();
 80251bc:	f7fd fd3c 	bl	8022c38 <MotorStart>
			state++;
 80251c0:	4b6e      	ldr	r3, [pc, #440]	; (802537c <Homing+0x294>)
 80251c2:	681b      	ldr	r3, [r3, #0]
 80251c4:	3301      	adds	r3, #1
 80251c6:	4a6d      	ldr	r2, [pc, #436]	; (802537c <Homing+0x294>)
 80251c8:	6013      	str	r3, [r2, #0]
			result = 0;
 80251ca:	2300      	movs	r3, #0
 80251cc:	60fb      	str	r3, [r7, #12]
		}
		break;
 80251ce:	e103      	b.n	80253d8 <Homing+0x2f0>
		case 1:
		{
			if(drive.Current >= 200)
 80251d0:	4b6c      	ldr	r3, [pc, #432]	; (8025384 <Homing+0x29c>)
 80251d2:	885b      	ldrh	r3, [r3, #2]
 80251d4:	2bc7      	cmp	r3, #199	; 0xc7
 80251d6:	f240 80fc 	bls.w	80253d2 <Homing+0x2ea>
			{
				MotorStop();
 80251da:	f7fd fd33 	bl	8022c44 <MotorStop>
				state++;
 80251de:	4b67      	ldr	r3, [pc, #412]	; (802537c <Homing+0x294>)
 80251e0:	681b      	ldr	r3, [r3, #0]
 80251e2:	3301      	adds	r3, #1
 80251e4:	4a65      	ldr	r2, [pc, #404]	; (802537c <Homing+0x294>)
 80251e6:	6013      	str	r3, [r2, #0]
				result = 0;
 80251e8:	2300      	movs	r3, #0
 80251ea:	60fb      	str	r3, [r7, #12]
			}
		}
		break;
 80251ec:	e0f1      	b.n	80253d2 <Homing+0x2ea>

			case 2:
			{
				WriteClutch(CLUTCH_UNLOCK);
 80251ee:	2001      	movs	r0, #1
 80251f0:	f7fe fb64 	bl	80238bc <WriteClutch>
				pause++;
 80251f4:	4b62      	ldr	r3, [pc, #392]	; (8025380 <Homing+0x298>)
 80251f6:	681b      	ldr	r3, [r3, #0]
 80251f8:	3301      	adds	r3, #1
 80251fa:	4a61      	ldr	r2, [pc, #388]	; (8025380 <Homing+0x298>)
 80251fc:	6013      	str	r3, [r2, #0]
				if(pause >= 20)
 80251fe:	4b60      	ldr	r3, [pc, #384]	; (8025380 <Homing+0x298>)
 8025200:	681b      	ldr	r3, [r3, #0]
 8025202:	2b13      	cmp	r3, #19
 8025204:	dd16      	ble.n	8025234 <Homing+0x14c>
				{
					//pause = 0;
					//state = 1;
					MotorClearError();
 8025206:	f7fd fd55 	bl	8022cb4 <MotorClearError>
					MotorSetPILimit(60);
 802520a:	203c      	movs	r0, #60	; 0x3c
 802520c:	f7fd fd45 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(500);
 8025210:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8025214:	f7fd fd27 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(5);
 8025218:	2005      	movs	r0, #5
 802521a:	f7fd fd31 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 300); //(Presets.CLOSE_DIR));
 802521e:	4b5a      	ldr	r3, [pc, #360]	; (8025388 <Homing+0x2a0>)
 8025220:	681b      	ldr	r3, [r3, #0]
 8025222:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8025226:	fb02 f303 	mul.w	r3, r2, r3
 802522a:	4618      	mov	r0, r3
 802522c:	f7fd fd10 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025230:	f7fd fd02 	bl	8022c38 <MotorStart>
				}
				if(pause >= 23) // to eat start stable
 8025234:	4b52      	ldr	r3, [pc, #328]	; (8025380 <Homing+0x298>)
 8025236:	681b      	ldr	r3, [r3, #0]
 8025238:	2b16      	cmp	r3, #22
 802523a:	dd07      	ble.n	802524c <Homing+0x164>
				{
					pause = 0;
 802523c:	4b50      	ldr	r3, [pc, #320]	; (8025380 <Homing+0x298>)
 802523e:	2200      	movs	r2, #0
 8025240:	601a      	str	r2, [r3, #0]
					state++;
 8025242:	4b4e      	ldr	r3, [pc, #312]	; (802537c <Homing+0x294>)
 8025244:	681b      	ldr	r3, [r3, #0]
 8025246:	3301      	adds	r3, #1
 8025248:	4a4c      	ldr	r2, [pc, #304]	; (802537c <Homing+0x294>)
 802524a:	6013      	str	r3, [r2, #0]
				}
				result = 0;
 802524c:	2300      	movs	r3, #0
 802524e:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025250:	e0c2      	b.n	80253d8 <Homing+0x2f0>

			case 3:
			{

				if(((drive.Current >= 2000) && !CloseSensor && !ServiceMode) || ActiveRubberL)
 8025252:	4b4c      	ldr	r3, [pc, #304]	; (8025384 <Homing+0x29c>)
 8025254:	885b      	ldrh	r3, [r3, #2]
 8025256:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 802525a:	d307      	bcc.n	802526c <Homing+0x184>
 802525c:	4b4b      	ldr	r3, [pc, #300]	; (802538c <Homing+0x2a4>)
 802525e:	681b      	ldr	r3, [r3, #0]
 8025260:	2b00      	cmp	r3, #0
 8025262:	d103      	bne.n	802526c <Homing+0x184>
 8025264:	4b4a      	ldr	r3, [pc, #296]	; (8025390 <Homing+0x2a8>)
 8025266:	681b      	ldr	r3, [r3, #0]
 8025268:	2b00      	cmp	r3, #0
 802526a:	d003      	beq.n	8025274 <Homing+0x18c>
 802526c:	4b49      	ldr	r3, [pc, #292]	; (8025394 <Homing+0x2ac>)
 802526e:	681b      	ldr	r3, [r3, #0]
 8025270:	2b00      	cmp	r3, #0
 8025272:	d008      	beq.n	8025286 <Homing+0x19e>
				{
					WriteClutch(CLUTCH_UNLOCK);
 8025274:	2001      	movs	r0, #1
 8025276:	f7fe fb21 	bl	80238bc <WriteClutch>
					MotorStop();
 802527a:	f7fd fce3 	bl	8022c44 <MotorStop>
					result = -4;
 802527e:	f06f 0303 	mvn.w	r3, #3
 8025282:	60fb      	str	r3, [r7, #12]
 8025284:	e001      	b.n	802528a <Homing+0x1a2>
				}
				else
				{
					result = 0;
 8025286:	2300      	movs	r3, #0
 8025288:	60fb      	str	r3, [r7, #12]
				}

				if((!ServiceMode && CloseSensor && (drive.Current >= 300)) || (ServiceMode && (drive.Current >= 300)) || (ServiceMode && (drive.Current >= 300) && serv_from_but))//
 802528a:	4b41      	ldr	r3, [pc, #260]	; (8025390 <Homing+0x2a8>)
 802528c:	681b      	ldr	r3, [r3, #0]
 802528e:	2b00      	cmp	r3, #0
 8025290:	d108      	bne.n	80252a4 <Homing+0x1bc>
 8025292:	4b3e      	ldr	r3, [pc, #248]	; (802538c <Homing+0x2a4>)
 8025294:	681b      	ldr	r3, [r3, #0]
 8025296:	2b00      	cmp	r3, #0
 8025298:	d004      	beq.n	80252a4 <Homing+0x1bc>
 802529a:	4b3a      	ldr	r3, [pc, #232]	; (8025384 <Homing+0x29c>)
 802529c:	885b      	ldrh	r3, [r3, #2]
 802529e:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80252a2:	d218      	bcs.n	80252d6 <Homing+0x1ee>
 80252a4:	4b3a      	ldr	r3, [pc, #232]	; (8025390 <Homing+0x2a8>)
 80252a6:	681b      	ldr	r3, [r3, #0]
 80252a8:	2b00      	cmp	r3, #0
 80252aa:	d004      	beq.n	80252b6 <Homing+0x1ce>
 80252ac:	4b35      	ldr	r3, [pc, #212]	; (8025384 <Homing+0x29c>)
 80252ae:	885b      	ldrh	r3, [r3, #2]
 80252b0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80252b4:	d20f      	bcs.n	80252d6 <Homing+0x1ee>
 80252b6:	4b36      	ldr	r3, [pc, #216]	; (8025390 <Homing+0x2a8>)
 80252b8:	681b      	ldr	r3, [r3, #0]
 80252ba:	2b00      	cmp	r3, #0
 80252bc:	f000 808b 	beq.w	80253d6 <Homing+0x2ee>
 80252c0:	4b30      	ldr	r3, [pc, #192]	; (8025384 <Homing+0x29c>)
 80252c2:	885b      	ldrh	r3, [r3, #2]
 80252c4:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 80252c8:	f0c0 8085 	bcc.w	80253d6 <Homing+0x2ee>
 80252cc:	4b32      	ldr	r3, [pc, #200]	; (8025398 <Homing+0x2b0>)
 80252ce:	681b      	ldr	r3, [r3, #0]
 80252d0:	2b00      	cmp	r3, #0
 80252d2:	f000 8080 	beq.w	80253d6 <Homing+0x2ee>
				{
					WriteClutch(CLUTCH_LOCK);
 80252d6:	2000      	movs	r0, #0
 80252d8:	f7fe faf0 	bl	80238bc <WriteClutch>
					MotorSetProportionalGain(300);
 80252dc:	f44f 7096 	mov.w	r0, #300	; 0x12c
 80252e0:	f7fd fcc1 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 80252e4:	200a      	movs	r0, #10
 80252e6:	f7fd fccb 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetPILimit(20);
 80252ea:	2014      	movs	r0, #20
 80252ec:	f7fd fcd5 	bl	8022c9a <MotorSetPILimit>
					MotorSetSpeed(Presets.CLOSE_DIR * 5);
 80252f0:	4b25      	ldr	r3, [pc, #148]	; (8025388 <Homing+0x2a0>)
 80252f2:	681a      	ldr	r2, [r3, #0]
 80252f4:	4613      	mov	r3, r2
 80252f6:	009b      	lsls	r3, r3, #2
 80252f8:	4413      	add	r3, r2
 80252fa:	4618      	mov	r0, r3
 80252fc:	f7fd fca8 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025300:	f7fd fc9a 	bl	8022c38 <MotorStart>
					state++;
 8025304:	4b1d      	ldr	r3, [pc, #116]	; (802537c <Homing+0x294>)
 8025306:	681b      	ldr	r3, [r3, #0]
 8025308:	3301      	adds	r3, #1
 802530a:	4a1c      	ldr	r2, [pc, #112]	; (802537c <Homing+0x294>)
 802530c:	6013      	str	r3, [r2, #0]
					pause = 0;
 802530e:	4b1c      	ldr	r3, [pc, #112]	; (8025380 <Homing+0x298>)
 8025310:	2200      	movs	r2, #0
 8025312:	601a      	str	r2, [r3, #0]
				}

			}
				break;
 8025314:	e05f      	b.n	80253d6 <Homing+0x2ee>

			case 4:
			{
				WriteClutch(CLUTCH_LOCK);
 8025316:	2000      	movs	r0, #0
 8025318:	f7fe fad0 	bl	80238bc <WriteClutch>
				pause++;
 802531c:	4b18      	ldr	r3, [pc, #96]	; (8025380 <Homing+0x298>)
 802531e:	681b      	ldr	r3, [r3, #0]
 8025320:	3301      	adds	r3, #1
 8025322:	4a17      	ldr	r2, [pc, #92]	; (8025380 <Homing+0x298>)
 8025324:	6013      	str	r3, [r2, #0]

				if (pause >= 20)//Presets.HOMING_CLUTCH_LOCK_PAUSE)
 8025326:	4b16      	ldr	r3, [pc, #88]	; (8025380 <Homing+0x298>)
 8025328:	681b      	ldr	r3, [r3, #0]
 802532a:	2b13      	cmp	r3, #19
 802532c:	dd21      	ble.n	8025372 <Homing+0x28a>
				{
					//MotorStop();
					drive.RAWPosition = 0;
 802532e:	4b15      	ldr	r3, [pc, #84]	; (8025384 <Homing+0x29c>)
 8025330:	2200      	movs	r2, #0
 8025332:	609a      	str	r2, [r3, #8]
					MotorSetPILimit(5);
 8025334:	2005      	movs	r0, #5
 8025336:	f7fd fcb0 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(100);
 802533a:	2064      	movs	r0, #100	; 0x64
 802533c:	f7fd fc93 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(1);
 8025340:	2001      	movs	r0, #1
 8025342:	f7fd fc9d 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 5);
 8025346:	4b10      	ldr	r3, [pc, #64]	; (8025388 <Homing+0x2a0>)
 8025348:	681a      	ldr	r2, [r3, #0]
 802534a:	4613      	mov	r3, r2
 802534c:	009b      	lsls	r3, r3, #2
 802534e:	4413      	add	r3, r2
 8025350:	4618      	mov	r0, r3
 8025352:	f7fd fc7d 	bl	8022c50 <MotorSetSpeed>
					result = 0; // success
 8025356:	2300      	movs	r3, #0
 8025358:	60fb      	str	r3, [r7, #12]
					pause = 0;
 802535a:	4b09      	ldr	r3, [pc, #36]	; (8025380 <Homing+0x298>)
 802535c:	2200      	movs	r2, #0
 802535e:	601a      	str	r2, [r3, #0]
					tim = 0;
 8025360:	4b05      	ldr	r3, [pc, #20]	; (8025378 <Homing+0x290>)
 8025362:	2200      	movs	r2, #0
 8025364:	601a      	str	r2, [r3, #0]
					state++;
 8025366:	4b05      	ldr	r3, [pc, #20]	; (802537c <Homing+0x294>)
 8025368:	681b      	ldr	r3, [r3, #0]
 802536a:	3301      	adds	r3, #1
 802536c:	4a03      	ldr	r2, [pc, #12]	; (802537c <Homing+0x294>)
 802536e:	6013      	str	r3, [r2, #0]
				else
				{
					result = 0;
				}
			}
				break;
 8025370:	e032      	b.n	80253d8 <Homing+0x2f0>
					result = 0;
 8025372:	2300      	movs	r3, #0
 8025374:	60fb      	str	r3, [r7, #12]
				break;
 8025376:	e02f      	b.n	80253d8 <Homing+0x2f0>
 8025378:	20000734 	.word	0x20000734
 802537c:	20000738 	.word	0x20000738
 8025380:	2000073c 	.word	0x2000073c
 8025384:	20000600 	.word	0x20000600
 8025388:	20000764 	.word	0x20000764
 802538c:	20000654 	.word	0x20000654
 8025390:	20000fc4 	.word	0x20000fc4
 8025394:	20000650 	.word	0x20000650
 8025398:	20000708 	.word	0x20000708
			case 5:
			{
				pause ++;
 802539c:	4b11      	ldr	r3, [pc, #68]	; (80253e4 <Homing+0x2fc>)
 802539e:	681b      	ldr	r3, [r3, #0]
 80253a0:	3301      	adds	r3, #1
 80253a2:	4a10      	ldr	r2, [pc, #64]	; (80253e4 <Homing+0x2fc>)
 80253a4:	6013      	str	r3, [r2, #0]
				if (5 <= pause)
 80253a6:	4b0f      	ldr	r3, [pc, #60]	; (80253e4 <Homing+0x2fc>)
 80253a8:	681b      	ldr	r3, [r3, #0]
 80253aa:	2b04      	cmp	r3, #4
 80253ac:	dd0b      	ble.n	80253c6 <Homing+0x2de>
				{
					pause = 0;
 80253ae:	4b0d      	ldr	r3, [pc, #52]	; (80253e4 <Homing+0x2fc>)
 80253b0:	2200      	movs	r2, #0
 80253b2:	601a      	str	r2, [r3, #0]
					result = 1;
 80253b4:	2301      	movs	r3, #1
 80253b6:	60fb      	str	r3, [r7, #12]
					//drive.RAWPosition = 0;
					tim = 0;
 80253b8:	4b0b      	ldr	r3, [pc, #44]	; (80253e8 <Homing+0x300>)
 80253ba:	2200      	movs	r2, #0
 80253bc:	601a      	str	r2, [r3, #0]
					state = 0;
 80253be:	4b0b      	ldr	r3, [pc, #44]	; (80253ec <Homing+0x304>)
 80253c0:	2200      	movs	r2, #0
 80253c2:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
			break;
 80253c4:	e008      	b.n	80253d8 <Homing+0x2f0>
					result = 0;
 80253c6:	2300      	movs	r3, #0
 80253c8:	60fb      	str	r3, [r7, #12]
			break;
 80253ca:	e005      	b.n	80253d8 <Homing+0x2f0>
			default:
				return -3; // bad case;
 80253cc:	f06f 0302 	mvn.w	r3, #2
 80253d0:	e003      	b.n	80253da <Homing+0x2f2>
		break;
 80253d2:	bf00      	nop
 80253d4:	e000      	b.n	80253d8 <Homing+0x2f0>
				break;
 80253d6:	bf00      	nop

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 80253d8:	68fb      	ldr	r3, [r7, #12]
}
 80253da:	4618      	mov	r0, r3
 80253dc:	3710      	adds	r7, #16
 80253de:	46bd      	mov	sp, r7
 80253e0:	bd80      	pop	{r7, pc}
 80253e2:	bf00      	nop
 80253e4:	2000073c 	.word	0x2000073c
 80253e8:	20000734 	.word	0x20000734
 80253ec:	20000738 	.word	0x20000738

080253f0 <CloseDoor>:


int32_t CloseDoor(int32_t cmd)
{
 80253f0:	b580      	push	{r7, lr}
 80253f2:	b084      	sub	sp, #16
 80253f4:	af00      	add	r7, sp, #0
 80253f6:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 80253f8:	2300      	movs	r3, #0
 80253fa:	60fb      	str	r3, [r7, #12]
	static int32_t state = 0;
	static int32_t pause = 0;
	static int32_t tim = 0;


	tim++;
 80253fc:	4b89      	ldr	r3, [pc, #548]	; (8025624 <CloseDoor+0x234>)
 80253fe:	681b      	ldr	r3, [r3, #0]
 8025400:	3301      	adds	r3, #1
 8025402:	4a88      	ldr	r2, [pc, #544]	; (8025624 <CloseDoor+0x234>)
 8025404:	6013      	str	r3, [r2, #0]

	if(tim >= 1000)
 8025406:	4b87      	ldr	r3, [pc, #540]	; (8025624 <CloseDoor+0x234>)
 8025408:	681b      	ldr	r3, [r3, #0]
 802540a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 802540e:	db0d      	blt.n	802542c <CloseDoor+0x3c>
	{
		MotorStop();
 8025410:	f7fd fc18 	bl	8022c44 <MotorStop>
		state = 0;
 8025414:	4b84      	ldr	r3, [pc, #528]	; (8025628 <CloseDoor+0x238>)
 8025416:	2200      	movs	r2, #0
 8025418:	601a      	str	r2, [r3, #0]
		tim = 0;
 802541a:	4b82      	ldr	r3, [pc, #520]	; (8025624 <CloseDoor+0x234>)
 802541c:	2200      	movs	r2, #0
 802541e:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025420:	4b82      	ldr	r3, [pc, #520]	; (802562c <CloseDoor+0x23c>)
 8025422:	2200      	movs	r2, #0
 8025424:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 8025426:	f04f 33ff 	mov.w	r3, #4294967295
 802542a:	e0f6      	b.n	802561a <CloseDoor+0x22a>
	}
	if (drive.Current >= 3000)
 802542c:	4b80      	ldr	r3, [pc, #512]	; (8025630 <CloseDoor+0x240>)
 802542e:	885b      	ldrh	r3, [r3, #2]
 8025430:	f640 32b7 	movw	r2, #2999	; 0xbb7
 8025434:	4293      	cmp	r3, r2
 8025436:	d90d      	bls.n	8025454 <CloseDoor+0x64>
	{
		MotorStop();
 8025438:	f7fd fc04 	bl	8022c44 <MotorStop>
		state = 0;
 802543c:	4b7a      	ldr	r3, [pc, #488]	; (8025628 <CloseDoor+0x238>)
 802543e:	2200      	movs	r2, #0
 8025440:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025442:	4b78      	ldr	r3, [pc, #480]	; (8025624 <CloseDoor+0x234>)
 8025444:	2200      	movs	r2, #0
 8025446:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025448:	4b78      	ldr	r3, [pc, #480]	; (802562c <CloseDoor+0x23c>)
 802544a:	2200      	movs	r2, #0
 802544c:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 802544e:	f06f 0301 	mvn.w	r3, #1
 8025452:	e0e2      	b.n	802561a <CloseDoor+0x22a>
	}


	if(!cmd)
 8025454:	687b      	ldr	r3, [r7, #4]
 8025456:	2b00      	cmp	r3, #0
 8025458:	d10c      	bne.n	8025474 <CloseDoor+0x84>
	{
		MotorStop();
 802545a:	f7fd fbf3 	bl	8022c44 <MotorStop>
		state = 0;
 802545e:	4b72      	ldr	r3, [pc, #456]	; (8025628 <CloseDoor+0x238>)
 8025460:	2200      	movs	r2, #0
 8025462:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025464:	4b6f      	ldr	r3, [pc, #444]	; (8025624 <CloseDoor+0x234>)
 8025466:	2200      	movs	r2, #0
 8025468:	601a      	str	r2, [r3, #0]
		pause = 0;
 802546a:	4b70      	ldr	r3, [pc, #448]	; (802562c <CloseDoor+0x23c>)
 802546c:	2200      	movs	r2, #0
 802546e:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8025470:	2300      	movs	r3, #0
 8025472:	e0d2      	b.n	802561a <CloseDoor+0x22a>
	}
	else
	{
		switch (state)
 8025474:	4b6c      	ldr	r3, [pc, #432]	; (8025628 <CloseDoor+0x238>)
 8025476:	681b      	ldr	r3, [r3, #0]
 8025478:	2b02      	cmp	r3, #2
 802547a:	f000 809d 	beq.w	80255b8 <CloseDoor+0x1c8>
 802547e:	2b02      	cmp	r3, #2
 8025480:	f300 80c6 	bgt.w	8025610 <CloseDoor+0x220>
 8025484:	2b00      	cmp	r3, #0
 8025486:	d002      	beq.n	802548e <CloseDoor+0x9e>
 8025488:	2b01      	cmp	r3, #1
 802548a:	d02a      	beq.n	80254e2 <CloseDoor+0xf2>
 802548c:	e0c0      	b.n	8025610 <CloseDoor+0x220>
		{
			case 0:
			{
				WriteClutch(CLUTCH_UNLOCK);
 802548e:	2001      	movs	r0, #1
 8025490:	f7fe fa14 	bl	80238bc <WriteClutch>
				pause++;
 8025494:	4b65      	ldr	r3, [pc, #404]	; (802562c <CloseDoor+0x23c>)
 8025496:	681b      	ldr	r3, [r3, #0]
 8025498:	3301      	adds	r3, #1
 802549a:	4a64      	ldr	r2, [pc, #400]	; (802562c <CloseDoor+0x23c>)
 802549c:	6013      	str	r3, [r2, #0]
//					Motor0_BLDC_SCALAR_SetSpeedVal(Presets.CLOSE_DIR * 1000);
//					Motor0_BLDC_SCALAR_MotorStart();
//				}
//
//
				if(pause >= 5)
 802549e:	4b63      	ldr	r3, [pc, #396]	; (802562c <CloseDoor+0x23c>)
 80254a0:	681b      	ldr	r3, [r3, #0]
 80254a2:	2b04      	cmp	r3, #4
 80254a4:	dd1a      	ble.n	80254dc <CloseDoor+0xec>
				{
					pause = 0;
 80254a6:	4b61      	ldr	r3, [pc, #388]	; (802562c <CloseDoor+0x23c>)
 80254a8:	2200      	movs	r2, #0
 80254aa:	601a      	str	r2, [r3, #0]
					state = 1;
 80254ac:	4b5e      	ldr	r3, [pc, #376]	; (8025628 <CloseDoor+0x238>)
 80254ae:	2201      	movs	r2, #1
 80254b0:	601a      	str	r2, [r3, #0]
					MotorSetPILimit(80);
 80254b2:	2050      	movs	r0, #80	; 0x50
 80254b4:	f7fd fbf1 	bl	8022c9a <MotorSetPILimit>
					MotorSetProportionalGain(1000);
 80254b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80254bc:	f7fd fbd3 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 80254c0:	200a      	movs	r0, #10
 80254c2:	f7fd fbdd 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 1200);
 80254c6:	4b5b      	ldr	r3, [pc, #364]	; (8025634 <CloseDoor+0x244>)
 80254c8:	681b      	ldr	r3, [r3, #0]
 80254ca:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80254ce:	fb02 f303 	mul.w	r3, r2, r3
 80254d2:	4618      	mov	r0, r3
 80254d4:	f7fd fbbc 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 80254d8:	f7fd fbae 	bl	8022c38 <MotorStart>
				}
				result = 0;
 80254dc:	2300      	movs	r3, #0
 80254de:	60fb      	str	r3, [r7, #12]
			}
				break;
 80254e0:	e09a      	b.n	8025618 <CloseDoor+0x228>
					Motor0_BLDC_SCALAR_SetSpeedVal(Presets.CLOSE_DIR * 600);
					Motor0_BLDC_SCALAR_MotorStart();
					result = 0;
				}
*/
				if((drive.Position <= 550) && (drive.Position > 120))
 80254e2:	4b53      	ldr	r3, [pc, #332]	; (8025630 <CloseDoor+0x240>)
 80254e4:	881b      	ldrh	r3, [r3, #0]
 80254e6:	f240 2226 	movw	r2, #550	; 0x226
 80254ea:	4293      	cmp	r3, r2
 80254ec:	d810      	bhi.n	8025510 <CloseDoor+0x120>
 80254ee:	4b50      	ldr	r3, [pc, #320]	; (8025630 <CloseDoor+0x240>)
 80254f0:	881b      	ldrh	r3, [r3, #0]
 80254f2:	2b78      	cmp	r3, #120	; 0x78
 80254f4:	d90c      	bls.n	8025510 <CloseDoor+0x120>
				{
					MotorSetSpeed(Presets.CLOSE_DIR * 300);
 80254f6:	4b4f      	ldr	r3, [pc, #316]	; (8025634 <CloseDoor+0x244>)
 80254f8:	681b      	ldr	r3, [r3, #0]
 80254fa:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80254fe:	fb02 f303 	mul.w	r3, r2, r3
 8025502:	4618      	mov	r0, r3
 8025504:	f7fd fba4 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025508:	f7fd fb96 	bl	8022c38 <MotorStart>
					result = 0;
 802550c:	2300      	movs	r3, #0
 802550e:	60fb      	str	r3, [r7, #12]
					else
					{
						result = 0;
					}*/
				}
				if((drive.Position <= 120) && (drive.Position > 20))
 8025510:	4b47      	ldr	r3, [pc, #284]	; (8025630 <CloseDoor+0x240>)
 8025512:	881b      	ldrh	r3, [r3, #0]
 8025514:	2b78      	cmp	r3, #120	; 0x78
 8025516:	d816      	bhi.n	8025546 <CloseDoor+0x156>
 8025518:	4b45      	ldr	r3, [pc, #276]	; (8025630 <CloseDoor+0x240>)
 802551a:	881b      	ldrh	r3, [r3, #0]
 802551c:	2b14      	cmp	r3, #20
 802551e:	d912      	bls.n	8025546 <CloseDoor+0x156>
				{
					MotorSetProportionalGain(500);
 8025520:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8025524:	f7fd fb9f 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(5);
 8025528:	2005      	movs	r0, #5
 802552a:	f7fd fba9 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 150);
 802552e:	4b41      	ldr	r3, [pc, #260]	; (8025634 <CloseDoor+0x244>)
 8025530:	681b      	ldr	r3, [r3, #0]
 8025532:	2296      	movs	r2, #150	; 0x96
 8025534:	fb02 f303 	mul.w	r3, r2, r3
 8025538:	4618      	mov	r0, r3
 802553a:	f7fd fb89 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 802553e:	f7fd fb7b 	bl	8022c38 <MotorStart>
					result = 0;
 8025542:	2300      	movs	r3, #0
 8025544:	60fb      	str	r3, [r7, #12]
						result = 0;
					}
					*/
				}
// blockge condition
				if(((drive.Current >= 2000) && (drive.Position >= 3)) || ActiveRubberL)// && !CloseSensor && !ServiceMode) || ActiveRubberL)
 8025546:	4b3a      	ldr	r3, [pc, #232]	; (8025630 <CloseDoor+0x240>)
 8025548:	885b      	ldrh	r3, [r3, #2]
 802554a:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 802554e:	d303      	bcc.n	8025558 <CloseDoor+0x168>
 8025550:	4b37      	ldr	r3, [pc, #220]	; (8025630 <CloseDoor+0x240>)
 8025552:	881b      	ldrh	r3, [r3, #0]
 8025554:	2b02      	cmp	r3, #2
 8025556:	d803      	bhi.n	8025560 <CloseDoor+0x170>
 8025558:	4b37      	ldr	r3, [pc, #220]	; (8025638 <CloseDoor+0x248>)
 802555a:	681b      	ldr	r3, [r3, #0]
 802555c:	2b00      	cmp	r3, #0
 802555e:	d008      	beq.n	8025572 <CloseDoor+0x182>
				{
					WriteClutch(CLUTCH_UNLOCK);
 8025560:	2001      	movs	r0, #1
 8025562:	f7fe f9ab 	bl	80238bc <WriteClutch>
					MotorStop();
 8025566:	f7fd fb6d 	bl	8022c44 <MotorStop>
					result = -4;
 802556a:	f06f 0303 	mvn.w	r3, #3
 802556e:	60fb      	str	r3, [r7, #12]
 8025570:	e001      	b.n	8025576 <CloseDoor+0x186>
				}
				else
				{
					result = 0;
 8025572:	2300      	movs	r3, #0
 8025574:	60fb      	str	r3, [r7, #12]
					WriteClutch(CLUTCH_LOCK);
					result = 0;
				}
*/
// closed successful
				if((/*(drive.Current > 400) && */(drive.Position <= 2)))// || ((CloseSensor) && (drive.Current >= 600)))//
 8025576:	4b2e      	ldr	r3, [pc, #184]	; (8025630 <CloseDoor+0x240>)
 8025578:	881b      	ldrh	r3, [r3, #0]
 802557a:	2b02      	cmp	r3, #2
 802557c:	d84b      	bhi.n	8025616 <CloseDoor+0x226>
				{
					WriteClutch(CLUTCH_LOCK);
 802557e:	2000      	movs	r0, #0
 8025580:	f7fe f99c 	bl	80238bc <WriteClutch>
					MotorSetProportionalGain(100);
 8025584:	2064      	movs	r0, #100	; 0x64
 8025586:	f7fd fb6e 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(1);
 802558a:	2001      	movs	r0, #1
 802558c:	f7fd fb78 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 20);
 8025590:	4b28      	ldr	r3, [pc, #160]	; (8025634 <CloseDoor+0x244>)
 8025592:	681a      	ldr	r2, [r3, #0]
 8025594:	4613      	mov	r3, r2
 8025596:	009b      	lsls	r3, r3, #2
 8025598:	4413      	add	r3, r2
 802559a:	009b      	lsls	r3, r3, #2
 802559c:	4618      	mov	r0, r3
 802559e:	f7fd fb57 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 80255a2:	f7fd fb49 	bl	8022c38 <MotorStart>
					state = 2;
 80255a6:	4b20      	ldr	r3, [pc, #128]	; (8025628 <CloseDoor+0x238>)
 80255a8:	2202      	movs	r2, #2
 80255aa:	601a      	str	r2, [r3, #0]
					result = 0;
 80255ac:	2300      	movs	r3, #0
 80255ae:	60fb      	str	r3, [r7, #12]
					pause = 0;
 80255b0:	4b1e      	ldr	r3, [pc, #120]	; (802562c <CloseDoor+0x23c>)
 80255b2:	2200      	movs	r2, #0
 80255b4:	601a      	str	r2, [r3, #0]
				//{
				//	result = -4;
				//	Motor0_BLDC_SCALAR_MotorStop();
				//}
			}
				break;
 80255b6:	e02e      	b.n	8025616 <CloseDoor+0x226>

			case 2:
			{
				WriteClutch(CLUTCH_LOCK);
 80255b8:	2000      	movs	r0, #0
 80255ba:	f7fe f97f 	bl	80238bc <WriteClutch>
				pause++;
 80255be:	4b1b      	ldr	r3, [pc, #108]	; (802562c <CloseDoor+0x23c>)
 80255c0:	681b      	ldr	r3, [r3, #0]
 80255c2:	3301      	adds	r3, #1
 80255c4:	4a19      	ldr	r2, [pc, #100]	; (802562c <CloseDoor+0x23c>)
 80255c6:	6013      	str	r3, [r2, #0]
				if (pause >= 40)//Presets.CLOSING_CLUTCH_LOCK_PAUSE)
 80255c8:	4b18      	ldr	r3, [pc, #96]	; (802562c <CloseDoor+0x23c>)
 80255ca:	681b      	ldr	r3, [r3, #0]
 80255cc:	2b27      	cmp	r3, #39	; 0x27
 80255ce:	dd1c      	ble.n	802560a <CloseDoor+0x21a>
				{
					{
						//MotorStop();
						MotorSetPILimit(5);
 80255d0:	2005      	movs	r0, #5
 80255d2:	f7fd fb62 	bl	8022c9a <MotorSetPILimit>
						MotorSetProportionalGain(100);
 80255d6:	2064      	movs	r0, #100	; 0x64
 80255d8:	f7fd fb45 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(1);
 80255dc:	2001      	movs	r0, #1
 80255de:	f7fd fb4f 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(Presets.CLOSE_DIR * 5);
 80255e2:	4b14      	ldr	r3, [pc, #80]	; (8025634 <CloseDoor+0x244>)
 80255e4:	681a      	ldr	r2, [r3, #0]
 80255e6:	4613      	mov	r3, r2
 80255e8:	009b      	lsls	r3, r3, #2
 80255ea:	4413      	add	r3, r2
 80255ec:	4618      	mov	r0, r3
 80255ee:	f7fd fb2f 	bl	8022c50 <MotorSetSpeed>
						state = 0;
 80255f2:	4b0d      	ldr	r3, [pc, #52]	; (8025628 <CloseDoor+0x238>)
 80255f4:	2200      	movs	r2, #0
 80255f6:	601a      	str	r2, [r3, #0]
						pause = 0;
 80255f8:	4b0c      	ldr	r3, [pc, #48]	; (802562c <CloseDoor+0x23c>)
 80255fa:	2200      	movs	r2, #0
 80255fc:	601a      	str	r2, [r3, #0]
						result = 1;
 80255fe:	2301      	movs	r3, #1
 8025600:	60fb      	str	r3, [r7, #12]
						tim = 0;
 8025602:	4b08      	ldr	r3, [pc, #32]	; (8025624 <CloseDoor+0x234>)
 8025604:	2200      	movs	r2, #0
 8025606:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
				break;
 8025608:	e006      	b.n	8025618 <CloseDoor+0x228>
					result = 0;
 802560a:	2300      	movs	r3, #0
 802560c:	60fb      	str	r3, [r7, #12]
				break;
 802560e:	e003      	b.n	8025618 <CloseDoor+0x228>
			default:
				return -3; // bad case;
 8025610:	f06f 0302 	mvn.w	r3, #2
 8025614:	e001      	b.n	802561a <CloseDoor+0x22a>
				break;
 8025616:	bf00      	nop

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025618:	68fb      	ldr	r3, [r7, #12]
}
 802561a:	4618      	mov	r0, r3
 802561c:	3710      	adds	r7, #16
 802561e:	46bd      	mov	sp, r7
 8025620:	bd80      	pop	{r7, pc}
 8025622:	bf00      	nop
 8025624:	20000740 	.word	0x20000740
 8025628:	20000744 	.word	0x20000744
 802562c:	20000748 	.word	0x20000748
 8025630:	20000600 	.word	0x20000600
 8025634:	20000764 	.word	0x20000764
 8025638:	20000650 	.word	0x20000650

0802563c <OpenDoor>:



int32_t OpenDoor (int32_t cmd)
{
 802563c:	b580      	push	{r7, lr}
 802563e:	b084      	sub	sp, #16
 8025640:	af00      	add	r7, sp, #0
 8025642:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8025644:	2300      	movs	r3, #0
 8025646:	60fb      	str	r3, [r7, #12]
	static int32_t pause = 0;
	static int32_t tim = 0;

	//static int32_t first_opening_done = 0;

	tim++;
 8025648:	4ba4      	ldr	r3, [pc, #656]	; (80258dc <OpenDoor+0x2a0>)
 802564a:	681b      	ldr	r3, [r3, #0]
 802564c:	3301      	adds	r3, #1
 802564e:	4aa3      	ldr	r2, [pc, #652]	; (80258dc <OpenDoor+0x2a0>)
 8025650:	6013      	str	r3, [r2, #0]


	if(tim >= 2000)
 8025652:	4ba2      	ldr	r3, [pc, #648]	; (80258dc <OpenDoor+0x2a0>)
 8025654:	681b      	ldr	r3, [r3, #0]
 8025656:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 802565a:	db0d      	blt.n	8025678 <OpenDoor+0x3c>
	{
		MotorStop();
 802565c:	f7fd faf2 	bl	8022c44 <MotorStop>
		state = 0;
 8025660:	4b9f      	ldr	r3, [pc, #636]	; (80258e0 <OpenDoor+0x2a4>)
 8025662:	2200      	movs	r2, #0
 8025664:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025666:	4b9d      	ldr	r3, [pc, #628]	; (80258dc <OpenDoor+0x2a0>)
 8025668:	2200      	movs	r2, #0
 802566a:	601a      	str	r2, [r3, #0]
		pause = 0;
 802566c:	4b9d      	ldr	r3, [pc, #628]	; (80258e4 <OpenDoor+0x2a8>)
 802566e:	2200      	movs	r2, #0
 8025670:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 8025672:	f04f 33ff 	mov.w	r3, #4294967295
 8025676:	e204      	b.n	8025a82 <OpenDoor+0x446>
	}
	if (drive.Current >= 3000)
 8025678:	4b9b      	ldr	r3, [pc, #620]	; (80258e8 <OpenDoor+0x2ac>)
 802567a:	885b      	ldrh	r3, [r3, #2]
 802567c:	f640 32b7 	movw	r2, #2999	; 0xbb7
 8025680:	4293      	cmp	r3, r2
 8025682:	d90d      	bls.n	80256a0 <OpenDoor+0x64>
	{
		MotorStop();
 8025684:	f7fd fade 	bl	8022c44 <MotorStop>
		state = 0;
 8025688:	4b95      	ldr	r3, [pc, #596]	; (80258e0 <OpenDoor+0x2a4>)
 802568a:	2200      	movs	r2, #0
 802568c:	601a      	str	r2, [r3, #0]
		tim = 0;
 802568e:	4b93      	ldr	r3, [pc, #588]	; (80258dc <OpenDoor+0x2a0>)
 8025690:	2200      	movs	r2, #0
 8025692:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025694:	4b93      	ldr	r3, [pc, #588]	; (80258e4 <OpenDoor+0x2a8>)
 8025696:	2200      	movs	r2, #0
 8025698:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 802569a:	f06f 0301 	mvn.w	r3, #1
 802569e:	e1f0      	b.n	8025a82 <OpenDoor+0x446>
	}


	if(!cmd)
 80256a0:	687b      	ldr	r3, [r7, #4]
 80256a2:	2b00      	cmp	r3, #0
 80256a4:	d10c      	bne.n	80256c0 <OpenDoor+0x84>
	{
		MotorStop();
 80256a6:	f7fd facd 	bl	8022c44 <MotorStop>
		state = 0;
 80256aa:	4b8d      	ldr	r3, [pc, #564]	; (80258e0 <OpenDoor+0x2a4>)
 80256ac:	2200      	movs	r2, #0
 80256ae:	601a      	str	r2, [r3, #0]
		pause = 0;
 80256b0:	4b8c      	ldr	r3, [pc, #560]	; (80258e4 <OpenDoor+0x2a8>)
 80256b2:	2200      	movs	r2, #0
 80256b4:	601a      	str	r2, [r3, #0]
		tim = 0;
 80256b6:	4b89      	ldr	r3, [pc, #548]	; (80258dc <OpenDoor+0x2a0>)
 80256b8:	2200      	movs	r2, #0
 80256ba:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 80256bc:	2300      	movs	r3, #0
 80256be:	e1e0      	b.n	8025a82 <OpenDoor+0x446>
	}
	else
	{
		switch (state)
 80256c0:	4b87      	ldr	r3, [pc, #540]	; (80258e0 <OpenDoor+0x2a4>)
 80256c2:	681b      	ldr	r3, [r3, #0]
 80256c4:	2b04      	cmp	r3, #4
 80256c6:	f200 81d7 	bhi.w	8025a78 <OpenDoor+0x43c>
 80256ca:	a201      	add	r2, pc, #4	; (adr r2, 80256d0 <OpenDoor+0x94>)
 80256cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80256d0:	080256e5 	.word	0x080256e5
 80256d4:	08025789 	.word	0x08025789
 80256d8:	080259cd 	.word	0x080259cd
 80256dc:	08025a0b 	.word	0x08025a0b
 80256e0:	08025a3f 	.word	0x08025a3f
		{
			case 0:
			{
				WriteClutch(CLUTCH_UNLOCK);
 80256e4:	2001      	movs	r0, #1
 80256e6:	f7fe f8e9 	bl	80238bc <WriteClutch>
				pause++;
 80256ea:	4b7e      	ldr	r3, [pc, #504]	; (80258e4 <OpenDoor+0x2a8>)
 80256ec:	681b      	ldr	r3, [r3, #0]
 80256ee:	3301      	adds	r3, #1
 80256f0:	4a7c      	ldr	r2, [pc, #496]	; (80258e4 <OpenDoor+0x2a8>)
 80256f2:	6013      	str	r3, [r2, #0]

				if(pause <= 10)
 80256f4:	4b7b      	ldr	r3, [pc, #492]	; (80258e4 <OpenDoor+0x2a8>)
 80256f6:	681b      	ldr	r3, [r3, #0]
 80256f8:	2b0a      	cmp	r3, #10
 80256fa:	dc01      	bgt.n	8025700 <OpenDoor+0xc4>
				{
					MotorStop();
 80256fc:	f7fd faa2 	bl	8022c44 <MotorStop>
//					{
//						Motor0_BLDC_SCALAR_MotorStop();
//					}
//				}

				if((pause > 10) && (pause <= 20))
 8025700:	4b78      	ldr	r3, [pc, #480]	; (80258e4 <OpenDoor+0x2a8>)
 8025702:	681b      	ldr	r3, [r3, #0]
 8025704:	2b0a      	cmp	r3, #10
 8025706:	dd19      	ble.n	802573c <OpenDoor+0x100>
 8025708:	4b76      	ldr	r3, [pc, #472]	; (80258e4 <OpenDoor+0x2a8>)
 802570a:	681b      	ldr	r3, [r3, #0]
 802570c:	2b14      	cmp	r3, #20
 802570e:	dc15      	bgt.n	802573c <OpenDoor+0x100>
				{
					MotorSetPILimit(80);
 8025710:	2050      	movs	r0, #80	; 0x50
 8025712:	f7fd fac2 	bl	8022c9a <MotorSetPILimit>
					MotorClearError();
 8025716:	f7fd facd 	bl	8022cb4 <MotorClearError>
					MotorSetProportionalGain(500);
 802571a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 802571e:	f7fd faa2 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(5);
 8025722:	2005      	movs	r0, #5
 8025724:	f7fd faac 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(Presets.CLOSE_DIR * 50);
 8025728:	4b70      	ldr	r3, [pc, #448]	; (80258ec <OpenDoor+0x2b0>)
 802572a:	681b      	ldr	r3, [r3, #0]
 802572c:	2232      	movs	r2, #50	; 0x32
 802572e:	fb02 f303 	mul.w	r3, r2, r3
 8025732:	4618      	mov	r0, r3
 8025734:	f7fd fa8c 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025738:	f7fd fa7e 	bl	8022c38 <MotorStart>

				}
//
				if(pause > 20)
 802573c:	4b69      	ldr	r3, [pc, #420]	; (80258e4 <OpenDoor+0x2a8>)
 802573e:	681b      	ldr	r3, [r3, #0]
 8025740:	2b14      	cmp	r3, #20
 8025742:	dd1e      	ble.n	8025782 <OpenDoor+0x146>
				{
					MotorSetPILimit(80);
 8025744:	2050      	movs	r0, #80	; 0x50
 8025746:	f7fd faa8 	bl	8022c9a <MotorSetPILimit>
					MotorClearError();
 802574a:	f7fd fab3 	bl	8022cb4 <MotorClearError>
					MotorSetProportionalGain(500);
 802574e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8025752:	f7fd fa88 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(5);
 8025756:	2005      	movs	r0, #5
 8025758:	f7fd fa92 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 200);
 802575c:	4b64      	ldr	r3, [pc, #400]	; (80258f0 <OpenDoor+0x2b4>)
 802575e:	681b      	ldr	r3, [r3, #0]
 8025760:	22c8      	movs	r2, #200	; 0xc8
 8025762:	fb02 f303 	mul.w	r3, r2, r3
 8025766:	4618      	mov	r0, r3
 8025768:	f7fd fa72 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 802576c:	f7fd fa64 	bl	8022c38 <MotorStart>
					state  = 1;
 8025770:	4b5b      	ldr	r3, [pc, #364]	; (80258e0 <OpenDoor+0x2a4>)
 8025772:	2201      	movs	r2, #1
 8025774:	601a      	str	r2, [r3, #0]
					pause = 0;
 8025776:	4b5b      	ldr	r3, [pc, #364]	; (80258e4 <OpenDoor+0x2a8>)
 8025778:	2200      	movs	r2, #0
 802577a:	601a      	str	r2, [r3, #0]
					WriteClutch(CLUTCH_UNLOCK);
 802577c:	2001      	movs	r0, #1
 802577e:	f7fe f89d 	bl	80238bc <WriteClutch>
					state = 1;
					pause = 0;
					WriteClutch(CLUTCH_UNLOCK);
				}
*/
				result = 0;
 8025782:	2300      	movs	r3, #0
 8025784:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025786:	e17b      	b.n	8025a80 <OpenDoor+0x444>

			case 1:
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_R);
				if((Presets.OPEN_POSITION != 0x0))
 8025788:	4b58      	ldr	r3, [pc, #352]	; (80258ec <OpenDoor+0x2b0>)
 802578a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802578c:	2b00      	cmp	r3, #0
 802578e:	f000 80b1 	beq.w	80258f4 <OpenDoor+0x2b8>
				{
					if ((drive.Position >= 100) && (drive.Position < (Presets.OPEN_POSITION - 500)))
 8025792:	4b55      	ldr	r3, [pc, #340]	; (80258e8 <OpenDoor+0x2ac>)
 8025794:	881b      	ldrh	r3, [r3, #0]
 8025796:	2b63      	cmp	r3, #99	; 0x63
 8025798:	d91e      	bls.n	80257d8 <OpenDoor+0x19c>
 802579a:	4b53      	ldr	r3, [pc, #332]	; (80258e8 <OpenDoor+0x2ac>)
 802579c:	881b      	ldrh	r3, [r3, #0]
 802579e:	461a      	mov	r2, r3
 80257a0:	4b52      	ldr	r3, [pc, #328]	; (80258ec <OpenDoor+0x2b0>)
 80257a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80257a4:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 80257a8:	429a      	cmp	r2, r3
 80257aa:	d215      	bcs.n	80257d8 <OpenDoor+0x19c>
					{
						MotorClearError();
 80257ac:	f7fd fa82 	bl	8022cb4 <MotorClearError>
						WriteClutch(CLUTCH_UNLOCK);
 80257b0:	2001      	movs	r0, #1
 80257b2:	f7fe f883 	bl	80238bc <WriteClutch>
						MotorSetProportionalGain(200);
 80257b6:	20c8      	movs	r0, #200	; 0xc8
 80257b8:	f7fd fa55 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(5);
 80257bc:	2005      	movs	r0, #5
 80257be:	f7fd fa5f 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 1000);
 80257c2:	4b4b      	ldr	r3, [pc, #300]	; (80258f0 <OpenDoor+0x2b4>)
 80257c4:	681b      	ldr	r3, [r3, #0]
 80257c6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80257ca:	fb02 f303 	mul.w	r3, r2, r3
 80257ce:	4618      	mov	r0, r3
 80257d0:	f7fd fa3e 	bl	8022c50 <MotorSetSpeed>
						MotorStart();
 80257d4:	f7fd fa30 	bl	8022c38 <MotorStart>
					}

					if((drive.Position >= (Presets.OPEN_POSITION - 630)) && (drive.Position < (Presets.OPEN_POSITION - 200)))
 80257d8:	4b43      	ldr	r3, [pc, #268]	; (80258e8 <OpenDoor+0x2ac>)
 80257da:	881b      	ldrh	r3, [r3, #0]
 80257dc:	461a      	mov	r2, r3
 80257de:	4b43      	ldr	r3, [pc, #268]	; (80258ec <OpenDoor+0x2b0>)
 80257e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80257e2:	f2a3 2376 	subw	r3, r3, #630	; 0x276
 80257e6:	429a      	cmp	r2, r3
 80257e8:	d318      	bcc.n	802581c <OpenDoor+0x1e0>
 80257ea:	4b3f      	ldr	r3, [pc, #252]	; (80258e8 <OpenDoor+0x2ac>)
 80257ec:	881b      	ldrh	r3, [r3, #0]
 80257ee:	461a      	mov	r2, r3
 80257f0:	4b3e      	ldr	r3, [pc, #248]	; (80258ec <OpenDoor+0x2b0>)
 80257f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80257f4:	3bc8      	subs	r3, #200	; 0xc8
 80257f6:	429a      	cmp	r2, r3
 80257f8:	d210      	bcs.n	802581c <OpenDoor+0x1e0>
					{
						MotorSetProportionalGain(200);
 80257fa:	20c8      	movs	r0, #200	; 0xc8
 80257fc:	f7fd fa33 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(5);
 8025800:	2005      	movs	r0, #5
 8025802:	f7fd fa3d 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 400);
 8025806:	4b3a      	ldr	r3, [pc, #232]	; (80258f0 <OpenDoor+0x2b4>)
 8025808:	681b      	ldr	r3, [r3, #0]
 802580a:	f44f 72c8 	mov.w	r2, #400	; 0x190
 802580e:	fb02 f303 	mul.w	r3, r2, r3
 8025812:	4618      	mov	r0, r3
 8025814:	f7fd fa1c 	bl	8022c50 <MotorSetSpeed>
						result = 0;
 8025818:	2300      	movs	r3, #0
 802581a:	60fb      	str	r3, [r7, #12]
					}

					if(drive.Position >= (Presets.OPEN_POSITION - 120))
 802581c:	4b32      	ldr	r3, [pc, #200]	; (80258e8 <OpenDoor+0x2ac>)
 802581e:	881b      	ldrh	r3, [r3, #0]
 8025820:	461a      	mov	r2, r3
 8025822:	4b32      	ldr	r3, [pc, #200]	; (80258ec <OpenDoor+0x2b0>)
 8025824:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025826:	3b78      	subs	r3, #120	; 0x78
 8025828:	429a      	cmp	r2, r3
 802582a:	d314      	bcc.n	8025856 <OpenDoor+0x21a>
					{
						MotorSetProportionalGain(200);
 802582c:	20c8      	movs	r0, #200	; 0xc8
 802582e:	f7fd fa1a 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(5); // 10
 8025832:	2005      	movs	r0, #5
 8025834:	f7fd fa24 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 150); //100
 8025838:	4b2d      	ldr	r3, [pc, #180]	; (80258f0 <OpenDoor+0x2b4>)
 802583a:	681b      	ldr	r3, [r3, #0]
 802583c:	2296      	movs	r2, #150	; 0x96
 802583e:	fb02 f303 	mul.w	r3, r2, r3
 8025842:	4618      	mov	r0, r3
 8025844:	f7fd fa04 	bl	8022c50 <MotorSetSpeed>
						MotorStart();
 8025848:	f7fd f9f6 	bl	8022c38 <MotorStart>
						state = 2;
 802584c:	4b24      	ldr	r3, [pc, #144]	; (80258e0 <OpenDoor+0x2a4>)
 802584e:	2202      	movs	r2, #2
 8025850:	601a      	str	r2, [r3, #0]
						result = 0;
 8025852:	2300      	movs	r3, #0
 8025854:	60fb      	str	r3, [r7, #12]
					}

					if(((drive.Current >= 2500) && (drive.Position < (Presets.OPEN_POSITION - 500) ) && (drive.Position >= 500)) || ((drive.Current >= 2000) && (drive.Position < (Presets.OPEN_POSITION - 100) ) && (drive.Position >= (Presets.OPEN_POSITION - 500))) || (drive.Position >= (Presets.OPEN_POSITION - 100) && (drive.Current >= 1000)))
 8025856:	4b24      	ldr	r3, [pc, #144]	; (80258e8 <OpenDoor+0x2ac>)
 8025858:	885b      	ldrh	r3, [r3, #2]
 802585a:	f640 12c3 	movw	r2, #2499	; 0x9c3
 802585e:	4293      	cmp	r3, r2
 8025860:	d90d      	bls.n	802587e <OpenDoor+0x242>
 8025862:	4b21      	ldr	r3, [pc, #132]	; (80258e8 <OpenDoor+0x2ac>)
 8025864:	881b      	ldrh	r3, [r3, #0]
 8025866:	461a      	mov	r2, r3
 8025868:	4b20      	ldr	r3, [pc, #128]	; (80258ec <OpenDoor+0x2b0>)
 802586a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802586c:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8025870:	429a      	cmp	r2, r3
 8025872:	d204      	bcs.n	802587e <OpenDoor+0x242>
 8025874:	4b1c      	ldr	r3, [pc, #112]	; (80258e8 <OpenDoor+0x2ac>)
 8025876:	881b      	ldrh	r3, [r3, #0]
 8025878:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 802587c:	d222      	bcs.n	80258c4 <OpenDoor+0x288>
 802587e:	4b1a      	ldr	r3, [pc, #104]	; (80258e8 <OpenDoor+0x2ac>)
 8025880:	885b      	ldrh	r3, [r3, #2]
 8025882:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8025886:	d310      	bcc.n	80258aa <OpenDoor+0x26e>
 8025888:	4b17      	ldr	r3, [pc, #92]	; (80258e8 <OpenDoor+0x2ac>)
 802588a:	881b      	ldrh	r3, [r3, #0]
 802588c:	461a      	mov	r2, r3
 802588e:	4b17      	ldr	r3, [pc, #92]	; (80258ec <OpenDoor+0x2b0>)
 8025890:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025892:	3b64      	subs	r3, #100	; 0x64
 8025894:	429a      	cmp	r2, r3
 8025896:	d208      	bcs.n	80258aa <OpenDoor+0x26e>
 8025898:	4b13      	ldr	r3, [pc, #76]	; (80258e8 <OpenDoor+0x2ac>)
 802589a:	881b      	ldrh	r3, [r3, #0]
 802589c:	461a      	mov	r2, r3
 802589e:	4b13      	ldr	r3, [pc, #76]	; (80258ec <OpenDoor+0x2b0>)
 80258a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80258a2:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 80258a6:	429a      	cmp	r2, r3
 80258a8:	d20c      	bcs.n	80258c4 <OpenDoor+0x288>
 80258aa:	4b0f      	ldr	r3, [pc, #60]	; (80258e8 <OpenDoor+0x2ac>)
 80258ac:	881b      	ldrh	r3, [r3, #0]
 80258ae:	461a      	mov	r2, r3
 80258b0:	4b0e      	ldr	r3, [pc, #56]	; (80258ec <OpenDoor+0x2b0>)
 80258b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80258b4:	3b64      	subs	r3, #100	; 0x64
 80258b6:	429a      	cmp	r2, r3
 80258b8:	d30d      	bcc.n	80258d6 <OpenDoor+0x29a>
 80258ba:	4b0b      	ldr	r3, [pc, #44]	; (80258e8 <OpenDoor+0x2ac>)
 80258bc:	885b      	ldrh	r3, [r3, #2]
 80258be:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80258c2:	d308      	bcc.n	80258d6 <OpenDoor+0x29a>
					{
						WriteClutch(CLUTCH_UNLOCK);
 80258c4:	2001      	movs	r0, #1
 80258c6:	f7fd fff9 	bl	80238bc <WriteClutch>
						MotorStop();
 80258ca:	f7fd f9bb 	bl	8022c44 <MotorStop>
						result = -4;
 80258ce:	f06f 0303 	mvn.w	r3, #3
 80258d2:	60fb      	str	r3, [r7, #12]
					}
					//result = 0;
				}

			}
				break;
 80258d4:	e0d3      	b.n	8025a7e <OpenDoor+0x442>
						result = 0;
 80258d6:	2300      	movs	r3, #0
 80258d8:	60fb      	str	r3, [r7, #12]
				break;
 80258da:	e0d0      	b.n	8025a7e <OpenDoor+0x442>
 80258dc:	2000074c 	.word	0x2000074c
 80258e0:	20000750 	.word	0x20000750
 80258e4:	20000754 	.word	0x20000754
 80258e8:	20000600 	.word	0x20000600
 80258ec:	20000764 	.word	0x20000764
 80258f0:	20000250 	.word	0x20000250
					if ((drive.Position >= 100))
 80258f4:	4b65      	ldr	r3, [pc, #404]	; (8025a8c <OpenDoor+0x450>)
 80258f6:	881b      	ldrh	r3, [r3, #0]
 80258f8:	2b63      	cmp	r3, #99	; 0x63
 80258fa:	d918      	bls.n	802592e <OpenDoor+0x2f2>
						MotorClearError();
 80258fc:	f7fd f9da 	bl	8022cb4 <MotorClearError>
						WriteClutch(CLUTCH_UNLOCK);
 8025900:	2001      	movs	r0, #1
 8025902:	f7fd ffdb 	bl	80238bc <WriteClutch>
						MotorSetProportionalGain(1000);
 8025906:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 802590a:	f7fd f9ac 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(10);
 802590e:	200a      	movs	r0, #10
 8025910:	f7fd f9b6 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 600);
 8025914:	4b5e      	ldr	r3, [pc, #376]	; (8025a90 <OpenDoor+0x454>)
 8025916:	681b      	ldr	r3, [r3, #0]
 8025918:	f44f 7216 	mov.w	r2, #600	; 0x258
 802591c:	fb02 f303 	mul.w	r3, r2, r3
 8025920:	4618      	mov	r0, r3
 8025922:	f7fd f995 	bl	8022c50 <MotorSetSpeed>
						MotorStart();
 8025926:	f7fd f987 	bl	8022c38 <MotorStart>
						result = 0;
 802592a:	2300      	movs	r3, #0
 802592c:	60fb      	str	r3, [r7, #12]
					if(drive.Position >= (DOOR_DEFAULT_OPEN_POSITION - 200))
 802592e:	4b57      	ldr	r3, [pc, #348]	; (8025a8c <OpenDoor+0x450>)
 8025930:	881b      	ldrh	r3, [r3, #0]
 8025932:	f240 424b 	movw	r2, #1099	; 0x44b
 8025936:	4293      	cmp	r3, r2
 8025938:	d912      	bls.n	8025960 <OpenDoor+0x324>
						MotorSetProportionalGain(2000);
 802593a:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 802593e:	f7fd f992 	bl	8022c66 <MotorSetProportionalGain>
						MotorSetIntegralGain(10);
 8025942:	200a      	movs	r0, #10
 8025944:	f7fd f99c 	bl	8022c80 <MotorSetIntegralGain>
						MotorSetSpeed(OPEN_DIR * 100);
 8025948:	4b51      	ldr	r3, [pc, #324]	; (8025a90 <OpenDoor+0x454>)
 802594a:	681b      	ldr	r3, [r3, #0]
 802594c:	2264      	movs	r2, #100	; 0x64
 802594e:	fb02 f303 	mul.w	r3, r2, r3
 8025952:	4618      	mov	r0, r3
 8025954:	f7fd f97c 	bl	8022c50 <MotorSetSpeed>
						MotorStart();
 8025958:	f7fd f96e 	bl	8022c38 <MotorStart>
						result = 0;
 802595c:	2300      	movs	r3, #0
 802595e:	60fb      	str	r3, [r7, #12]
					if((drive.Position >= DOOR_DEFAULT_OPEN_POSITION) && (drive.Current >= 100) && !ServiceMode)
 8025960:	4b4a      	ldr	r3, [pc, #296]	; (8025a8c <OpenDoor+0x450>)
 8025962:	881b      	ldrh	r3, [r3, #0]
 8025964:	f240 5213 	movw	r2, #1299	; 0x513
 8025968:	4293      	cmp	r3, r2
 802596a:	d919      	bls.n	80259a0 <OpenDoor+0x364>
 802596c:	4b47      	ldr	r3, [pc, #284]	; (8025a8c <OpenDoor+0x450>)
 802596e:	885b      	ldrh	r3, [r3, #2]
 8025970:	2b63      	cmp	r3, #99	; 0x63
 8025972:	d915      	bls.n	80259a0 <OpenDoor+0x364>
 8025974:	4b47      	ldr	r3, [pc, #284]	; (8025a94 <OpenDoor+0x458>)
 8025976:	681b      	ldr	r3, [r3, #0]
 8025978:	2b00      	cmp	r3, #0
 802597a:	d111      	bne.n	80259a0 <OpenDoor+0x364>
						MotorStop();
 802597c:	f7fd f962 	bl	8022c44 <MotorStop>
						Presets.OPEN_POSITION = drive.Position;
 8025980:	4b42      	ldr	r3, [pc, #264]	; (8025a8c <OpenDoor+0x450>)
 8025982:	881b      	ldrh	r3, [r3, #0]
 8025984:	461a      	mov	r2, r3
 8025986:	4b44      	ldr	r3, [pc, #272]	; (8025a98 <OpenDoor+0x45c>)
 8025988:	625a      	str	r2, [r3, #36]	; 0x24
						SaveAllPresets(&Presets);
 802598a:	4843      	ldr	r0, [pc, #268]	; (8025a98 <OpenDoor+0x45c>)
 802598c:	f000 fa0b 	bl	8025da6 <SaveAllPresets>
						ReadAllPresets(&Presets);
 8025990:	4841      	ldr	r0, [pc, #260]	; (8025a98 <OpenDoor+0x45c>)
 8025992:	f000 f9fb 	bl	8025d8c <ReadAllPresets>
						state = 3;
 8025996:	4b41      	ldr	r3, [pc, #260]	; (8025a9c <OpenDoor+0x460>)
 8025998:	2203      	movs	r2, #3
 802599a:	601a      	str	r2, [r3, #0]
						result = 0;
 802599c:	2300      	movs	r3, #0
 802599e:	60fb      	str	r3, [r7, #12]
					if((drive.Position >= DOOR_DEFAULT_OPEN_POSITION) && (drive.Current >= 100) && ServiceMode)
 80259a0:	4b3a      	ldr	r3, [pc, #232]	; (8025a8c <OpenDoor+0x450>)
 80259a2:	881b      	ldrh	r3, [r3, #0]
 80259a4:	f240 5213 	movw	r2, #1299	; 0x513
 80259a8:	4293      	cmp	r3, r2
 80259aa:	d968      	bls.n	8025a7e <OpenDoor+0x442>
 80259ac:	4b37      	ldr	r3, [pc, #220]	; (8025a8c <OpenDoor+0x450>)
 80259ae:	885b      	ldrh	r3, [r3, #2]
 80259b0:	2b63      	cmp	r3, #99	; 0x63
 80259b2:	d964      	bls.n	8025a7e <OpenDoor+0x442>
 80259b4:	4b37      	ldr	r3, [pc, #220]	; (8025a94 <OpenDoor+0x458>)
 80259b6:	681b      	ldr	r3, [r3, #0]
 80259b8:	2b00      	cmp	r3, #0
 80259ba:	d060      	beq.n	8025a7e <OpenDoor+0x442>
						MotorStop();
 80259bc:	f7fd f942 	bl	8022c44 <MotorStop>
						state = 3;
 80259c0:	4b36      	ldr	r3, [pc, #216]	; (8025a9c <OpenDoor+0x460>)
 80259c2:	2203      	movs	r2, #3
 80259c4:	601a      	str	r2, [r3, #0]
						result = 0;
 80259c6:	2300      	movs	r3, #0
 80259c8:	60fb      	str	r3, [r7, #12]
				break;
 80259ca:	e058      	b.n	8025a7e <OpenDoor+0x442>
//					{
//						result = 0;
//					}
//				}

				if(((drive.Position >= (Presets.OPEN_POSITION - 5))))
 80259cc:	4b2f      	ldr	r3, [pc, #188]	; (8025a8c <OpenDoor+0x450>)
 80259ce:	881b      	ldrh	r3, [r3, #0]
 80259d0:	461a      	mov	r2, r3
 80259d2:	4b31      	ldr	r3, [pc, #196]	; (8025a98 <OpenDoor+0x45c>)
 80259d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80259d6:	3b05      	subs	r3, #5
 80259d8:	429a      	cmp	r2, r3
 80259da:	d313      	bcc.n	8025a04 <OpenDoor+0x3c8>
				{
					MotorSetProportionalGain(400);
 80259dc:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80259e0:	f7fd f941 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 80259e4:	200a      	movs	r0, #10
 80259e6:	f7fd f94b 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 5);
 80259ea:	4b29      	ldr	r3, [pc, #164]	; (8025a90 <OpenDoor+0x454>)
 80259ec:	681a      	ldr	r2, [r3, #0]
 80259ee:	4613      	mov	r3, r2
 80259f0:	009b      	lsls	r3, r3, #2
 80259f2:	4413      	add	r3, r2
 80259f4:	4618      	mov	r0, r3
 80259f6:	f7fd f92b 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 80259fa:	f7fd f91d 	bl	8022c38 <MotorStart>
					//Motor0_BLDC_SCALAR_MotorStop();

					state = 3;
 80259fe:	4b27      	ldr	r3, [pc, #156]	; (8025a9c <OpenDoor+0x460>)
 8025a00:	2203      	movs	r2, #3
 8025a02:	601a      	str	r2, [r3, #0]
				}
				result = 0;
 8025a04:	2300      	movs	r3, #0
 8025a06:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025a08:	e03a      	b.n	8025a80 <OpenDoor+0x444>

			case 3:
			{
				pause++;
 8025a0a:	4b25      	ldr	r3, [pc, #148]	; (8025aa0 <OpenDoor+0x464>)
 8025a0c:	681b      	ldr	r3, [r3, #0]
 8025a0e:	3301      	adds	r3, #1
 8025a10:	4a23      	ldr	r2, [pc, #140]	; (8025aa0 <OpenDoor+0x464>)
 8025a12:	6013      	str	r3, [r2, #0]
				if (pause >= 1)
 8025a14:	4b22      	ldr	r3, [pc, #136]	; (8025aa0 <OpenDoor+0x464>)
 8025a16:	681b      	ldr	r3, [r3, #0]
 8025a18:	2b00      	cmp	r3, #0
 8025a1a:	dd0d      	ble.n	8025a38 <OpenDoor+0x3fc>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025a1c:	2000      	movs	r0, #0
 8025a1e:	f7fd ff4d 	bl	80238bc <WriteClutch>
						MotorStop();
 8025a22:	f7fd f90f 	bl	8022c44 <MotorStop>
						state = 4;
 8025a26:	4b1d      	ldr	r3, [pc, #116]	; (8025a9c <OpenDoor+0x460>)
 8025a28:	2204      	movs	r2, #4
 8025a2a:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025a2c:	4b1c      	ldr	r3, [pc, #112]	; (8025aa0 <OpenDoor+0x464>)
 8025a2e:	2200      	movs	r2, #0
 8025a30:	601a      	str	r2, [r3, #0]
						result = 0;
 8025a32:	2300      	movs	r3, #0
 8025a34:	60fb      	str	r3, [r7, #12]
				else
				{
					result = 0;
				}
			}
				break;
 8025a36:	e023      	b.n	8025a80 <OpenDoor+0x444>
					result = 0;
 8025a38:	2300      	movs	r3, #0
 8025a3a:	60fb      	str	r3, [r7, #12]
				break;
 8025a3c:	e020      	b.n	8025a80 <OpenDoor+0x444>

			case 4:
			{
				pause++;
 8025a3e:	4b18      	ldr	r3, [pc, #96]	; (8025aa0 <OpenDoor+0x464>)
 8025a40:	681b      	ldr	r3, [r3, #0]
 8025a42:	3301      	adds	r3, #1
 8025a44:	4a16      	ldr	r2, [pc, #88]	; (8025aa0 <OpenDoor+0x464>)
 8025a46:	6013      	str	r3, [r2, #0]
				if (pause >= 10)
 8025a48:	4b15      	ldr	r3, [pc, #84]	; (8025aa0 <OpenDoor+0x464>)
 8025a4a:	681b      	ldr	r3, [r3, #0]
 8025a4c:	2b09      	cmp	r3, #9
 8025a4e:	dd10      	ble.n	8025a72 <OpenDoor+0x436>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025a50:	2000      	movs	r0, #0
 8025a52:	f7fd ff33 	bl	80238bc <WriteClutch>
						MotorStop();
 8025a56:	f7fd f8f5 	bl	8022c44 <MotorStop>
						state = 0;
 8025a5a:	4b10      	ldr	r3, [pc, #64]	; (8025a9c <OpenDoor+0x460>)
 8025a5c:	2200      	movs	r2, #0
 8025a5e:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025a60:	4b0f      	ldr	r3, [pc, #60]	; (8025aa0 <OpenDoor+0x464>)
 8025a62:	2200      	movs	r2, #0
 8025a64:	601a      	str	r2, [r3, #0]
						result = 1;
 8025a66:	2301      	movs	r3, #1
 8025a68:	60fb      	str	r3, [r7, #12]
						tim = 0;
 8025a6a:	4b0e      	ldr	r3, [pc, #56]	; (8025aa4 <OpenDoor+0x468>)
 8025a6c:	2200      	movs	r2, #0
 8025a6e:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
				break;
 8025a70:	e006      	b.n	8025a80 <OpenDoor+0x444>
					result = 0;
 8025a72:	2300      	movs	r3, #0
 8025a74:	60fb      	str	r3, [r7, #12]
				break;
 8025a76:	e003      	b.n	8025a80 <OpenDoor+0x444>
			default:
				return -3; // bad case;
 8025a78:	f06f 0302 	mvn.w	r3, #2
 8025a7c:	e001      	b.n	8025a82 <OpenDoor+0x446>
				break;
 8025a7e:	bf00      	nop

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025a80:	68fb      	ldr	r3, [r7, #12]
}
 8025a82:	4618      	mov	r0, r3
 8025a84:	3710      	adds	r7, #16
 8025a86:	46bd      	mov	sp, r7
 8025a88:	bd80      	pop	{r7, pc}
 8025a8a:	bf00      	nop
 8025a8c:	20000600 	.word	0x20000600
 8025a90:	20000250 	.word	0x20000250
 8025a94:	20000fc4 	.word	0x20000fc4
 8025a98:	20000764 	.word	0x20000764
 8025a9c:	20000750 	.word	0x20000750
 8025aa0:	20000754 	.word	0x20000754
 8025aa4:	2000074c 	.word	0x2000074c

08025aa8 <OpenAfterBlockage>:

int32_t OpenAfterBlockage (int32_t cmd)
{
 8025aa8:	b580      	push	{r7, lr}
 8025aaa:	b084      	sub	sp, #16
 8025aac:	af00      	add	r7, sp, #0
 8025aae:	6078      	str	r0, [r7, #4]
	int32_t result = 0;
 8025ab0:	2300      	movs	r3, #0
 8025ab2:	60fb      	str	r3, [r7, #12]
	static int32_t pause = 0;
	static int32_t tim = 0;

	//static int32_t first_opening_done = 0;

	tim++;
 8025ab4:	4baa      	ldr	r3, [pc, #680]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025ab6:	681b      	ldr	r3, [r3, #0]
 8025ab8:	3301      	adds	r3, #1
 8025aba:	4aa9      	ldr	r2, [pc, #676]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025abc:	6013      	str	r3, [r2, #0]


	if(tim >= 1000)
 8025abe:	4ba8      	ldr	r3, [pc, #672]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025ac0:	681b      	ldr	r3, [r3, #0]
 8025ac2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8025ac6:	db0d      	blt.n	8025ae4 <OpenAfterBlockage+0x3c>
	{
		MotorStop();
 8025ac8:	f7fd f8bc 	bl	8022c44 <MotorStop>
		state = 0;
 8025acc:	4ba5      	ldr	r3, [pc, #660]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025ace:	2200      	movs	r2, #0
 8025ad0:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025ad2:	4ba3      	ldr	r3, [pc, #652]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025ad4:	2200      	movs	r2, #0
 8025ad6:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025ad8:	4ba3      	ldr	r3, [pc, #652]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025ada:	2200      	movs	r2, #0
 8025adc:	601a      	str	r2, [r3, #0]
		return -1; // timeout error
 8025ade:	f04f 33ff 	mov.w	r3, #4294967295
 8025ae2:	e14e      	b.n	8025d82 <OpenAfterBlockage+0x2da>
	}
	if (drive.Current >= 3000)
 8025ae4:	4ba1      	ldr	r3, [pc, #644]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025ae6:	885b      	ldrh	r3, [r3, #2]
 8025ae8:	f640 32b7 	movw	r2, #2999	; 0xbb7
 8025aec:	4293      	cmp	r3, r2
 8025aee:	d90d      	bls.n	8025b0c <OpenAfterBlockage+0x64>
	{
		MotorStop();
 8025af0:	f7fd f8a8 	bl	8022c44 <MotorStop>
		state = 0;
 8025af4:	4b9b      	ldr	r3, [pc, #620]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025af6:	2200      	movs	r2, #0
 8025af8:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025afa:	4b99      	ldr	r3, [pc, #612]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025afc:	2200      	movs	r2, #0
 8025afe:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025b00:	4b99      	ldr	r3, [pc, #612]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025b02:	2200      	movs	r2, #0
 8025b04:	601a      	str	r2, [r3, #0]
		return -2; // max current error
 8025b06:	f06f 0301 	mvn.w	r3, #1
 8025b0a:	e13a      	b.n	8025d82 <OpenAfterBlockage+0x2da>
	}


	if(!cmd)
 8025b0c:	687b      	ldr	r3, [r7, #4]
 8025b0e:	2b00      	cmp	r3, #0
 8025b10:	d10c      	bne.n	8025b2c <OpenAfterBlockage+0x84>
	{
		MotorStop();
 8025b12:	f7fd f897 	bl	8022c44 <MotorStop>
		state = 0;
 8025b16:	4b93      	ldr	r3, [pc, #588]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025b18:	2200      	movs	r2, #0
 8025b1a:	601a      	str	r2, [r3, #0]
		pause = 0;
 8025b1c:	4b92      	ldr	r3, [pc, #584]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025b1e:	2200      	movs	r2, #0
 8025b20:	601a      	str	r2, [r3, #0]
		tim = 0;
 8025b22:	4b8f      	ldr	r3, [pc, #572]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025b24:	2200      	movs	r2, #0
 8025b26:	601a      	str	r2, [r3, #0]
		//result = 0;
		return 0;
 8025b28:	2300      	movs	r3, #0
 8025b2a:	e12a      	b.n	8025d82 <OpenAfterBlockage+0x2da>
	}
	else
	{
		switch (state)
 8025b2c:	4b8d      	ldr	r3, [pc, #564]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025b2e:	681b      	ldr	r3, [r3, #0]
 8025b30:	2b04      	cmp	r3, #4
 8025b32:	f200 8121 	bhi.w	8025d78 <OpenAfterBlockage+0x2d0>
 8025b36:	a201      	add	r2, pc, #4	; (adr r2, 8025b3c <OpenAfterBlockage+0x94>)
 8025b38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025b3c:	08025b51 	.word	0x08025b51
 8025b40:	08025ba7 	.word	0x08025ba7
 8025b44:	08025cb3 	.word	0x08025cb3
 8025b48:	08025cf1 	.word	0x08025cf1
 8025b4c:	08025d25 	.word	0x08025d25
		{
			case 0:
			{
				WriteClutch(CLUTCH_UNLOCK);
 8025b50:	2001      	movs	r0, #1
 8025b52:	f7fd feb3 	bl	80238bc <WriteClutch>

//				DIGITAL_IO_SetOutputHigh(&HS_SW_1);
//				DIGITAL_IO_SetOutputHigh(&HS_SW_2);
				//DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
				pause++;
 8025b56:	4b84      	ldr	r3, [pc, #528]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025b58:	681b      	ldr	r3, [r3, #0]
 8025b5a:	3301      	adds	r3, #1
 8025b5c:	4a82      	ldr	r2, [pc, #520]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025b5e:	6013      	str	r3, [r2, #0]
//					Motor0_BLDC_SCALAR_SetSpeedIntegralGain(10);
//					Motor0_BLDC_SCALAR_SetSpeedVal(OPEN_DIR * 250);
//					Motor0_BLDC_SCALAR_MotorStart();
//				}
//
				if(pause > 5)
 8025b60:	4b81      	ldr	r3, [pc, #516]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025b62:	681b      	ldr	r3, [r3, #0]
 8025b64:	2b05      	cmp	r3, #5
 8025b66:	dd1b      	ble.n	8025ba0 <OpenAfterBlockage+0xf8>
				{
					MotorClearError();
 8025b68:	f7fd f8a4 	bl	8022cb4 <MotorClearError>
					MotorSetProportionalGain(2000);
 8025b6c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8025b70:	f7fd f879 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(20);
 8025b74:	2014      	movs	r0, #20
 8025b76:	f7fd f883 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 200);
 8025b7a:	4b7d      	ldr	r3, [pc, #500]	; (8025d70 <OpenAfterBlockage+0x2c8>)
 8025b7c:	681b      	ldr	r3, [r3, #0]
 8025b7e:	22c8      	movs	r2, #200	; 0xc8
 8025b80:	fb02 f303 	mul.w	r3, r2, r3
 8025b84:	4618      	mov	r0, r3
 8025b86:	f7fd f863 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025b8a:	f7fd f855 	bl	8022c38 <MotorStart>
					state  = 1;
 8025b8e:	4b75      	ldr	r3, [pc, #468]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025b90:	2201      	movs	r2, #1
 8025b92:	601a      	str	r2, [r3, #0]
					pause = 0;
 8025b94:	4b74      	ldr	r3, [pc, #464]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025b96:	2200      	movs	r2, #0
 8025b98:	601a      	str	r2, [r3, #0]
					WriteClutch(CLUTCH_UNLOCK);
 8025b9a:	2001      	movs	r0, #1
 8025b9c:	f7fd fe8e 	bl	80238bc <WriteClutch>
					state = 1;
					pause = 0;
					WriteClutch(CLUTCH_UNLOCK);
				}
*/
				result = 0;
 8025ba0:	2300      	movs	r3, #0
 8025ba2:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025ba4:	e0ec      	b.n	8025d80 <OpenAfterBlockage+0x2d8>
			case 1:
			{
				//DIGITAL_IO_SetOutputLow(&STATUS_LED_R);
//				if((Presets.OPEN_POSITION != 0x0))
	//			{
				if ((drive.Position >= 40) && (drive.Position < (Presets.OPEN_POSITION - 500)))
 8025ba6:	4b71      	ldr	r3, [pc, #452]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025ba8:	881b      	ldrh	r3, [r3, #0]
 8025baa:	2b27      	cmp	r3, #39	; 0x27
 8025bac:	d91f      	bls.n	8025bee <OpenAfterBlockage+0x146>
 8025bae:	4b6f      	ldr	r3, [pc, #444]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025bb0:	881b      	ldrh	r3, [r3, #0]
 8025bb2:	461a      	mov	r2, r3
 8025bb4:	4b6f      	ldr	r3, [pc, #444]	; (8025d74 <OpenAfterBlockage+0x2cc>)
 8025bb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025bb8:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8025bbc:	429a      	cmp	r2, r3
 8025bbe:	d216      	bcs.n	8025bee <OpenAfterBlockage+0x146>
				{
					MotorClearError();
 8025bc0:	f7fd f878 	bl	8022cb4 <MotorClearError>
				    WriteClutch(CLUTCH_UNLOCK);
 8025bc4:	2001      	movs	r0, #1
 8025bc6:	f7fd fe79 	bl	80238bc <WriteClutch>
					MotorSetProportionalGain(1000);
 8025bca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8025bce:	f7fd f84a 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025bd2:	200a      	movs	r0, #10
 8025bd4:	f7fd f854 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 1000);
 8025bd8:	4b65      	ldr	r3, [pc, #404]	; (8025d70 <OpenAfterBlockage+0x2c8>)
 8025bda:	681b      	ldr	r3, [r3, #0]
 8025bdc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8025be0:	fb02 f303 	mul.w	r3, r2, r3
 8025be4:	4618      	mov	r0, r3
 8025be6:	f7fd f833 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025bea:	f7fd f825 	bl	8022c38 <MotorStart>
				}

				if((drive.Position >= (Presets.OPEN_POSITION - 500)) && (drive.Position < (Presets.OPEN_POSITION - 200)))
 8025bee:	4b5f      	ldr	r3, [pc, #380]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025bf0:	881b      	ldrh	r3, [r3, #0]
 8025bf2:	461a      	mov	r2, r3
 8025bf4:	4b5f      	ldr	r3, [pc, #380]	; (8025d74 <OpenAfterBlockage+0x2cc>)
 8025bf6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025bf8:	f5a3 73fa 	sub.w	r3, r3, #500	; 0x1f4
 8025bfc:	429a      	cmp	r2, r3
 8025bfe:	d312      	bcc.n	8025c26 <OpenAfterBlockage+0x17e>
 8025c00:	4b5a      	ldr	r3, [pc, #360]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c02:	881b      	ldrh	r3, [r3, #0]
 8025c04:	461a      	mov	r2, r3
 8025c06:	4b5b      	ldr	r3, [pc, #364]	; (8025d74 <OpenAfterBlockage+0x2cc>)
 8025c08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025c0a:	3bc8      	subs	r3, #200	; 0xc8
 8025c0c:	429a      	cmp	r2, r3
 8025c0e:	d20a      	bcs.n	8025c26 <OpenAfterBlockage+0x17e>
				{
					MotorSetSpeed(OPEN_DIR * 400);
 8025c10:	4b57      	ldr	r3, [pc, #348]	; (8025d70 <OpenAfterBlockage+0x2c8>)
 8025c12:	681b      	ldr	r3, [r3, #0]
 8025c14:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8025c18:	fb02 f303 	mul.w	r3, r2, r3
 8025c1c:	4618      	mov	r0, r3
 8025c1e:	f7fd f817 	bl	8022c50 <MotorSetSpeed>
					result = 0;
 8025c22:	2300      	movs	r3, #0
 8025c24:	60fb      	str	r3, [r7, #12]
				}


				if(((drive.Current >= 2500) && (drive.Position < 1300) && (drive.Position >= 500)) || ((drive.Position > 1300) && (drive.Current >= 800)))
 8025c26:	4b51      	ldr	r3, [pc, #324]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c28:	885b      	ldrh	r3, [r3, #2]
 8025c2a:	f640 12c3 	movw	r2, #2499	; 0x9c3
 8025c2e:	4293      	cmp	r3, r2
 8025c30:	d90a      	bls.n	8025c48 <OpenAfterBlockage+0x1a0>
 8025c32:	4b4e      	ldr	r3, [pc, #312]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c34:	881b      	ldrh	r3, [r3, #0]
 8025c36:	f240 5213 	movw	r2, #1299	; 0x513
 8025c3a:	4293      	cmp	r3, r2
 8025c3c:	d804      	bhi.n	8025c48 <OpenAfterBlockage+0x1a0>
 8025c3e:	4b4b      	ldr	r3, [pc, #300]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c40:	881b      	ldrh	r3, [r3, #0]
 8025c42:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8025c46:	d20a      	bcs.n	8025c5e <OpenAfterBlockage+0x1b6>
 8025c48:	4b48      	ldr	r3, [pc, #288]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c4a:	881b      	ldrh	r3, [r3, #0]
 8025c4c:	f240 5214 	movw	r2, #1300	; 0x514
 8025c50:	4293      	cmp	r3, r2
 8025c52:	d90d      	bls.n	8025c70 <OpenAfterBlockage+0x1c8>
 8025c54:	4b45      	ldr	r3, [pc, #276]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c56:	885b      	ldrh	r3, [r3, #2]
 8025c58:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 8025c5c:	d308      	bcc.n	8025c70 <OpenAfterBlockage+0x1c8>
				{
					WriteClutch(CLUTCH_UNLOCK);
 8025c5e:	2001      	movs	r0, #1
 8025c60:	f7fd fe2c 	bl	80238bc <WriteClutch>
					MotorStop();
 8025c64:	f7fc ffee 	bl	8022c44 <MotorStop>
					result = -4;
 8025c68:	f06f 0303 	mvn.w	r3, #3
 8025c6c:	60fb      	str	r3, [r7, #12]
 8025c6e:	e001      	b.n	8025c74 <OpenAfterBlockage+0x1cc>
				}
				else
				{
					result = 0;
 8025c70:	2300      	movs	r3, #0
 8025c72:	60fb      	str	r3, [r7, #12]
				}

				if(drive.Position >= (Presets.OPEN_POSITION - 150))
 8025c74:	4b3d      	ldr	r3, [pc, #244]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025c76:	881b      	ldrh	r3, [r3, #0]
 8025c78:	461a      	mov	r2, r3
 8025c7a:	4b3e      	ldr	r3, [pc, #248]	; (8025d74 <OpenAfterBlockage+0x2cc>)
 8025c7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025c7e:	3b96      	subs	r3, #150	; 0x96
 8025c80:	429a      	cmp	r2, r3
 8025c82:	d37c      	bcc.n	8025d7e <OpenAfterBlockage+0x2d6>
				{
					MotorSetProportionalGain(2000);
 8025c84:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8025c88:	f7fc ffed 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025c8c:	200a      	movs	r0, #10
 8025c8e:	f7fc fff7 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 100);
 8025c92:	4b37      	ldr	r3, [pc, #220]	; (8025d70 <OpenAfterBlockage+0x2c8>)
 8025c94:	681b      	ldr	r3, [r3, #0]
 8025c96:	2264      	movs	r2, #100	; 0x64
 8025c98:	fb02 f303 	mul.w	r3, r2, r3
 8025c9c:	4618      	mov	r0, r3
 8025c9e:	f7fc ffd7 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025ca2:	f7fc ffc9 	bl	8022c38 <MotorStart>
					state = 2;
 8025ca6:	4b2f      	ldr	r3, [pc, #188]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025ca8:	2202      	movs	r2, #2
 8025caa:	601a      	str	r2, [r3, #0]
					result = 0;
 8025cac:	2300      	movs	r3, #0
 8025cae:	60fb      	str	r3, [r7, #12]
//					}
//
//				}
				//result = 0;
			}
				break;
 8025cb0:	e065      	b.n	8025d7e <OpenAfterBlockage+0x2d6>
//					{
//						result = 0;
//					}
//				}

				if(((drive.Position >= (Presets.OPEN_POSITION - 10))))
 8025cb2:	4b2e      	ldr	r3, [pc, #184]	; (8025d6c <OpenAfterBlockage+0x2c4>)
 8025cb4:	881b      	ldrh	r3, [r3, #0]
 8025cb6:	461a      	mov	r2, r3
 8025cb8:	4b2e      	ldr	r3, [pc, #184]	; (8025d74 <OpenAfterBlockage+0x2cc>)
 8025cba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025cbc:	3b0a      	subs	r3, #10
 8025cbe:	429a      	cmp	r2, r3
 8025cc0:	d313      	bcc.n	8025cea <OpenAfterBlockage+0x242>
				{
					MotorSetProportionalGain(400);
 8025cc2:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8025cc6:	f7fc ffce 	bl	8022c66 <MotorSetProportionalGain>
					MotorSetIntegralGain(10);
 8025cca:	200a      	movs	r0, #10
 8025ccc:	f7fc ffd8 	bl	8022c80 <MotorSetIntegralGain>
					MotorSetSpeed(OPEN_DIR * 5);
 8025cd0:	4b27      	ldr	r3, [pc, #156]	; (8025d70 <OpenAfterBlockage+0x2c8>)
 8025cd2:	681a      	ldr	r2, [r3, #0]
 8025cd4:	4613      	mov	r3, r2
 8025cd6:	009b      	lsls	r3, r3, #2
 8025cd8:	4413      	add	r3, r2
 8025cda:	4618      	mov	r0, r3
 8025cdc:	f7fc ffb8 	bl	8022c50 <MotorSetSpeed>
					MotorStart();
 8025ce0:	f7fc ffaa 	bl	8022c38 <MotorStart>
					//Motor0_BLDC_SCALAR_MotorStop();

					state = 3;
 8025ce4:	4b1f      	ldr	r3, [pc, #124]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025ce6:	2203      	movs	r2, #3
 8025ce8:	601a      	str	r2, [r3, #0]
				}
				result = 0;
 8025cea:	2300      	movs	r3, #0
 8025cec:	60fb      	str	r3, [r7, #12]
			}
				break;
 8025cee:	e047      	b.n	8025d80 <OpenAfterBlockage+0x2d8>

			case 3:
			{
				pause++;
 8025cf0:	4b1d      	ldr	r3, [pc, #116]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025cf2:	681b      	ldr	r3, [r3, #0]
 8025cf4:	3301      	adds	r3, #1
 8025cf6:	4a1c      	ldr	r2, [pc, #112]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025cf8:	6013      	str	r3, [r2, #0]
				if (pause >= 1)
 8025cfa:	4b1b      	ldr	r3, [pc, #108]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025cfc:	681b      	ldr	r3, [r3, #0]
 8025cfe:	2b00      	cmp	r3, #0
 8025d00:	dd0d      	ble.n	8025d1e <OpenAfterBlockage+0x276>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025d02:	2000      	movs	r0, #0
 8025d04:	f7fd fdda 	bl	80238bc <WriteClutch>
						MotorStop();
 8025d08:	f7fc ff9c 	bl	8022c44 <MotorStop>
						state = 4;
 8025d0c:	4b15      	ldr	r3, [pc, #84]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025d0e:	2204      	movs	r2, #4
 8025d10:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025d12:	4b15      	ldr	r3, [pc, #84]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025d14:	2200      	movs	r2, #0
 8025d16:	601a      	str	r2, [r3, #0]
						result = 0;
 8025d18:	2300      	movs	r3, #0
 8025d1a:	60fb      	str	r3, [r7, #12]
				else
				{
					result = 0;
				}
			}
				break;
 8025d1c:	e030      	b.n	8025d80 <OpenAfterBlockage+0x2d8>
					result = 0;
 8025d1e:	2300      	movs	r3, #0
 8025d20:	60fb      	str	r3, [r7, #12]
				break;
 8025d22:	e02d      	b.n	8025d80 <OpenAfterBlockage+0x2d8>

			case 4:
			{
				pause++;
 8025d24:	4b10      	ldr	r3, [pc, #64]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025d26:	681b      	ldr	r3, [r3, #0]
 8025d28:	3301      	adds	r3, #1
 8025d2a:	4a0f      	ldr	r2, [pc, #60]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025d2c:	6013      	str	r3, [r2, #0]
				if (pause >= 10)
 8025d2e:	4b0e      	ldr	r3, [pc, #56]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025d30:	681b      	ldr	r3, [r3, #0]
 8025d32:	2b09      	cmp	r3, #9
 8025d34:	dd10      	ble.n	8025d58 <OpenAfterBlockage+0x2b0>
				{
					{
						WriteClutch(CLUTCH_LOCK);
 8025d36:	2000      	movs	r0, #0
 8025d38:	f7fd fdc0 	bl	80238bc <WriteClutch>
						MotorStop();
 8025d3c:	f7fc ff82 	bl	8022c44 <MotorStop>
						state = 0;
 8025d40:	4b08      	ldr	r3, [pc, #32]	; (8025d64 <OpenAfterBlockage+0x2bc>)
 8025d42:	2200      	movs	r2, #0
 8025d44:	601a      	str	r2, [r3, #0]
						pause = 0;
 8025d46:	4b08      	ldr	r3, [pc, #32]	; (8025d68 <OpenAfterBlockage+0x2c0>)
 8025d48:	2200      	movs	r2, #0
 8025d4a:	601a      	str	r2, [r3, #0]
						result = 1;
 8025d4c:	2301      	movs	r3, #1
 8025d4e:	60fb      	str	r3, [r7, #12]
						tim = 0;
 8025d50:	4b03      	ldr	r3, [pc, #12]	; (8025d60 <OpenAfterBlockage+0x2b8>)
 8025d52:	2200      	movs	r2, #0
 8025d54:	601a      	str	r2, [r3, #0]
				else
				{
					result = 0;
				}
			}
				break;
 8025d56:	e013      	b.n	8025d80 <OpenAfterBlockage+0x2d8>
					result = 0;
 8025d58:	2300      	movs	r3, #0
 8025d5a:	60fb      	str	r3, [r7, #12]
				break;
 8025d5c:	e010      	b.n	8025d80 <OpenAfterBlockage+0x2d8>
 8025d5e:	bf00      	nop
 8025d60:	20000758 	.word	0x20000758
 8025d64:	2000075c 	.word	0x2000075c
 8025d68:	20000760 	.word	0x20000760
 8025d6c:	20000600 	.word	0x20000600
 8025d70:	20000250 	.word	0x20000250
 8025d74:	20000764 	.word	0x20000764
			default:
				return -3; // bad case;
 8025d78:	f06f 0302 	mvn.w	r3, #2
 8025d7c:	e001      	b.n	8025d82 <OpenAfterBlockage+0x2da>
				break;
 8025d7e:	bf00      	nop

				break;
		}//end switch
	}//end else (cmd!=0)
	return result;
 8025d80:	68fb      	ldr	r3, [r7, #12]
}
 8025d82:	4618      	mov	r0, r3
 8025d84:	3710      	adds	r7, #16
 8025d86:	46bd      	mov	sp, r7
 8025d88:	bd80      	pop	{r7, pc}
 8025d8a:	bf00      	nop

08025d8c <ReadAllPresets>:
/* ---------------------------------------------------------------------------*/

/* ---------------------------------------------------------------------------*/
/* Public Functions ----------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
void ReadAllPresets( const PresetsTypeDef *const pntrPresets ) {
 8025d8c:	b580      	push	{r7, lr}
 8025d8e:	b082      	sub	sp, #8
 8025d90:	af00      	add	r7, sp, #0
 8025d92:	6078      	str	r0, [r7, #4]
	E_EEPROM_XMC4_ReadArray( 0, (uint8_t*)pntrPresets, sizeof(*pntrPresets) );
 8025d94:	224c      	movs	r2, #76	; 0x4c
 8025d96:	6879      	ldr	r1, [r7, #4]
 8025d98:	2000      	movs	r0, #0
 8025d9a:	f000 f903 	bl	8025fa4 <E_EEPROM_XMC4_ReadArray>
}
 8025d9e:	bf00      	nop
 8025da0:	3708      	adds	r7, #8
 8025da2:	46bd      	mov	sp, r7
 8025da4:	bd80      	pop	{r7, pc}

08025da6 <SaveAllPresets>:
	E_EEPROM_XMC4_ReadArray( (uint16_t)offset, pntrParam, 4 ); // read 4 bytes (one parameter)
}



E_EEPROM_XMC4_STATUS_t SaveAllPresets( const PresetsTypeDef *const pntrPresets ) {
 8025da6:	b580      	push	{r7, lr}
 8025da8:	b082      	sub	sp, #8
 8025daa:	af00      	add	r7, sp, #0
 8025dac:	6078      	str	r0, [r7, #4]
	E_EEPROM_XMC4_WriteArray( 0, (uint8_t*)pntrPresets, sizeof(*pntrPresets) );
 8025dae:	224c      	movs	r2, #76	; 0x4c
 8025db0:	6879      	ldr	r1, [r7, #4]
 8025db2:	2000      	movs	r0, #0
 8025db4:	f000 f8c4 	bl	8025f40 <E_EEPROM_XMC4_WriteArray>
	return E_EEPROM_XMC4_UpdateFlashContents();
 8025db8:	f000 f91c 	bl	8025ff4 <E_EEPROM_XMC4_UpdateFlashContents>
 8025dbc:	4603      	mov	r3, r0
}
 8025dbe:	4618      	mov	r0, r3
 8025dc0:	3708      	adds	r7, #8
 8025dc2:	46bd      	mov	sp, r7
 8025dc4:	bd80      	pop	{r7, pc}
	...

08025dc8 <XMC_FLASH_SetMargin>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
 8025dc8:	b480      	push	{r7}
 8025dca:	b083      	sub	sp, #12
 8025dcc:	af00      	add	r7, sp, #0
 8025dce:	4603      	mov	r3, r0
 8025dd0:	71fb      	strb	r3, [r7, #7]
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 8025dd2:	4b09      	ldr	r3, [pc, #36]	; (8025df8 <XMC_FLASH_SetMargin+0x30>)
 8025dd4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8025dd8:	699b      	ldr	r3, [r3, #24]
 8025dda:	f023 020f 	bic.w	r2, r3, #15
 8025dde:	79fb      	ldrb	r3, [r7, #7]
 8025de0:	4905      	ldr	r1, [pc, #20]	; (8025df8 <XMC_FLASH_SetMargin+0x30>)
 8025de2:	4313      	orrs	r3, r2
 8025de4:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
 8025de8:	6193      	str	r3, [r2, #24]
}
 8025dea:	bf00      	nop
 8025dec:	370c      	adds	r7, #12
 8025dee:	46bd      	mov	sp, r7
 8025df0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025df4:	4770      	bx	lr
 8025df6:	bf00      	nop
 8025df8:	58001000 	.word	0x58001000

08025dfc <XMC_FLASH_EnableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_EnableDoubleBitErrorTrap(void)
{
 8025dfc:	b480      	push	{r7}
 8025dfe:	af00      	add	r7, sp, #0
  FLASH0->MARP &= (uint32_t)~FLASH_MARP_TRAPDIS_Msk;
 8025e00:	4b07      	ldr	r3, [pc, #28]	; (8025e20 <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 8025e02:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8025e06:	699b      	ldr	r3, [r3, #24]
 8025e08:	4a05      	ldr	r2, [pc, #20]	; (8025e20 <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 8025e0a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8025e0e:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8025e12:	6193      	str	r3, [r2, #24]
}
 8025e14:	bf00      	nop
 8025e16:	46bd      	mov	sp, r7
 8025e18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025e1c:	4770      	bx	lr
 8025e1e:	bf00      	nop
 8025e20:	58001000 	.word	0x58001000

08025e24 <XMC_FLASH_DisableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_DisableDoubleBitErrorTrap(void)
{
 8025e24:	b480      	push	{r7}
 8025e26:	af00      	add	r7, sp, #0
  FLASH0->MARP |= FLASH_MARP_TRAPDIS_Msk;
 8025e28:	4b07      	ldr	r3, [pc, #28]	; (8025e48 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 8025e2a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8025e2e:	699b      	ldr	r3, [r3, #24]
 8025e30:	4a05      	ldr	r2, [pc, #20]	; (8025e48 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 8025e32:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8025e36:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8025e3a:	6193      	str	r3, [r2, #24]
}
 8025e3c:	bf00      	nop
 8025e3e:	46bd      	mov	sp, r7
 8025e40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025e44:	4770      	bx	lr
 8025e46:	bf00      	nop
 8025e48:	58001000 	.word	0x58001000

08025e4c <XMC_FCE_InitializeSeedValue>:
 *
 * \par
 * The function sets the initial CRC (seed) value in the CRC register.
 */
__STATIC_INLINE void XMC_FCE_InitializeSeedValue(const XMC_FCE_t *const engine, uint32_t seedvalue)
{
 8025e4c:	b480      	push	{r7}
 8025e4e:	b083      	sub	sp, #12
 8025e50:	af00      	add	r7, sp, #0
 8025e52:	6078      	str	r0, [r7, #4]
 8025e54:	6039      	str	r1, [r7, #0]
  engine->kernel_ptr->CRC = seedvalue;
 8025e56:	687b      	ldr	r3, [r7, #4]
 8025e58:	681b      	ldr	r3, [r3, #0]
 8025e5a:	683a      	ldr	r2, [r7, #0]
 8025e5c:	619a      	str	r2, [r3, #24]
}
 8025e5e:	bf00      	nop
 8025e60:	370c      	adds	r7, #12
 8025e62:	46bd      	mov	sp, r7
 8025e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025e68:	4770      	bx	lr
	...

08025e6c <E_EEPROM_XMC4_Init>:

/* ---------------------------------------------------------------------------*/
/* Public Functions ----------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 8025e6c:	b580      	push	{r7, lr}
 8025e6e:	b084      	sub	sp, #16
 8025e70:	af00      	add	r7, sp, #0
 8025e72:	6078      	str	r0, [r7, #4]
  uint32_t sector_count;
  E_EEPROM_XMC4_STATUS_t status ;

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL));

  status = E_EEPROM_XMC4_STATUS_OK;
 8025e74:	2300      	movs	r3, #0
 8025e76:	72fb      	strb	r3, [r7, #11]

  if (handle->initialized == (bool)false)
 8025e78:	687b      	ldr	r3, [r7, #4]
 8025e7a:	781b      	ldrb	r3, [r3, #0]
 8025e7c:	f083 0301 	eor.w	r3, r3, #1
 8025e80:	b2db      	uxtb	r3, r3
 8025e82:	2b00      	cmp	r3, #0
 8025e84:	d04c      	beq.n	8025f20 <E_EEPROM_XMC4_Init+0xb4>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 8025e86:	4b29      	ldr	r3, [pc, #164]	; (8025f2c <E_EEPROM_XMC4_Init+0xc0>)
 8025e88:	2200      	movs	r2, #0
 8025e8a:	605a      	str	r2, [r3, #4]
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8025e8c:	4b28      	ldr	r3, [pc, #160]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025e8e:	2200      	movs	r2, #0
 8025e90:	605a      	str	r2, [r3, #4]

    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_TIGHT0);
 8025e92:	2001      	movs	r0, #1
 8025e94:	f7ff ff98 	bl	8025dc8 <XMC_FLASH_SetMargin>
    XMC_FLASH_DisableDoubleBitErrorTrap();
 8025e98:	f7ff ffc4 	bl	8025e24 <XMC_FLASH_DisableDoubleBitErrorTrap>

    XMC_FCE_Enable();
 8025e9c:	f002 f996 	bl	80281cc <XMC_FCE_Enable>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8025ea0:	4824      	ldr	r0, [pc, #144]	; (8025f34 <E_EEPROM_XMC4_Init+0xc8>)
 8025ea2:	f002 f97e 	bl	80281a2 <XMC_FCE_Init>

    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8025ea6:	2300      	movs	r3, #0
 8025ea8:	60fb      	str	r3, [r7, #12]
 8025eaa:	e005      	b.n	8025eb8 <E_EEPROM_XMC4_Init+0x4c>
    {
      E_EEPROM_XMC4_lInitReadSectorInfo(sector_count);
 8025eac:	68f8      	ldr	r0, [r7, #12]
 8025eae:	f000 f945 	bl	802613c <E_EEPROM_XMC4_lInitReadSectorInfo>
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8025eb2:	68fb      	ldr	r3, [r7, #12]
 8025eb4:	3301      	adds	r3, #1
 8025eb6:	60fb      	str	r3, [r7, #12]
 8025eb8:	68fb      	ldr	r3, [r7, #12]
 8025eba:	2b03      	cmp	r3, #3
 8025ebc:	d9f6      	bls.n	8025eac <E_EEPROM_XMC4_Init+0x40>
    }

    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_DEFAULT);
 8025ebe:	2000      	movs	r0, #0
 8025ec0:	f7ff ff82 	bl	8025dc8 <XMC_FLASH_SetMargin>

    /* Implement the OVER ERASE CHECK code here and return the status*/

    /* If Read was successful*/
    if (status == E_EEPROM_XMC4_STATUS_OK)
 8025ec4:	7afb      	ldrb	r3, [r7, #11]
 8025ec6:	2b00      	cmp	r3, #0
 8025ec8:	d125      	bne.n	8025f16 <E_EEPROM_XMC4_Init+0xaa>
    {
      /* Execute erase state machine to free up the unwanted sectors and keep
       * only the sector which has latest valid block. If no valid block found then all sectors are emptied.
       */
      status = E_EEPROM_XMC4_lInitEraseStateMachine();
 8025eca:	f000 f98f 	bl	80261ec <E_EEPROM_XMC4_lInitEraseStateMachine>
 8025ece:	4603      	mov	r3, r0
 8025ed0:	72fb      	strb	r3, [r7, #11]

      /* If erase operations were successful, continue block data updates to RAM buffer */
      if (status == E_EEPROM_XMC4_STATUS_OK)
 8025ed2:	7afb      	ldrb	r3, [r7, #11]
 8025ed4:	2b00      	cmp	r3, #0
 8025ed6:	d11e      	bne.n	8025f16 <E_EEPROM_XMC4_Init+0xaa>
      {

        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
 8025ed8:	4b15      	ldr	r3, [pc, #84]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025eda:	685b      	ldr	r3, [r3, #4]
 8025edc:	2b00      	cmp	r3, #0
 8025ede:	d106      	bne.n	8025eee <E_EEPROM_XMC4_Init+0x82>
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
 8025ee0:	4b13      	ldr	r3, [pc, #76]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025ee2:	2200      	movs	r2, #0
 8025ee4:	609a      	str	r2, [r3, #8]
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8025ee6:	4b12      	ldr	r3, [pc, #72]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025ee8:	4a13      	ldr	r2, [pc, #76]	; (8025f38 <E_EEPROM_XMC4_Init+0xcc>)
 8025eea:	601a      	str	r2, [r3, #0]
 8025eec:	e013      	b.n	8025f16 <E_EEPROM_XMC4_Init+0xaa>
        }
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
 8025eee:	f000 f9d5 	bl	802629c <E_EEPROM_XMC4_lCopyFlashToRam>

          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 8025ef2:	4b0f      	ldr	r3, [pc, #60]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025ef4:	681a      	ldr	r2, [r3, #0]
 8025ef6:	4b0e      	ldr	r3, [pc, #56]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025ef8:	685b      	ldr	r3, [r3, #4]
 8025efa:	1ad3      	subs	r3, r2, r3
 8025efc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8025f00:	d001      	beq.n	8025f06 <E_EEPROM_XMC4_Init+0x9a>
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
 8025f02:	2301      	movs	r3, #1
 8025f04:	72fb      	strb	r3, [r7, #11]
          }

          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8025f06:	4b0a      	ldr	r3, [pc, #40]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025f08:	681b      	ldr	r3, [r3, #0]
 8025f0a:	4a0c      	ldr	r2, [pc, #48]	; (8025f3c <E_EEPROM_XMC4_Init+0xd0>)
 8025f0c:	4293      	cmp	r3, r2
 8025f0e:	d902      	bls.n	8025f16 <E_EEPROM_XMC4_Init+0xaa>
          {
            e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8025f10:	4b07      	ldr	r3, [pc, #28]	; (8025f30 <E_EEPROM_XMC4_Init+0xc4>)
 8025f12:	4a09      	ldr	r2, [pc, #36]	; (8025f38 <E_EEPROM_XMC4_Init+0xcc>)
 8025f14:	601a      	str	r2, [r3, #0]

        }
      }
    }

    XMC_FLASH_EnableDoubleBitErrorTrap();
 8025f16:	f7ff ff71 	bl	8025dfc <XMC_FLASH_EnableDoubleBitErrorTrap>

    handle->initialized = (bool)true;
 8025f1a:	687b      	ldr	r3, [r7, #4]
 8025f1c:	2201      	movs	r2, #1
 8025f1e:	701a      	strb	r2, [r3, #0]
  }

  return (status);
 8025f20:	7afb      	ldrb	r3, [r7, #11]
}
 8025f22:	4618      	mov	r0, r3
 8025f24:	3710      	adds	r7, #16
 8025f26:	46bd      	mov	sp, r7
 8025f28:	bd80      	pop	{r7, pc}
 8025f2a:	bf00      	nop
 8025f2c:	200007b0 	.word	0x200007b0
 8025f30:	20000254 	.word	0x20000254
 8025f34:	0802b0d0 	.word	0x0802b0d0
 8025f38:	0c010000 	.word	0x0c010000
 8025f3c:	0c01ffff 	.word	0x0c01ffff

08025f40 <E_EEPROM_XMC4_WriteArray>:



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 8025f40:	b580      	push	{r7, lr}
 8025f42:	b086      	sub	sp, #24
 8025f44:	af00      	add	r7, sp, #0
 8025f46:	4603      	mov	r3, r0
 8025f48:	6039      	str	r1, [r7, #0]
 8025f4a:	80fb      	strh	r3, [r7, #6]
 8025f4c:	4613      	mov	r3, r2
 8025f4e:	80bb      	strh	r3, [r7, #4]
  bool status;

  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length", ((offset_address + length) <= E_EEPROM_XMC4_DATA_BLOCK_SIZE));

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8025f50:	88fb      	ldrh	r3, [r7, #6]
 8025f52:	4a13      	ldr	r2, [pc, #76]	; (8025fa0 <E_EEPROM_XMC4_WriteArray+0x60>)
 8025f54:	4413      	add	r3, r2
 8025f56:	613b      	str	r3, [r7, #16]
  status = (memcmp(address_ptr, data, length) != 0);
 8025f58:	88bb      	ldrh	r3, [r7, #4]
 8025f5a:	461a      	mov	r2, r3
 8025f5c:	6839      	ldr	r1, [r7, #0]
 8025f5e:	6938      	ldr	r0, [r7, #16]
 8025f60:	f005 f80a 	bl	802af78 <memcmp>
 8025f64:	4603      	mov	r3, r0
 8025f66:	2b00      	cmp	r3, #0
 8025f68:	bf14      	ite	ne
 8025f6a:	2301      	movne	r3, #1
 8025f6c:	2300      	moveq	r3, #0
 8025f6e:	73fb      	strb	r3, [r7, #15]

  for (i = 0U; i < length; i++)
 8025f70:	2300      	movs	r3, #0
 8025f72:	82fb      	strh	r3, [r7, #22]
 8025f74:	e00a      	b.n	8025f8c <E_EEPROM_XMC4_WriteArray+0x4c>
  {
      *(address_ptr + i) = *(data + i);
 8025f76:	8afb      	ldrh	r3, [r7, #22]
 8025f78:	683a      	ldr	r2, [r7, #0]
 8025f7a:	441a      	add	r2, r3
 8025f7c:	8afb      	ldrh	r3, [r7, #22]
 8025f7e:	6939      	ldr	r1, [r7, #16]
 8025f80:	440b      	add	r3, r1
 8025f82:	7812      	ldrb	r2, [r2, #0]
 8025f84:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < length; i++)
 8025f86:	8afb      	ldrh	r3, [r7, #22]
 8025f88:	3301      	adds	r3, #1
 8025f8a:	82fb      	strh	r3, [r7, #22]
 8025f8c:	8afa      	ldrh	r2, [r7, #22]
 8025f8e:	88bb      	ldrh	r3, [r7, #4]
 8025f90:	429a      	cmp	r2, r3
 8025f92:	d3f0      	bcc.n	8025f76 <E_EEPROM_XMC4_WriteArray+0x36>
  }

  return status;
 8025f94:	7bfb      	ldrb	r3, [r7, #15]
}
 8025f96:	4618      	mov	r0, r3
 8025f98:	3718      	adds	r7, #24
 8025f9a:	46bd      	mov	sp, r7
 8025f9c:	bd80      	pop	{r7, pc}
 8025f9e:	bf00      	nop
 8025fa0:	200007b8 	.word	0x200007b8

08025fa4 <E_EEPROM_XMC4_ReadArray>:



/* Read a set of bytes from RAM Buffer */
void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length)
{
 8025fa4:	b480      	push	{r7}
 8025fa6:	b085      	sub	sp, #20
 8025fa8:	af00      	add	r7, sp, #0
 8025faa:	4603      	mov	r3, r0
 8025fac:	6039      	str	r1, [r7, #0]
 8025fae:	80fb      	strh	r3, [r7, #6]
 8025fb0:	4613      	mov	r3, r2
 8025fb2:	80bb      	strh	r3, [r7, #4]
  uint16_t i;
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length", ((offset_address + length) <= E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8025fb4:	88fb      	ldrh	r3, [r7, #6]
 8025fb6:	4a0e      	ldr	r2, [pc, #56]	; (8025ff0 <E_EEPROM_XMC4_ReadArray+0x4c>)
 8025fb8:	4413      	add	r3, r2
 8025fba:	60bb      	str	r3, [r7, #8]

  for (i=0U; i<length; i++)
 8025fbc:	2300      	movs	r3, #0
 8025fbe:	81fb      	strh	r3, [r7, #14]
 8025fc0:	e00a      	b.n	8025fd8 <E_EEPROM_XMC4_ReadArray+0x34>
  {
    *(data + i) = *(address_ptr + i);
 8025fc2:	89fb      	ldrh	r3, [r7, #14]
 8025fc4:	68ba      	ldr	r2, [r7, #8]
 8025fc6:	441a      	add	r2, r3
 8025fc8:	89fb      	ldrh	r3, [r7, #14]
 8025fca:	6839      	ldr	r1, [r7, #0]
 8025fcc:	440b      	add	r3, r1
 8025fce:	7812      	ldrb	r2, [r2, #0]
 8025fd0:	701a      	strb	r2, [r3, #0]
  for (i=0U; i<length; i++)
 8025fd2:	89fb      	ldrh	r3, [r7, #14]
 8025fd4:	3301      	adds	r3, #1
 8025fd6:	81fb      	strh	r3, [r7, #14]
 8025fd8:	89fa      	ldrh	r2, [r7, #14]
 8025fda:	88bb      	ldrh	r3, [r7, #4]
 8025fdc:	429a      	cmp	r2, r3
 8025fde:	d3f0      	bcc.n	8025fc2 <E_EEPROM_XMC4_ReadArray+0x1e>
  }
}
 8025fe0:	bf00      	nop
 8025fe2:	bf00      	nop
 8025fe4:	3714      	adds	r7, #20
 8025fe6:	46bd      	mov	sp, r7
 8025fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025fec:	4770      	bx	lr
 8025fee:	bf00      	nop
 8025ff0:	200007b8 	.word	0x200007b8

08025ff4 <E_EEPROM_XMC4_UpdateFlashContents>:



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 8025ff4:	b580      	push	{r7, lr}
 8025ff6:	b082      	sub	sp, #8
 8025ff8:	af00      	add	r7, sp, #0
  E_EEPROM_XMC4_STATUS_t status;
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;
 8025ffa:	2300      	movs	r3, #0
 8025ffc:	71fb      	strb	r3, [r7, #7]

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);
 8025ffe:	4b22      	ldr	r3, [pc, #136]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8026000:	689b      	ldr	r3, [r3, #8]
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 8026002:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8026006:	3304      	adds	r3, #4
 8026008:	039b      	lsls	r3, r3, #14
 802600a:	603b      	str	r3, [r7, #0]

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 802600c:	4b1e      	ldr	r3, [pc, #120]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802600e:	681b      	ldr	r3, [r3, #0]
 8026010:	683a      	ldr	r2, [r7, #0]
 8026012:	429a      	cmp	r2, r3
 8026014:	d111      	bne.n	802603a <E_EEPROM_XMC4_UpdateFlashContents+0x46>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 8026016:	4b1d      	ldr	r3, [pc, #116]	; (802608c <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8026018:	685b      	ldr	r3, [r3, #4]
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 802601a:	2b00      	cmp	r3, #0
 802601c:	d00d      	beq.n	802603a <E_EEPROM_XMC4_UpdateFlashContents+0x46>
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 802601e:	4b1a      	ldr	r3, [pc, #104]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8026020:	685b      	ldr	r3, [r3, #4]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
 8026022:	0b9b      	lsrs	r3, r3, #14
 8026024:	f003 0303 	and.w	r3, r3, #3
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 8026028:	4a17      	ldr	r2, [pc, #92]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802602a:	6093      	str	r3, [r2, #8]
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 802602c:	4b16      	ldr	r3, [pc, #88]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802602e:	220f      	movs	r2, #15
 8026030:	60da      	str	r2, [r3, #12]

    /* Execute erase state machine to free up the unwanted sectors and keep only the sector which has latest block*/
    status = E_EEPROM_XMC4_lInitEraseStateMachine();
 8026032:	f000 f8db 	bl	80261ec <E_EEPROM_XMC4_lInitEraseStateMachine>
 8026036:	4603      	mov	r3, r0
 8026038:	71fb      	strb	r3, [r7, #7]
  }

  if (status ==  E_EEPROM_XMC4_STATUS_OK)
 802603a:	79fb      	ldrb	r3, [r7, #7]
 802603c:	2b00      	cmp	r3, #0
 802603e:	d11d      	bne.n	802607c <E_EEPROM_XMC4_UpdateFlashContents+0x88>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count++;
 8026040:	4b12      	ldr	r3, [pc, #72]	; (802608c <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8026042:	685b      	ldr	r3, [r3, #4]
 8026044:	3301      	adds	r3, #1
 8026046:	4a11      	ldr	r2, [pc, #68]	; (802608c <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8026048:	6053      	str	r3, [r2, #4]

    status = E_EEPROM_XMC4_lWriteToFlash();
 802604a:	f000 f839 	bl	80260c0 <E_EEPROM_XMC4_lWriteToFlash>
 802604e:	4603      	mov	r3, r0
 8026050:	71fb      	strb	r3, [r7, #7]

    /* If the flash write succeeds, update the latest flash data location in RAM for reference */
    if (status == E_EEPROM_XMC4_STATUS_OK)
 8026052:	79fb      	ldrb	r3, [r7, #7]
 8026054:	2b00      	cmp	r3, #0
 8026056:	d103      	bne.n	8026060 <E_EEPROM_XMC4_UpdateFlashContents+0x6c>
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
 8026058:	4b0b      	ldr	r3, [pc, #44]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802605a:	681b      	ldr	r3, [r3, #0]
 802605c:	4a0a      	ldr	r2, [pc, #40]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802605e:	6053      	str	r3, [r2, #4]
    }

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026060:	4b09      	ldr	r3, [pc, #36]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8026062:	681b      	ldr	r3, [r3, #0]
 8026064:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8026068:	4a07      	ldr	r2, [pc, #28]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802606a:	6013      	str	r3, [r2, #0]

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 802606c:	4b06      	ldr	r3, [pc, #24]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802606e:	681b      	ldr	r3, [r3, #0]
 8026070:	4a07      	ldr	r2, [pc, #28]	; (8026090 <E_EEPROM_XMC4_UpdateFlashContents+0x9c>)
 8026072:	4293      	cmp	r3, r2
 8026074:	d902      	bls.n	802607c <E_EEPROM_XMC4_UpdateFlashContents+0x88>
    {
      e_eeprom_xmc4_sector_info.next_free_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8026076:	4b04      	ldr	r3, [pc, #16]	; (8026088 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8026078:	4a06      	ldr	r2, [pc, #24]	; (8026094 <E_EEPROM_XMC4_UpdateFlashContents+0xa0>)
 802607a:	601a      	str	r2, [r3, #0]
    }
  }

  return (status);
 802607c:	79fb      	ldrb	r3, [r7, #7]
}
 802607e:	4618      	mov	r0, r3
 8026080:	3708      	adds	r7, #8
 8026082:	46bd      	mov	sp, r7
 8026084:	bd80      	pop	{r7, pc}
 8026086:	bf00      	nop
 8026088:	20000254 	.word	0x20000254
 802608c:	200007b0 	.word	0x200007b0
 8026090:	0c01ffff 	.word	0x0c01ffff
 8026094:	0c010000 	.word	0x0c010000

08026098 <E_EEPROM_XMC4_IsFlashEmpty>:


/* Check the availability data in the flash emulated EEPROM area */
bool E_EEPROM_XMC4_IsFlashEmpty(void)
{
 8026098:	b480      	push	{r7}
 802609a:	b083      	sub	sp, #12
 802609c:	af00      	add	r7, sp, #0
  bool status = false;
 802609e:	2300      	movs	r3, #0
 80260a0:	71fb      	strb	r3, [r7, #7]

  /* If data available flash_data_addr will have a valid address*/
  if (e_eeprom_xmc4_sector_info.flash_data_addr == 0U)
 80260a2:	4b06      	ldr	r3, [pc, #24]	; (80260bc <E_EEPROM_XMC4_IsFlashEmpty+0x24>)
 80260a4:	685b      	ldr	r3, [r3, #4]
 80260a6:	2b00      	cmp	r3, #0
 80260a8:	d101      	bne.n	80260ae <E_EEPROM_XMC4_IsFlashEmpty+0x16>
  {
    status = true;
 80260aa:	2301      	movs	r3, #1
 80260ac:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 80260ae:	79fb      	ldrb	r3, [r7, #7]
}
 80260b0:	4618      	mov	r0, r3
 80260b2:	370c      	adds	r7, #12
 80260b4:	46bd      	mov	sp, r7
 80260b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260ba:	4770      	bx	lr
 80260bc:	20000254 	.word	0x20000254

080260c0 <E_EEPROM_XMC4_lWriteToFlash>:
/* Private Functions ---------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/

/* Local function to program data blocks from RAM into FLASH */
static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lWriteToFlash(void)
{
 80260c0:	b580      	push	{r7, lr}
 80260c2:	b084      	sub	sp, #16
 80260c4:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
 80260c6:	2300      	movs	r3, #0
 80260c8:	70fb      	strb	r3, [r7, #3]
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
 80260ca:	4b18      	ldr	r3, [pc, #96]	; (802612c <E_EEPROM_XMC4_lWriteToFlash+0x6c>)
 80260cc:	681b      	ldr	r3, [r3, #0]
 80260ce:	60fb      	str	r3, [r7, #12]
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 80260d0:	4b17      	ldr	r3, [pc, #92]	; (8026130 <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 80260d2:	60bb      	str	r3, [r7, #8]

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
 80260d4:	4817      	ldr	r0, [pc, #92]	; (8026134 <E_EEPROM_XMC4_lWriteToFlash+0x74>)
 80260d6:	f000 f8c9 	bl	802626c <E_EEPROM_XMC4_lCalculateCRC>
 80260da:	4603      	mov	r3, r0
 80260dc:	4a14      	ldr	r2, [pc, #80]	; (8026130 <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 80260de:	6013      	str	r3, [r2, #0]
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 80260e0:	2300      	movs	r3, #0
 80260e2:	607b      	str	r3, [r7, #4]
 80260e4:	e01a      	b.n	802611c <E_EEPROM_XMC4_lWriteToFlash+0x5c>
  {
    XMC_FLASH_ClearStatus();
 80260e6:	f000 f989 	bl	80263fc <XMC_FLASH_ClearStatus>

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);
 80260ea:	68b9      	ldr	r1, [r7, #8]
 80260ec:	68f8      	ldr	r0, [r7, #12]
 80260ee:	f000 f999 	bl	8026424 <XMC_FLASH_ProgramPage>

    if ((XMC_FLASH_GetStatus() & (uint32_t)(XMC_FLASH_STATUS_VERIFY_ERROR | XMC_FLASH_STATUS_OPERATION_ERROR)) != 0)
 80260f2:	f000 f989 	bl	8026408 <XMC_FLASH_GetStatus>
 80260f6:	4602      	mov	r2, r0
 80260f8:	4b0f      	ldr	r3, [pc, #60]	; (8026138 <E_EEPROM_XMC4_lWriteToFlash+0x78>)
 80260fa:	4013      	ands	r3, r2
 80260fc:	2b00      	cmp	r3, #0
 80260fe:	d002      	beq.n	8026106 <E_EEPROM_XMC4_lWriteToFlash+0x46>
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
 8026100:	2303      	movs	r3, #3
 8026102:	70fb      	strb	r3, [r7, #3]
      break;
 8026104:	e00d      	b.n	8026122 <E_EEPROM_XMC4_lWriteToFlash+0x62>
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 8026106:	68bb      	ldr	r3, [r7, #8]
 8026108:	f503 7380 	add.w	r3, r3, #256	; 0x100
 802610c:	60bb      	str	r3, [r7, #8]
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 802610e:	68fb      	ldr	r3, [r7, #12]
 8026110:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8026114:	60fb      	str	r3, [r7, #12]
  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 8026116:	687b      	ldr	r3, [r7, #4]
 8026118:	3301      	adds	r3, #1
 802611a:	607b      	str	r3, [r7, #4]
 802611c:	687b      	ldr	r3, [r7, #4]
 802611e:	2b07      	cmp	r3, #7
 8026120:	d9e1      	bls.n	80260e6 <E_EEPROM_XMC4_lWriteToFlash+0x26>
  }

  return (status);
 8026122:	78fb      	ldrb	r3, [r7, #3]
}
 8026124:	4618      	mov	r0, r3
 8026126:	3710      	adds	r7, #16
 8026128:	46bd      	mov	sp, r7
 802612a:	bd80      	pop	{r7, pc}
 802612c:	20000254 	.word	0x20000254
 8026130:	200007b0 	.word	0x200007b0
 8026134:	200007b4 	.word	0x200007b4
 8026138:	80000100 	.word	0x80000100

0802613c <E_EEPROM_XMC4_lInitReadSectorInfo>:



static void E_EEPROM_XMC4_lInitReadSectorInfo(const uint32_t sector)
{
 802613c:	b580      	push	{r7, lr}
 802613e:	b08a      	sub	sp, #40	; 0x28
 8026140:	af00      	add	r7, sp, #0
 8026142:	6078      	str	r0, [r7, #4]
  uint32_t block_cycle_count;
  uint32_t written_crc;
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
 8026144:	687b      	ldr	r3, [r7, #4]
 8026146:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 802614a:	3304      	adds	r3, #4
 802614c:	039b      	lsls	r3, r3, #14
 802614e:	61fb      	str	r3, [r7, #28]
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026150:	69fb      	ldr	r3, [r7, #28]
 8026152:	f503 5360 	add.w	r3, r3, #14336	; 0x3800
 8026156:	627b      	str	r3, [r7, #36]	; 0x24
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8026158:	2300      	movs	r3, #0
 802615a:	623b      	str	r3, [r7, #32]

  do
  {
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
 802615c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802615e:	61bb      	str	r3, [r7, #24]
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 8026160:	69bb      	ldr	r3, [r7, #24]
 8026162:	685b      	ldr	r3, [r3, #4]
 8026164:	617b      	str	r3, [r7, #20]

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
 8026166:	697b      	ldr	r3, [r7, #20]
 8026168:	2b00      	cmp	r3, #0
 802616a:	d02e      	beq.n	80261ca <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 802616c:	4b1d      	ldr	r3, [pc, #116]	; (80261e4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 802616e:	68da      	ldr	r2, [r3, #12]
 8026170:	2101      	movs	r1, #1
 8026172:	687b      	ldr	r3, [r7, #4]
 8026174:	fa01 f303 	lsl.w	r3, r1, r3
 8026178:	4313      	orrs	r3, r2
 802617a:	4a1a      	ldr	r2, [pc, #104]	; (80261e4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 802617c:	60d3      	str	r3, [r2, #12]

      /* If this is the first non empty block identified, then store the address as next free address */
      if (free_block_addr == E_EEPROM_XMC4_EMPTY)
 802617e:	6a3b      	ldr	r3, [r7, #32]
 8026180:	2b00      	cmp	r3, #0
 8026182:	d103      	bne.n	802618c <E_EEPROM_XMC4_lInitReadSectorInfo+0x50>
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026186:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 802618a:	623b      	str	r3, [r7, #32]
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 802618c:	69bb      	ldr	r3, [r7, #24]
 802618e:	681b      	ldr	r3, [r3, #0]
 8026190:	613b      	str	r3, [r7, #16]
      /* Calculate the CRC for the written data in flash (3rd word to the last word)*/
      calculated_crc = E_EEPROM_XMC4_lCalculateCRC(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 8026192:	69bb      	ldr	r3, [r7, #24]
 8026194:	3304      	adds	r3, #4
 8026196:	4618      	mov	r0, r3
 8026198:	f000 f868 	bl	802626c <E_EEPROM_XMC4_lCalculateCRC>
 802619c:	60f8      	str	r0, [r7, #12]

      if (calculated_crc == written_crc)
 802619e:	68fa      	ldr	r2, [r7, #12]
 80261a0:	693b      	ldr	r3, [r7, #16]
 80261a2:	429a      	cmp	r2, r3
 80261a4:	d111      	bne.n	80261ca <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
      {
        /* If both CRC matches and the current block cycle counter is greater than the previous recorded value,
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
 80261a6:	4b10      	ldr	r3, [pc, #64]	; (80261e8 <E_EEPROM_XMC4_lInitReadSectorInfo+0xac>)
 80261a8:	685b      	ldr	r3, [r3, #4]
 80261aa:	697a      	ldr	r2, [r7, #20]
 80261ac:	429a      	cmp	r2, r3
 80261ae:	d90c      	bls.n	80261ca <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 80261b0:	4a0d      	ldr	r2, [pc, #52]	; (80261e8 <E_EEPROM_XMC4_lInitReadSectorInfo+0xac>)
 80261b2:	697b      	ldr	r3, [r7, #20]
 80261b4:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.current_sector = sector;
 80261b6:	4a0b      	ldr	r2, [pc, #44]	; (80261e4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 80261b8:	687b      	ldr	r3, [r7, #4]
 80261ba:	6093      	str	r3, [r2, #8]
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
 80261bc:	4a09      	ldr	r2, [pc, #36]	; (80261e4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 80261be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80261c0:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.next_free_start_addr = free_block_addr;
 80261c2:	4a08      	ldr	r2, [pc, #32]	; (80261e4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 80261c4:	6a3b      	ldr	r3, [r7, #32]
 80261c6:	6013      	str	r3, [r2, #0]
          break;
 80261c8:	e008      	b.n	80261dc <E_EEPROM_XMC4_lInitReadSectorInfo+0xa0>
        }
      }
    }
    /* Move the block read address to one block size up starting from the bottom of sector */
    block_read_addr -= E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 80261ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80261cc:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 80261d0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Iterate the read process until the block read address crosses sector start address or a
   * latest valid block is identified.
   */
  } while ( block_read_addr >= sector_start_addr );
 80261d2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80261d4:	69fb      	ldr	r3, [r7, #28]
 80261d6:	429a      	cmp	r2, r3
 80261d8:	d2c0      	bcs.n	802615c <E_EEPROM_XMC4_lInitReadSectorInfo+0x20>

}
 80261da:	bf00      	nop
 80261dc:	bf00      	nop
 80261de:	3728      	adds	r7, #40	; 0x28
 80261e0:	46bd      	mov	sp, r7
 80261e2:	bd80      	pop	{r7, pc}
 80261e4:	20000254 	.word	0x20000254
 80261e8:	200007b0 	.word	0x200007b0

080261ec <E_EEPROM_XMC4_lInitEraseStateMachine>:



static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lInitEraseStateMachine(void)
{
 80261ec:	b580      	push	{r7, lr}
 80261ee:	b084      	sub	sp, #16
 80261f0:	af00      	add	r7, sp, #0
  uint32_t sector_count;
  uint32_t sector_start_addr;
  E_EEPROM_XMC4_STATUS_t status ;

  status = E_EEPROM_XMC4_STATUS_OK;
 80261f2:	2300      	movs	r3, #0
 80261f4:	72fb      	strb	r3, [r7, #11]
  sector_count = 0U;
 80261f6:	2300      	movs	r3, #0
 80261f8:	60fb      	str	r3, [r7, #12]

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80261fa:	4b1b      	ldr	r3, [pc, #108]	; (8026268 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 80261fc:	689b      	ldr	r3, [r3, #8]
 80261fe:	68fa      	ldr	r2, [r7, #12]
 8026200:	429a      	cmp	r2, r3
 8026202:	d026      	beq.n	8026252 <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026204:	4b18      	ldr	r3, [pc, #96]	; (8026268 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 8026206:	68da      	ldr	r2, [r3, #12]
 8026208:	68fb      	ldr	r3, [r7, #12]
 802620a:	fa22 f303 	lsr.w	r3, r2, r3
 802620e:	f003 0301 	and.w	r3, r3, #1
 8026212:	2b00      	cmp	r3, #0
 8026214:	d01d      	beq.n	8026252 <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);
 8026216:	68fb      	ldr	r3, [r7, #12]
 8026218:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 802621c:	3304      	adds	r3, #4
 802621e:	039b      	lsls	r3, r3, #14
 8026220:	607b      	str	r3, [r7, #4]

        XMC_FLASH_ClearStatus();
 8026222:	f000 f8eb 	bl	80263fc <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026226:	687b      	ldr	r3, [r7, #4]
 8026228:	4618      	mov	r0, r3
 802622a:	f000 f92f 	bl	802648c <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 802622e:	f000 f8eb 	bl	8026408 <XMC_FLASH_GetStatus>
 8026232:	4603      	mov	r3, r0
 8026234:	2b20      	cmp	r3, #32
 8026236:	d002      	beq.n	802623e <E_EEPROM_XMC4_lInitEraseStateMachine+0x52>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8026238:	2304      	movs	r3, #4
 802623a:	72fb      	strb	r3, [r7, #11]
          break;
 802623c:	e00f      	b.n	802625e <E_EEPROM_XMC4_lInitEraseStateMachine+0x72>
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 802623e:	4b0a      	ldr	r3, [pc, #40]	; (8026268 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 8026240:	68da      	ldr	r2, [r3, #12]
 8026242:	2101      	movs	r1, #1
 8026244:	68fb      	ldr	r3, [r7, #12]
 8026246:	fa01 f303 	lsl.w	r3, r1, r3
 802624a:	43db      	mvns	r3, r3
 802624c:	4013      	ands	r3, r2
 802624e:	4a06      	ldr	r2, [pc, #24]	; (8026268 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 8026250:	60d3      	str	r3, [r2, #12]
      }
    }
    sector_count++;
 8026252:	68fb      	ldr	r3, [r7, #12]
 8026254:	3301      	adds	r3, #1
 8026256:	60fb      	str	r3, [r7, #12]
    /* Iterate the erase loop until all 4 sectors are checked. Break and return failure on any sector erase errors.*/
  } while ( sector_count < E_EEPROM_XMC4_MAX_SECTORS );
 8026258:	68fb      	ldr	r3, [r7, #12]
 802625a:	2b03      	cmp	r3, #3
 802625c:	d9cd      	bls.n	80261fa <E_EEPROM_XMC4_lInitEraseStateMachine+0xe>

  return (status);
 802625e:	7afb      	ldrb	r3, [r7, #11]
}
 8026260:	4618      	mov	r0, r3
 8026262:	3710      	adds	r7, #16
 8026264:	46bd      	mov	sp, r7
 8026266:	bd80      	pop	{r7, pc}
 8026268:	20000254 	.word	0x20000254

0802626c <E_EEPROM_XMC4_lCalculateCRC>:

/* Local function to CRC */
static uint32_t E_EEPROM_XMC4_lCalculateCRC(const uint32_t *data_start_addr)
{
 802626c:	b580      	push	{r7, lr}
 802626e:	b084      	sub	sp, #16
 8026270:	af00      	add	r7, sp, #0
 8026272:	6078      	str	r0, [r7, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);
 8026274:	2100      	movs	r1, #0
 8026276:	4808      	ldr	r0, [pc, #32]	; (8026298 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 8026278:	f7ff fde8 	bl	8025e4c <XMC_FCE_InitializeSeedValue>

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 802627c:	f107 030c 	add.w	r3, r7, #12
 8026280:	f240 72fc 	movw	r2, #2044	; 0x7fc
 8026284:	6879      	ldr	r1, [r7, #4]
 8026286:	4804      	ldr	r0, [pc, #16]	; (8026298 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 8026288:	f001 ffb2 	bl	80281f0 <XMC_FCE_CalculateCRC32>

  return (result);
 802628c:	68fb      	ldr	r3, [r7, #12]
}
 802628e:	4618      	mov	r0, r3
 8026290:	3710      	adds	r7, #16
 8026292:	46bd      	mov	sp, r7
 8026294:	bd80      	pop	{r7, pc}
 8026296:	bf00      	nop
 8026298:	0802b0d0 	.word	0x0802b0d0

0802629c <E_EEPROM_XMC4_lCopyFlashToRam>:



/* Local function to copy data blocks from FLASH to RAM */
static void E_EEPROM_XMC4_lCopyFlashToRam(void)
{
 802629c:	b480      	push	{r7}
 802629e:	b085      	sub	sp, #20
 80262a0:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
 80262a2:	4b10      	ldr	r3, [pc, #64]	; (80262e4 <E_EEPROM_XMC4_lCopyFlashToRam+0x48>)
 80262a4:	685b      	ldr	r3, [r3, #4]
 80262a6:	60bb      	str	r3, [r7, #8]
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 80262a8:	4b0f      	ldr	r3, [pc, #60]	; (80262e8 <E_EEPROM_XMC4_lCopyFlashToRam+0x4c>)
 80262aa:	607b      	str	r3, [r7, #4]

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 80262ac:	2300      	movs	r3, #0
 80262ae:	60fb      	str	r3, [r7, #12]
 80262b0:	e00c      	b.n	80262cc <E_EEPROM_XMC4_lCopyFlashToRam+0x30>
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
 80262b2:	68fb      	ldr	r3, [r7, #12]
 80262b4:	009b      	lsls	r3, r3, #2
 80262b6:	68ba      	ldr	r2, [r7, #8]
 80262b8:	441a      	add	r2, r3
 80262ba:	68fb      	ldr	r3, [r7, #12]
 80262bc:	009b      	lsls	r3, r3, #2
 80262be:	6879      	ldr	r1, [r7, #4]
 80262c0:	440b      	add	r3, r1
 80262c2:	6812      	ldr	r2, [r2, #0]
 80262c4:	601a      	str	r2, [r3, #0]
  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 80262c6:	68fb      	ldr	r3, [r7, #12]
 80262c8:	3301      	adds	r3, #1
 80262ca:	60fb      	str	r3, [r7, #12]
 80262cc:	68fb      	ldr	r3, [r7, #12]
 80262ce:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80262d2:	d3ee      	bcc.n	80262b2 <E_EEPROM_XMC4_lCopyFlashToRam+0x16>
  }
}
 80262d4:	bf00      	nop
 80262d6:	bf00      	nop
 80262d8:	3714      	adds	r7, #20
 80262da:	46bd      	mov	sp, r7
 80262dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80262e0:	4770      	bx	lr
 80262e2:	bf00      	nop
 80262e4:	20000254 	.word	0x20000254
 80262e8:	200007b0 	.word	0x200007b0

080262ec <XMC_FLASH_lEnterPageModeCommand>:

/*
 * Command to program the PFLASH in to page mode, so that assembly buffer is used
 */
void XMC_FLASH_lEnterPageModeCommand(void)
{
 80262ec:	b480      	push	{r7}
 80262ee:	b083      	sub	sp, #12
 80262f0:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80262f2:	4b05      	ldr	r3, [pc, #20]	; (8026308 <XMC_FLASH_lEnterPageModeCommand+0x1c>)
 80262f4:	607b      	str	r3, [r7, #4]
  *address = (uint32_t)0x50U;
 80262f6:	687b      	ldr	r3, [r7, #4]
 80262f8:	2250      	movs	r2, #80	; 0x50
 80262fa:	601a      	str	r2, [r3, #0]
}
 80262fc:	bf00      	nop
 80262fe:	370c      	adds	r7, #12
 8026300:	46bd      	mov	sp, r7
 8026302:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026306:	4770      	bx	lr
 8026308:	0c005554 	.word	0x0c005554

0802630c <XMC_FLASH_lLoadPageCommand>:

/*
 * Command to load the data into the page assembly buffer
 */
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
 802630c:	b480      	push	{r7}
 802630e:	b085      	sub	sp, #20
 8026310:	af00      	add	r7, sp, #0
 8026312:	6078      	str	r0, [r7, #4]
 8026314:	6039      	str	r1, [r7, #0]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
 8026316:	4b08      	ldr	r3, [pc, #32]	; (8026338 <XMC_FLASH_lLoadPageCommand+0x2c>)
 8026318:	60fb      	str	r3, [r7, #12]
  *address = low_word;
 802631a:	68fb      	ldr	r3, [r7, #12]
 802631c:	687a      	ldr	r2, [r7, #4]
 802631e:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
 8026320:	4b06      	ldr	r3, [pc, #24]	; (802633c <XMC_FLASH_lLoadPageCommand+0x30>)
 8026322:	60fb      	str	r3, [r7, #12]
  *address = high_word;
 8026324:	68fb      	ldr	r3, [r7, #12]
 8026326:	683a      	ldr	r2, [r7, #0]
 8026328:	601a      	str	r2, [r3, #0]
}
 802632a:	bf00      	nop
 802632c:	3714      	adds	r7, #20
 802632e:	46bd      	mov	sp, r7
 8026330:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026334:	4770      	bx	lr
 8026336:	bf00      	nop
 8026338:	0c0055f0 	.word	0x0c0055f0
 802633c:	0c0055f4 	.word	0x0c0055f4

08026340 <XMC_FLASH_lWritePageCommand>:

/*
 * Command to start the programming of one page with data from the assembly buffer
 */
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
 8026340:	b480      	push	{r7}
 8026342:	b085      	sub	sp, #20
 8026344:	af00      	add	r7, sp, #0
 8026346:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8026348:	4b0c      	ldr	r3, [pc, #48]	; (802637c <XMC_FLASH_lWritePageCommand+0x3c>)
 802634a:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 802634c:	68fb      	ldr	r3, [r7, #12]
 802634e:	22aa      	movs	r2, #170	; 0xaa
 8026350:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 8026352:	4b0b      	ldr	r3, [pc, #44]	; (8026380 <XMC_FLASH_lWritePageCommand+0x40>)
 8026354:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 8026356:	68fb      	ldr	r3, [r7, #12]
 8026358:	2255      	movs	r2, #85	; 0x55
 802635a:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 802635c:	4b07      	ldr	r3, [pc, #28]	; (802637c <XMC_FLASH_lWritePageCommand+0x3c>)
 802635e:	60fb      	str	r3, [r7, #12]
  *address = 0xa0U;
 8026360:	68fb      	ldr	r3, [r7, #12]
 8026362:	22a0      	movs	r2, #160	; 0xa0
 8026364:	601a      	str	r2, [r3, #0]
  address = page_start_address;
 8026366:	687b      	ldr	r3, [r7, #4]
 8026368:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 802636a:	68fb      	ldr	r3, [r7, #12]
 802636c:	22aa      	movs	r2, #170	; 0xaa
 802636e:	601a      	str	r2, [r3, #0]
}
 8026370:	bf00      	nop
 8026372:	3714      	adds	r7, #20
 8026374:	46bd      	mov	sp, r7
 8026376:	f85d 7b04 	ldr.w	r7, [sp], #4
 802637a:	4770      	bx	lr
 802637c:	0c005554 	.word	0x0c005554
 8026380:	0c00aaa8 	.word	0x0c00aaa8

08026384 <XMC_FLASH_lEraseSectorCommand>:

/*
 * Command to erase sector which is starting with the specified address
 */
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
 8026384:	b480      	push	{r7}
 8026386:	b085      	sub	sp, #20
 8026388:	af00      	add	r7, sp, #0
 802638a:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 802638c:	4b11      	ldr	r3, [pc, #68]	; (80263d4 <XMC_FLASH_lEraseSectorCommand+0x50>)
 802638e:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 8026390:	68fb      	ldr	r3, [r7, #12]
 8026392:	22aa      	movs	r2, #170	; 0xaa
 8026394:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 8026396:	4b10      	ldr	r3, [pc, #64]	; (80263d8 <XMC_FLASH_lEraseSectorCommand+0x54>)
 8026398:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 802639a:	68fb      	ldr	r3, [r7, #12]
 802639c:	2255      	movs	r2, #85	; 0x55
 802639e:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80263a0:	4b0c      	ldr	r3, [pc, #48]	; (80263d4 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80263a2:	60fb      	str	r3, [r7, #12]
  *address = 0x80U;
 80263a4:	68fb      	ldr	r3, [r7, #12]
 80263a6:	2280      	movs	r2, #128	; 0x80
 80263a8:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80263aa:	4b0a      	ldr	r3, [pc, #40]	; (80263d4 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80263ac:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80263ae:	68fb      	ldr	r3, [r7, #12]
 80263b0:	22aa      	movs	r2, #170	; 0xaa
 80263b2:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 80263b4:	4b08      	ldr	r3, [pc, #32]	; (80263d8 <XMC_FLASH_lEraseSectorCommand+0x54>)
 80263b6:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 80263b8:	68fb      	ldr	r3, [r7, #12]
 80263ba:	2255      	movs	r2, #85	; 0x55
 80263bc:	601a      	str	r2, [r3, #0]
  address = sector_start_address;
 80263be:	687b      	ldr	r3, [r7, #4]
 80263c0:	60fb      	str	r3, [r7, #12]
  *address = 0x30U;
 80263c2:	68fb      	ldr	r3, [r7, #12]
 80263c4:	2230      	movs	r2, #48	; 0x30
 80263c6:	601a      	str	r2, [r3, #0]
}
 80263c8:	bf00      	nop
 80263ca:	3714      	adds	r7, #20
 80263cc:	46bd      	mov	sp, r7
 80263ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80263d2:	4770      	bx	lr
 80263d4:	0c005554 	.word	0x0c005554
 80263d8:	0c00aaa8 	.word	0x0c00aaa8

080263dc <XMC_FLASH_lClearStatusCommand>:

/*
 * Command to clear FSR.PROG and FSR.ERASE and the error flags in FSR such as PFOPER, SQER, PROER, PFDBER, ORIER, VER
 */
void XMC_FLASH_lClearStatusCommand(void)
{
 80263dc:	b480      	push	{r7}
 80263de:	b083      	sub	sp, #12
 80263e0:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80263e2:	4b05      	ldr	r3, [pc, #20]	; (80263f8 <XMC_FLASH_lClearStatusCommand+0x1c>)
 80263e4:	607b      	str	r3, [r7, #4]
  *address = 0xf5U;
 80263e6:	687b      	ldr	r3, [r7, #4]
 80263e8:	22f5      	movs	r2, #245	; 0xf5
 80263ea:	601a      	str	r2, [r3, #0]
}
 80263ec:	bf00      	nop
 80263ee:	370c      	adds	r7, #12
 80263f0:	46bd      	mov	sp, r7
 80263f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80263f6:	4770      	bx	lr
 80263f8:	0c005554 	.word	0x0c005554

080263fc <XMC_FLASH_ClearStatus>:

/*
* This API shall clear Program, erase and error flags(PFOPER, SQER, PROER, PFDBER, ORIER, VER) of FSR register.
*/
void XMC_FLASH_ClearStatus(void)
{
 80263fc:	b580      	push	{r7, lr}
 80263fe:	af00      	add	r7, sp, #0
  XMC_FLASH_lClearStatusCommand();
 8026400:	f7ff ffec 	bl	80263dc <XMC_FLASH_lClearStatusCommand>
}
 8026404:	bf00      	nop
 8026406:	bd80      	pop	{r7, pc}

08026408 <XMC_FLASH_GetStatus>:

/*
 * This API returns the FSR register value
 */
uint32_t XMC_FLASH_GetStatus(void)
{
 8026408:	b480      	push	{r7}
 802640a:	af00      	add	r7, sp, #0
  return FLASH0->FSR;
 802640c:	4b04      	ldr	r3, [pc, #16]	; (8026420 <XMC_FLASH_GetStatus+0x18>)
 802640e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8026412:	691b      	ldr	r3, [r3, #16]
}
 8026414:	4618      	mov	r0, r3
 8026416:	46bd      	mov	sp, r7
 8026418:	f85d 7b04 	ldr.w	r7, [sp], #4
 802641c:	4770      	bx	lr
 802641e:	bf00      	nop
 8026420:	58001000 	.word	0x58001000

08026424 <XMC_FLASH_ProgramPage>:

/*
 * This API write the PFLASH page
 */
void XMC_FLASH_ProgramPage(uint32_t *address, const uint32_t *data)
{
 8026424:	b580      	push	{r7, lr}
 8026426:	b084      	sub	sp, #16
 8026428:	af00      	add	r7, sp, #0
 802642a:	6078      	str	r0, [r7, #4]
 802642c:	6039      	str	r1, [r7, #0]
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();
 802642e:	f7ff ffd5 	bl	80263dc <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEnterPageModeCommand();
 8026432:	f7ff ff5b 	bl	80262ec <XMC_FLASH_lEnterPageModeCommand>

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8026436:	2300      	movs	r3, #0
 8026438:	60fb      	str	r3, [r7, #12]
 802643a:	e010      	b.n	802645e <XMC_FLASH_ProgramPage+0x3a>
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
 802643c:	68fb      	ldr	r3, [r7, #12]
 802643e:	009b      	lsls	r3, r3, #2
 8026440:	683a      	ldr	r2, [r7, #0]
 8026442:	4413      	add	r3, r2
 8026444:	6818      	ldr	r0, [r3, #0]
 8026446:	68fb      	ldr	r3, [r7, #12]
 8026448:	3301      	adds	r3, #1
 802644a:	009b      	lsls	r3, r3, #2
 802644c:	683a      	ldr	r2, [r7, #0]
 802644e:	4413      	add	r3, r2
 8026450:	681b      	ldr	r3, [r3, #0]
 8026452:	4619      	mov	r1, r3
 8026454:	f7ff ff5a 	bl	802630c <XMC_FLASH_lLoadPageCommand>
  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8026458:	68fb      	ldr	r3, [r7, #12]
 802645a:	3302      	adds	r3, #2
 802645c:	60fb      	str	r3, [r7, #12]
 802645e:	68fb      	ldr	r3, [r7, #12]
 8026460:	2b3f      	cmp	r3, #63	; 0x3f
 8026462:	d9eb      	bls.n	802643c <XMC_FLASH_ProgramPage+0x18>
  }

  XMC_FLASH_lWritePageCommand(address);
 8026464:	6878      	ldr	r0, [r7, #4]
 8026466:	f7ff ff6b 	bl	8026340 <XMC_FLASH_lWritePageCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 802646a:	bf00      	nop
 802646c:	4b06      	ldr	r3, [pc, #24]	; (8026488 <XMC_FLASH_ProgramPage+0x64>)
 802646e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8026472:	691b      	ldr	r3, [r3, #16]
 8026474:	f003 0301 	and.w	r3, r3, #1
 8026478:	2b00      	cmp	r3, #0
 802647a:	d1f7      	bne.n	802646c <XMC_FLASH_ProgramPage+0x48>
}
 802647c:	bf00      	nop
 802647e:	bf00      	nop
 8026480:	3710      	adds	r7, #16
 8026482:	46bd      	mov	sp, r7
 8026484:	bd80      	pop	{r7, pc}
 8026486:	bf00      	nop
 8026488:	58001000 	.word	0x58001000

0802648c <XMC_FLASH_EraseSector>:

/*
 * This API erase the logical sector
 */
void XMC_FLASH_EraseSector(uint32_t *address)
{
 802648c:	b580      	push	{r7, lr}
 802648e:	b082      	sub	sp, #8
 8026490:	af00      	add	r7, sp, #0
 8026492:	6078      	str	r0, [r7, #4]
  XMC_FLASH_lClearStatusCommand();
 8026494:	f7ff ffa2 	bl	80263dc <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEraseSectorCommand(address);
 8026498:	6878      	ldr	r0, [r7, #4]
 802649a:	f7ff ff73 	bl	8026384 <XMC_FLASH_lEraseSectorCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 802649e:	bf00      	nop
 80264a0:	4b06      	ldr	r3, [pc, #24]	; (80264bc <XMC_FLASH_EraseSector+0x30>)
 80264a2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80264a6:	691b      	ldr	r3, [r3, #16]
 80264a8:	f003 0301 	and.w	r3, r3, #1
 80264ac:	2b00      	cmp	r3, #0
 80264ae:	d1f7      	bne.n	80264a0 <XMC_FLASH_EraseSector+0x14>
}
 80264b0:	bf00      	nop
 80264b2:	bf00      	nop
 80264b4:	3708      	adds	r7, #8
 80264b6:	46bd      	mov	sp, r7
 80264b8:	bd80      	pop	{r7, pc}
 80264ba:	bf00      	nop
 80264bc:	58001000 	.word	0x58001000

080264c0 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 80264c0:	b480      	push	{r7}
 80264c2:	b085      	sub	sp, #20
 80264c4:	af00      	add	r7, sp, #0
 80264c6:	60f8      	str	r0, [r7, #12]
 80264c8:	460b      	mov	r3, r1
 80264ca:	607a      	str	r2, [r7, #4]
 80264cc:	72fb      	strb	r3, [r7, #11]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 80264ce:	7afb      	ldrb	r3, [r7, #11]
 80264d0:	089b      	lsrs	r3, r3, #2
 80264d2:	b2db      	uxtb	r3, r3
 80264d4:	461a      	mov	r2, r3
 80264d6:	68fb      	ldr	r3, [r7, #12]
 80264d8:	3204      	adds	r2, #4
 80264da:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80264de:	7afb      	ldrb	r3, [r7, #11]
 80264e0:	f003 0303 	and.w	r3, r3, #3
 80264e4:	00db      	lsls	r3, r3, #3
 80264e6:	21f8      	movs	r1, #248	; 0xf8
 80264e8:	fa01 f303 	lsl.w	r3, r1, r3
 80264ec:	43db      	mvns	r3, r3
 80264ee:	7af9      	ldrb	r1, [r7, #11]
 80264f0:	0889      	lsrs	r1, r1, #2
 80264f2:	b2c9      	uxtb	r1, r1
 80264f4:	4608      	mov	r0, r1
 80264f6:	ea02 0103 	and.w	r1, r2, r3
 80264fa:	68fb      	ldr	r3, [r7, #12]
 80264fc:	1d02      	adds	r2, r0, #4
 80264fe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8026502:	68fb      	ldr	r3, [r7, #12]
 8026504:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8026506:	7afb      	ldrb	r3, [r7, #11]
 8026508:	005b      	lsls	r3, r3, #1
 802650a:	2103      	movs	r1, #3
 802650c:	fa01 f303 	lsl.w	r3, r1, r3
 8026510:	43db      	mvns	r3, r3
 8026512:	401a      	ands	r2, r3
 8026514:	68fb      	ldr	r3, [r7, #12]
 8026516:	675a      	str	r2, [r3, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8026518:	68fb      	ldr	r3, [r7, #12]
 802651a:	4a3a      	ldr	r2, [pc, #232]	; (8026604 <XMC_GPIO_Init+0x144>)
 802651c:	4293      	cmp	r3, r2
 802651e:	d003      	beq.n	8026528 <XMC_GPIO_Init+0x68>
 8026520:	68fb      	ldr	r3, [r7, #12]
 8026522:	4a39      	ldr	r2, [pc, #228]	; (8026608 <XMC_GPIO_Init+0x148>)
 8026524:	4293      	cmp	r3, r2
 8026526:	d10a      	bne.n	802653e <XMC_GPIO_Init+0x7e>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 8026528:	68fb      	ldr	r3, [r7, #12]
 802652a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 802652c:	7afb      	ldrb	r3, [r7, #11]
 802652e:	2101      	movs	r1, #1
 8026530:	fa01 f303 	lsl.w	r3, r1, r3
 8026534:	43db      	mvns	r3, r3
 8026536:	401a      	ands	r2, r3
 8026538:	68fb      	ldr	r3, [r7, #12]
 802653a:	661a      	str	r2, [r3, #96]	; 0x60
 802653c:	e041      	b.n	80265c2 <XMC_GPIO_Init+0x102>
  }
  else
  {
    if ((config->mode & XMC_GPIO_MODE_OE) != 0)
 802653e:	687b      	ldr	r3, [r7, #4]
 8026540:	781b      	ldrb	r3, [r3, #0]
 8026542:	b25b      	sxtb	r3, r3
 8026544:	2b00      	cmp	r3, #0
 8026546:	da3c      	bge.n	80265c2 <XMC_GPIO_Init+0x102>
    {
      /* If output is enabled */

      /* Set output level */
      port->OMR = (uint32_t)config->output_level << pin;
 8026548:	687b      	ldr	r3, [r7, #4]
 802654a:	685a      	ldr	r2, [r3, #4]
 802654c:	7afb      	ldrb	r3, [r7, #11]
 802654e:	409a      	lsls	r2, r3
 8026550:	68fb      	ldr	r3, [r7, #12]
 8026552:	605a      	str	r2, [r3, #4]

      /* Set output driver strength */
      port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 8026554:	7afb      	ldrb	r3, [r7, #11]
 8026556:	08db      	lsrs	r3, r3, #3
 8026558:	b2db      	uxtb	r3, r3
 802655a:	461a      	mov	r2, r3
 802655c:	68fb      	ldr	r3, [r7, #12]
 802655e:	3210      	adds	r2, #16
 8026560:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8026564:	7afb      	ldrb	r3, [r7, #11]
 8026566:	f003 0307 	and.w	r3, r3, #7
 802656a:	009b      	lsls	r3, r3, #2
 802656c:	2107      	movs	r1, #7
 802656e:	fa01 f303 	lsl.w	r3, r1, r3
 8026572:	43db      	mvns	r3, r3
 8026574:	7af9      	ldrb	r1, [r7, #11]
 8026576:	08c9      	lsrs	r1, r1, #3
 8026578:	b2c9      	uxtb	r1, r1
 802657a:	4608      	mov	r0, r1
 802657c:	ea02 0103 	and.w	r1, r2, r3
 8026580:	68fb      	ldr	r3, [r7, #12]
 8026582:	f100 0210 	add.w	r2, r0, #16
 8026586:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 802658a:	7afb      	ldrb	r3, [r7, #11]
 802658c:	08db      	lsrs	r3, r3, #3
 802658e:	b2db      	uxtb	r3, r3
 8026590:	461a      	mov	r2, r3
 8026592:	68fb      	ldr	r3, [r7, #12]
 8026594:	3210      	adds	r2, #16
 8026596:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802659a:	687b      	ldr	r3, [r7, #4]
 802659c:	7a1b      	ldrb	r3, [r3, #8]
 802659e:	4619      	mov	r1, r3
 80265a0:	7afb      	ldrb	r3, [r7, #11]
 80265a2:	f003 0307 	and.w	r3, r3, #7
 80265a6:	009b      	lsls	r3, r3, #2
 80265a8:	fa01 f303 	lsl.w	r3, r1, r3
 80265ac:	7af9      	ldrb	r1, [r7, #11]
 80265ae:	08c9      	lsrs	r1, r1, #3
 80265b0:	b2c9      	uxtb	r1, r1
 80265b2:	4608      	mov	r0, r1
 80265b4:	ea42 0103 	orr.w	r1, r2, r3
 80265b8:	68fb      	ldr	r3, [r7, #12]
 80265ba:	f100 0210 	add.w	r2, r0, #16
 80265be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 80265c2:	7afb      	ldrb	r3, [r7, #11]
 80265c4:	089b      	lsrs	r3, r3, #2
 80265c6:	b2db      	uxtb	r3, r3
 80265c8:	461a      	mov	r2, r3
 80265ca:	68fb      	ldr	r3, [r7, #12]
 80265cc:	3204      	adds	r2, #4
 80265ce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80265d2:	687b      	ldr	r3, [r7, #4]
 80265d4:	781b      	ldrb	r3, [r3, #0]
 80265d6:	4619      	mov	r1, r3
 80265d8:	7afb      	ldrb	r3, [r7, #11]
 80265da:	f003 0303 	and.w	r3, r3, #3
 80265de:	00db      	lsls	r3, r3, #3
 80265e0:	fa01 f303 	lsl.w	r3, r1, r3
 80265e4:	7af9      	ldrb	r1, [r7, #11]
 80265e6:	0889      	lsrs	r1, r1, #2
 80265e8:	b2c9      	uxtb	r1, r1
 80265ea:	4608      	mov	r0, r1
 80265ec:	ea42 0103 	orr.w	r1, r2, r3
 80265f0:	68fb      	ldr	r3, [r7, #12]
 80265f2:	1d02      	adds	r2, r0, #4
 80265f4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80265f8:	bf00      	nop
 80265fa:	3714      	adds	r7, #20
 80265fc:	46bd      	mov	sp, r7
 80265fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026602:	4770      	bx	lr
 8026604:	48028e00 	.word	0x48028e00
 8026608:	48028f00 	.word	0x48028f00

0802660c <XMC_SCU_CLOCK_GetCpuClockFrequency>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
{
 802660c:	b480      	push	{r7}
 802660e:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8026610:	4b03      	ldr	r3, [pc, #12]	; (8026620 <XMC_SCU_CLOCK_GetCpuClockFrequency+0x14>)
 8026612:	681b      	ldr	r3, [r3, #0]
}
 8026614:	4618      	mov	r0, r3
 8026616:	46bd      	mov	sp, r7
 8026618:	f85d 7b04 	ldr.w	r7, [sp], #4
 802661c:	4770      	bx	lr
 802661e:	bf00      	nop
 8026620:	2000ffc0 	.word	0x2000ffc0

08026624 <XMC_SCU_lDelay>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
 8026624:	b580      	push	{r7, lr}
 8026626:	b084      	sub	sp, #16
 8026628:	af00      	add	r7, sp, #0
 802662a:	6078      	str	r0, [r7, #4]
  uint32_t i;

  SystemCoreClockUpdate();
 802662c:	f7fa f854 	bl	80206d8 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8026630:	4b0c      	ldr	r3, [pc, #48]	; (8026664 <XMC_SCU_lDelay+0x40>)
 8026632:	681b      	ldr	r3, [r3, #0]
 8026634:	4a0c      	ldr	r2, [pc, #48]	; (8026668 <XMC_SCU_lDelay+0x44>)
 8026636:	fba2 2303 	umull	r2, r3, r2, r3
 802663a:	0c9a      	lsrs	r2, r3, #18
 802663c:	687b      	ldr	r3, [r7, #4]
 802663e:	fb02 f303 	mul.w	r3, r2, r3
 8026642:	607b      	str	r3, [r7, #4]

  for (i = 0U; i < delay; ++i)
 8026644:	2300      	movs	r3, #0
 8026646:	60fb      	str	r3, [r7, #12]
 8026648:	e003      	b.n	8026652 <XMC_SCU_lDelay+0x2e>
  {
    __NOP();
 802664a:	bf00      	nop
  for (i = 0U; i < delay; ++i)
 802664c:	68fb      	ldr	r3, [r7, #12]
 802664e:	3301      	adds	r3, #1
 8026650:	60fb      	str	r3, [r7, #12]
 8026652:	68fa      	ldr	r2, [r7, #12]
 8026654:	687b      	ldr	r3, [r7, #4]
 8026656:	429a      	cmp	r2, r3
 8026658:	d3f7      	bcc.n	802664a <XMC_SCU_lDelay+0x26>
  }
}
 802665a:	bf00      	nop
 802665c:	bf00      	nop
 802665e:	3710      	adds	r7, #16
 8026660:	46bd      	mov	sp, r7
 8026662:	bd80      	pop	{r7, pc}
 8026664:	2000ffc0 	.word	0x2000ffc0
 8026668:	431bde83 	.word	0x431bde83

0802666c <XMC_SCU_INTERUPT_GetEventStatus>:
  SCU_INTERRUPT->SRSET |= (uint32_t)event;
}

/* API to retrieve the SCU event status */
XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
{
 802666c:	b480      	push	{r7}
 802666e:	af00      	add	r7, sp, #0
  return (SCU_INTERRUPT->SRRAW);
 8026670:	4b03      	ldr	r3, [pc, #12]	; (8026680 <XMC_SCU_INTERUPT_GetEventStatus+0x14>)
 8026672:	685b      	ldr	r3, [r3, #4]
}
 8026674:	4618      	mov	r0, r3
 8026676:	46bd      	mov	sp, r7
 8026678:	f85d 7b04 	ldr.w	r7, [sp], #4
 802667c:	4770      	bx	lr
 802667e:	bf00      	nop
 8026680:	50004074 	.word	0x50004074

08026684 <XMC_SCU_INTERRUPT_ClearEventStatus>:

/* API to clear the SCU event status */
void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
{
 8026684:	b480      	push	{r7}
 8026686:	b083      	sub	sp, #12
 8026688:	af00      	add	r7, sp, #0
 802668a:	6078      	str	r0, [r7, #4]
  SCU_INTERRUPT->SRCLR = (uint32_t)event;
 802668c:	4a04      	ldr	r2, [pc, #16]	; (80266a0 <XMC_SCU_INTERRUPT_ClearEventStatus+0x1c>)
 802668e:	687b      	ldr	r3, [r7, #4]
 8026690:	60d3      	str	r3, [r2, #12]
}
 8026692:	bf00      	nop
 8026694:	370c      	adds	r7, #12
 8026696:	46bd      	mov	sp, r7
 8026698:	f85d 7b04 	ldr.w	r7, [sp], #4
 802669c:	4770      	bx	lr
 802669e:	bf00      	nop
 80266a0:	50004074 	.word	0x50004074

080266a4 <XMC_SCU_SetBootMode>:
  return (uint32_t)(SCU_GENERAL->STCON & SCU_GENERAL_STCON_SWCON_Msk);
}

/* API to program a new device bootmode */
void XMC_SCU_SetBootMode(const XMC_SCU_BOOTMODE_t bootmode)
{
 80266a4:	b480      	push	{r7}
 80266a6:	b083      	sub	sp, #12
 80266a8:	af00      	add	r7, sp, #0
 80266aa:	4603      	mov	r3, r0
 80266ac:	80fb      	strh	r3, [r7, #6]
  SCU_GENERAL->STCON = (uint32_t)bootmode;
 80266ae:	4a04      	ldr	r2, [pc, #16]	; (80266c0 <XMC_SCU_SetBootMode+0x1c>)
 80266b0:	88fb      	ldrh	r3, [r7, #6]
 80266b2:	6113      	str	r3, [r2, #16]
}
 80266b4:	bf00      	nop
 80266b6:	370c      	adds	r7, #12
 80266b8:	46bd      	mov	sp, r7
 80266ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80266be:	4770      	bx	lr
 80266c0:	50004000 	.word	0x50004000

080266c4 <XMC_SCU_CLOCK_Init>:
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 80266c4:	b590      	push	{r4, r7, lr}
 80266c6:	b085      	sub	sp, #20
 80266c8:	af02      	add	r7, sp, #8
 80266ca:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("", ((config->fstdby_clksrc == XMC_SCU_HIB_STDBYCLKSRC_OSCULP) && (config->enable_osculp == true)) ||
                 (config->fstdby_clksrc != XMC_SCU_HIB_STDBYCLKSRC_OSCULP));
  XMC_ASSERT("", ((config->syspll_config.clksrc == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) &&
                 (config->enable_oschp == true)) || (config->syspll_config.clksrc != XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP));

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);
 80266cc:	2000      	movs	r0, #0
 80266ce:	f000 f895 	bl	80267fc <XMC_SCU_CLOCK_SetSystemClockSource>

  XMC_SCU_HIB_EnableHibernateDomain();
 80266d2:	f000 fa25 	bl	8026b20 <XMC_SCU_HIB_EnableHibernateDomain>

  if (config->enable_osculp == true)
 80266d6:	687b      	ldr	r3, [r7, #4]
 80266d8:	79db      	ldrb	r3, [r3, #7]
 80266da:	2b00      	cmp	r3, #0
 80266dc:	d00a      	beq.n	80266f4 <XMC_SCU_CLOCK_Init+0x30>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
 80266de:	f000 fa5d 	bl	8026b9c <XMC_SCU_CLOCK_EnableLowPowerOscillator>
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 80266e2:	bf00      	nop
 80266e4:	f000 fa48 	bl	8026b78 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>
 80266e8:	4603      	mov	r3, r0
 80266ea:	f083 0301 	eor.w	r3, r3, #1
 80266ee:	b2db      	uxtb	r3, r3
 80266f0:	2b00      	cmp	r3, #0
 80266f2:	d1f7      	bne.n	80266e4 <XMC_SCU_CLOCK_Init+0x20>
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
 80266f4:	687b      	ldr	r3, [r7, #4]
 80266f6:	7a5b      	ldrb	r3, [r3, #9]
 80266f8:	4618      	mov	r0, r3
 80266fa:	f000 f8e8 	bl	80268ce <XMC_SCU_HIB_SetStandbyClockSource>
  //while (XMC_SCU_GetMirrorStatus() != 0)
 // {
    /* Wait until update of the stanby clock source is done in the HIB domain */    
 // }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 80266fe:	687b      	ldr	r3, [r7, #4]
 8026700:	7a1b      	ldrb	r3, [r3, #8]
 8026702:	4618      	mov	r0, r3
 8026704:	f000 f9e6 	bl	8026ad4 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 8026708:	687b      	ldr	r3, [r7, #4]
 802670a:	7c1b      	ldrb	r3, [r3, #16]
 802670c:	4618      	mov	r0, r3
 802670e:	f000 f8e9 	bl	80268e4 <XMC_SCU_CLOCK_SetSystemClockDivider>
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 8026712:	687b      	ldr	r3, [r7, #4]
 8026714:	7c5b      	ldrb	r3, [r3, #17]
 8026716:	4618      	mov	r0, r3
 8026718:	f000 f910 	bl	802693c <XMC_SCU_CLOCK_SetCpuClockDivider>
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 802671c:	687b      	ldr	r3, [r7, #4]
 802671e:	7c9b      	ldrb	r3, [r3, #18]
 8026720:	4618      	mov	r0, r3
 8026722:	f000 f8f5 	bl	8026910 <XMC_SCU_CLOCK_SetCcuClockDivider>
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 8026726:	687b      	ldr	r3, [r7, #4]
 8026728:	7cdb      	ldrb	r3, [r3, #19]
 802672a:	4618      	mov	r0, r3
 802672c:	f000 f91c 	bl	8026968 <XMC_SCU_CLOCK_SetPeripheralClockDivider>

  if (config->enable_oschp == true)
 8026730:	687b      	ldr	r3, [r7, #4]
 8026732:	799b      	ldrb	r3, [r3, #6]
 8026734:	2b00      	cmp	r3, #0
 8026736:	d00a      	beq.n	802674e <XMC_SCU_CLOCK_Init+0x8a>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
 8026738:	f000 fa6a 	bl	8026c10 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 802673c:	bf00      	nop
 802673e:	f000 fa8f 	bl	8026c60 <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>
 8026742:	4603      	mov	r3, r0
 8026744:	f083 0301 	eor.w	r3, r3, #1
 8026748:	b2db      	uxtb	r3, r3
 802674a:	2b00      	cmp	r3, #0
 802674c:	d1f7      	bne.n	802673e <XMC_SCU_CLOCK_Init+0x7a>
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 802674e:	687b      	ldr	r3, [r7, #4]
 8026750:	78db      	ldrb	r3, [r3, #3]
 8026752:	2b00      	cmp	r3, #0
 8026754:	d102      	bne.n	802675c <XMC_SCU_CLOCK_Init+0x98>
  {
    XMC_SCU_CLOCK_DisableSystemPll();
 8026756:	f000 faa9 	bl	8026cac <XMC_SCU_CLOCK_DisableSystemPll>
 802675a:	e011      	b.n	8026780 <XMC_SCU_CLOCK_Init+0xbc>
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
 802675c:	f000 fa94 	bl	8026c88 <XMC_SCU_CLOCK_EnableSystemPll>
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8026760:	687b      	ldr	r3, [r7, #4]
 8026762:	8898      	ldrh	r0, [r3, #4]
 8026764:	687b      	ldr	r3, [r7, #4]
 8026766:	78d9      	ldrb	r1, [r3, #3]
                                 config->syspll_config.mode,
                                 (uint32_t)config->syspll_config.p_div,
 8026768:	687b      	ldr	r3, [r7, #4]
 802676a:	785b      	ldrb	r3, [r3, #1]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 802676c:	461a      	mov	r2, r3
                                 (uint32_t)config->syspll_config.n_div,
 802676e:	687b      	ldr	r3, [r7, #4]
 8026770:	781b      	ldrb	r3, [r3, #0]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8026772:	461c      	mov	r4, r3
                                 (uint32_t)config->syspll_config.k_div);
 8026774:	687b      	ldr	r3, [r7, #4]
 8026776:	789b      	ldrb	r3, [r3, #2]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8026778:	9300      	str	r3, [sp, #0]
 802677a:	4623      	mov	r3, r4
 802677c:	f000 faa8 	bl	8026cd0 <XMC_SCU_CLOCK_StartSystemPll>
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 8026780:	687b      	ldr	r3, [r7, #4]
 8026782:	68db      	ldr	r3, [r3, #12]
 8026784:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8026788:	d103      	bne.n	8026792 <XMC_SCU_CLOCK_Init+0xce>
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
 802678a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 802678e:	f000 f835 	bl	80267fc <XMC_SCU_CLOCK_SetSystemClockSource>
  }
  SystemCoreClockUpdate();
 8026792:	f7f9 ffa1 	bl	80206d8 <SystemCoreClockUpdate>
}
 8026796:	bf00      	nop
 8026798:	370c      	adds	r7, #12
 802679a:	46bd      	mov	sp, r7
 802679c:	bd90      	pop	{r4, r7, pc}
	...

080267a0 <XMC_SCU_RESET_DeassertPeripheralReset>:
  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 80267a0:	b480      	push	{r7}
 80267a2:	b085      	sub	sp, #20
 80267a4:	af00      	add	r7, sp, #0
 80267a6:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 80267a8:	687b      	ldr	r3, [r7, #4]
 80267aa:	0f1b      	lsrs	r3, r3, #28
 80267ac:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 80267ae:	687b      	ldr	r3, [r7, #4]
 80267b0:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 80267b4:	60bb      	str	r3, [r7, #8]

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 80267b6:	68fa      	ldr	r2, [r7, #12]
 80267b8:	4613      	mov	r3, r2
 80267ba:	005b      	lsls	r3, r3, #1
 80267bc:	4413      	add	r3, r2
 80267be:	009b      	lsls	r3, r3, #2
 80267c0:	461a      	mov	r2, r3
 80267c2:	4b05      	ldr	r3, [pc, #20]	; (80267d8 <XMC_SCU_RESET_DeassertPeripheralReset+0x38>)
 80267c4:	4413      	add	r3, r2
 80267c6:	68ba      	ldr	r2, [r7, #8]
 80267c8:	601a      	str	r2, [r3, #0]
}
 80267ca:	bf00      	nop
 80267cc:	3714      	adds	r7, #20
 80267ce:	46bd      	mov	sp, r7
 80267d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267d4:	4770      	bx	lr
 80267d6:	bf00      	nop
 80267d8:	50004414 	.word	0x50004414

080267dc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
 80267dc:	b580      	push	{r7, lr}
 80267de:	af00      	add	r7, sp, #0
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 80267e0:	f7ff ff14 	bl	802660c <XMC_SCU_CLOCK_GetCpuClockFrequency>
 80267e4:	4602      	mov	r2, r0
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
 80267e6:	4b04      	ldr	r3, [pc, #16]	; (80267f8 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x1c>)
 80267e8:	695b      	ldr	r3, [r3, #20]
 80267ea:	f003 0301 	and.w	r3, r3, #1
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 80267ee:	fa22 f303 	lsr.w	r3, r2, r3
}
 80267f2:	4618      	mov	r0, r3
 80267f4:	bd80      	pop	{r7, pc}
 80267f6:	bf00      	nop
 80267f8:	50004600 	.word	0x50004600

080267fc <XMC_SCU_CLOCK_SetSystemClockSource>:

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
 80267fc:	b480      	push	{r7}
 80267fe:	b083      	sub	sp, #12
 8026800:	af00      	add	r7, sp, #0
 8026802:	6078      	str	r0, [r7, #4]
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8026804:	4b06      	ldr	r3, [pc, #24]	; (8026820 <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 8026806:	68db      	ldr	r3, [r3, #12]
 8026808:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 802680c:	4904      	ldr	r1, [pc, #16]	; (8026820 <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 802680e:	687b      	ldr	r3, [r7, #4]
 8026810:	4313      	orrs	r3, r2
 8026812:	60cb      	str	r3, [r1, #12]
                      ((uint32_t)source);
}
 8026814:	bf00      	nop
 8026816:	370c      	adds	r7, #12
 8026818:	46bd      	mov	sp, r7
 802681a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802681e:	4770      	bx	lr
 8026820:	50004600 	.word	0x50004600

08026824 <XMC_SCU_CLOCK_SetUsbClockSource>:

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
 8026824:	b480      	push	{r7}
 8026826:	b083      	sub	sp, #12
 8026828:	af00      	add	r7, sp, #0
 802682a:	6078      	str	r0, [r7, #4]
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 802682c:	4b06      	ldr	r3, [pc, #24]	; (8026848 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 802682e:	699b      	ldr	r3, [r3, #24]
 8026830:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8026834:	4904      	ldr	r1, [pc, #16]	; (8026848 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 8026836:	687b      	ldr	r3, [r7, #4]
 8026838:	4313      	orrs	r3, r2
 802683a:	618b      	str	r3, [r1, #24]
                      ((uint32_t)source);
}
 802683c:	bf00      	nop
 802683e:	370c      	adds	r7, #12
 8026840:	46bd      	mov	sp, r7
 8026842:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026846:	4770      	bx	lr
 8026848:	50004600 	.word	0x50004600

0802684c <XMC_SCU_CLOCK_SetWdtClockSource>:

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
 802684c:	b480      	push	{r7}
 802684e:	b083      	sub	sp, #12
 8026850:	af00      	add	r7, sp, #0
 8026852:	6078      	str	r0, [r7, #4]
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 8026854:	4b06      	ldr	r3, [pc, #24]	; (8026870 <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 8026856:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8026858:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 802685c:	4904      	ldr	r1, [pc, #16]	; (8026870 <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 802685e:	687b      	ldr	r3, [r7, #4]
 8026860:	4313      	orrs	r3, r2
 8026862:	624b      	str	r3, [r1, #36]	; 0x24
                      ((uint32_t)source);
}
 8026864:	bf00      	nop
 8026866:	370c      	adds	r7, #12
 8026868:	46bd      	mov	sp, r7
 802686a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802686e:	4770      	bx	lr
 8026870:	50004600 	.word	0x50004600

08026874 <XMC_SCU_CLOCK_SetSystemPllClockSource>:
                      ((uint32_t)source);
}

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
 8026874:	b480      	push	{r7}
 8026876:	b083      	sub	sp, #12
 8026878:	af00      	add	r7, sp, #0
 802687a:	4603      	mov	r3, r0
 802687c:	80fb      	strh	r3, [r7, #6]
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 802687e:	88fb      	ldrh	r3, [r7, #6]
 8026880:	2b00      	cmp	r3, #0
 8026882:	d108      	bne.n	8026896 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x22>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8026884:	4b0b      	ldr	r3, [pc, #44]	; (80268b4 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 8026886:	68db      	ldr	r3, [r3, #12]
 8026888:	4a0a      	ldr	r2, [pc, #40]	; (80268b4 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 802688a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802688e:	f023 0301 	bic.w	r3, r3, #1
 8026892:	60d3      	str	r3, [r2, #12]
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
}
 8026894:	e007      	b.n	80268a6 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x32>
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8026896:	4b07      	ldr	r3, [pc, #28]	; (80268b4 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 8026898:	68db      	ldr	r3, [r3, #12]
 802689a:	4a06      	ldr	r2, [pc, #24]	; (80268b4 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 802689c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80268a0:	f043 0301 	orr.w	r3, r3, #1
 80268a4:	60d3      	str	r3, [r2, #12]
}
 80268a6:	bf00      	nop
 80268a8:	370c      	adds	r7, #12
 80268aa:	46bd      	mov	sp, r7
 80268ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80268b0:	4770      	bx	lr
 80268b2:	bf00      	nop
 80268b4:	50004710 	.word	0x50004710

080268b8 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
 80268b8:	b480      	push	{r7}
 80268ba:	b083      	sub	sp, #12
 80268bc:	af00      	add	r7, sp, #0
 80268be:	4603      	mov	r3, r0
 80268c0:	71fb      	strb	r3, [r7, #7]
 // {
 // }

 // SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 //                       ((uint32_t)source);
}
 80268c2:	bf00      	nop
 80268c4:	370c      	adds	r7, #12
 80268c6:	46bd      	mov	sp, r7
 80268c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80268cc:	4770      	bx	lr

080268ce <XMC_SCU_HIB_SetStandbyClockSource>:

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
 80268ce:	b480      	push	{r7}
 80268d0:	b083      	sub	sp, #12
 80268d2:	af00      	add	r7, sp, #0
 80268d4:	4603      	mov	r3, r0
 80268d6:	71fb      	strb	r3, [r7, #7]
 // {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
 // }
//  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 //                       ((uint32_t)source);
}
 80268d8:	bf00      	nop
 80268da:	370c      	adds	r7, #12
 80268dc:	46bd      	mov	sp, r7
 80268de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80268e2:	4770      	bx	lr

080268e4 <XMC_SCU_CLOCK_SetSystemClockDivider>:

/* API to program the divider placed between fsys and its parent */
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
 80268e4:	b480      	push	{r7}
 80268e6:	b083      	sub	sp, #12
 80268e8:	af00      	add	r7, sp, #0
 80268ea:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80268ec:	4b07      	ldr	r3, [pc, #28]	; (802690c <XMC_SCU_CLOCK_SetSystemClockDivider+0x28>)
 80268ee:	68db      	ldr	r3, [r3, #12]
 80268f0:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 80268f4:	687b      	ldr	r3, [r7, #4]
 80268f6:	3b01      	subs	r3, #1
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80268f8:	4904      	ldr	r1, [pc, #16]	; (802690c <XMC_SCU_CLOCK_SetSystemClockDivider+0x28>)
 80268fa:	4313      	orrs	r3, r2
 80268fc:	60cb      	str	r3, [r1, #12]
}
 80268fe:	bf00      	nop
 8026900:	370c      	adds	r7, #12
 8026902:	46bd      	mov	sp, r7
 8026904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026908:	4770      	bx	lr
 802690a:	bf00      	nop
 802690c:	50004600 	.word	0x50004600

08026910 <XMC_SCU_CLOCK_SetCcuClockDivider>:

/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
 8026910:	b480      	push	{r7}
 8026912:	b083      	sub	sp, #12
 8026914:	af00      	add	r7, sp, #0
 8026916:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8026918:	4b07      	ldr	r3, [pc, #28]	; (8026938 <XMC_SCU_CLOCK_SetCcuClockDivider+0x28>)
 802691a:	6a1b      	ldr	r3, [r3, #32]
 802691c:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 8026920:	687b      	ldr	r3, [r7, #4]
 8026922:	3b01      	subs	r3, #1
  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8026924:	4904      	ldr	r1, [pc, #16]	; (8026938 <XMC_SCU_CLOCK_SetCcuClockDivider+0x28>)
 8026926:	4313      	orrs	r3, r2
 8026928:	620b      	str	r3, [r1, #32]
}
 802692a:	bf00      	nop
 802692c:	370c      	adds	r7, #12
 802692e:	46bd      	mov	sp, r7
 8026930:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026934:	4770      	bx	lr
 8026936:	bf00      	nop
 8026938:	50004600 	.word	0x50004600

0802693c <XMC_SCU_CLOCK_SetCpuClockDivider>:

/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
 802693c:	b480      	push	{r7}
 802693e:	b083      	sub	sp, #12
 8026940:	af00      	add	r7, sp, #0
 8026942:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8026944:	4b07      	ldr	r3, [pc, #28]	; (8026964 <XMC_SCU_CLOCK_SetCpuClockDivider+0x28>)
 8026946:	691b      	ldr	r3, [r3, #16]
 8026948:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 802694c:	687b      	ldr	r3, [r7, #4]
 802694e:	3b01      	subs	r3, #1
  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8026950:	4904      	ldr	r1, [pc, #16]	; (8026964 <XMC_SCU_CLOCK_SetCpuClockDivider+0x28>)
 8026952:	4313      	orrs	r3, r2
 8026954:	610b      	str	r3, [r1, #16]
}
 8026956:	bf00      	nop
 8026958:	370c      	adds	r7, #12
 802695a:	46bd      	mov	sp, r7
 802695c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026960:	4770      	bx	lr
 8026962:	bf00      	nop
 8026964:	50004600 	.word	0x50004600

08026968 <XMC_SCU_CLOCK_SetPeripheralClockDivider>:

/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
 8026968:	b480      	push	{r7}
 802696a:	b083      	sub	sp, #12
 802696c:	af00      	add	r7, sp, #0
 802696e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8026970:	4b07      	ldr	r3, [pc, #28]	; (8026990 <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x28>)
 8026972:	695b      	ldr	r3, [r3, #20]
 8026974:	f023 0201 	bic.w	r2, r3, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 8026978:	687b      	ldr	r3, [r7, #4]
 802697a:	3b01      	subs	r3, #1
  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 802697c:	4904      	ldr	r1, [pc, #16]	; (8026990 <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x28>)
 802697e:	4313      	orrs	r3, r2
 8026980:	614b      	str	r3, [r1, #20]
}
 8026982:	bf00      	nop
 8026984:	370c      	adds	r7, #12
 8026986:	46bd      	mov	sp, r7
 8026988:	f85d 7b04 	ldr.w	r7, [sp], #4
 802698c:	4770      	bx	lr
 802698e:	bf00      	nop
 8026990:	50004600 	.word	0x50004600

08026994 <XMC_SCU_CLOCK_SetUsbClockDivider>:

/* API to program the divider placed between fsdmmc and its parent */
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
 8026994:	b480      	push	{r7}
 8026996:	b083      	sub	sp, #12
 8026998:	af00      	add	r7, sp, #0
 802699a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 802699c:	4b07      	ldr	r3, [pc, #28]	; (80269bc <XMC_SCU_CLOCK_SetUsbClockDivider+0x28>)
 802699e:	699b      	ldr	r3, [r3, #24]
 80269a0:	f023 0207 	bic.w	r2, r3, #7
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 80269a4:	687b      	ldr	r3, [r7, #4]
 80269a6:	3b01      	subs	r3, #1
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 80269a8:	4904      	ldr	r1, [pc, #16]	; (80269bc <XMC_SCU_CLOCK_SetUsbClockDivider+0x28>)
 80269aa:	4313      	orrs	r3, r2
 80269ac:	618b      	str	r3, [r1, #24]
}
 80269ae:	bf00      	nop
 80269b0:	370c      	adds	r7, #12
 80269b2:	46bd      	mov	sp, r7
 80269b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80269b8:	4770      	bx	lr
 80269ba:	bf00      	nop
 80269bc:	50004600 	.word	0x50004600

080269c0 <XMC_SCU_CLOCK_SetEbuClockDivider>:

#if defined(EBU)
/* API to program the divider placed between febu and its parent */
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
 80269c0:	b480      	push	{r7}
 80269c2:	b083      	sub	sp, #12
 80269c4:	af00      	add	r7, sp, #0
 80269c6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 80269c8:	4b07      	ldr	r3, [pc, #28]	; (80269e8 <XMC_SCU_CLOCK_SetEbuClockDivider+0x28>)
 80269ca:	69db      	ldr	r3, [r3, #28]
 80269cc:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 80269d0:	687b      	ldr	r3, [r7, #4]
 80269d2:	3b01      	subs	r3, #1
  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 80269d4:	4904      	ldr	r1, [pc, #16]	; (80269e8 <XMC_SCU_CLOCK_SetEbuClockDivider+0x28>)
 80269d6:	4313      	orrs	r3, r2
 80269d8:	61cb      	str	r3, [r1, #28]
}
 80269da:	bf00      	nop
 80269dc:	370c      	adds	r7, #12
 80269de:	46bd      	mov	sp, r7
 80269e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80269e4:	4770      	bx	lr
 80269e6:	bf00      	nop
 80269e8:	50004600 	.word	0x50004600

080269ec <XMC_SCU_CLOCK_SetWdtClockDivider>:
#endif

/* API to program the divider placed between fwdt and its parent */
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
 80269ec:	b480      	push	{r7}
 80269ee:	b083      	sub	sp, #12
 80269f0:	af00      	add	r7, sp, #0
 80269f2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80269f4:	4b07      	ldr	r3, [pc, #28]	; (8026a14 <XMC_SCU_CLOCK_SetWdtClockDivider+0x28>)
 80269f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80269f8:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 80269fc:	687b      	ldr	r3, [r7, #4]
 80269fe:	3b01      	subs	r3, #1
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8026a00:	4904      	ldr	r1, [pc, #16]	; (8026a14 <XMC_SCU_CLOCK_SetWdtClockDivider+0x28>)
 8026a02:	4313      	orrs	r3, r2
 8026a04:	624b      	str	r3, [r1, #36]	; 0x24
}
 8026a06:	bf00      	nop
 8026a08:	370c      	adds	r7, #12
 8026a0a:	46bd      	mov	sp, r7
 8026a0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a10:	4770      	bx	lr
 8026a12:	bf00      	nop
 8026a14:	50004600 	.word	0x50004600

08026a18 <XMC_SCU_CLOCK_EnableClock>:
}
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
 8026a18:	b480      	push	{r7}
 8026a1a:	b083      	sub	sp, #12
 8026a1c:	af00      	add	r7, sp, #0
 8026a1e:	4603      	mov	r3, r0
 8026a20:	71fb      	strb	r3, [r7, #7]
  SCU_CLK->CLKSET = ((uint32_t)clock);
 8026a22:	4a04      	ldr	r2, [pc, #16]	; (8026a34 <XMC_SCU_CLOCK_EnableClock+0x1c>)
 8026a24:	79fb      	ldrb	r3, [r7, #7]
 8026a26:	6053      	str	r3, [r2, #4]
}
 8026a28:	bf00      	nop
 8026a2a:	370c      	adds	r7, #12
 8026a2c:	46bd      	mov	sp, r7
 8026a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a32:	4770      	bx	lr
 8026a34:	50004600 	.word	0x50004600

08026a38 <XMC_SCU_CLOCK_EnableUsbPll>:
  return ((SCU_POWER->EVRVADCSTAT & SCU_POWER_EVRVADCSTAT_VADC33V_Msk) >> SCU_POWER_EVRVADCSTAT_VADC33V_Pos) * XMC_SCU_POWER_LSB33V;
}

/* API to enable USB PLL for USB clock */
void XMC_SCU_CLOCK_EnableUsbPll(void)
{
 8026a38:	b480      	push	{r7}
 8026a3a:	af00      	add	r7, sp, #0
  SCU_PLL->USBPLLCON &= (uint32_t)~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 8026a3c:	4b06      	ldr	r3, [pc, #24]	; (8026a58 <XMC_SCU_CLOCK_EnableUsbPll+0x20>)
 8026a3e:	695b      	ldr	r3, [r3, #20]
 8026a40:	4a05      	ldr	r2, [pc, #20]	; (8026a58 <XMC_SCU_CLOCK_EnableUsbPll+0x20>)
 8026a42:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8026a46:	f023 0302 	bic.w	r3, r3, #2
 8026a4a:	6153      	str	r3, [r2, #20]
}
 8026a4c:	bf00      	nop
 8026a4e:	46bd      	mov	sp, r7
 8026a50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a54:	4770      	bx	lr
 8026a56:	bf00      	nop
 8026a58:	50004710 	.word	0x50004710

08026a5c <XMC_SCU_CLOCK_StartUsbPll>:
  SCU_PLL->USBPLLCON |= (uint32_t)(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
}

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
 8026a5c:	b480      	push	{r7}
 8026a5e:	b083      	sub	sp, #12
 8026a60:	af00      	add	r7, sp, #0
 8026a62:	6078      	str	r0, [r7, #4]
 8026a64:	6039      	str	r1, [r7, #0]
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8026a66:	4b1a      	ldr	r3, [pc, #104]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a68:	695b      	ldr	r3, [r3, #20]
 8026a6a:	4a19      	ldr	r2, [pc, #100]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a6c:	f043 0301 	orr.w	r3, r3, #1
 8026a70:	6153      	str	r3, [r2, #20]

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8026a72:	4b17      	ldr	r3, [pc, #92]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a74:	695b      	ldr	r3, [r3, #20]
 8026a76:	4a16      	ldr	r2, [pc, #88]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a78:	f043 0310 	orr.w	r3, r3, #16
 8026a7c:	6153      	str	r3, [r2, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8026a7e:	683b      	ldr	r3, [r7, #0]
 8026a80:	3b01      	subs	r3, #1
 8026a82:	021a      	lsls	r2, r3, #8
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8026a84:	687b      	ldr	r3, [r7, #4]
 8026a86:	3b01      	subs	r3, #1
 8026a88:	061b      	lsls	r3, r3, #24
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8026a8a:	4911      	ldr	r1, [pc, #68]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a8c:	4313      	orrs	r3, r2
 8026a8e:	614b      	str	r3, [r1, #20]

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8026a90:	4b0f      	ldr	r3, [pc, #60]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a92:	695b      	ldr	r3, [r3, #20]
 8026a94:	4a0e      	ldr	r2, [pc, #56]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8026a9a:	6153      	str	r3, [r2, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 8026a9c:	4b0c      	ldr	r3, [pc, #48]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026a9e:	695b      	ldr	r3, [r3, #20]
 8026aa0:	4a0b      	ldr	r2, [pc, #44]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026aa2:	f023 0310 	bic.w	r3, r3, #16
 8026aa6:	6153      	str	r3, [r2, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8026aa8:	4b09      	ldr	r3, [pc, #36]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026aaa:	695b      	ldr	r3, [r3, #20]
 8026aac:	4a08      	ldr	r2, [pc, #32]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026aae:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8026ab2:	6153      	str	r3, [r2, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 8026ab4:	bf00      	nop
 8026ab6:	4b06      	ldr	r3, [pc, #24]	; (8026ad0 <XMC_SCU_CLOCK_StartUsbPll+0x74>)
 8026ab8:	691b      	ldr	r3, [r3, #16]
 8026aba:	f003 0304 	and.w	r3, r3, #4
 8026abe:	2b00      	cmp	r3, #0
 8026ac0:	d0f9      	beq.n	8026ab6 <XMC_SCU_CLOCK_StartUsbPll+0x5a>
  {
    /* wait for PLL Lock */
  }

}
 8026ac2:	bf00      	nop
 8026ac4:	bf00      	nop
 8026ac6:	370c      	adds	r7, #12
 8026ac8:	46bd      	mov	sp, r7
 8026aca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ace:	4770      	bx	lr
 8026ad0:	50004710 	.word	0x50004710

08026ad4 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>:
                                  SCU_PLL_USBPLLCON_VCOBYP_Msk);
}

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
 8026ad4:	b580      	push	{r7, lr}
 8026ad6:	b082      	sub	sp, #8
 8026ad8:	af00      	add	r7, sp, #0
 8026ada:	4603      	mov	r3, r0
 8026adc:	71fb      	strb	r3, [r7, #7]
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8026ade:	4b0f      	ldr	r3, [pc, #60]	; (8026b1c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026ae0:	685b      	ldr	r3, [r3, #4]
 8026ae2:	4a0e      	ldr	r2, [pc, #56]	; (8026b1c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026ae4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8026ae8:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8026aea:	79fb      	ldrb	r3, [r7, #7]
 8026aec:	2b01      	cmp	r3, #1
 8026aee:	d10e      	bne.n	8026b0e <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x3a>
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8026af0:	4b0a      	ldr	r3, [pc, #40]	; (8026b1c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026af2:	685b      	ldr	r3, [r3, #4]
 8026af4:	4a09      	ldr	r2, [pc, #36]	; (8026b1c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026af6:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8026afa:	6053      	str	r3, [r2, #4]
    XMC_SCU_lDelay(100UL);
 8026afc:	2064      	movs	r0, #100	; 0x64
 8026afe:	f7ff fd91 	bl	8026624 <XMC_SCU_lDelay>

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 8026b02:	4b06      	ldr	r3, [pc, #24]	; (8026b1c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026b04:	685b      	ldr	r3, [r3, #4]
 8026b06:	4a05      	ldr	r2, [pc, #20]	; (8026b1c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8026b08:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8026b0c:	6053      	str	r3, [r2, #4]
  }

  XMC_SCU_lDelay(100UL);
 8026b0e:	2064      	movs	r0, #100	; 0x64
 8026b10:	f7ff fd88 	bl	8026624 <XMC_SCU_lDelay>
}
 8026b14:	bf00      	nop
 8026b16:	3708      	adds	r7, #8
 8026b18:	46bd      	mov	sp, r7
 8026b1a:	bd80      	pop	{r7, pc}
 8026b1c:	50004710 	.word	0x50004710

08026b20 <XMC_SCU_HIB_EnableHibernateDomain>:
  return (bool)((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) != 0UL);
}

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
 8026b20:	b480      	push	{r7}
 8026b22:	af00      	add	r7, sp, #0
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8026b24:	4b12      	ldr	r3, [pc, #72]	; (8026b70 <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8026b26:	681b      	ldr	r3, [r3, #0]
 8026b28:	f003 0301 	and.w	r3, r3, #1
 8026b2c:	2b00      	cmp	r3, #0
 8026b2e:	d109      	bne.n	8026b44 <XMC_SCU_HIB_EnableHibernateDomain+0x24>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8026b30:	4b0f      	ldr	r3, [pc, #60]	; (8026b70 <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8026b32:	2201      	movs	r2, #1
 8026b34:	605a      	str	r2, [r3, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8026b36:	bf00      	nop
 8026b38:	4b0d      	ldr	r3, [pc, #52]	; (8026b70 <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8026b3a:	681b      	ldr	r3, [r3, #0]
 8026b3c:	f003 0301 	and.w	r3, r3, #1
 8026b40:	2b00      	cmp	r3, #0
 8026b42:	d0f9      	beq.n	8026b38 <XMC_SCU_HIB_EnableHibernateDomain+0x18>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 8026b44:	4b0b      	ldr	r3, [pc, #44]	; (8026b74 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8026b46:	681b      	ldr	r3, [r3, #0]
 8026b48:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8026b4c:	2b00      	cmp	r3, #0
 8026b4e:	d00a      	beq.n	8026b66 <XMC_SCU_HIB_EnableHibernateDomain+0x46>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 8026b50:	4b08      	ldr	r3, [pc, #32]	; (8026b74 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8026b52:	f44f 7200 	mov.w	r2, #512	; 0x200
 8026b56:	609a      	str	r2, [r3, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8026b58:	bf00      	nop
 8026b5a:	4b06      	ldr	r3, [pc, #24]	; (8026b74 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8026b5c:	681b      	ldr	r3, [r3, #0]
 8026b5e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8026b62:	2b00      	cmp	r3, #0
 8026b64:	d1f9      	bne.n	8026b5a <XMC_SCU_HIB_EnableHibernateDomain+0x3a>
    {
      /* wait until HIB domain is enabled */
    }
  }
}
 8026b66:	bf00      	nop
 8026b68:	46bd      	mov	sp, r7
 8026b6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b6e:	4770      	bx	lr
 8026b70:	50004200 	.word	0x50004200
 8026b74:	50004400 	.word	0x50004400

08026b78 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>:
}

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
 8026b78:	b480      	push	{r7}
 8026b7a:	af00      	add	r7, sp, #0
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 8026b7c:	4b06      	ldr	r3, [pc, #24]	; (8026b98 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable+0x20>)
 8026b7e:	681b      	ldr	r3, [r3, #0]
 8026b80:	f003 0308 	and.w	r3, r3, #8
 8026b84:	2b00      	cmp	r3, #0
 8026b86:	bf0c      	ite	eq
 8026b88:	2301      	moveq	r3, #1
 8026b8a:	2300      	movne	r3, #0
 8026b8c:	b2db      	uxtb	r3, r3
}
 8026b8e:	4618      	mov	r0, r3
 8026b90:	46bd      	mov	sp, r7
 8026b92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026b96:	4770      	bx	lr
 8026b98:	50004300 	.word	0x50004300

08026b9c <XMC_SCU_CLOCK_EnableLowPowerOscillator>:

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
 8026b9c:	b580      	push	{r7, lr}
 8026b9e:	af00      	add	r7, sp, #0
  /* Enable OSC_ULP */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED);
 8026ba0:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8026ba4:	f7ff fd6e 	bl	8026684 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8026ba8:	4b18      	ldr	r3, [pc, #96]	; (8026c0c <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026baa:	69db      	ldr	r3, [r3, #28]
 8026bac:	4a17      	ldr	r2, [pc, #92]	; (8026c0c <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026bae:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8026bb2:	61d3      	str	r3, [r2, #28]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED) == 0);
 8026bb4:	bf00      	nop
 8026bb6:	f7ff fd59 	bl	802666c <XMC_SCU_INTERUPT_GetEventStatus>
 8026bba:	4603      	mov	r3, r0
 8026bbc:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8026bc0:	2b00      	cmp	r3, #0
 8026bc2:	d0f8      	beq.n	8026bb6 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x1a>

  /* Clear ULP WDG status */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED);
 8026bc4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8026bc8:	f7ff fd5c 	bl	8026684 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCLR = (uint32_t)SCU_HIBERNATE_HDCLR_ULPWDG_Msk;
 8026bcc:	4b0f      	ldr	r3, [pc, #60]	; (8026c0c <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026bce:	2208      	movs	r2, #8
 8026bd0:	605a      	str	r2, [r3, #4]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED) == 0);
 8026bd2:	bf00      	nop
 8026bd4:	f7ff fd4a 	bl	802666c <XMC_SCU_INTERUPT_GetEventStatus>
 8026bd8:	4603      	mov	r3, r0
 8026bda:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8026bde:	2b00      	cmp	r3, #0
 8026be0:	d0f8      	beq.n	8026bd4 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x38>

  /* Enable ULP WDG */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED);
 8026be2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8026be6:	f7ff fd4d 	bl	8026684 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 8026bea:	4b08      	ldr	r3, [pc, #32]	; (8026c0c <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026bec:	68db      	ldr	r3, [r3, #12]
 8026bee:	4a07      	ldr	r2, [pc, #28]	; (8026c0c <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8026bf0:	f043 0308 	orr.w	r3, r3, #8
 8026bf4:	60d3      	str	r3, [r2, #12]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED) == 0);
 8026bf6:	bf00      	nop
 8026bf8:	f7ff fd38 	bl	802666c <XMC_SCU_INTERUPT_GetEventStatus>
 8026bfc:	4603      	mov	r3, r0
 8026bfe:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8026c02:	2b00      	cmp	r3, #0
 8026c04:	d0f8      	beq.n	8026bf8 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x5c>
}
 8026c06:	bf00      	nop
 8026c08:	bf00      	nop
 8026c0a:	bd80      	pop	{r7, pc}
 8026c0c:	50004300 	.word	0x50004300

08026c10 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>:
  return (SCU_HIBERNATE->OSCULSTAT & SCU_HIBERNATE_OSCULSTAT_X1D_Msk);
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
 8026c10:	b598      	push	{r3, r4, r7, lr}
 8026c12:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8026c14:	4b0f      	ldr	r3, [pc, #60]	; (8026c54 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026c16:	685b      	ldr	r3, [r3, #4]
 8026c18:	4a0e      	ldr	r2, [pc, #56]	; (8026c54 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026c1a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8026c1e:	6053      	str	r3, [r2, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8026c20:	4b0d      	ldr	r3, [pc, #52]	; (8026c58 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 8026c22:	685b      	ldr	r3, [r3, #4]
 8026c24:	f423 2470 	bic.w	r4, r3, #983040	; 0xf0000
 8026c28:	f024 0430 	bic.w	r4, r4, #48	; 0x30
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8026c2c:	f003 f834 	bl	8029c98 <OSCHP_GetFrequency>
 8026c30:	4603      	mov	r3, r0
 8026c32:	4a0a      	ldr	r2, [pc, #40]	; (8026c5c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x4c>)
 8026c34:	fba2 2303 	umull	r2, r3, r2, r3
 8026c38:	0d1b      	lsrs	r3, r3, #20
 8026c3a:	3b01      	subs	r3, #1
 8026c3c:	041b      	lsls	r3, r3, #16
  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8026c3e:	4a06      	ldr	r2, [pc, #24]	; (8026c58 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 8026c40:	4323      	orrs	r3, r4
 8026c42:	6053      	str	r3, [r2, #4]

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 8026c44:	4b03      	ldr	r3, [pc, #12]	; (8026c54 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026c46:	685b      	ldr	r3, [r3, #4]
 8026c48:	4a02      	ldr	r2, [pc, #8]	; (8026c54 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8026c4a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8026c4e:	6053      	str	r3, [r2, #4]
}
 8026c50:	bf00      	nop
 8026c52:	bd98      	pop	{r3, r4, r7, pc}
 8026c54:	50004710 	.word	0x50004710
 8026c58:	50004700 	.word	0x50004700
 8026c5c:	6b5fca6b 	.word	0x6b5fca6b

08026c60 <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>:

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
 8026c60:	b480      	push	{r7}
 8026c62:	af00      	add	r7, sp, #0
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 8026c64:	4b07      	ldr	r3, [pc, #28]	; (8026c84 <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable+0x24>)
 8026c66:	681b      	ldr	r3, [r3, #0]
 8026c68:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8026c6c:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8026c70:	bf0c      	ite	eq
 8026c72:	2301      	moveq	r3, #1
 8026c74:	2300      	movne	r3, #0
 8026c76:	b2db      	uxtb	r3, r3
}
 8026c78:	4618      	mov	r0, r3
 8026c7a:	46bd      	mov	sp, r7
 8026c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026c80:	4770      	bx	lr
 8026c82:	bf00      	nop
 8026c84:	50004710 	.word	0x50004710

08026c88 <XMC_SCU_CLOCK_EnableSystemPll>:
  return (SCU_OSC->OSCHPSTAT & SCU_OSC_OSCHPSTAT_X1D_Msk);
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
 8026c88:	b480      	push	{r7}
 8026c8a:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8026c8c:	4b06      	ldr	r3, [pc, #24]	; (8026ca8 <XMC_SCU_CLOCK_EnableSystemPll+0x20>)
 8026c8e:	685b      	ldr	r3, [r3, #4]
 8026c90:	4a05      	ldr	r2, [pc, #20]	; (8026ca8 <XMC_SCU_CLOCK_EnableSystemPll+0x20>)
 8026c92:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8026c96:	f023 0302 	bic.w	r3, r3, #2
 8026c9a:	6053      	str	r3, [r2, #4]
}
 8026c9c:	bf00      	nop
 8026c9e:	46bd      	mov	sp, r7
 8026ca0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ca4:	4770      	bx	lr
 8026ca6:	bf00      	nop
 8026ca8:	50004710 	.word	0x50004710

08026cac <XMC_SCU_CLOCK_DisableSystemPll>:

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
 8026cac:	b480      	push	{r7}
 8026cae:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8026cb0:	4b06      	ldr	r3, [pc, #24]	; (8026ccc <XMC_SCU_CLOCK_DisableSystemPll+0x20>)
 8026cb2:	685b      	ldr	r3, [r3, #4]
 8026cb4:	4a05      	ldr	r2, [pc, #20]	; (8026ccc <XMC_SCU_CLOCK_DisableSystemPll+0x20>)
 8026cb6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8026cba:	f043 0302 	orr.w	r3, r3, #2
 8026cbe:	6053      	str	r3, [r2, #4]
}
 8026cc0:	bf00      	nop
 8026cc2:	46bd      	mov	sp, r7
 8026cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026cc8:	4770      	bx	lr
 8026cca:	bf00      	nop
 8026ccc:	50004710 	.word	0x50004710

08026cd0 <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 8026cd0:	b580      	push	{r7, lr}
 8026cd2:	b086      	sub	sp, #24
 8026cd4:	af00      	add	r7, sp, #0
 8026cd6:	60ba      	str	r2, [r7, #8]
 8026cd8:	607b      	str	r3, [r7, #4]
 8026cda:	4603      	mov	r3, r0
 8026cdc:	81fb      	strh	r3, [r7, #14]
 8026cde:	460b      	mov	r3, r1
 8026ce0:	737b      	strb	r3, [r7, #13]

  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);
 8026ce2:	89fb      	ldrh	r3, [r7, #14]
 8026ce4:	4618      	mov	r0, r3
 8026ce6:	f7ff fdc5 	bl	8026874 <XMC_SCU_CLOCK_SetSystemPllClockSource>

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8026cea:	7b7b      	ldrb	r3, [r7, #13]
 8026cec:	2b01      	cmp	r3, #1
 8026cee:	f040 8084 	bne.w	8026dfa <XMC_SCU_CLOCK_StartSystemPll+0x12a>
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
 8026cf2:	89fb      	ldrh	r3, [r7, #14]
 8026cf4:	2b00      	cmp	r3, #0
 8026cf6:	d109      	bne.n	8026d0c <XMC_SCU_CLOCK_StartSystemPll+0x3c>
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 8026cf8:	f002 ffce 	bl	8029c98 <OSCHP_GetFrequency>
 8026cfc:	4603      	mov	r3, r0
 8026cfe:	4a4c      	ldr	r2, [pc, #304]	; (8026e30 <XMC_SCU_CLOCK_StartSystemPll+0x160>)
 8026d00:	fba2 2303 	umull	r2, r3, r2, r3
 8026d04:	0c9b      	lsrs	r3, r3, #18
 8026d06:	059b      	lsls	r3, r3, #22
 8026d08:	617b      	str	r3, [r7, #20]
 8026d0a:	e002      	b.n	8026d12 <XMC_SCU_CLOCK_StartSystemPll+0x42>
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 8026d0c:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 8026d10:	617b      	str	r3, [r7, #20]
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 8026d12:	697b      	ldr	r3, [r7, #20]
 8026d14:	687a      	ldr	r2, [r7, #4]
 8026d16:	fb03 f202 	mul.w	r2, r3, r2
 8026d1a:	68bb      	ldr	r3, [r7, #8]
 8026d1c:	fbb2 f3f3 	udiv	r3, r2, r3
 8026d20:	617b      	str	r3, [r7, #20]
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8026d22:	697b      	ldr	r3, [r7, #20]
 8026d24:	4a43      	ldr	r2, [pc, #268]	; (8026e34 <XMC_SCU_CLOCK_StartSystemPll+0x164>)
 8026d26:	fba2 2303 	umull	r2, r3, r2, r3
 8026d2a:	091b      	lsrs	r3, r3, #4
 8026d2c:	0d9b      	lsrs	r3, r3, #22
 8026d2e:	613b      	str	r3, [r7, #16]

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8026d30:	4b41      	ldr	r3, [pc, #260]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d32:	685b      	ldr	r3, [r3, #4]
 8026d34:	4a40      	ldr	r2, [pc, #256]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d36:	f043 0301 	orr.w	r3, r3, #1
 8026d3a:	6053      	str	r3, [r2, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 8026d3c:	4b3e      	ldr	r3, [pc, #248]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d3e:	685b      	ldr	r3, [r3, #4]
 8026d40:	4a3d      	ldr	r2, [pc, #244]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d42:	f043 0310 	orr.w	r3, r3, #16
 8026d46:	6053      	str	r3, [r2, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8026d48:	4b3b      	ldr	r3, [pc, #236]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d4a:	689a      	ldr	r2, [r3, #8]
 8026d4c:	4b3b      	ldr	r3, [pc, #236]	; (8026e3c <XMC_SCU_CLOCK_StartSystemPll+0x16c>)
 8026d4e:	4013      	ands	r3, r2
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8026d50:	687a      	ldr	r2, [r7, #4]
 8026d52:	3a01      	subs	r2, #1
 8026d54:	0212      	lsls	r2, r2, #8
 8026d56:	431a      	orrs	r2, r3
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 8026d58:	693b      	ldr	r3, [r7, #16]
 8026d5a:	3b01      	subs	r3, #1
 8026d5c:	041b      	lsls	r3, r3, #16
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8026d5e:	431a      	orrs	r2, r3
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 8026d60:	68bb      	ldr	r3, [r7, #8]
 8026d62:	3b01      	subs	r3, #1
 8026d64:	061b      	lsls	r3, r3, #24
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8026d66:	4934      	ldr	r1, [pc, #208]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d68:	4313      	orrs	r3, r2
 8026d6a:	608b      	str	r3, [r1, #8]

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8026d6c:	4b32      	ldr	r3, [pc, #200]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d6e:	685b      	ldr	r3, [r3, #4]
 8026d70:	4a31      	ldr	r2, [pc, #196]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8026d76:	6053      	str	r3, [r2, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 8026d78:	4b2f      	ldr	r3, [pc, #188]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d7a:	685b      	ldr	r3, [r3, #4]
 8026d7c:	4a2e      	ldr	r2, [pc, #184]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d7e:	f023 0310 	bic.w	r3, r3, #16
 8026d82:	6053      	str	r3, [r2, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 8026d84:	4b2c      	ldr	r3, [pc, #176]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d86:	685b      	ldr	r3, [r3, #4]
 8026d88:	4a2b      	ldr	r2, [pc, #172]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d8a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8026d8e:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 8026d90:	bf00      	nop
 8026d92:	4b29      	ldr	r3, [pc, #164]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026d94:	681b      	ldr	r3, [r3, #0]
 8026d96:	f003 0304 	and.w	r3, r3, #4
 8026d9a:	2b00      	cmp	r3, #0
 8026d9c:	d0f9      	beq.n	8026d92 <XMC_SCU_CLOCK_StartSystemPll+0xc2>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8026d9e:	4b26      	ldr	r3, [pc, #152]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026da0:	685b      	ldr	r3, [r3, #4]
 8026da2:	4a25      	ldr	r2, [pc, #148]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026da4:	f023 0301 	bic.w	r3, r3, #1
 8026da8:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8026daa:	bf00      	nop
 8026dac:	4b22      	ldr	r3, [pc, #136]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026dae:	681b      	ldr	r3, [r3, #0]
 8026db0:	f003 0301 	and.w	r3, r3, #1
 8026db4:	2b00      	cmp	r3, #0
 8026db6:	d1f9      	bne.n	8026dac <XMC_SCU_CLOCK_StartSystemPll+0xdc>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 8026db8:	697b      	ldr	r3, [r7, #20]
 8026dba:	4a21      	ldr	r2, [pc, #132]	; (8026e40 <XMC_SCU_CLOCK_StartSystemPll+0x170>)
 8026dbc:	fba2 2303 	umull	r2, r3, r2, r3
 8026dc0:	095b      	lsrs	r3, r3, #5
 8026dc2:	0d9b      	lsrs	r3, r3, #22
 8026dc4:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8026dc6:	6a3a      	ldr	r2, [r7, #32]
 8026dc8:	693b      	ldr	r3, [r7, #16]
 8026dca:	429a      	cmp	r2, r3
 8026dcc:	d202      	bcs.n	8026dd4 <XMC_SCU_CLOCK_StartSystemPll+0x104>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8026dce:	6938      	ldr	r0, [r7, #16]
 8026dd0:	f000 f83a 	bl	8026e48 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 8026dd4:	697b      	ldr	r3, [r7, #20]
 8026dd6:	085b      	lsrs	r3, r3, #1
 8026dd8:	4a1a      	ldr	r2, [pc, #104]	; (8026e44 <XMC_SCU_CLOCK_StartSystemPll+0x174>)
 8026dda:	fba2 2303 	umull	r2, r3, r2, r3
 8026dde:	095b      	lsrs	r3, r3, #5
 8026de0:	0d9b      	lsrs	r3, r3, #22
 8026de2:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8026de4:	6a3a      	ldr	r2, [r7, #32]
 8026de6:	693b      	ldr	r3, [r7, #16]
 8026de8:	429a      	cmp	r2, r3
 8026dea:	d202      	bcs.n	8026df2 <XMC_SCU_CLOCK_StartSystemPll+0x122>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8026dec:	6938      	ldr	r0, [r7, #16]
 8026dee:	f000 f82b 	bl	8026e48 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
 8026df2:	6a38      	ldr	r0, [r7, #32]
 8026df4:	f000 f828 	bl	8026e48 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
    {
      /* wait for prescaler mode */
    }
  }
}
 8026df8:	e015      	b.n	8026e26 <XMC_SCU_CLOCK_StartSystemPll+0x156>
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8026dfa:	4b0f      	ldr	r3, [pc, #60]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026dfc:	689b      	ldr	r3, [r3, #8]
 8026dfe:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 8026e02:	6a3b      	ldr	r3, [r7, #32]
 8026e04:	3b01      	subs	r3, #1
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8026e06:	490c      	ldr	r1, [pc, #48]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e08:	4313      	orrs	r3, r2
 8026e0a:	608b      	str	r3, [r1, #8]
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8026e0c:	4b0a      	ldr	r3, [pc, #40]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e0e:	685b      	ldr	r3, [r3, #4]
 8026e10:	4a09      	ldr	r2, [pc, #36]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e12:	f043 0301 	orr.w	r3, r3, #1
 8026e16:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 8026e18:	bf00      	nop
 8026e1a:	4b07      	ldr	r3, [pc, #28]	; (8026e38 <XMC_SCU_CLOCK_StartSystemPll+0x168>)
 8026e1c:	681b      	ldr	r3, [r3, #0]
 8026e1e:	f003 0301 	and.w	r3, r3, #1
 8026e22:	2b00      	cmp	r3, #0
 8026e24:	d0f9      	beq.n	8026e1a <XMC_SCU_CLOCK_StartSystemPll+0x14a>
}
 8026e26:	bf00      	nop
 8026e28:	3718      	adds	r7, #24
 8026e2a:	46bd      	mov	sp, r7
 8026e2c:	bd80      	pop	{r7, pc}
 8026e2e:	bf00      	nop
 8026e30:	431bde83 	.word	0x431bde83
 8026e34:	aaaaaaab 	.word	0xaaaaaaab
 8026e38:	50004710 	.word	0x50004710
 8026e3c:	f08080ff 	.word	0xf08080ff
 8026e40:	88888889 	.word	0x88888889
 8026e44:	b60b60b7 	.word	0xb60b60b7

08026e48 <XMC_SCU_CLOCK_StepSystemPllFrequency>:
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_PLLPWD_Msk;
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
 8026e48:	b580      	push	{r7, lr}
 8026e4a:	b082      	sub	sp, #8
 8026e4c:	af00      	add	r7, sp, #0
 8026e4e:	6078      	str	r0, [r7, #4]
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8026e50:	4b08      	ldr	r3, [pc, #32]	; (8026e74 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x2c>)
 8026e52:	689b      	ldr	r3, [r3, #8]
 8026e54:	f423 02fe 	bic.w	r2, r3, #8323072	; 0x7f0000
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 8026e58:	687b      	ldr	r3, [r7, #4]
 8026e5a:	3b01      	subs	r3, #1
 8026e5c:	041b      	lsls	r3, r3, #16
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8026e5e:	4905      	ldr	r1, [pc, #20]	; (8026e74 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x2c>)
 8026e60:	4313      	orrs	r3, r2
 8026e62:	608b      	str	r3, [r1, #8]

  XMC_SCU_lDelay(50U);
 8026e64:	2032      	movs	r0, #50	; 0x32
 8026e66:	f7ff fbdd 	bl	8026624 <XMC_SCU_lDelay>
}
 8026e6a:	bf00      	nop
 8026e6c:	3708      	adds	r7, #8
 8026e6e:	46bd      	mov	sp, r7
 8026e70:	bd80      	pop	{r7, pc}
 8026e72:	bf00      	nop
 8026e74:	50004710 	.word	0x50004710

08026e78 <XMC_CAN_IsPanelControlReady>:
 * \par<b>Related APIs:</b><BR>
 *  XMC_CAN_PanelControl()
 *
 */
__STATIC_INLINE bool XMC_CAN_IsPanelControlReady(XMC_CAN_t *const obj)
{
 8026e78:	b480      	push	{r7}
 8026e7a:	b083      	sub	sp, #12
 8026e7c:	af00      	add	r7, sp, #0
 8026e7e:	6078      	str	r0, [r7, #4]
  return (bool)((obj->PANCTR & (CAN_PANCTR_BUSY_Msk | CAN_PANCTR_RBUSY_Msk)) == 0);
 8026e80:	687b      	ldr	r3, [r7, #4]
 8026e82:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8026e86:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8026e8a:	2b00      	cmp	r3, #0
 8026e8c:	bf0c      	ite	eq
 8026e8e:	2301      	moveq	r3, #1
 8026e90:	2300      	movne	r3, #0
 8026e92:	b2db      	uxtb	r3, r3
}
 8026e94:	4618      	mov	r0, r3
 8026e96:	370c      	adds	r7, #12
 8026e98:	46bd      	mov	sp, r7
 8026e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026e9e:	4770      	bx	lr

08026ea0 <XMC_CAN_PanelControl>:

__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
 8026ea0:	b480      	push	{r7}
 8026ea2:	b083      	sub	sp, #12
 8026ea4:	af00      	add	r7, sp, #0
 8026ea6:	6078      	str	r0, [r7, #4]
 8026ea8:	4608      	mov	r0, r1
 8026eaa:	4611      	mov	r1, r2
 8026eac:	461a      	mov	r2, r3
 8026eae:	4603      	mov	r3, r0
 8026eb0:	70fb      	strb	r3, [r7, #3]
 8026eb2:	460b      	mov	r3, r1
 8026eb4:	70bb      	strb	r3, [r7, #2]
 8026eb6:	4613      	mov	r3, r2
 8026eb8:	707b      	strb	r3, [r7, #1]
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8026eba:	78fa      	ldrb	r2, [r7, #3]
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 8026ebc:	78bb      	ldrb	r3, [r7, #2]
 8026ebe:	041b      	lsls	r3, r3, #16
 8026ec0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8026ec4:	431a      	orrs	r2, r3
                (((uint32_t)arg2 << CAN_PANCTR_PANAR2_Pos) & (uint32_t)CAN_PANCTR_PANAR2_Msk);
 8026ec6:	787b      	ldrb	r3, [r7, #1]
 8026ec8:	061b      	lsls	r3, r3, #24
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 8026eca:	431a      	orrs	r2, r3
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8026ecc:	687b      	ldr	r3, [r7, #4]
 8026ece:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
}
 8026ed2:	bf00      	nop
 8026ed4:	370c      	adds	r7, #12
 8026ed6:	46bd      	mov	sp, r7
 8026ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026edc:	4770      	bx	lr

08026ede <XMC_CAN_NODE_EnableConfigurationChange>:
 * XMC_CAN_NODE_DisableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
 8026ede:	b480      	push	{r7}
 8026ee0:	b083      	sub	sp, #12
 8026ee2:	af00      	add	r7, sp, #0
 8026ee4:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8026ee6:	687b      	ldr	r3, [r7, #4]
 8026ee8:	681b      	ldr	r3, [r3, #0]
 8026eea:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8026eee:	687b      	ldr	r3, [r7, #4]
 8026ef0:	601a      	str	r2, [r3, #0]
}
 8026ef2:	bf00      	nop
 8026ef4:	370c      	adds	r7, #12
 8026ef6:	46bd      	mov	sp, r7
 8026ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026efc:	4770      	bx	lr

08026efe <XMC_CAN_NODE_DisableConfigurationChange>:
 * XMC_CAN_NODE_EnableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
 8026efe:	b480      	push	{r7}
 8026f00:	b083      	sub	sp, #12
 8026f02:	af00      	add	r7, sp, #0
 8026f04:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 8026f06:	687b      	ldr	r3, [r7, #4]
 8026f08:	681b      	ldr	r3, [r3, #0]
 8026f0a:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8026f0e:	687b      	ldr	r3, [r7, #4]
 8026f10:	601a      	str	r2, [r3, #0]
}
 8026f12:	bf00      	nop
 8026f14:	370c      	adds	r7, #12
 8026f16:	46bd      	mov	sp, r7
 8026f18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026f1c:	4770      	bx	lr

08026f1e <max>:

#if defined(CAN)
#include "xmc_scu.h"

__STATIC_INLINE uint32_t max(uint32_t a, uint32_t b)
{
 8026f1e:	b480      	push	{r7}
 8026f20:	b083      	sub	sp, #12
 8026f22:	af00      	add	r7, sp, #0
 8026f24:	6078      	str	r0, [r7, #4]
 8026f26:	6039      	str	r1, [r7, #0]
  return (a > b) ? a : b;
 8026f28:	683a      	ldr	r2, [r7, #0]
 8026f2a:	687b      	ldr	r3, [r7, #4]
 8026f2c:	4293      	cmp	r3, r2
 8026f2e:	bf38      	it	cc
 8026f30:	4613      	movcc	r3, r2
}
 8026f32:	4618      	mov	r0, r3
 8026f34:	370c      	adds	r7, #12
 8026f36:	46bd      	mov	sp, r7
 8026f38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026f3c:	4770      	bx	lr

08026f3e <min>:

__STATIC_INLINE uint32_t min(uint32_t a, uint32_t b)
{
 8026f3e:	b480      	push	{r7}
 8026f40:	b083      	sub	sp, #12
 8026f42:	af00      	add	r7, sp, #0
 8026f44:	6078      	str	r0, [r7, #4]
 8026f46:	6039      	str	r1, [r7, #0]
  return (a < b) ? a : b;
 8026f48:	683a      	ldr	r2, [r7, #0]
 8026f4a:	687b      	ldr	r3, [r7, #4]
 8026f4c:	4293      	cmp	r3, r2
 8026f4e:	bf28      	it	cs
 8026f50:	4613      	movcs	r3, r2
}
 8026f52:	4618      	mov	r0, r3
 8026f54:	370c      	adds	r7, #12
 8026f56:	46bd      	mov	sp, r7
 8026f58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026f5c:	4770      	bx	lr
	...

08026f60 <XMC_CAN_NODE_NominalBitTimeConfigureEx>:
#define XMC_CAN_NODE_MAX_TSEG2 7


int32_t XMC_CAN_NODE_NominalBitTimeConfigureEx(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const bit_time_config)
{
 8026f60:	b580      	push	{r7, lr}
 8026f62:	b088      	sub	sp, #32
 8026f64:	af00      	add	r7, sp, #0
 8026f66:	6078      	str	r0, [r7, #4]
 8026f68:	6039      	str	r1, [r7, #0]
  /* Check that the CAN frequency is a multiple of the required baudrate */
  if ((bit_time_config->can_frequency % bit_time_config->baudrate) == 0)
 8026f6a:	683b      	ldr	r3, [r7, #0]
 8026f6c:	681b      	ldr	r3, [r3, #0]
 8026f6e:	683a      	ldr	r2, [r7, #0]
 8026f70:	6852      	ldr	r2, [r2, #4]
 8026f72:	fbb3 f1f2 	udiv	r1, r3, r2
 8026f76:	fb01 f202 	mul.w	r2, r1, r2
 8026f7a:	1a9b      	subs	r3, r3, r2
 8026f7c:	2b00      	cmp	r3, #0
 8026f7e:	f040 8091 	bne.w	80270a4 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x144>
  {
    uint32_t prescaler = 0;
 8026f82:	2300      	movs	r3, #0
 8026f84:	61fb      	str	r3, [r7, #28]
    uint32_t div8 = 0;
 8026f86:	2300      	movs	r3, #0
 8026f88:	61bb      	str	r3, [r7, #24]

    /* Calculate the factor between can frequency and required baudrate, this is equal to (prescaler x ntq) */
    uint32_t fcan_div = bit_time_config->can_frequency / bit_time_config->baudrate;
 8026f8a:	683b      	ldr	r3, [r7, #0]
 8026f8c:	681a      	ldr	r2, [r3, #0]
 8026f8e:	683b      	ldr	r3, [r7, #0]
 8026f90:	685b      	ldr	r3, [r3, #4]
 8026f92:	fbb2 f3f3 	udiv	r3, r2, r3
 8026f96:	60bb      	str	r3, [r7, #8]

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
 8026f98:	2319      	movs	r3, #25
 8026f9a:	617b      	str	r3, [r7, #20]
    uint32_t tseg1 = 0;
 8026f9c:	2300      	movs	r3, #0
 8026f9e:	613b      	str	r3, [r7, #16]
    uint32_t tseg2 = 0;
 8026fa0:	2300      	movs	r3, #0
 8026fa2:	60fb      	str	r3, [r7, #12]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8026fa4:	e04a      	b.n	802703c <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xdc>
    {
      /* consider this ntq, only if fcan_div is multiple of ntq */
      if ((fcan_div % ntq) == 0)
 8026fa6:	68bb      	ldr	r3, [r7, #8]
 8026fa8:	697a      	ldr	r2, [r7, #20]
 8026faa:	fbb3 f2f2 	udiv	r2, r3, r2
 8026fae:	6979      	ldr	r1, [r7, #20]
 8026fb0:	fb01 f202 	mul.w	r2, r1, r2
 8026fb4:	1a9b      	subs	r3, r3, r2
 8026fb6:	2b00      	cmp	r3, #0
 8026fb8:	d13d      	bne.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
      {
        div8 = 0;
 8026fba:	2300      	movs	r3, #0
 8026fbc:	61bb      	str	r3, [r7, #24]
        prescaler = fcan_div / ntq;
 8026fbe:	68ba      	ldr	r2, [r7, #8]
 8026fc0:	697b      	ldr	r3, [r7, #20]
 8026fc2:	fbb2 f3f3 	udiv	r3, r2, r3
 8026fc6:	61fb      	str	r3, [r7, #28]
        if ((prescaler > 0) && (prescaler <= XMC_CAN_NODE_MAX_PRESCALER))
 8026fc8:	69fb      	ldr	r3, [r7, #28]
 8026fca:	2b00      	cmp	r3, #0
 8026fcc:	d033      	beq.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 8026fce:	69fb      	ldr	r3, [r7, #28]
 8026fd0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8026fd4:	d82f      	bhi.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
        {
          if (prescaler >= 64)
 8026fd6:	69fb      	ldr	r3, [r7, #28]
 8026fd8:	2b3f      	cmp	r3, #63	; 0x3f
 8026fda:	d90a      	bls.n	8026ff2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x92>
          {
            /* consider prescaler >=64, if it is integer divisible by 8*/
            if ((prescaler & 0x7U) != 0)
 8026fdc:	69fb      	ldr	r3, [r7, #28]
 8026fde:	f003 0307 	and.w	r3, r3, #7
 8026fe2:	2b00      	cmp	r3, #0
 8026fe4:	d003      	beq.n	8026fee <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x8e>
            {
              --ntq;
 8026fe6:	697b      	ldr	r3, [r7, #20]
 8026fe8:	3b01      	subs	r3, #1
 8026fea:	617b      	str	r3, [r7, #20]
              continue;
 8026fec:	e026      	b.n	802703c <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xdc>
            }
            else
            {
              div8 = 1;
 8026fee:	2301      	movs	r3, #1
 8026ff0:	61bb      	str	r3, [r7, #24]
            }
          }

          tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 10000;
 8026ff2:	697b      	ldr	r3, [r7, #20]
 8026ff4:	3b01      	subs	r3, #1
 8026ff6:	683a      	ldr	r2, [r7, #0]
 8026ff8:	8912      	ldrh	r2, [r2, #8]
 8026ffa:	fb02 f303 	mul.w	r3, r2, r3
 8026ffe:	4a2c      	ldr	r2, [pc, #176]	; (80270b0 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x150>)
 8027000:	fba2 2303 	umull	r2, r3, r2, r3
 8027004:	0b5b      	lsrs	r3, r3, #13
 8027006:	613b      	str	r3, [r7, #16]
          tseg2 = ntq - tseg1 - 1;
 8027008:	697a      	ldr	r2, [r7, #20]
 802700a:	693b      	ldr	r3, [r7, #16]
 802700c:	1ad3      	subs	r3, r2, r3
 802700e:	3b01      	subs	r3, #1
 8027010:	60fb      	str	r3, [r7, #12]

          if ((XMC_CAN_NODE_MIN_TSEG1 <= tseg1) && (tseg1 <= XMC_CAN_NODE_MAX_TSEG1) &&
 8027012:	693b      	ldr	r3, [r7, #16]
 8027014:	2b02      	cmp	r3, #2
 8027016:	d90e      	bls.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 8027018:	693b      	ldr	r3, [r7, #16]
 802701a:	2b0f      	cmp	r3, #15
 802701c:	d80b      	bhi.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 802701e:	68fb      	ldr	r3, [r7, #12]
 8027020:	2b01      	cmp	r3, #1
 8027022:	d908      	bls.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
              (XMC_CAN_NODE_MIN_TSEG2 <= tseg2) && (tseg2 < XMC_CAN_NODE_MAX_TSEG2) && (tseg2 >= bit_time_config->sjw))
 8027024:	68fb      	ldr	r3, [r7, #12]
 8027026:	2b06      	cmp	r3, #6
 8027028:	d805      	bhi.n	8027036 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 802702a:	683b      	ldr	r3, [r7, #0]
 802702c:	895b      	ldrh	r3, [r3, #10]
 802702e:	461a      	mov	r2, r3
 8027030:	68fb      	ldr	r3, [r7, #12]
 8027032:	4293      	cmp	r3, r2
 8027034:	d206      	bcs.n	8027044 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe4>
          }


        }
      }
      --ntq;
 8027036:	697b      	ldr	r3, [r7, #20]
 8027038:	3b01      	subs	r3, #1
 802703a:	617b      	str	r3, [r7, #20]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 802703c:	697b      	ldr	r3, [r7, #20]
 802703e:	2b07      	cmp	r3, #7
 8027040:	d8b1      	bhi.n	8026fa6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x46>
 8027042:	e000      	b.n	8027046 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe6>
            break;
 8027044:	bf00      	nop
    }

    if (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8027046:	697b      	ldr	r3, [r7, #20]
 8027048:	2b07      	cmp	r3, #7
 802704a:	d92b      	bls.n	80270a4 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x144>

      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: prescaler", (prescaler != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg1", (tseg1 != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg2", (tseg2 != 0));

      XMC_CAN_NODE_EnableConfigurationChange(can_node);
 802704c:	6878      	ldr	r0, [r7, #4]
 802704e:	f7ff ff46 	bl	8026ede <XMC_CAN_NODE_EnableConfigurationChange>

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 8027052:	68fb      	ldr	r3, [r7, #12]
 8027054:	3b01      	subs	r3, #1
 8027056:	031b      	lsls	r3, r3, #12
 8027058:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 802705c:	683b      	ldr	r3, [r7, #0]
 802705e:	895b      	ldrh	r3, [r3, #10]
 8027060:	3b01      	subs	r3, #1
 8027062:	019b      	lsls	r3, r3, #6
 8027064:	b2db      	uxtb	r3, r3
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 8027066:	431a      	orrs	r2, r3
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 8027068:	693b      	ldr	r3, [r7, #16]
 802706a:	3b01      	subs	r3, #1
 802706c:	021b      	lsls	r3, r3, #8
 802706e:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 8027072:	ea42 0103 	orr.w	r1, r2, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 8027076:	69ba      	ldr	r2, [r7, #24]
 8027078:	4613      	mov	r3, r2
 802707a:	005b      	lsls	r3, r3, #1
 802707c:	4413      	add	r3, r2
 802707e:	69fa      	ldr	r2, [r7, #28]
 8027080:	fa22 f303 	lsr.w	r3, r2, r3
 8027084:	3b01      	subs	r3, #1
 8027086:	f003 033f 	and.w	r3, r3, #63	; 0x3f
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 802708a:	ea41 0203 	orr.w	r2, r1, r3
                       ((div8 << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
 802708e:	69bb      	ldr	r3, [r7, #24]
 8027090:	03db      	lsls	r3, r3, #15
 8027092:	b29b      	uxth	r3, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 8027094:	431a      	orrs	r2, r3
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 8027096:	687b      	ldr	r3, [r7, #4]
 8027098:	611a      	str	r2, [r3, #16]

      XMC_CAN_NODE_DisableConfigurationChange(can_node);
 802709a:	6878      	ldr	r0, [r7, #4]
 802709c:	f7ff ff2f 	bl	8026efe <XMC_CAN_NODE_DisableConfigurationChange>

      return XMC_CAN_STATUS_SUCCESS;
 80270a0:	2300      	movs	r3, #0
 80270a2:	e000      	b.n	80270a6 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x146>
    }
  }

  return XMC_CAN_STATUS_ERROR;
 80270a4:	2301      	movs	r3, #1
}
 80270a6:	4618      	mov	r0, r3
 80270a8:	3720      	adds	r7, #32
 80270aa:	46bd      	mov	sp, r7
 80270ac:	bd80      	pop	{r7, pc}
 80270ae:	bf00      	nop
 80270b0:	d1b71759 	.word	0xd1b71759

080270b4 <XMC_CAN_AllocateMOtoNodeList>:
                   (((uint32_t)0U << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
  XMC_CAN_NODE_DisableConfigurationChange(can_node);
}
/* Function to allocate message object from free list to node list */
void XMC_CAN_AllocateMOtoNodeList(XMC_CAN_t *const obj, const uint8_t node_num, const uint8_t mo_num)
{
 80270b4:	b580      	push	{r7, lr}
 80270b6:	b082      	sub	sp, #8
 80270b8:	af00      	add	r7, sp, #0
 80270ba:	6078      	str	r0, [r7, #4]
 80270bc:	460b      	mov	r3, r1
 80270be:	70fb      	strb	r3, [r7, #3]
 80270c0:	4613      	mov	r3, r2
 80270c2:	70bb      	strb	r3, [r7, #2]
  /* wait while panel operation is in progress. */
  while (XMC_CAN_IsPanelControlReady(obj) == false)
 80270c4:	bf00      	nop
 80270c6:	6878      	ldr	r0, [r7, #4]
 80270c8:	f7ff fed6 	bl	8026e78 <XMC_CAN_IsPanelControlReady>
 80270cc:	4603      	mov	r3, r0
 80270ce:	f083 0301 	eor.w	r3, r3, #1
 80270d2:	b2db      	uxtb	r3, r3
 80270d4:	2b00      	cmp	r3, #0
 80270d6:	d1f6      	bne.n	80270c6 <XMC_CAN_AllocateMOtoNodeList+0x12>
  {
    /*Do nothing*/
  };

  /* Panel Command for  allocation of MO to node list */
  XMC_CAN_PanelControl(obj, XMC_CAN_PANCMD_STATIC_ALLOCATE, mo_num, (node_num + 1U));
 80270d8:	78fb      	ldrb	r3, [r7, #3]
 80270da:	3301      	adds	r3, #1
 80270dc:	b2db      	uxtb	r3, r3
 80270de:	78ba      	ldrb	r2, [r7, #2]
 80270e0:	2102      	movs	r1, #2
 80270e2:	6878      	ldr	r0, [r7, #4]
 80270e4:	f7ff fedc 	bl	8026ea0 <XMC_CAN_PanelControl>
}
 80270e8:	bf00      	nop
 80270ea:	3708      	adds	r7, #8
 80270ec:	46bd      	mov	sp, r7
 80270ee:	bd80      	pop	{r7, pc}

080270f0 <XMC_CAN_Enable>:
#endif
}

/* Enable XMC_CAN Peripheral */
void XMC_CAN_Enable(XMC_CAN_t *const obj)
{
 80270f0:	b580      	push	{r7, lr}
 80270f2:	b082      	sub	sp, #8
 80270f4:	af00      	add	r7, sp, #0
 80270f6:	6078      	str	r0, [r7, #4]
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MCAN);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_MCAN);
 80270f8:	480a      	ldr	r0, [pc, #40]	; (8027124 <XMC_CAN_Enable+0x34>)
 80270fa:	f7ff fb51 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  /* Enable CAN Module */
  obj->CLC &= ~(uint32_t)CAN_CLC_DISR_Msk;
 80270fe:	687b      	ldr	r3, [r7, #4]
 8027100:	681b      	ldr	r3, [r3, #0]
 8027102:	f023 0201 	bic.w	r2, r3, #1
 8027106:	687b      	ldr	r3, [r7, #4]
 8027108:	601a      	str	r2, [r3, #0]
  while (obj->CLC & CAN_CLC_DISS_Msk)
 802710a:	bf00      	nop
 802710c:	687b      	ldr	r3, [r7, #4]
 802710e:	681b      	ldr	r3, [r3, #0]
 8027110:	f003 0302 	and.w	r3, r3, #2
 8027114:	2b00      	cmp	r3, #0
 8027116:	d1f9      	bne.n	802710c <XMC_CAN_Enable+0x1c>
  {
    /*Do nothing*/
  };
}
 8027118:	bf00      	nop
 802711a:	bf00      	nop
 802711c:	3708      	adds	r7, #8
 802711e:	46bd      	mov	sp, r7
 8027120:	bd80      	pop	{r7, pc}
 8027122:	bf00      	nop
 8027124:	10000010 	.word	0x10000010

08027128 <XMC_CAN_SetBaudrateClockSource>:
  obj->FDR |= ((uint32_t)can_divider_mode << CAN_FDR_DM_Pos) | ((uint32_t)step << CAN_FDR_STEP_Pos);
}
#endif

void XMC_CAN_SetBaudrateClockSource(XMC_CAN_t *const obj, const XMC_CAN_CANCLKSRC_t source)
{
 8027128:	b480      	push	{r7}
 802712a:	b083      	sub	sp, #12
 802712c:	af00      	add	r7, sp, #0
 802712e:	6078      	str	r0, [r7, #4]
 8027130:	460b      	mov	r3, r1
 8027132:	70fb      	strb	r3, [r7, #3]
  obj->MCR = (obj->MCR & ~CAN_MCR_CLKSEL_Msk) | source ;
#else
  XMC_UNUSED_ARG(obj);
  XMC_UNUSED_ARG(source);
#endif
}
 8027134:	bf00      	nop
 8027136:	370c      	adds	r7, #12
 8027138:	46bd      	mov	sp, r7
 802713a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802713e:	4770      	bx	lr

08027140 <XMC_CAN_GetBaudrateClockFrequency>:
  return XMC_CAN_CANCLKSRC_FPERI;
#endif
}

uint32_t XMC_CAN_GetBaudrateClockFrequency(XMC_CAN_t *const obj)
{
 8027140:	b580      	push	{r7, lr}
 8027142:	b084      	sub	sp, #16
 8027144:	af00      	add	r7, sp, #0
 8027146:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0;
 8027148:	2300      	movs	r3, #0
 802714a:	60fb      	str	r3, [r7, #12]
      frequency = OSCHP_GetFrequency();
      break;
  }
#else
  XMC_UNUSED_ARG(obj);
  frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 802714c:	f7ff fb46 	bl	80267dc <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 8027150:	60f8      	str	r0, [r7, #12]
#endif

  return frequency;
 8027152:	68fb      	ldr	r3, [r7, #12]
}
 8027154:	4618      	mov	r0, r3
 8027156:	3710      	adds	r7, #16
 8027158:	46bd      	mov	sp, r7
 802715a:	bd80      	pop	{r7, pc}

0802715c <XMC_CAN_InitEx>:

uint32_t XMC_CAN_InitEx(XMC_CAN_t *const obj, XMC_CAN_CANCLKSRC_t clksrc, uint32_t can_frequency)
{
 802715c:	b580      	push	{r7, lr}
 802715e:	b088      	sub	sp, #32
 8027160:	af00      	add	r7, sp, #0
 8027162:	60f8      	str	r0, [r7, #12]
 8027164:	460b      	mov	r3, r1
 8027166:	607a      	str	r2, [r7, #4]
 8027168:	72fb      	strb	r3, [r7, #11]
  uint32_t step_n;
  uint32_t freq_n;
  uint32_t peripheral_frequency;

  /*Enabling the module*/
  XMC_CAN_Enable(obj);
 802716a:	68f8      	ldr	r0, [r7, #12]
 802716c:	f7ff ffc0 	bl	80270f0 <XMC_CAN_Enable>

  XMC_CAN_SetBaudrateClockSource(obj, clksrc);
 8027170:	7afb      	ldrb	r3, [r7, #11]
 8027172:	4619      	mov	r1, r3
 8027174:	68f8      	ldr	r0, [r7, #12]
 8027176:	f7ff ffd7 	bl	8027128 <XMC_CAN_SetBaudrateClockSource>
  peripheral_frequency = XMC_CAN_GetBaudrateClockFrequency(obj);
 802717a:	68f8      	ldr	r0, [r7, #12]
 802717c:	f7ff ffe0 	bl	8027140 <XMC_CAN_GetBaudrateClockFrequency>
 8027180:	61f8      	str	r0, [r7, #28]
  XMC_ASSERT("XMC_CAN_Init: frequency not supported", can_frequency <= peripheral_frequency);

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
 8027182:	69fa      	ldr	r2, [r7, #28]
 8027184:	687b      	ldr	r3, [r7, #4]
 8027186:	fbb2 f3f3 	udiv	r3, r2, r3
 802718a:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 802718e:	4619      	mov	r1, r3
 8027190:	2000      	movs	r0, #0
 8027192:	f7ff fec4 	bl	8026f1e <max>
 8027196:	4603      	mov	r3, r0
 8027198:	f240 31ff 	movw	r1, #1023	; 0x3ff
 802719c:	4618      	mov	r0, r3
 802719e:	f7ff fece 	bl	8026f3e <min>
 80271a2:	61b8      	str	r0, [r7, #24]
  freq_n = (uint32_t)(peripheral_frequency / (1024U - step_n));
 80271a4:	69bb      	ldr	r3, [r7, #24]
 80271a6:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 80271aa:	69fa      	ldr	r2, [r7, #28]
 80271ac:	fbb2 f3f3 	udiv	r3, r2, r3
 80271b0:	617b      	str	r3, [r7, #20]

  obj->FDR &= (uint32_t) ~(CAN_FDR_DM_Msk | CAN_FDR_STEP_Msk);
 80271b2:	68fb      	ldr	r3, [r7, #12]
 80271b4:	68db      	ldr	r3, [r3, #12]
 80271b6:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 80271ba:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80271be:	68fa      	ldr	r2, [r7, #12]
 80271c0:	60d3      	str	r3, [r2, #12]
  obj->FDR |= ((uint32_t)XMC_CAN_DM_NORMAL << CAN_FDR_DM_Pos) | ((uint32_t)step_n << CAN_FDR_STEP_Pos);
 80271c2:	68fb      	ldr	r3, [r7, #12]
 80271c4:	68da      	ldr	r2, [r3, #12]
 80271c6:	69bb      	ldr	r3, [r7, #24]
 80271c8:	4313      	orrs	r3, r2
 80271ca:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 80271ce:	68fb      	ldr	r3, [r7, #12]
 80271d0:	60da      	str	r2, [r3, #12]

  return freq_n;
 80271d2:	697b      	ldr	r3, [r7, #20]
}
 80271d4:	4618      	mov	r0, r3
 80271d6:	3720      	adds	r7, #32
 80271d8:	46bd      	mov	sp, r7
 80271da:	bd80      	pop	{r7, pc}

080271dc <XMC_CAN_MO_SetIdentifier>:
  return (XMC_CAN_GetBaudrateClockFrequency(obj) * (1024U - step_n));
}

/* Sets the Identifier of the MO */
void XMC_CAN_MO_SetIdentifier(XMC_CAN_MO_t *const can_mo, const uint32_t can_identifier)
{
 80271dc:	b480      	push	{r7}
 80271de:	b083      	sub	sp, #12
 80271e0:	af00      	add	r7, sp, #0
 80271e2:	6078      	str	r0, [r7, #4]
 80271e4:	6039      	str	r1, [r7, #0]
  if ((can_mo->can_mo_ptr->MOAR & CAN_MO_MOAR_IDE_Msk) != (uint32_t)CAN_MO_MOAR_IDE_Msk)
 80271e6:	687b      	ldr	r3, [r7, #4]
 80271e8:	681b      	ldr	r3, [r3, #0]
 80271ea:	699b      	ldr	r3, [r3, #24]
 80271ec:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80271f0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80271f4:	d00d      	beq.n	8027212 <XMC_CAN_MO_SetIdentifier+0x36>
  {
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 80271f6:	687b      	ldr	r3, [r7, #4]
 80271f8:	681b      	ldr	r3, [r3, #0]
 80271fa:	699b      	ldr	r3, [r3, #24]
 80271fc:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
                               ((can_identifier << XMC_CAN_MO_MOAR_STDID_Pos) & (uint32_t)CAN_MO_MOAR_ID_Msk);
 8027200:	683b      	ldr	r3, [r7, #0]
 8027202:	049b      	lsls	r3, r3, #18
 8027204:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 8027208:	687b      	ldr	r3, [r7, #4]
 802720a:	681b      	ldr	r3, [r3, #0]
 802720c:	430a      	orrs	r2, r1
 802720e:	619a      	str	r2, [r3, #24]
 8027210:	e00b      	b.n	802722a <XMC_CAN_MO_SetIdentifier+0x4e>
  }
  else
  {
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 8027212:	687b      	ldr	r3, [r7, #4]
 8027214:	681b      	ldr	r3, [r3, #0]
 8027216:	699b      	ldr	r3, [r3, #24]
 8027218:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
                               (can_identifier & (uint32_t)CAN_MO_MOAR_ID_Msk);
 802721c:	683b      	ldr	r3, [r7, #0]
 802721e:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
    can_mo->can_mo_ptr->MOAR = ((can_mo->can_mo_ptr->MOAR) & ~(uint32_t)(CAN_MO_MOAR_ID_Msk)) |
 8027222:	687b      	ldr	r3, [r7, #4]
 8027224:	681b      	ldr	r3, [r3, #0]
 8027226:	430a      	orrs	r2, r1
 8027228:	619a      	str	r2, [r3, #24]
  }
  can_mo->can_identifier = can_identifier;
 802722a:	683b      	ldr	r3, [r7, #0]
 802722c:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8027230:	687a      	ldr	r2, [r7, #4]
 8027232:	6853      	ldr	r3, [r2, #4]
 8027234:	f361 031c 	bfi	r3, r1, #0, #29
 8027238:	6053      	str	r3, [r2, #4]
}
 802723a:	bf00      	nop
 802723c:	370c      	adds	r7, #12
 802723e:	46bd      	mov	sp, r7
 8027240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027244:	4770      	bx	lr
	...

08027248 <XMC_CAN_MO_Config>:
  can_mo->can_id_mask = can_id_mask;
}

/* Initialization of XMC_CAN MO Object */
void XMC_CAN_MO_Config(const XMC_CAN_MO_t *const can_mo)
{
 8027248:	b580      	push	{r7, lr}
 802724a:	b086      	sub	sp, #24
 802724c:	af00      	add	r7, sp, #0
 802724e:	6078      	str	r0, [r7, #4]
  uint32_t reg;

  /* Configure MPN */
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U) / 0x0020U;
 8027250:	687b      	ldr	r3, [r7, #4]
 8027252:	681b      	ldr	r3, [r3, #0]
 8027254:	f103 4338 	add.w	r3, r3, #3087007744	; 0xb8000000
 8027258:	f5a3 33a8 	sub.w	r3, r3, #86016	; 0x15000
 802725c:	095b      	lsrs	r3, r3, #5
 802725e:	617b      	str	r3, [r7, #20]
  uint32_t set = (((uint32_t)(num / 32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num % 32) << CAN_MO_MOIPR_MPN_Pos));
 8027260:	697b      	ldr	r3, [r7, #20]
 8027262:	095b      	lsrs	r3, r3, #5
 8027264:	035a      	lsls	r2, r3, #13
 8027266:	697b      	ldr	r3, [r7, #20]
 8027268:	021b      	lsls	r3, r3, #8
 802726a:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 802726e:	4313      	orrs	r3, r2
 8027270:	613b      	str	r3, [r7, #16]
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
 8027272:	687b      	ldr	r3, [r7, #4]
 8027274:	681b      	ldr	r3, [r3, #0]
 8027276:	689a      	ldr	r2, [r3, #8]
 8027278:	687b      	ldr	r3, [r7, #4]
 802727a:	681b      	ldr	r3, [r3, #0]
 802727c:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 8027280:	609a      	str	r2, [r3, #8]
  can_mo->can_mo_ptr->MOIPR |= set;
 8027282:	687b      	ldr	r3, [r7, #4]
 8027284:	681b      	ldr	r3, [r3, #0]
 8027286:	6899      	ldr	r1, [r3, #8]
 8027288:	687b      	ldr	r3, [r7, #4]
 802728a:	681b      	ldr	r3, [r3, #0]
 802728c:	693a      	ldr	r2, [r7, #16]
 802728e:	430a      	orrs	r2, r1
 8027290:	609a      	str	r2, [r3, #8]

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 8027292:	687b      	ldr	r3, [r7, #4]
 8027294:	79db      	ldrb	r3, [r3, #7]
 8027296:	f003 0320 	and.w	r3, r3, #32
 802729a:	b2db      	uxtb	r3, r3
 802729c:	2b00      	cmp	r3, #0
 802729e:	d006      	beq.n	80272ae <XMC_CAN_MO_Config+0x66>
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
 80272a0:	687b      	ldr	r3, [r7, #4]
 80272a2:	79db      	ldrb	r3, [r3, #7]
 80272a4:	f003 0320 	and.w	r3, r3, #32
 80272a8:	b2db      	uxtb	r3, r3
  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 80272aa:	2b00      	cmp	r3, #0
 80272ac:	d060      	beq.n	8027370 <XMC_CAN_MO_Config+0x128>
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
 80272ae:	687b      	ldr	r3, [r7, #4]
 80272b0:	7e1b      	ldrb	r3, [r3, #24]
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
 80272b2:	2b00      	cmp	r3, #0
 80272b4:	d003      	beq.n	80272be <XMC_CAN_MO_Config+0x76>
       (can_mo->can_mo_type != XMC_CAN_MO_TYPE_TRANSMSGOBJ)))
 80272b6:	687b      	ldr	r3, [r7, #4]
 80272b8:	7e1b      	ldrb	r3, [r3, #24]
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
 80272ba:	2b01      	cmp	r3, #1
 80272bc:	d158      	bne.n	8027370 <XMC_CAN_MO_Config+0x128>
  }
  else
  {

    /* Disable Message object */
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 80272be:	687b      	ldr	r3, [r7, #4]
 80272c0:	681b      	ldr	r3, [r3, #0]
 80272c2:	2220      	movs	r2, #32
 80272c4:	61da      	str	r2, [r3, #28]
    if (can_mo->can_id_mode == (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS)
 80272c6:	687b      	ldr	r3, [r7, #4]
 80272c8:	79db      	ldrb	r3, [r3, #7]
 80272ca:	f003 0320 	and.w	r3, r3, #32
 80272ce:	b2db      	uxtb	r3, r3
 80272d0:	2b00      	cmp	r3, #0
 80272d2:	d128      	bne.n	8027326 <XMC_CAN_MO_Config+0xde>
    {
      reg = can_mo->mo_ar;
 80272d4:	687b      	ldr	r3, [r7, #4]
 80272d6:	685b      	ldr	r3, [r3, #4]
 80272d8:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAR_ID_Msk);
 80272da:	68fb      	ldr	r3, [r7, #12]
 80272dc:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 80272e0:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_identifier << XMC_CAN_MO_MOAR_STDID_Pos);
 80272e2:	687b      	ldr	r3, [r7, #4]
 80272e4:	685b      	ldr	r3, [r3, #4]
 80272e6:	f3c3 031c 	ubfx	r3, r3, #0, #29
 80272ea:	049b      	lsls	r3, r3, #18
 80272ec:	461a      	mov	r2, r3
 80272ee:	68fb      	ldr	r3, [r7, #12]
 80272f0:	4313      	orrs	r3, r2
 80272f2:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAR = reg;
 80272f4:	687b      	ldr	r3, [r7, #4]
 80272f6:	681b      	ldr	r3, [r3, #0]
 80272f8:	68fa      	ldr	r2, [r7, #12]
 80272fa:	619a      	str	r2, [r3, #24]

      reg = can_mo->mo_amr;
 80272fc:	687b      	ldr	r3, [r7, #4]
 80272fe:	689b      	ldr	r3, [r3, #8]
 8027300:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAMR_AM_Msk);
 8027302:	68fb      	ldr	r3, [r7, #12]
 8027304:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 8027308:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_id_mask << XMC_CAN_MO_MOAR_STDID_Pos);
 802730a:	687b      	ldr	r3, [r7, #4]
 802730c:	689b      	ldr	r3, [r3, #8]
 802730e:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8027312:	049b      	lsls	r3, r3, #18
 8027314:	461a      	mov	r2, r3
 8027316:	68fb      	ldr	r3, [r7, #12]
 8027318:	4313      	orrs	r3, r2
 802731a:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAMR = reg;
 802731c:	687b      	ldr	r3, [r7, #4]
 802731e:	681b      	ldr	r3, [r3, #0]
 8027320:	68fa      	ldr	r2, [r7, #12]
 8027322:	60da      	str	r2, [r3, #12]
 8027324:	e009      	b.n	802733a <XMC_CAN_MO_Config+0xf2>
    }
    else
    {
      can_mo->can_mo_ptr->MOAR = can_mo->mo_ar;
 8027326:	687b      	ldr	r3, [r7, #4]
 8027328:	681b      	ldr	r3, [r3, #0]
 802732a:	687a      	ldr	r2, [r7, #4]
 802732c:	6852      	ldr	r2, [r2, #4]
 802732e:	619a      	str	r2, [r3, #24]
      can_mo->can_mo_ptr->MOAMR = can_mo->mo_amr;
 8027330:	687b      	ldr	r3, [r7, #4]
 8027332:	681b      	ldr	r3, [r3, #0]
 8027334:	687a      	ldr	r2, [r7, #4]
 8027336:	6892      	ldr	r2, [r2, #8]
 8027338:	60da      	str	r2, [r3, #12]
    }
    /* Check whether message object is transmit message object */
    if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 802733a:	687b      	ldr	r3, [r7, #4]
 802733c:	7e1b      	ldrb	r3, [r3, #24]
 802733e:	2b01      	cmp	r3, #1
 8027340:	d10c      	bne.n	802735c <XMC_CAN_MO_Config+0x114>
    {
      /* Set MO as Transmit message object  */
      XMC_CAN_MO_UpdateData(can_mo);
 8027342:	6878      	ldr	r0, [r7, #4]
 8027344:	f000 f81c 	bl	8027380 <XMC_CAN_MO_UpdateData>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_SETDIR_Msk;
 8027348:	687b      	ldr	r3, [r7, #4]
 802734a:	681b      	ldr	r3, [r3, #0]
 802734c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8027350:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL and Set MSGVAL, TXEN0 and TXEN1 bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 8027352:	687b      	ldr	r3, [r7, #4]
 8027354:	681b      	ldr	r3, [r3, #0]
 8027356:	4a08      	ldr	r2, [pc, #32]	; (8027378 <XMC_CAN_MO_Config+0x130>)
 8027358:	61da      	str	r2, [r3, #28]
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
                                   CAN_MO_MOCTR_SETRXEN_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
    }

  }
}
 802735a:	e009      	b.n	8027370 <XMC_CAN_MO_Config+0x128>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESDIR_Msk;
 802735c:	687b      	ldr	r3, [r7, #4]
 802735e:	681b      	ldr	r3, [r3, #0]
 8027360:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8027364:	61da      	str	r2, [r3, #28]
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 8027366:	687b      	ldr	r3, [r7, #4]
 8027368:	681b      	ldr	r3, [r3, #0]
 802736a:	4a04      	ldr	r2, [pc, #16]	; (802737c <XMC_CAN_MO_Config+0x134>)
 802736c:	61da      	str	r2, [r3, #28]
}
 802736e:	e7ff      	b.n	8027370 <XMC_CAN_MO_Config+0x128>
 8027370:	bf00      	nop
 8027372:	3718      	adds	r7, #24
 8027374:	46bd      	mov	sp, r7
 8027376:	bd80      	pop	{r7, pc}
 8027378:	062000c0 	.word	0x062000c0
 802737c:	00a00640 	.word	0x00a00640

08027380 <XMC_CAN_MO_UpdateData>:

/* Update of XMC_CAN Object */
XMC_CAN_STATUS_t XMC_CAN_MO_UpdateData(const XMC_CAN_MO_t *const can_mo)
{
 8027380:	b480      	push	{r7}
 8027382:	b085      	sub	sp, #20
 8027384:	af00      	add	r7, sp, #0
 8027386:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 8027388:	2303      	movs	r3, #3
 802738a:	73fb      	strb	r3, [r7, #15]
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 802738c:	687b      	ldr	r3, [r7, #4]
 802738e:	7e1b      	ldrb	r3, [r3, #24]
 8027390:	2b01      	cmp	r3, #1
 8027392:	d122      	bne.n	80273da <XMC_CAN_MO_UpdateData+0x5a>
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 8027394:	687b      	ldr	r3, [r7, #4]
 8027396:	681b      	ldr	r3, [r3, #0]
 8027398:	2220      	movs	r2, #32
 802739a:	61da      	str	r2, [r3, #28]
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 802739c:	687b      	ldr	r3, [r7, #4]
 802739e:	681b      	ldr	r3, [r3, #0]
 80273a0:	681b      	ldr	r3, [r3, #0]
 80273a2:	f023 6170 	bic.w	r1, r3, #251658240	; 0xf000000
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
 80273a6:	687b      	ldr	r3, [r7, #4]
 80273a8:	7b1b      	ldrb	r3, [r3, #12]
 80273aa:	061b      	lsls	r3, r3, #24
 80273ac:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 80273b0:	687b      	ldr	r3, [r7, #4]
 80273b2:	681b      	ldr	r3, [r3, #0]
 80273b4:	430a      	orrs	r2, r1
 80273b6:	601a      	str	r2, [r3, #0]
    /* Configure Data registers*/
    can_mo->can_mo_ptr->MODATAL = can_mo->can_data[0];
 80273b8:	687b      	ldr	r3, [r7, #4]
 80273ba:	681b      	ldr	r3, [r3, #0]
 80273bc:	687a      	ldr	r2, [r7, #4]
 80273be:	6912      	ldr	r2, [r2, #16]
 80273c0:	611a      	str	r2, [r3, #16]
    can_mo->can_mo_ptr->MODATAH = can_mo->can_data[1];
 80273c2:	687b      	ldr	r3, [r7, #4]
 80273c4:	681b      	ldr	r3, [r3, #0]
 80273c6:	687a      	ldr	r2, [r7, #4]
 80273c8:	6952      	ldr	r2, [r2, #20]
 80273ca:	615a      	str	r2, [r3, #20]
    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1 bits */
    can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETNEWDAT_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
 80273cc:	687b      	ldr	r3, [r7, #4]
 80273ce:	681b      	ldr	r3, [r3, #0]
 80273d0:	4a06      	ldr	r2, [pc, #24]	; (80273ec <XMC_CAN_MO_UpdateData+0x6c>)
 80273d2:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
 80273d4:	2300      	movs	r3, #0
 80273d6:	73fb      	strb	r3, [r7, #15]
 80273d8:	e001      	b.n	80273de <XMC_CAN_MO_UpdateData+0x5e>
  }
  else
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 80273da:	2303      	movs	r3, #3
 80273dc:	73fb      	strb	r3, [r7, #15]
  }
  return error;
 80273de:	7bfb      	ldrb	r3, [r7, #15]
}
 80273e0:	4618      	mov	r0, r3
 80273e2:	3714      	adds	r7, #20
 80273e4:	46bd      	mov	sp, r7
 80273e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273ea:	4770      	bx	lr
 80273ec:	00280040 	.word	0x00280040

080273f0 <XMC_CAN_MO_Transmit>:

/* This function is will put a transmit request to transmit message object */
XMC_CAN_STATUS_t XMC_CAN_MO_Transmit(const XMC_CAN_MO_t *const can_mo)
{
 80273f0:	b480      	push	{r7}
 80273f2:	b087      	sub	sp, #28
 80273f4:	af00      	add	r7, sp, #0
 80273f6:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
 80273f8:	2301      	movs	r3, #1
 80273fa:	75fb      	strb	r3, [r7, #23]
  uint32_t mo_type = (uint32_t)(((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_MSGVAL_Msk) >> CAN_MO_MOSTAT_MSGVAL_Pos);
 80273fc:	687b      	ldr	r3, [r7, #4]
 80273fe:	681b      	ldr	r3, [r3, #0]
 8027400:	69db      	ldr	r3, [r3, #28]
 8027402:	095b      	lsrs	r3, r3, #5
 8027404:	f003 0301 	and.w	r3, r3, #1
 8027408:	613b      	str	r3, [r7, #16]
  uint32_t mo_transmission_ongoing = (uint32_t) ((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_TXRQ_Msk) >> CAN_MO_MOSTAT_TXRQ_Pos;
 802740a:	687b      	ldr	r3, [r7, #4]
 802740c:	681b      	ldr	r3, [r3, #0]
 802740e:	69db      	ldr	r3, [r3, #28]
 8027410:	0a1b      	lsrs	r3, r3, #8
 8027412:	f003 0301 	and.w	r3, r3, #1
 8027416:	60fb      	str	r3, [r7, #12]
  /* check if message is disabled */
  if (mo_type == 0U)
 8027418:	693b      	ldr	r3, [r7, #16]
 802741a:	2b00      	cmp	r3, #0
 802741c:	d102      	bne.n	8027424 <XMC_CAN_MO_Transmit+0x34>
  {
    error = XMC_CAN_STATUS_MO_DISABLED;
 802741e:	2304      	movs	r3, #4
 8027420:	75fb      	strb	r3, [r7, #23]
 8027422:	e00c      	b.n	802743e <XMC_CAN_MO_Transmit+0x4e>
  }
  /* check if transmission is ongoing on message object */
  else if (mo_transmission_ongoing == 1U)
 8027424:	68fb      	ldr	r3, [r7, #12]
 8027426:	2b01      	cmp	r3, #1
 8027428:	d102      	bne.n	8027430 <XMC_CAN_MO_Transmit+0x40>
  {
    error = XMC_CAN_STATUS_BUSY;
 802742a:	2302      	movs	r3, #2
 802742c:	75fb      	strb	r3, [r7, #23]
 802742e:	e006      	b.n	802743e <XMC_CAN_MO_Transmit+0x4e>
  }
  else
  {
    /* set TXRQ bit */
    can_mo->can_mo_ptr-> MOCTR = CAN_MO_MOCTR_SETTXRQ_Msk | CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk;
 8027430:	687b      	ldr	r3, [r7, #4]
 8027432:	681b      	ldr	r3, [r3, #0]
 8027434:	f04f 62e0 	mov.w	r2, #117440512	; 0x7000000
 8027438:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
 802743a:	2300      	movs	r3, #0
 802743c:	75fb      	strb	r3, [r7, #23]
  }
  return error;
 802743e:	7dfb      	ldrb	r3, [r7, #23]
}
 8027440:	4618      	mov	r0, r3
 8027442:	371c      	adds	r7, #28
 8027444:	46bd      	mov	sp, r7
 8027446:	f85d 7b04 	ldr.w	r7, [sp], #4
 802744a:	4770      	bx	lr

0802744c <XMC_CAN_MO_Receive>:
}


/* This function is will read the message object data bytes */
XMC_CAN_STATUS_t XMC_CAN_MO_Receive (XMC_CAN_MO_t *can_mo)
{
 802744c:	b480      	push	{r7}
 802744e:	b087      	sub	sp, #28
 8027450:	af00      	add	r7, sp, #0
 8027452:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
 8027454:	2301      	movs	r3, #1
 8027456:	75fb      	strb	r3, [r7, #23]
  uint8_t rx_pnd = 0U;
 8027458:	2300      	movs	r3, #0
 802745a:	75bb      	strb	r3, [r7, #22]
  uint8_t new_data = 0U;
 802745c:	2300      	movs	r3, #0
 802745e:	757b      	strb	r3, [r7, #21]
  uint32_t mo_type = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_DIR_Msk) >> CAN_MO_MOSTAT_DIR_Pos;
 8027460:	687b      	ldr	r3, [r7, #4]
 8027462:	681b      	ldr	r3, [r3, #0]
 8027464:	69db      	ldr	r3, [r3, #28]
 8027466:	0adb      	lsrs	r3, r3, #11
 8027468:	f003 0301 	and.w	r3, r3, #1
 802746c:	613b      	str	r3, [r7, #16]
  uint32_t mo_recepcion_ongoing = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos;
 802746e:	687b      	ldr	r3, [r7, #4]
 8027470:	681b      	ldr	r3, [r3, #0]
 8027472:	69db      	ldr	r3, [r3, #28]
 8027474:	089b      	lsrs	r3, r3, #2
 8027476:	f003 0301 	and.w	r3, r3, #1
 802747a:	60fb      	str	r3, [r7, #12]
  /* check if message object is a receive message object */
  if (mo_type != (uint32_t)XMC_CAN_MO_TYPE_RECMSGOBJ)
 802747c:	693b      	ldr	r3, [r7, #16]
 802747e:	2b00      	cmp	r3, #0
 8027480:	d002      	beq.n	8027488 <XMC_CAN_MO_Receive+0x3c>
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 8027482:	2303      	movs	r3, #3
 8027484:	75fb      	strb	r3, [r7, #23]
 8027486:	e0a3      	b.n	80275d0 <XMC_CAN_MO_Receive+0x184>
  }
  /* check if reception is ongoing on message object */
  else if (mo_recepcion_ongoing == 1U)
 8027488:	68fb      	ldr	r3, [r7, #12]
 802748a:	2b01      	cmp	r3, #1
 802748c:	d102      	bne.n	8027494 <XMC_CAN_MO_Receive+0x48>
  {
    error = XMC_CAN_STATUS_BUSY;
 802748e:	2302      	movs	r3, #2
 8027490:	75fb      	strb	r3, [r7, #23]
 8027492:	e09d      	b.n	80275d0 <XMC_CAN_MO_Receive+0x184>
  else
  {
    /* read message parameters */
    do
    {
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESNEWDAT_Msk;
 8027494:	687b      	ldr	r3, [r7, #4]
 8027496:	681b      	ldr	r3, [r3, #0]
 8027498:	2208      	movs	r2, #8
 802749a:	61da      	str	r2, [r3, #28]
      if ((((can_mo->can_mo_ptr->MOAR) & CAN_MO_MOAR_IDE_Msk) >> CAN_MO_MOAR_IDE_Pos) == 0U)
 802749c:	687b      	ldr	r3, [r7, #4]
 802749e:	681b      	ldr	r3, [r3, #0]
 80274a0:	699b      	ldr	r3, [r3, #24]
 80274a2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80274a6:	2b00      	cmp	r3, #0
 80274a8:	d13d      	bne.n	8027526 <XMC_CAN_MO_Receive+0xda>
      {
        can_mo->can_id_mode = (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS;
 80274aa:	687a      	ldr	r2, [r7, #4]
 80274ac:	79d3      	ldrb	r3, [r2, #7]
 80274ae:	f36f 1345 	bfc	r3, #5, #1
 80274b2:	71d3      	strb	r3, [r2, #7]
        can_mo->can_identifier = (can_mo->can_mo_ptr->MOAR & XMC_CAN_MO_MOAR_STDID_Msk) >> XMC_CAN_MO_MOAR_STDID_Pos;
 80274b4:	687b      	ldr	r3, [r7, #4]
 80274b6:	681b      	ldr	r3, [r3, #0]
 80274b8:	699b      	ldr	r3, [r3, #24]
 80274ba:	0c9b      	lsrs	r3, r3, #18
 80274bc:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80274c0:	f3c3 010a 	ubfx	r1, r3, #0, #11
 80274c4:	687a      	ldr	r2, [r7, #4]
 80274c6:	6853      	ldr	r3, [r2, #4]
 80274c8:	f361 031c 	bfi	r3, r1, #0, #29
 80274cc:	6053      	str	r3, [r2, #4]
        can_mo->can_ide_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_MIDE_Msk) >> CAN_MO_MOAMR_MIDE_Pos;
 80274ce:	687b      	ldr	r3, [r7, #4]
 80274d0:	681b      	ldr	r3, [r3, #0]
 80274d2:	68db      	ldr	r3, [r3, #12]
 80274d4:	0f5b      	lsrs	r3, r3, #29
 80274d6:	f003 0301 	and.w	r3, r3, #1
 80274da:	b2d9      	uxtb	r1, r3
 80274dc:	687a      	ldr	r2, [r7, #4]
 80274de:	7ad3      	ldrb	r3, [r2, #11]
 80274e0:	f361 1345 	bfi	r3, r1, #5, #1
 80274e4:	72d3      	strb	r3, [r2, #11]
        if (can_mo->can_ide_mask == 1U)
 80274e6:	687b      	ldr	r3, [r7, #4]
 80274e8:	7adb      	ldrb	r3, [r3, #11]
 80274ea:	f003 0320 	and.w	r3, r3, #32
 80274ee:	b2db      	uxtb	r3, r3
 80274f0:	2b00      	cmp	r3, #0
 80274f2:	d00d      	beq.n	8027510 <XMC_CAN_MO_Receive+0xc4>
        {
          can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & XMC_CAN_MO_MOAR_STDID_Msk) >> XMC_CAN_MO_MOAR_STDID_Pos;
 80274f4:	687b      	ldr	r3, [r7, #4]
 80274f6:	681b      	ldr	r3, [r3, #0]
 80274f8:	68db      	ldr	r3, [r3, #12]
 80274fa:	0c9b      	lsrs	r3, r3, #18
 80274fc:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8027500:	f3c3 010a 	ubfx	r1, r3, #0, #11
 8027504:	687a      	ldr	r2, [r7, #4]
 8027506:	6893      	ldr	r3, [r2, #8]
 8027508:	f361 031c 	bfi	r3, r1, #0, #29
 802750c:	6093      	str	r3, [r2, #8]
 802750e:	e02f      	b.n	8027570 <XMC_CAN_MO_Receive+0x124>
        }
        else
        {
          can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_AM_Msk);
 8027510:	687b      	ldr	r3, [r7, #4]
 8027512:	681b      	ldr	r3, [r3, #0]
 8027514:	68db      	ldr	r3, [r3, #12]
 8027516:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 802751a:	687a      	ldr	r2, [r7, #4]
 802751c:	6893      	ldr	r3, [r2, #8]
 802751e:	f361 031c 	bfi	r3, r1, #0, #29
 8027522:	6093      	str	r3, [r2, #8]
 8027524:	e024      	b.n	8027570 <XMC_CAN_MO_Receive+0x124>
        }
      }
      else
      {
        can_mo->can_id_mode = (uint32_t)XMC_CAN_FRAME_TYPE_EXTENDED_29BITS;
 8027526:	687a      	ldr	r2, [r7, #4]
 8027528:	79d3      	ldrb	r3, [r2, #7]
 802752a:	f043 0320 	orr.w	r3, r3, #32
 802752e:	71d3      	strb	r3, [r2, #7]
        can_mo->can_identifier = (can_mo->can_mo_ptr->MOAR & CAN_MO_MOAR_ID_Msk);
 8027530:	687b      	ldr	r3, [r7, #4]
 8027532:	681b      	ldr	r3, [r3, #0]
 8027534:	699b      	ldr	r3, [r3, #24]
 8027536:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 802753a:	687a      	ldr	r2, [r7, #4]
 802753c:	6853      	ldr	r3, [r2, #4]
 802753e:	f361 031c 	bfi	r3, r1, #0, #29
 8027542:	6053      	str	r3, [r2, #4]
        can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_AM_Msk);
 8027544:	687b      	ldr	r3, [r7, #4]
 8027546:	681b      	ldr	r3, [r3, #0]
 8027548:	68db      	ldr	r3, [r3, #12]
 802754a:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 802754e:	687a      	ldr	r2, [r7, #4]
 8027550:	6893      	ldr	r3, [r2, #8]
 8027552:	f361 031c 	bfi	r3, r1, #0, #29
 8027556:	6093      	str	r3, [r2, #8]
        can_mo->can_ide_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_MIDE_Msk) >> CAN_MO_MOAMR_MIDE_Pos;
 8027558:	687b      	ldr	r3, [r7, #4]
 802755a:	681b      	ldr	r3, [r3, #0]
 802755c:	68db      	ldr	r3, [r3, #12]
 802755e:	0f5b      	lsrs	r3, r3, #29
 8027560:	f003 0301 	and.w	r3, r3, #1
 8027564:	b2d9      	uxtb	r1, r3
 8027566:	687a      	ldr	r2, [r7, #4]
 8027568:	7ad3      	ldrb	r3, [r2, #11]
 802756a:	f361 1345 	bfi	r3, r1, #5, #1
 802756e:	72d3      	strb	r3, [r2, #11]
      }
      can_mo->can_data_length = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOFCR) & CAN_MO_MOFCR_DLC_Msk) >> CAN_MO_MOFCR_DLC_Pos);
 8027570:	687b      	ldr	r3, [r7, #4]
 8027572:	681b      	ldr	r3, [r3, #0]
 8027574:	681b      	ldr	r3, [r3, #0]
 8027576:	0e1b      	lsrs	r3, r3, #24
 8027578:	b2db      	uxtb	r3, r3
 802757a:	f003 030f 	and.w	r3, r3, #15
 802757e:	b2da      	uxtb	r2, r3
 8027580:	687b      	ldr	r3, [r7, #4]
 8027582:	731a      	strb	r2, [r3, #12]

      can_mo->can_data[0] = can_mo->can_mo_ptr->MODATAL;
 8027584:	687b      	ldr	r3, [r7, #4]
 8027586:	681b      	ldr	r3, [r3, #0]
 8027588:	691a      	ldr	r2, [r3, #16]
 802758a:	687b      	ldr	r3, [r7, #4]
 802758c:	611a      	str	r2, [r3, #16]
      can_mo->can_data[1] = can_mo->can_mo_ptr->MODATAH;
 802758e:	687b      	ldr	r3, [r7, #4]
 8027590:	681b      	ldr	r3, [r3, #0]
 8027592:	695a      	ldr	r2, [r3, #20]
 8027594:	687b      	ldr	r3, [r7, #4]
 8027596:	615a      	str	r2, [r3, #20]

      rx_pnd = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos);
 8027598:	687b      	ldr	r3, [r7, #4]
 802759a:	681b      	ldr	r3, [r3, #0]
 802759c:	69db      	ldr	r3, [r3, #28]
 802759e:	089b      	lsrs	r3, r3, #2
 80275a0:	b2db      	uxtb	r3, r3
 80275a2:	f003 0301 	and.w	r3, r3, #1
 80275a6:	75bb      	strb	r3, [r7, #22]
      new_data = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_NEWDAT_Msk) >> CAN_MO_MOSTAT_NEWDAT_Pos);
 80275a8:	687b      	ldr	r3, [r7, #4]
 80275aa:	681b      	ldr	r3, [r3, #0]
 80275ac:	69db      	ldr	r3, [r3, #28]
 80275ae:	08db      	lsrs	r3, r3, #3
 80275b0:	b2db      	uxtb	r3, r3
 80275b2:	f003 0301 	and.w	r3, r3, #1
 80275b6:	757b      	strb	r3, [r7, #21]
    }
    while ((rx_pnd != 0U) && (new_data != 0U));
 80275b8:	7dbb      	ldrb	r3, [r7, #22]
 80275ba:	2b00      	cmp	r3, #0
 80275bc:	d003      	beq.n	80275c6 <XMC_CAN_MO_Receive+0x17a>
 80275be:	7d7b      	ldrb	r3, [r7, #21]
 80275c0:	2b00      	cmp	r3, #0
 80275c2:	f47f af67 	bne.w	8027494 <XMC_CAN_MO_Receive+0x48>

    can_mo->can_mo_type = XMC_CAN_MO_TYPE_RECMSGOBJ;
 80275c6:	687b      	ldr	r3, [r7, #4]
 80275c8:	2200      	movs	r2, #0
 80275ca:	761a      	strb	r2, [r3, #24]
    error = XMC_CAN_STATUS_SUCCESS;
 80275cc:	2300      	movs	r3, #0
 80275ce:	75fb      	strb	r3, [r7, #23]
  }
  return error;
 80275d0:	7dfb      	ldrb	r3, [r7, #23]
}
 80275d2:	4618      	mov	r0, r3
 80275d4:	371c      	adds	r7, #28
 80275d6:	46bd      	mov	sp, r7
 80275d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80275dc:	4770      	bx	lr

080275de <XMC_CAN_NODE_EnableEvent>:

/* Function to enable node event */
void XMC_CAN_NODE_EnableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event)
{
 80275de:	b480      	push	{r7}
 80275e0:	b083      	sub	sp, #12
 80275e2:	af00      	add	r7, sp, #0
 80275e4:	6078      	str	r0, [r7, #4]
 80275e6:	6039      	str	r1, [r7, #0]
  if (event != XMC_CAN_NODE_EVENT_CFCIE)
 80275e8:	683b      	ldr	r3, [r7, #0]
 80275ea:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80275ee:	d006      	beq.n	80275fe <XMC_CAN_NODE_EnableEvent+0x20>
  {
    can_node->NCR |= (uint32_t)event;
 80275f0:	687b      	ldr	r3, [r7, #4]
 80275f2:	681a      	ldr	r2, [r3, #0]
 80275f4:	683b      	ldr	r3, [r7, #0]
 80275f6:	431a      	orrs	r2, r3
 80275f8:	687b      	ldr	r3, [r7, #4]
 80275fa:	601a      	str	r2, [r3, #0]
  }
  else
  {
    can_node->NFCR |= (uint32_t)event;
  }
}
 80275fc:	e005      	b.n	802760a <XMC_CAN_NODE_EnableEvent+0x2c>
    can_node->NFCR |= (uint32_t)event;
 80275fe:	687b      	ldr	r3, [r7, #4]
 8027600:	699a      	ldr	r2, [r3, #24]
 8027602:	683b      	ldr	r3, [r7, #0]
 8027604:	431a      	orrs	r2, r3
 8027606:	687b      	ldr	r3, [r7, #4]
 8027608:	619a      	str	r2, [r3, #24]
}
 802760a:	bf00      	nop
 802760c:	370c      	adds	r7, #12
 802760e:	46bd      	mov	sp, r7
 8027610:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027614:	4770      	bx	lr

08027616 <XMC_CCU4_StartPrescaler>:
{
 8027616:	b480      	push	{r7}
 8027618:	b083      	sub	sp, #12
 802761a:	af00      	add	r7, sp, #0
 802761c:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 802761e:	687b      	ldr	r3, [r7, #4]
 8027620:	f44f 7280 	mov.w	r2, #256	; 0x100
 8027624:	60da      	str	r2, [r3, #12]
}
 8027626:	bf00      	nop
 8027628:	370c      	adds	r7, #12
 802762a:	46bd      	mov	sp, r7
 802762c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027630:	4770      	bx	lr
	...

08027634 <XMC_CCU4_lDeassertReset>:
    XMC_ASSERT("XMC_CCU4_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
 8027634:	b580      	push	{r7, lr}
 8027636:	b082      	sub	sp, #8
 8027638:	af00      	add	r7, sp, #0
 802763a:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
 802763c:	687b      	ldr	r3, [r7, #4]
 802763e:	4a11      	ldr	r2, [pc, #68]	; (8027684 <XMC_CCU4_lDeassertReset+0x50>)
 8027640:	4293      	cmp	r3, r2
 8027642:	d103      	bne.n	802764c <XMC_CCU4_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 8027644:	2004      	movs	r0, #4
 8027646:	f7ff f8ab 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 802764a:	e016      	b.n	802767a <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU41)
 802764c:	687b      	ldr	r3, [r7, #4]
 802764e:	4a0e      	ldr	r2, [pc, #56]	; (8027688 <XMC_CCU4_lDeassertReset+0x54>)
 8027650:	4293      	cmp	r3, r2
 8027652:	d103      	bne.n	802765c <XMC_CCU4_lDeassertReset+0x28>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 8027654:	2008      	movs	r0, #8
 8027656:	f7ff f8a3 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 802765a:	e00e      	b.n	802767a <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU42)
 802765c:	687b      	ldr	r3, [r7, #4]
 802765e:	4a0b      	ldr	r2, [pc, #44]	; (802768c <XMC_CCU4_lDeassertReset+0x58>)
 8027660:	4293      	cmp	r3, r2
 8027662:	d103      	bne.n	802766c <XMC_CCU4_lDeassertReset+0x38>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 8027664:	2010      	movs	r0, #16
 8027666:	f7ff f89b 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 802766a:	e006      	b.n	802767a <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU43)
 802766c:	687b      	ldr	r3, [r7, #4]
 802766e:	4a08      	ldr	r2, [pc, #32]	; (8027690 <XMC_CCU4_lDeassertReset+0x5c>)
 8027670:	4293      	cmp	r3, r2
 8027672:	d102      	bne.n	802767a <XMC_CCU4_lDeassertReset+0x46>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 8027674:	4807      	ldr	r0, [pc, #28]	; (8027694 <XMC_CCU4_lDeassertReset+0x60>)
 8027676:	f7ff f893 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 802767a:	bf00      	nop
 802767c:	3708      	adds	r7, #8
 802767e:	46bd      	mov	sp, r7
 8027680:	bd80      	pop	{r7, pc}
 8027682:	bf00      	nop
 8027684:	4000c000 	.word	0x4000c000
 8027688:	40010000 	.word	0x40010000
 802768c:	40014000 	.word	0x40014000
 8027690:	48004000 	.word	0x48004000
 8027694:	10000001 	.word	0x10000001

08027698 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
 8027698:	b580      	push	{r7, lr}
 802769a:	b082      	sub	sp, #8
 802769c:	af00      	add	r7, sp, #0
 802769e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 80276a0:	2010      	movs	r0, #16
 80276a2:	f7ff f9b9 	bl	8026a18 <XMC_SCU_CLOCK_EnableClock>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
 80276a6:	6878      	ldr	r0, [r7, #4]
 80276a8:	f7ff ffc4 	bl	8027634 <XMC_CCU4_lDeassertReset>
#endif
}
 80276ac:	bf00      	nop
 80276ae:	3708      	adds	r7, #8
 80276b0:	46bd      	mov	sp, r7
 80276b2:	bd80      	pop	{r7, pc}

080276b4 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 80276b4:	b580      	push	{r7, lr}
 80276b6:	b084      	sub	sp, #16
 80276b8:	af00      	add	r7, sp, #0
 80276ba:	6078      	str	r0, [r7, #4]
 80276bc:	460b      	mov	r3, r1
 80276be:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
 80276c0:	6878      	ldr	r0, [r7, #4]
 80276c2:	f7ff ffe9 	bl	8027698 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
 80276c6:	6878      	ldr	r0, [r7, #4]
 80276c8:	f7ff ffa5 	bl	8027616 <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
 80276cc:	687b      	ldr	r3, [r7, #4]
 80276ce:	681b      	ldr	r3, [r3, #0]
 80276d0:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 80276d2:	68fb      	ldr	r3, [r7, #12]
 80276d4:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80276d8:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 80276da:	78fb      	ldrb	r3, [r7, #3]
 80276dc:	039b      	lsls	r3, r3, #14
 80276de:	68fa      	ldr	r2, [r7, #12]
 80276e0:	4313      	orrs	r3, r2
 80276e2:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 80276e4:	687b      	ldr	r3, [r7, #4]
 80276e6:	68fa      	ldr	r2, [r7, #12]
 80276e8:	601a      	str	r2, [r3, #0]
}
 80276ea:	bf00      	nop
 80276ec:	3710      	adds	r7, #16
 80276ee:	46bd      	mov	sp, r7
 80276f0:	bd80      	pop	{r7, pc}

080276f2 <XMC_CCU4_SetMultiChannelShadowTransferMode>:
  module->GCTRL = gctrl;
}

/* API to configure the multichannel shadow transfer request via SW and via the CCU4x.MCSS input. */
void XMC_CCU4_SetMultiChannelShadowTransferMode(XMC_CCU4_MODULE_t *const module, const uint32_t slice_mode_msk)
{
 80276f2:	b480      	push	{r7}
 80276f4:	b085      	sub	sp, #20
 80276f6:	af00      	add	r7, sp, #0
 80276f8:	6078      	str	r0, [r7, #4]
 80276fa:	6039      	str	r1, [r7, #0]
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));

  gctrl = module->GCTRL;
 80276fc:	687b      	ldr	r3, [r7, #4]
 80276fe:	681b      	ldr	r3, [r3, #0]
 8027700:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 8027702:	683b      	ldr	r3, [r7, #0]
 8027704:	0c1b      	lsrs	r3, r3, #16
 8027706:	43db      	mvns	r3, r3
 8027708:	68fa      	ldr	r2, [r7, #12]
 802770a:	4013      	ands	r3, r2
 802770c:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 802770e:	683b      	ldr	r3, [r7, #0]
 8027710:	b29b      	uxth	r3, r3
 8027712:	68fa      	ldr	r2, [r7, #12]
 8027714:	4313      	orrs	r3, r2
 8027716:	60fb      	str	r3, [r7, #12]
  module->GCTRL = gctrl;
 8027718:	687b      	ldr	r3, [r7, #4]
 802771a:	68fa      	ldr	r2, [r7, #12]
 802771c:	601a      	str	r2, [r3, #0]
}
 802771e:	bf00      	nop
 8027720:	3714      	adds	r7, #20
 8027722:	46bd      	mov	sp, r7
 8027724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027728:	4770      	bx	lr

0802772a <XMC_CCU4_SLICE_CompareInit>:

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 802772a:	b480      	push	{r7}
 802772c:	b083      	sub	sp, #12
 802772e:	af00      	add	r7, sp, #0
 8027730:	6078      	str	r0, [r7, #4]
 8027732:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8027734:	683b      	ldr	r3, [r7, #0]
 8027736:	681a      	ldr	r2, [r3, #0]
 8027738:	687b      	ldr	r3, [r7, #4]
 802773a:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 802773c:	683b      	ldr	r3, [r7, #0]
 802773e:	795b      	ldrb	r3, [r3, #5]
 8027740:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8027744:	b2db      	uxtb	r3, r3
 8027746:	051a      	lsls	r2, r3, #20
 8027748:	687b      	ldr	r3, [r7, #4]
 802774a:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 802774c:	683b      	ldr	r3, [r7, #0]
 802774e:	791b      	ldrb	r3, [r3, #4]
 8027750:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027754:	b2db      	uxtb	r3, r3
 8027756:	461a      	mov	r2, r3
 8027758:	687b      	ldr	r3, [r7, #4]
 802775a:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 802775c:	683b      	ldr	r3, [r7, #0]
 802775e:	795b      	ldrb	r3, [r3, #5]
 8027760:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027764:	b2db      	uxtb	r3, r3
 8027766:	461a      	mov	r2, r3
 8027768:	687b      	ldr	r3, [r7, #4]
 802776a:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 802776c:	683b      	ldr	r3, [r7, #0]
 802776e:	795b      	ldrb	r3, [r3, #5]
 8027770:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8027774:	b2db      	uxtb	r3, r3
 8027776:	461a      	mov	r2, r3
 8027778:	687b      	ldr	r3, [r7, #4]
 802777a:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 802777c:	683b      	ldr	r3, [r7, #0]
 802777e:	791b      	ldrb	r3, [r3, #4]
 8027780:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8027784:	b2db      	uxtb	r3, r3
 8027786:	461a      	mov	r2, r3
 8027788:	687b      	ldr	r3, [r7, #4]
 802778a:	62da      	str	r2, [r3, #44]	; 0x2c
}
 802778c:	bf00      	nop
 802778e:	370c      	adds	r7, #12
 8027790:	46bd      	mov	sp, r7
 8027792:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027796:	4770      	bx	lr

08027798 <XMC_CCU4_SLICE_CaptureInit>:

/* API to configure CC4 Slice for Capture */
void XMC_CCU4_SLICE_CaptureInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_CAPTURE_CONFIG_t *const capture_init)
{
 8027798:	b480      	push	{r7}
 802779a:	b083      	sub	sp, #12
 802779c:	af00      	add	r7, sp, #0
 802779e:	6078      	str	r0, [r7, #4]
 80277a0:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CaptureInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CaptureInit:Capture Init Pointer is NULL",
             (XMC_CCU4_SLICE_CAPTURE_CONFIG_t *) NULL != capture_init);

  /* Program the capture mode */
  slice->TC = capture_init->tc;
 80277a2:	683b      	ldr	r3, [r7, #0]
 80277a4:	681a      	ldr	r2, [r3, #0]
 80277a6:	687b      	ldr	r3, [r7, #4]
 80277a8:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t)capture_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80277aa:	683b      	ldr	r3, [r7, #0]
 80277ac:	795b      	ldrb	r3, [r3, #5]
 80277ae:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80277b2:	b2db      	uxtb	r3, r3
 80277b4:	051a      	lsls	r2, r3, #20
 80277b6:	687b      	ldr	r3, [r7, #4]
 80277b8:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) capture_init->prescaler_initval;
 80277ba:	683b      	ldr	r3, [r7, #0]
 80277bc:	791b      	ldrb	r3, [r3, #4]
 80277be:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80277c2:	b2db      	uxtb	r3, r3
 80277c4:	461a      	mov	r2, r3
 80277c6:	687b      	ldr	r3, [r7, #4]
 80277c8:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program initial floating prescaler compare value */
  slice->FPCS = (uint32_t) capture_init->float_limit;
 80277ca:	683b      	ldr	r3, [r7, #0]
 80277cc:	791b      	ldrb	r3, [r3, #4]
 80277ce:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80277d2:	b2db      	uxtb	r3, r3
 80277d4:	461a      	mov	r2, r3
 80277d6:	687b      	ldr	r3, [r7, #4]
 80277d8:	62da      	str	r2, [r3, #44]	; 0x2c
}
 80277da:	bf00      	nop
 80277dc:	370c      	adds	r7, #12
 80277de:	46bd      	mov	sp, r7
 80277e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80277e4:	4770      	bx	lr

080277e6 <XMC_CCU4_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice */
void XMC_CCU4_SLICE_StartConfig(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_EVENT_t event,
                                const XMC_CCU4_SLICE_START_MODE_t start_mode)
{
 80277e6:	b480      	push	{r7}
 80277e8:	b085      	sub	sp, #20
 80277ea:	af00      	add	r7, sp, #0
 80277ec:	6078      	str	r0, [r7, #4]
 80277ee:	460b      	mov	r3, r1
 80277f0:	70fb      	strb	r3, [r7, #3]
 80277f2:	4613      	mov	r3, r2
 80277f4:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Start Mode",
             ((start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR) || \
              (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START)));
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 80277f6:	687b      	ldr	r3, [r7, #4]
 80277f8:	685b      	ldr	r3, [r3, #4]
 80277fa:	60bb      	str	r3, [r7, #8]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_STRTS_Msk);
 80277fc:	68bb      	ldr	r3, [r7, #8]
 80277fe:	f023 0303 	bic.w	r3, r3, #3
 8027802:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_STRTS_Pos;
 8027804:	78fb      	ldrb	r3, [r7, #3]
 8027806:	68ba      	ldr	r2, [r7, #8]
 8027808:	4313      	orrs	r3, r2
 802780a:	60bb      	str	r3, [r7, #8]

  slice->CMC = cmc;
 802780c:	687b      	ldr	r3, [r7, #4]
 802780e:	68ba      	ldr	r2, [r7, #8]
 8027810:	605a      	str	r2, [r3, #4]

  tc  = slice->TC;
 8027812:	687b      	ldr	r3, [r7, #4]
 8027814:	695b      	ldr	r3, [r3, #20]
 8027816:	60fb      	str	r3, [r7, #12]
  /* Next, Configure the start mode */
  if (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR)
 8027818:	78bb      	ldrb	r3, [r7, #2]
 802781a:	2b01      	cmp	r3, #1
 802781c:	d104      	bne.n	8027828 <XMC_CCU4_SLICE_StartConfig+0x42>
  {
    tc |= (uint32_t)CCU4_CC4_TC_STRM_Msk;
 802781e:	68fb      	ldr	r3, [r7, #12]
 8027820:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8027824:	60fb      	str	r3, [r7, #12]
 8027826:	e003      	b.n	8027830 <XMC_CCU4_SLICE_StartConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t)CCU4_CC4_TC_STRM_Msk);
 8027828:	68fb      	ldr	r3, [r7, #12]
 802782a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802782e:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8027830:	687b      	ldr	r3, [r7, #4]
 8027832:	68fa      	ldr	r2, [r7, #12]
 8027834:	615a      	str	r2, [r3, #20]
}
 8027836:	bf00      	nop
 8027838:	3714      	adds	r7, #20
 802783a:	46bd      	mov	sp, r7
 802783c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027840:	4770      	bx	lr

08027842 <XMC_CCU4_SLICE_StopConfig>:

/* API to configure the Stop trigger function of a slice */
void XMC_CCU4_SLICE_StopConfig(XMC_CCU4_SLICE_t *const slice,
                               const XMC_CCU4_SLICE_EVENT_t event,
                               const XMC_CCU4_SLICE_END_MODE_t end_mode)
{
 8027842:	b480      	push	{r7}
 8027844:	b085      	sub	sp, #20
 8027846:	af00      	add	r7, sp, #0
 8027848:	6078      	str	r0, [r7, #4]
 802784a:	460b      	mov	r3, r1
 802784c:	70fb      	strb	r3, [r7, #3]
 802784e:	4613      	mov	r3, r2
 8027850:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Start Mode", XMC_CCU4_CHECK_END_MODE(end_mode));

  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8027852:	687b      	ldr	r3, [r7, #4]
 8027854:	685b      	ldr	r3, [r3, #4]
 8027856:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_ENDS_Msk);
 8027858:	68fb      	ldr	r3, [r7, #12]
 802785a:	f023 030c 	bic.w	r3, r3, #12
 802785e:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_ENDS_Pos;
 8027860:	78fb      	ldrb	r3, [r7, #3]
 8027862:	009b      	lsls	r3, r3, #2
 8027864:	68fa      	ldr	r2, [r7, #12]
 8027866:	4313      	orrs	r3, r2
 8027868:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 802786a:	687b      	ldr	r3, [r7, #4]
 802786c:	68fa      	ldr	r2, [r7, #12]
 802786e:	605a      	str	r2, [r3, #4]

  /* Next, Configure the stop mode */
  tc = slice->TC;
 8027870:	687b      	ldr	r3, [r7, #4]
 8027872:	695b      	ldr	r3, [r3, #20]
 8027874:	60bb      	str	r3, [r7, #8]
  tc &= ~((uint32_t) CCU4_CC4_TC_ENDM_Msk);
 8027876:	68bb      	ldr	r3, [r7, #8]
 8027878:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802787c:	60bb      	str	r3, [r7, #8]
  tc |= ((uint32_t) end_mode) << CCU4_CC4_TC_ENDM_Pos;
 802787e:	78bb      	ldrb	r3, [r7, #2]
 8027880:	021b      	lsls	r3, r3, #8
 8027882:	68ba      	ldr	r2, [r7, #8]
 8027884:	4313      	orrs	r3, r2
 8027886:	60bb      	str	r3, [r7, #8]

  slice->TC = tc;
 8027888:	687b      	ldr	r3, [r7, #4]
 802788a:	68ba      	ldr	r2, [r7, #8]
 802788c:	615a      	str	r2, [r3, #20]
}
 802788e:	bf00      	nop
 8027890:	3714      	adds	r7, #20
 8027892:	46bd      	mov	sp, r7
 8027894:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027898:	4770      	bx	lr

0802789a <XMC_CCU4_SLICE_LoadConfig>:

/* API to configure the Load trigger function of a slice */
void XMC_CCU4_SLICE_LoadConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 802789a:	b480      	push	{r7}
 802789c:	b085      	sub	sp, #20
 802789e:	af00      	add	r7, sp, #0
 80278a0:	6078      	str	r0, [r7, #4]
 80278a2:	460b      	mov	r3, r1
 80278a4:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_LoadConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_LoadConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the load function */
  cmc = slice->CMC;
 80278a6:	687b      	ldr	r3, [r7, #4]
 80278a8:	685b      	ldr	r3, [r3, #4]
 80278aa:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_LDS_Msk);
 80278ac:	68fb      	ldr	r3, [r7, #12]
 80278ae:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80278b2:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_LDS_Pos;
 80278b4:	78fb      	ldrb	r3, [r7, #3]
 80278b6:	031b      	lsls	r3, r3, #12
 80278b8:	68fa      	ldr	r2, [r7, #12]
 80278ba:	4313      	orrs	r3, r2
 80278bc:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 80278be:	687b      	ldr	r3, [r7, #4]
 80278c0:	68fa      	ldr	r2, [r7, #12]
 80278c2:	605a      	str	r2, [r3, #4]
}
 80278c4:	bf00      	nop
 80278c6:	3714      	adds	r7, #20
 80278c8:	46bd      	mov	sp, r7
 80278ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278ce:	4770      	bx	lr

080278d0 <XMC_CCU4_SLICE_ModulationConfig>:
/* API to configure the slice modulation function */
void XMC_CCU4_SLICE_ModulationConfig(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_EVENT_t event,
                                     const XMC_CCU4_SLICE_MODULATION_MODE_t mod_mode,
                                     const bool synch_with_pwm)
{
 80278d0:	b480      	push	{r7}
 80278d2:	b085      	sub	sp, #20
 80278d4:	af00      	add	r7, sp, #0
 80278d6:	6078      	str	r0, [r7, #4]
 80278d8:	4608      	mov	r0, r1
 80278da:	4611      	mov	r1, r2
 80278dc:	461a      	mov	r2, r3
 80278de:	4603      	mov	r3, r0
 80278e0:	70fb      	strb	r3, [r7, #3]
 80278e2:	460b      	mov	r3, r1
 80278e4:	70bb      	strb	r3, [r7, #2]
 80278e6:	4613      	mov	r3, r2
 80278e8:	707b      	strb	r3, [r7, #1]
  XMC_ASSERT("XMC_CCU4_SLICE_ModulationConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_ModulationConfig:Invalid Modulation Mode",
             ((mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT) || \
              (mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_ST_OUT)));

  tc  = slice->TC;
 80278ea:	687b      	ldr	r3, [r7, #4]
 80278ec:	695b      	ldr	r3, [r3, #20]
 80278ee:	60fb      	str	r3, [r7, #12]
  cmc = slice->CMC;
 80278f0:	687b      	ldr	r3, [r7, #4]
 80278f2:	685b      	ldr	r3, [r3, #4]
 80278f4:	60bb      	str	r3, [r7, #8]

  /* First, Bind the event with the modulation function */
  cmc &= ~((uint32_t) CCU4_CC4_CMC_MOS_Msk);
 80278f6:	68bb      	ldr	r3, [r7, #8]
 80278f8:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 80278fc:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_MOS_Pos;
 80278fe:	78fb      	ldrb	r3, [r7, #3]
 8027900:	049b      	lsls	r3, r3, #18
 8027902:	68ba      	ldr	r2, [r7, #8]
 8027904:	4313      	orrs	r3, r2
 8027906:	60bb      	str	r3, [r7, #8]
  slice->CMC = cmc;
 8027908:	687b      	ldr	r3, [r7, #4]
 802790a:	68ba      	ldr	r2, [r7, #8]
 802790c:	605a      	str	r2, [r3, #4]

  /* Next, Modulation mode */
  if (mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT)
 802790e:	78bb      	ldrb	r3, [r7, #2]
 8027910:	2b01      	cmp	r3, #1
 8027912:	d104      	bne.n	802791e <XMC_CCU4_SLICE_ModulationConfig+0x4e>
  {
    tc |= (uint32_t) CCU4_CC4_TC_EMT_Msk;
 8027914:	68fb      	ldr	r3, [r7, #12]
 8027916:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802791a:	60fb      	str	r3, [r7, #12]
 802791c:	e003      	b.n	8027926 <XMC_CCU4_SLICE_ModulationConfig+0x56>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_EMT_Msk);
 802791e:	68fb      	ldr	r3, [r7, #12]
 8027920:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8027924:	60fb      	str	r3, [r7, #12]
  }

  /* Synchronization of modulation effect with PWM cycle */
  if (synch_with_pwm == (bool) true)
 8027926:	787b      	ldrb	r3, [r7, #1]
 8027928:	2b00      	cmp	r3, #0
 802792a:	d004      	beq.n	8027936 <XMC_CCU4_SLICE_ModulationConfig+0x66>
  {
    tc |= (uint32_t) CCU4_CC4_TC_EMS_Msk;
 802792c:	68fb      	ldr	r3, [r7, #12]
 802792e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8027932:	60fb      	str	r3, [r7, #12]
 8027934:	e003      	b.n	802793e <XMC_CCU4_SLICE_ModulationConfig+0x6e>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_EMS_Msk);
 8027936:	68fb      	ldr	r3, [r7, #12]
 8027938:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 802793c:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 802793e:	687b      	ldr	r3, [r7, #4]
 8027940:	68fa      	ldr	r2, [r7, #12]
 8027942:	615a      	str	r2, [r3, #20]
}
 8027944:	bf00      	nop
 8027946:	3714      	adds	r7, #20
 8027948:	46bd      	mov	sp, r7
 802794a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802794e:	4770      	bx	lr

08027950 <XMC_CCU4_SLICE_CountConfig>:

/* API to configure the slice count function */
void XMC_CCU4_SLICE_CountConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8027950:	b480      	push	{r7}
 8027952:	b085      	sub	sp, #20
 8027954:	af00      	add	r7, sp, #0
 8027956:	6078      	str	r0, [r7, #4]
 8027958:	460b      	mov	r3, r1
 802795a:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_CountConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CountConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the count function */
  cmc = slice->CMC;
 802795c:	687b      	ldr	r3, [r7, #4]
 802795e:	685b      	ldr	r3, [r3, #4]
 8027960:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_CNTS_Msk);
 8027962:	68fb      	ldr	r3, [r7, #12]
 8027964:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8027968:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_CNTS_Pos;
 802796a:	78fb      	ldrb	r3, [r7, #3]
 802796c:	039b      	lsls	r3, r3, #14
 802796e:	68fa      	ldr	r2, [r7, #12]
 8027970:	4313      	orrs	r3, r2
 8027972:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027974:	687b      	ldr	r3, [r7, #4]
 8027976:	68fa      	ldr	r2, [r7, #12]
 8027978:	605a      	str	r2, [r3, #4]
}
 802797a:	bf00      	nop
 802797c:	3714      	adds	r7, #20
 802797e:	46bd      	mov	sp, r7
 8027980:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027984:	4770      	bx	lr

08027986 <XMC_CCU4_SLICE_GateConfig>:

/* API to configure slice gate function */
void XMC_CCU4_SLICE_GateConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8027986:	b480      	push	{r7}
 8027988:	b085      	sub	sp, #20
 802798a:	af00      	add	r7, sp, #0
 802798c:	6078      	str	r0, [r7, #4]
 802798e:	460b      	mov	r3, r1
 8027990:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_GateConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GateConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the gate function */
  cmc = slice->CMC;
 8027992:	687b      	ldr	r3, [r7, #4]
 8027994:	685b      	ldr	r3, [r3, #4]
 8027996:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_GATES_Msk);
 8027998:	68fb      	ldr	r3, [r7, #12]
 802799a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802799e:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_GATES_Pos;
 80279a0:	78fb      	ldrb	r3, [r7, #3]
 80279a2:	021b      	lsls	r3, r3, #8
 80279a4:	68fa      	ldr	r2, [r7, #12]
 80279a6:	4313      	orrs	r3, r2
 80279a8:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 80279aa:	687b      	ldr	r3, [r7, #4]
 80279ac:	68fa      	ldr	r2, [r7, #12]
 80279ae:	605a      	str	r2, [r3, #4]
}
 80279b0:	bf00      	nop
 80279b2:	3714      	adds	r7, #20
 80279b4:	46bd      	mov	sp, r7
 80279b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279ba:	4770      	bx	lr

080279bc <XMC_CCU4_SLICE_Capture1Config>:
  slice->CMC = cmc;
}

/* API to configure Capture-1 function */
void XMC_CCU4_SLICE_Capture1Config(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 80279bc:	b480      	push	{r7}
 80279be:	b085      	sub	sp, #20
 80279c0:	af00      	add	r7, sp, #0
 80279c2:	6078      	str	r0, [r7, #4]
 80279c4:	460b      	mov	r3, r1
 80279c6:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_Capture1Config:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_Capture1Config:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the gate function */
  cmc = slice->CMC;
 80279c8:	687b      	ldr	r3, [r7, #4]
 80279ca:	685b      	ldr	r3, [r3, #4]
 80279cc:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_CAP1S_Msk);
 80279ce:	68fb      	ldr	r3, [r7, #12]
 80279d0:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80279d4:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_CAP1S_Pos;
 80279d6:	78fb      	ldrb	r3, [r7, #3]
 80279d8:	019b      	lsls	r3, r3, #6
 80279da:	68fa      	ldr	r2, [r7, #12]
 80279dc:	4313      	orrs	r3, r2
 80279de:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 80279e0:	687b      	ldr	r3, [r7, #4]
 80279e2:	68fa      	ldr	r2, [r7, #12]
 80279e4:	605a      	str	r2, [r3, #4]
}
 80279e6:	bf00      	nop
 80279e8:	3714      	adds	r7, #20
 80279ea:	46bd      	mov	sp, r7
 80279ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80279f0:	4770      	bx	lr

080279f2 <XMC_CCU4_SLICE_DirectionConfig>:

/* API to configure direction function */
void XMC_CCU4_SLICE_DirectionConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 80279f2:	b480      	push	{r7}
 80279f4:	b085      	sub	sp, #20
 80279f6:	af00      	add	r7, sp, #0
 80279f8:	6078      	str	r0, [r7, #4]
 80279fa:	460b      	mov	r3, r1
 80279fc:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_DirectionConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_DirectionConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the direction function */
  cmc = slice->CMC;
 80279fe:	687b      	ldr	r3, [r7, #4]
 8027a00:	685b      	ldr	r3, [r3, #4]
 8027a02:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_UDS_Msk);
 8027a04:	68fb      	ldr	r3, [r7, #12]
 8027a06:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8027a0a:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_UDS_Pos;
 8027a0c:	78fb      	ldrb	r3, [r7, #3]
 8027a0e:	029b      	lsls	r3, r3, #10
 8027a10:	68fa      	ldr	r2, [r7, #12]
 8027a12:	4313      	orrs	r3, r2
 8027a14:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027a16:	687b      	ldr	r3, [r7, #4]
 8027a18:	68fa      	ldr	r2, [r7, #12]
 8027a1a:	605a      	str	r2, [r3, #4]
}
 8027a1c:	bf00      	nop
 8027a1e:	3714      	adds	r7, #20
 8027a20:	46bd      	mov	sp, r7
 8027a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027a26:	4770      	bx	lr

08027a28 <XMC_CCU4_SLICE_StatusBitOverrideConfig>:

/* API to configure slice status bit override function */
void XMC_CCU4_SLICE_StatusBitOverrideConfig(XMC_CCU4_SLICE_t *const slice)
{
 8027a28:	b480      	push	{r7}
 8027a2a:	b085      	sub	sp, #20
 8027a2c:	af00      	add	r7, sp, #0
 8027a2e:	6078      	str	r0, [r7, #4]
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU4_SLICE_StatusBitOverrideConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  /* Bind the event with the override function */
  cmc = slice->CMC;
 8027a30:	687b      	ldr	r3, [r7, #4]
 8027a32:	685b      	ldr	r3, [r3, #4]
 8027a34:	60fb      	str	r3, [r7, #12]
  /* Map status bit trigger override to Event 1 &
         status bit value override to Event 2 */
  cmc &= ~((uint32_t) CCU4_CC4_CMC_OFS_Msk);
 8027a36:	68fb      	ldr	r3, [r7, #12]
 8027a38:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8027a3c:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) 1) << CCU4_CC4_CMC_OFS_Pos;
 8027a3e:	68fb      	ldr	r3, [r7, #12]
 8027a40:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8027a44:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027a46:	687b      	ldr	r3, [r7, #4]
 8027a48:	68fa      	ldr	r2, [r7, #12]
 8027a4a:	605a      	str	r2, [r3, #4]
}
 8027a4c:	bf00      	nop
 8027a4e:	3714      	adds	r7, #20
 8027a50:	46bd      	mov	sp, r7
 8027a52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027a56:	4770      	bx	lr

08027a58 <XMC_CCU4_SLICE_TrapConfig>:

/* API to configure trap function */
void XMC_CCU4_SLICE_TrapConfig(XMC_CCU4_SLICE_t *const slice,
                               const XMC_CCU4_SLICE_TRAP_EXIT_MODE_t exit_mode,
                               const bool synch_with_pwm)
{
 8027a58:	b480      	push	{r7}
 8027a5a:	b085      	sub	sp, #20
 8027a5c:	af00      	add	r7, sp, #0
 8027a5e:	6078      	str	r0, [r7, #4]
 8027a60:	460b      	mov	r3, r1
 8027a62:	70fb      	strb	r3, [r7, #3]
 8027a64:	4613      	mov	r3, r2
 8027a66:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_TrapConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_TrapConfig:Invalid Exit Mode", ((exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC) || \
             (exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW)));

  /* First, Map trap function to Event 2 */
  cmc = slice->CMC;
 8027a68:	687b      	ldr	r3, [r7, #4]
 8027a6a:	685b      	ldr	r3, [r3, #4]
 8027a6c:	60bb      	str	r3, [r7, #8]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_TS_Msk);
 8027a6e:	68bb      	ldr	r3, [r7, #8]
 8027a70:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8027a74:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) 1) << CCU4_CC4_CMC_TS_Pos;
 8027a76:	68bb      	ldr	r3, [r7, #8]
 8027a78:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8027a7c:	60bb      	str	r3, [r7, #8]
  slice->CMC = cmc;
 8027a7e:	687b      	ldr	r3, [r7, #4]
 8027a80:	68ba      	ldr	r2, [r7, #8]
 8027a82:	605a      	str	r2, [r3, #4]

  /* Next, Configure synchronization option */
  tc = slice->TC;
 8027a84:	687b      	ldr	r3, [r7, #4]
 8027a86:	695b      	ldr	r3, [r3, #20]
 8027a88:	60fb      	str	r3, [r7, #12]

  if (synch_with_pwm == (bool) true)
 8027a8a:	78bb      	ldrb	r3, [r7, #2]
 8027a8c:	2b00      	cmp	r3, #0
 8027a8e:	d004      	beq.n	8027a9a <XMC_CCU4_SLICE_TrapConfig+0x42>
  {
    tc |= (uint32_t) CCU4_CC4_TC_TRPSE_Msk;
 8027a90:	68fb      	ldr	r3, [r7, #12]
 8027a92:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8027a96:	60fb      	str	r3, [r7, #12]
 8027a98:	e003      	b.n	8027aa2 <XMC_CCU4_SLICE_TrapConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_TRPSE_Msk);
 8027a9a:	68fb      	ldr	r3, [r7, #12]
 8027a9c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8027aa0:	60fb      	str	r3, [r7, #12]
  }

  /* Configure exit mode */
  if (exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW)
 8027aa2:	78fb      	ldrb	r3, [r7, #3]
 8027aa4:	2b01      	cmp	r3, #1
 8027aa6:	d104      	bne.n	8027ab2 <XMC_CCU4_SLICE_TrapConfig+0x5a>
  {
    tc |= (uint32_t) CCU4_CC4_TC_TRPSW_Msk;
 8027aa8:	68fb      	ldr	r3, [r7, #12]
 8027aaa:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8027aae:	60fb      	str	r3, [r7, #12]
 8027ab0:	e003      	b.n	8027aba <XMC_CCU4_SLICE_TrapConfig+0x62>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_TRPSW_Msk);
 8027ab2:	68fb      	ldr	r3, [r7, #12]
 8027ab4:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8027ab8:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8027aba:	687b      	ldr	r3, [r7, #4]
 8027abc:	68fa      	ldr	r2, [r7, #12]
 8027abe:	615a      	str	r2, [r3, #20]
}
 8027ac0:	bf00      	nop
 8027ac2:	3714      	adds	r7, #20
 8027ac4:	46bd      	mov	sp, r7
 8027ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027aca:	4770      	bx	lr

08027acc <XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent>:

/* API to configure a slice Status Bit Override event */
void XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev1_config,
    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev2_config)
{
 8027acc:	b480      	push	{r7}
 8027ace:	b087      	sub	sp, #28
 8027ad0:	af00      	add	r7, sp, #0
 8027ad2:	60f8      	str	r0, [r7, #12]
 8027ad4:	60b9      	str	r1, [r7, #8]
 8027ad6:	607a      	str	r2, [r7, #4]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS1_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU4_CC4_INS1_EV2IS_Pos;

  slice->INS1 = ins;
#else
  ins = slice->INS;
 8027ad8:	68fb      	ldr	r3, [r7, #12]
 8027ada:	681b      	ldr	r3, [r3, #0]
 8027adc:	617b      	str	r3, [r7, #20]

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU4_CC4_INS_EV1EM_Pos);
 8027ade:	697b      	ldr	r3, [r7, #20]
 8027ae0:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8027ae4:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->edge) << CCU4_CC4_INS_EV1EM_Pos;
 8027ae6:	68bb      	ldr	r3, [r7, #8]
 8027ae8:	785b      	ldrb	r3, [r3, #1]
 8027aea:	049b      	lsls	r3, r3, #18
 8027aec:	697a      	ldr	r2, [r7, #20]
 8027aee:	4313      	orrs	r3, r2
 8027af0:	617b      	str	r3, [r7, #20]

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU4_CC4_INS_EV2EM_Pos);
 8027af2:	697b      	ldr	r3, [r7, #20]
 8027af4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8027af8:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->edge) << CCU4_CC4_INS_EV2EM_Pos;
 8027afa:	687b      	ldr	r3, [r7, #4]
 8027afc:	785b      	ldrb	r3, [r3, #1]
 8027afe:	051b      	lsls	r3, r3, #20
 8027b00:	697a      	ldr	r2, [r7, #20]
 8027b02:	4313      	orrs	r3, r2
 8027b04:	617b      	str	r3, [r7, #20]

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU4_CC4_INS_EV1LM_Pos);
 8027b06:	697b      	ldr	r3, [r7, #20]
 8027b08:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8027b0c:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->level) << CCU4_CC4_INS_EV1LM_Pos;
 8027b0e:	68bb      	ldr	r3, [r7, #8]
 8027b10:	789b      	ldrb	r3, [r3, #2]
 8027b12:	05db      	lsls	r3, r3, #23
 8027b14:	697a      	ldr	r2, [r7, #20]
 8027b16:	4313      	orrs	r3, r2
 8027b18:	617b      	str	r3, [r7, #20]

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU4_CC4_INS_EV2LM_Pos);
 8027b1a:	697b      	ldr	r3, [r7, #20]
 8027b1c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8027b20:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->level) << CCU4_CC4_INS_EV2LM_Pos;
 8027b22:	687b      	ldr	r3, [r7, #4]
 8027b24:	789b      	ldrb	r3, [r3, #2]
 8027b26:	061b      	lsls	r3, r3, #24
 8027b28:	697a      	ldr	r2, [r7, #20]
 8027b2a:	4313      	orrs	r3, r2
 8027b2c:	617b      	str	r3, [r7, #20]

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU4_CC4_INS_LPF1M_Pos);
 8027b2e:	697b      	ldr	r3, [r7, #20]
 8027b30:	f023 53c0 	bic.w	r3, r3, #402653184	; 0x18000000
 8027b34:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->duration) << CCU4_CC4_INS_LPF1M_Pos;
 8027b36:	68bb      	ldr	r3, [r7, #8]
 8027b38:	78db      	ldrb	r3, [r3, #3]
 8027b3a:	06db      	lsls	r3, r3, #27
 8027b3c:	697a      	ldr	r2, [r7, #20]
 8027b3e:	4313      	orrs	r3, r2
 8027b40:	617b      	str	r3, [r7, #20]

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU4_CC4_INS_LPF2M_Pos);
 8027b42:	697b      	ldr	r3, [r7, #20]
 8027b44:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8027b48:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->duration) << CCU4_CC4_INS_LPF2M_Pos;
 8027b4a:	687b      	ldr	r3, [r7, #4]
 8027b4c:	78db      	ldrb	r3, [r3, #3]
 8027b4e:	075b      	lsls	r3, r3, #29
 8027b50:	697a      	ldr	r2, [r7, #20]
 8027b52:	4313      	orrs	r3, r2
 8027b54:	617b      	str	r3, [r7, #20]

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS_EV1IS_Pos);
 8027b56:	697b      	ldr	r3, [r7, #20]
 8027b58:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8027b5c:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU4_CC4_INS_EV1IS_Pos;
 8027b5e:	68bb      	ldr	r3, [r7, #8]
 8027b60:	781b      	ldrb	r3, [r3, #0]
 8027b62:	011b      	lsls	r3, r3, #4
 8027b64:	697a      	ldr	r2, [r7, #20]
 8027b66:	4313      	orrs	r3, r2
 8027b68:	617b      	str	r3, [r7, #20]

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS_EV2IS_Pos);
 8027b6a:	697b      	ldr	r3, [r7, #20]
 8027b6c:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8027b70:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU4_CC4_INS_EV2IS_Pos;
 8027b72:	687b      	ldr	r3, [r7, #4]
 8027b74:	781b      	ldrb	r3, [r3, #0]
 8027b76:	021b      	lsls	r3, r3, #8
 8027b78:	697a      	ldr	r2, [r7, #20]
 8027b7a:	4313      	orrs	r3, r2
 8027b7c:	617b      	str	r3, [r7, #20]

  slice->INS = ins;
 8027b7e:	68fb      	ldr	r3, [r7, #12]
 8027b80:	697a      	ldr	r2, [r7, #20]
 8027b82:	601a      	str	r2, [r3, #0]
#endif
}
 8027b84:	bf00      	nop
 8027b86:	371c      	adds	r7, #28
 8027b88:	46bd      	mov	sp, r7
 8027b8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027b8e:	4770      	bx	lr

08027b90 <XMC_CCU4_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU4_SLICE_ConfigureEvent(XMC_CCU4_SLICE_t *const slice,
                                   const XMC_CCU4_SLICE_EVENT_t event,
                                   const XMC_CCU4_SLICE_EVENT_CONFIG_t *const config)
{
 8027b90:	b480      	push	{r7}
 8027b92:	b089      	sub	sp, #36	; 0x24
 8027b94:	af00      	add	r7, sp, #0
 8027b96:	60f8      	str	r0, [r7, #12]
 8027b98:	460b      	mov	r3, r1
 8027b9a:	607a      	str	r2, [r7, #4]
 8027b9c:	72fb      	strb	r3, [r7, #11]
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) || \
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8027b9e:	7afb      	ldrb	r3, [r7, #11]
 8027ba0:	3b01      	subs	r3, #1
 8027ba2:	77fb      	strb	r3, [r7, #31]
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8027ba4:	68fb      	ldr	r3, [r7, #12]
 8027ba6:	681b      	ldr	r3, [r3, #0]
 8027ba8:	61bb      	str	r3, [r7, #24]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8027baa:	7ffb      	ldrb	r3, [r7, #31]
 8027bac:	005b      	lsls	r3, r3, #1
 8027bae:	b2db      	uxtb	r3, r3
 8027bb0:	3310      	adds	r3, #16
 8027bb2:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8027bb4:	7dfb      	ldrb	r3, [r7, #23]
 8027bb6:	2203      	movs	r2, #3
 8027bb8:	fa02 f303 	lsl.w	r3, r2, r3
 8027bbc:	43db      	mvns	r3, r3
 8027bbe:	69ba      	ldr	r2, [r7, #24]
 8027bc0:	4013      	ands	r3, r2
 8027bc2:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->edge) << pos;
 8027bc4:	687b      	ldr	r3, [r7, #4]
 8027bc6:	785b      	ldrb	r3, [r3, #1]
 8027bc8:	461a      	mov	r2, r3
 8027bca:	7dfb      	ldrb	r3, [r7, #23]
 8027bcc:	fa02 f303 	lsl.w	r3, r2, r3
 8027bd0:	69ba      	ldr	r2, [r7, #24]
 8027bd2:	4313      	orrs	r3, r2
 8027bd4:	61bb      	str	r3, [r7, #24]

  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
 8027bd6:	7ffb      	ldrb	r3, [r7, #31]
 8027bd8:	3316      	adds	r3, #22
 8027bda:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8027bdc:	7dfb      	ldrb	r3, [r7, #23]
 8027bde:	2201      	movs	r2, #1
 8027be0:	fa02 f303 	lsl.w	r3, r2, r3
 8027be4:	43db      	mvns	r3, r3
 8027be6:	69ba      	ldr	r2, [r7, #24]
 8027be8:	4013      	ands	r3, r2
 8027bea:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->level) << pos;
 8027bec:	687b      	ldr	r3, [r7, #4]
 8027bee:	789b      	ldrb	r3, [r3, #2]
 8027bf0:	461a      	mov	r2, r3
 8027bf2:	7dfb      	ldrb	r3, [r7, #23]
 8027bf4:	fa02 f303 	lsl.w	r3, r2, r3
 8027bf8:	69ba      	ldr	r2, [r7, #24]
 8027bfa:	4313      	orrs	r3, r2
 8027bfc:	61bb      	str	r3, [r7, #24]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8027bfe:	7ffb      	ldrb	r3, [r7, #31]
 8027c00:	005b      	lsls	r3, r3, #1
 8027c02:	b2db      	uxtb	r3, r3
 8027c04:	3319      	adds	r3, #25
 8027c06:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8027c08:	7dfb      	ldrb	r3, [r7, #23]
 8027c0a:	2203      	movs	r2, #3
 8027c0c:	fa02 f303 	lsl.w	r3, r2, r3
 8027c10:	43db      	mvns	r3, r3
 8027c12:	69ba      	ldr	r2, [r7, #24]
 8027c14:	4013      	ands	r3, r2
 8027c16:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->duration) << pos;
 8027c18:	687b      	ldr	r3, [r7, #4]
 8027c1a:	78db      	ldrb	r3, [r3, #3]
 8027c1c:	461a      	mov	r2, r3
 8027c1e:	7dfb      	ldrb	r3, [r7, #23]
 8027c20:	fa02 f303 	lsl.w	r3, r2, r3
 8027c24:	69ba      	ldr	r2, [r7, #24]
 8027c26:	4313      	orrs	r3, r2
 8027c28:	61bb      	str	r3, [r7, #24]

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 8027c2a:	7ffb      	ldrb	r3, [r7, #31]
 8027c2c:	009b      	lsls	r3, r3, #2
 8027c2e:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8027c30:	7dfb      	ldrb	r3, [r7, #23]
 8027c32:	220f      	movs	r2, #15
 8027c34:	fa02 f303 	lsl.w	r3, r2, r3
 8027c38:	43db      	mvns	r3, r3
 8027c3a:	69ba      	ldr	r2, [r7, #24]
 8027c3c:	4013      	ands	r3, r2
 8027c3e:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->mapped_input) << pos;
 8027c40:	687b      	ldr	r3, [r7, #4]
 8027c42:	781b      	ldrb	r3, [r3, #0]
 8027c44:	461a      	mov	r2, r3
 8027c46:	7dfb      	ldrb	r3, [r7, #23]
 8027c48:	fa02 f303 	lsl.w	r3, r2, r3
 8027c4c:	69ba      	ldr	r2, [r7, #24]
 8027c4e:	4313      	orrs	r3, r2
 8027c50:	61bb      	str	r3, [r7, #24]

  slice->INS = ins;
 8027c52:	68fb      	ldr	r3, [r7, #12]
 8027c54:	69ba      	ldr	r2, [r7, #24]
 8027c56:	601a      	str	r2, [r3, #0]
#endif
}
 8027c58:	bf00      	nop
 8027c5a:	3724      	adds	r7, #36	; 0x24
 8027c5c:	46bd      	mov	sp, r7
 8027c5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027c62:	4770      	bx	lr

08027c64 <XMC_CCU4_SLICE_GetCaptureRegisterValue>:
  }
}

/* Retrieves desired capture register value */
uint32_t XMC_CCU4_SLICE_GetCaptureRegisterValue(const XMC_CCU4_SLICE_t *const slice, const uint8_t reg_num)
{
 8027c64:	b480      	push	{r7}
 8027c66:	b083      	sub	sp, #12
 8027c68:	af00      	add	r7, sp, #0
 8027c6a:	6078      	str	r0, [r7, #4]
 8027c6c:	460b      	mov	r3, r1
 8027c6e:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_GetCaptureRegisterValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetCaptureRegisterValue:Invalid register number", (reg_num < 4U));
  return (slice->CV[reg_num]);
 8027c70:	78fb      	ldrb	r3, [r7, #3]
 8027c72:	687a      	ldr	r2, [r7, #4]
 8027c74:	331c      	adds	r3, #28
 8027c76:	009b      	lsls	r3, r3, #2
 8027c78:	4413      	add	r3, r2
 8027c7a:	685b      	ldr	r3, [r3, #4]
}
 8027c7c:	4618      	mov	r0, r3
 8027c7e:	370c      	adds	r7, #12
 8027c80:	46bd      	mov	sp, r7
 8027c82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027c86:	4770      	bx	lr

08027c88 <XMC_CCU4_SLICE_SetPrescaler>:
  XMC_CCU4_SLICE_SetDitherCompareValue((XMC_CCU4_SLICE_t *)slice, (uint8_t)spread);
}

/* Programs Pre-scalar divider  */
void XMC_CCU4_SLICE_SetPrescaler(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_PRESCALER_t div_val)
{
 8027c88:	b480      	push	{r7}
 8027c8a:	b085      	sub	sp, #20
 8027c8c:	af00      	add	r7, sp, #0
 8027c8e:	6078      	str	r0, [r7, #4]
 8027c90:	460b      	mov	r3, r1
 8027c92:	70fb      	strb	r3, [r7, #3]
  uint32_t fpc;

  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 8027c94:	687b      	ldr	r3, [r7, #4]
 8027c96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8027c98:	60fb      	str	r3, [r7, #12]
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 8027c9a:	68fb      	ldr	r3, [r7, #12]
 8027c9c:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8027ca0:	60fb      	str	r3, [r7, #12]
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 8027ca2:	78fb      	ldrb	r3, [r7, #3]
 8027ca4:	021b      	lsls	r3, r3, #8
 8027ca6:	68fa      	ldr	r2, [r7, #12]
 8027ca8:	4313      	orrs	r3, r2
 8027caa:	60fb      	str	r3, [r7, #12]
  slice->FPC = fpc;
 8027cac:	687b      	ldr	r3, [r7, #4]
 8027cae:	68fa      	ldr	r2, [r7, #12]
 8027cb0:	629a      	str	r2, [r3, #40]	; 0x28
  /*
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8027cb2:	78fa      	ldrb	r2, [r7, #3]
 8027cb4:	687b      	ldr	r3, [r7, #4]
 8027cb6:	625a      	str	r2, [r3, #36]	; 0x24
}
 8027cb8:	bf00      	nop
 8027cba:	3714      	adds	r7, #20
 8027cbc:	46bd      	mov	sp, r7
 8027cbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027cc2:	4770      	bx	lr

08027cc4 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 8027cc4:	b480      	push	{r7}
 8027cc6:	b087      	sub	sp, #28
 8027cc8:	af00      	add	r7, sp, #0
 8027cca:	6078      	str	r0, [r7, #4]
 8027ccc:	460b      	mov	r3, r1
 8027cce:	70fb      	strb	r3, [r7, #3]
 8027cd0:	4613      	mov	r3, r2
 8027cd2:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 8027cd4:	78fb      	ldrb	r3, [r7, #3]
 8027cd6:	2b0b      	cmp	r3, #11
 8027cd8:	d836      	bhi.n	8027d48 <XMC_CCU4_SLICE_SetInterruptNode+0x84>
 8027cda:	a201      	add	r2, pc, #4	; (adr r2, 8027ce0 <XMC_CCU4_SLICE_SetInterruptNode+0x1c>)
 8027cdc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8027ce0:	08027d11 	.word	0x08027d11
 8027ce4:	08027d11 	.word	0x08027d11
 8027ce8:	08027d1b 	.word	0x08027d1b
 8027cec:	08027d1b 	.word	0x08027d1b
 8027cf0:	08027d49 	.word	0x08027d49
 8027cf4:	08027d49 	.word	0x08027d49
 8027cf8:	08027d49 	.word	0x08027d49
 8027cfc:	08027d49 	.word	0x08027d49
 8027d00:	08027d25 	.word	0x08027d25
 8027d04:	08027d31 	.word	0x08027d31
 8027d08:	08027d3d 	.word	0x08027d3d
 8027d0c:	08027d3d 	.word	0x08027d3d
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
 8027d10:	2303      	movs	r3, #3
 8027d12:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
 8027d14:	2300      	movs	r3, #0
 8027d16:	617b      	str	r3, [r7, #20]
      break;
 8027d18:	e01b      	b.n	8027d52 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
 8027d1a:	230c      	movs	r3, #12
 8027d1c:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
 8027d1e:	2302      	movs	r3, #2
 8027d20:	617b      	str	r3, [r7, #20]
      break;
 8027d22:	e016      	b.n	8027d52 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
 8027d24:	f44f 7340 	mov.w	r3, #768	; 0x300
 8027d28:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
 8027d2a:	2308      	movs	r3, #8
 8027d2c:	617b      	str	r3, [r7, #20]
      break;
 8027d2e:	e010      	b.n	8027d52 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
 8027d30:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8027d34:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
 8027d36:	230a      	movs	r3, #10
 8027d38:	617b      	str	r3, [r7, #20]
      break;
 8027d3a:	e00a      	b.n	8027d52 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU4_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
 8027d3c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8027d40:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
 8027d42:	230c      	movs	r3, #12
 8027d44:	617b      	str	r3, [r7, #20]
      break;
 8027d46:	e004      	b.n	8027d52 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>
	  
	default:
	  mask = 0;
 8027d48:	2300      	movs	r3, #0
 8027d4a:	613b      	str	r3, [r7, #16]
	  pos = 0;
 8027d4c:	2300      	movs	r3, #0
 8027d4e:	617b      	str	r3, [r7, #20]
	  break;
 8027d50:	bf00      	nop
  }

  if (mask != 0)
 8027d52:	693b      	ldr	r3, [r7, #16]
 8027d54:	2b00      	cmp	r3, #0
 8027d56:	d013      	beq.n	8027d80 <XMC_CCU4_SLICE_SetInterruptNode+0xbc>
  {
    srs = slice->SRS;
 8027d58:	687b      	ldr	r3, [r7, #4]
 8027d5a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8027d5e:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 8027d60:	693b      	ldr	r3, [r7, #16]
 8027d62:	43db      	mvns	r3, r3
 8027d64:	68fa      	ldr	r2, [r7, #12]
 8027d66:	4013      	ands	r3, r2
 8027d68:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 8027d6a:	78ba      	ldrb	r2, [r7, #2]
 8027d6c:	697b      	ldr	r3, [r7, #20]
 8027d6e:	fa02 f303 	lsl.w	r3, r2, r3
 8027d72:	68fa      	ldr	r2, [r7, #12]
 8027d74:	4313      	orrs	r3, r2
 8027d76:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 8027d78:	687b      	ldr	r3, [r7, #4]
 8027d7a:	68fa      	ldr	r2, [r7, #12]
 8027d7c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 8027d80:	bf00      	nop
 8027d82:	371c      	adds	r7, #28
 8027d84:	46bd      	mov	sp, r7
 8027d86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027d8a:	4770      	bx	lr

08027d8c <XMC_CCU8_StartPrescaler>:
{
 8027d8c:	b480      	push	{r7}
 8027d8e:	b083      	sub	sp, #12
 8027d90:	af00      	add	r7, sp, #0
 8027d92:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8027d94:	687b      	ldr	r3, [r7, #4]
 8027d96:	f44f 7280 	mov.w	r2, #256	; 0x100
 8027d9a:	60da      	str	r2, [r3, #12]
}
 8027d9c:	bf00      	nop
 8027d9e:	370c      	adds	r7, #12
 8027da0:	46bd      	mov	sp, r7
 8027da2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027da6:	4770      	bx	lr

08027da8 <XMC_CCU8_SLICE_StopTimer>:
{
 8027da8:	b480      	push	{r7}
 8027daa:	b083      	sub	sp, #12
 8027dac:	af00      	add	r7, sp, #0
 8027dae:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8027db0:	687b      	ldr	r3, [r7, #4]
 8027db2:	2201      	movs	r2, #1
 8027db4:	611a      	str	r2, [r3, #16]
}
 8027db6:	bf00      	nop
 8027db8:	370c      	adds	r7, #12
 8027dba:	46bd      	mov	sp, r7
 8027dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027dc0:	4770      	bx	lr
	...

08027dc4 <XMC_CCU8_lDeassertReset>:
    XMC_ASSERT("XMC_CCU8_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
 8027dc4:	b580      	push	{r7, lr}
 8027dc6:	b082      	sub	sp, #8
 8027dc8:	af00      	add	r7, sp, #0
 8027dca:	6078      	str	r0, [r7, #4]
  if (module == CCU80)
 8027dcc:	687b      	ldr	r3, [r7, #4]
 8027dce:	4a09      	ldr	r2, [pc, #36]	; (8027df4 <XMC_CCU8_lDeassertReset+0x30>)
 8027dd0:	4293      	cmp	r3, r2
 8027dd2:	d103      	bne.n	8027ddc <XMC_CCU8_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 8027dd4:	2080      	movs	r0, #128	; 0x80
 8027dd6:	f7fe fce3 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU8_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 8027dda:	e007      	b.n	8027dec <XMC_CCU8_lDeassertReset+0x28>
  else if (module == CCU81)
 8027ddc:	687b      	ldr	r3, [r7, #4]
 8027dde:	4a06      	ldr	r2, [pc, #24]	; (8027df8 <XMC_CCU8_lDeassertReset+0x34>)
 8027de0:	4293      	cmp	r3, r2
 8027de2:	d103      	bne.n	8027dec <XMC_CCU8_lDeassertReset+0x28>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 8027de4:	f44f 7080 	mov.w	r0, #256	; 0x100
 8027de8:	f7fe fcda 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8027dec:	bf00      	nop
 8027dee:	3708      	adds	r7, #8
 8027df0:	46bd      	mov	sp, r7
 8027df2:	bd80      	pop	{r7, pc}
 8027df4:	40020000 	.word	0x40020000
 8027df8:	40024000 	.word	0x40024000

08027dfc <XMC_CCU8_EnableModule>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to set the CCU8 module as active and enable the clock  */
void XMC_CCU8_EnableModule(XMC_CCU8_MODULE_t *const module)
{
 8027dfc:	b580      	push	{r7, lr}
 8027dfe:	b082      	sub	sp, #8
 8027e00:	af00      	add	r7, sp, #0
 8027e02:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8027e04:	2010      	movs	r0, #16
 8027e06:	f7fe fe07 	bl	8026a18 <XMC_SCU_CLOCK_EnableClock>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU8_lUngateClock(module);
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU8_lDeassertReset(module);
 8027e0a:	6878      	ldr	r0, [r7, #4]
 8027e0c:	f7ff ffda 	bl	8027dc4 <XMC_CCU8_lDeassertReset>
#endif
}
 8027e10:	bf00      	nop
 8027e12:	3708      	adds	r7, #8
 8027e14:	46bd      	mov	sp, r7
 8027e16:	bd80      	pop	{r7, pc}

08027e18 <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8027e18:	b580      	push	{r7, lr}
 8027e1a:	b084      	sub	sp, #16
 8027e1c:	af00      	add	r7, sp, #0
 8027e1e:	6078      	str	r0, [r7, #4]
 8027e20:	460b      	mov	r3, r1
 8027e22:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU8_Init:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_Init:Invalid mcs action", XMC_CCU8_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
 8027e24:	6878      	ldr	r0, [r7, #4]
 8027e26:	f7ff ffe9 	bl	8027dfc <XMC_CCU8_EnableModule>
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
 8027e2a:	6878      	ldr	r0, [r7, #4]
 8027e2c:	f7ff ffae 	bl	8027d8c <XMC_CCU8_StartPrescaler>

  gctrl = module->GCTRL;
 8027e30:	687b      	ldr	r3, [r7, #4]
 8027e32:	681b      	ldr	r3, [r3, #0]
 8027e34:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 8027e36:	68fb      	ldr	r3, [r7, #12]
 8027e38:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8027e3c:	60fb      	str	r3, [r7, #12]
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 8027e3e:	78fb      	ldrb	r3, [r7, #3]
 8027e40:	039b      	lsls	r3, r3, #14
 8027e42:	68fa      	ldr	r2, [r7, #12]
 8027e44:	4313      	orrs	r3, r2
 8027e46:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 8027e48:	687b      	ldr	r3, [r7, #4]
 8027e4a:	68fa      	ldr	r2, [r7, #12]
 8027e4c:	601a      	str	r2, [r3, #0]
}
 8027e4e:	bf00      	nop
 8027e50:	3710      	adds	r7, #16
 8027e52:	46bd      	mov	sp, r7
 8027e54:	bd80      	pop	{r7, pc}

08027e56 <XMC_CCU8_SLICE_CompareInit>:
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8027e56:	b580      	push	{r7, lr}
 8027e58:	b082      	sub	sp, #8
 8027e5a:	af00      	add	r7, sp, #0
 8027e5c:	6078      	str	r0, [r7, #4]
 8027e5e:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
 8027e60:	6878      	ldr	r0, [r7, #4]
 8027e62:	f7ff ffa1 	bl	8027da8 <XMC_CCU8_SLICE_StopTimer>
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8027e66:	683b      	ldr	r3, [r7, #0]
 8027e68:	681a      	ldr	r2, [r3, #0]
 8027e6a:	687b      	ldr	r3, [r7, #4]
 8027e6c:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8027e6e:	683b      	ldr	r3, [r7, #0]
 8027e70:	7b5b      	ldrb	r3, [r3, #13]
 8027e72:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8027e76:	b2db      	uxtb	r3, r3
 8027e78:	051a      	lsls	r2, r3, #20
 8027e7a:	687b      	ldr	r3, [r7, #4]
 8027e7c:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8027e7e:	683b      	ldr	r3, [r7, #0]
 8027e80:	7b1b      	ldrb	r3, [r3, #12]
 8027e82:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027e86:	b2db      	uxtb	r3, r3
 8027e88:	461a      	mov	r2, r3
 8027e8a:	687b      	ldr	r3, [r7, #4]
 8027e8c:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8027e8e:	683b      	ldr	r3, [r7, #0]
 8027e90:	7b1b      	ldrb	r3, [r3, #12]
 8027e92:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8027e96:	b2db      	uxtb	r3, r3
 8027e98:	461a      	mov	r2, r3
 8027e9a:	687b      	ldr	r3, [r7, #4]
 8027e9c:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8027e9e:	683b      	ldr	r3, [r7, #0]
 8027ea0:	7b5b      	ldrb	r3, [r3, #13]
 8027ea2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027ea6:	b2db      	uxtb	r3, r3
 8027ea8:	461a      	mov	r2, r3
 8027eaa:	687b      	ldr	r3, [r7, #4]
 8027eac:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 8027eae:	683b      	ldr	r3, [r7, #0]
 8027eb0:	685a      	ldr	r2, [r3, #4]
 8027eb2:	687b      	ldr	r3, [r7, #4]
 8027eb4:	619a      	str	r2, [r3, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 8027eb6:	683b      	ldr	r3, [r7, #0]
 8027eb8:	689b      	ldr	r3, [r3, #8]
 8027eba:	f083 0214 	eor.w	r2, r3, #20
 8027ebe:	687b      	ldr	r3, [r7, #4]
 8027ec0:	649a      	str	r2, [r3, #72]	; 0x48
#endif
}
 8027ec2:	bf00      	nop
 8027ec4:	3708      	adds	r7, #8
 8027ec6:	46bd      	mov	sp, r7
 8027ec8:	bd80      	pop	{r7, pc}

08027eca <XMC_CCU8_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice*/
void XMC_CCU8_SLICE_StartConfig(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_EVENT_t event,
                                const XMC_CCU8_SLICE_START_MODE_t start_mode)
{
 8027eca:	b480      	push	{r7}
 8027ecc:	b085      	sub	sp, #20
 8027ece:	af00      	add	r7, sp, #0
 8027ed0:	6078      	str	r0, [r7, #4]
 8027ed2:	460b      	mov	r3, r1
 8027ed4:	70fb      	strb	r3, [r7, #3]
 8027ed6:	4613      	mov	r3, r2
 8027ed8:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode",
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) || \
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;
 8027eda:	687b      	ldr	r3, [r7, #4]
 8027edc:	685b      	ldr	r3, [r3, #4]
 8027ede:	60bb      	str	r3, [r7, #8]

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
 8027ee0:	68bb      	ldr	r3, [r7, #8]
 8027ee2:	f023 0303 	bic.w	r3, r3, #3
 8027ee6:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_STRTS_Pos;
 8027ee8:	78fb      	ldrb	r3, [r7, #3]
 8027eea:	68ba      	ldr	r2, [r7, #8]
 8027eec:	4313      	orrs	r3, r2
 8027eee:	60bb      	str	r3, [r7, #8]

  slice->CMC = cmc;
 8027ef0:	687b      	ldr	r3, [r7, #4]
 8027ef2:	68ba      	ldr	r2, [r7, #8]
 8027ef4:	605a      	str	r2, [r3, #4]

  tc  = slice->TC;
 8027ef6:	687b      	ldr	r3, [r7, #4]
 8027ef8:	695b      	ldr	r3, [r3, #20]
 8027efa:	60fb      	str	r3, [r7, #12]

  if (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
 8027efc:	78bb      	ldrb	r3, [r7, #2]
 8027efe:	2b01      	cmp	r3, #1
 8027f00:	d104      	bne.n	8027f0c <XMC_CCU8_SLICE_StartConfig+0x42>
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
 8027f02:	68fb      	ldr	r3, [r7, #12]
 8027f04:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8027f08:	60fb      	str	r3, [r7, #12]
 8027f0a:	e003      	b.n	8027f14 <XMC_CCU8_SLICE_StartConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_STRM_Msk);
 8027f0c:	68fb      	ldr	r3, [r7, #12]
 8027f0e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8027f12:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8027f14:	687b      	ldr	r3, [r7, #4]
 8027f16:	68fa      	ldr	r2, [r7, #12]
 8027f18:	615a      	str	r2, [r3, #20]
}
 8027f1a:	bf00      	nop
 8027f1c:	3714      	adds	r7, #20
 8027f1e:	46bd      	mov	sp, r7
 8027f20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027f24:	4770      	bx	lr

08027f26 <XMC_CCU8_SLICE_StopConfig>:

/* API to configure the Stop trigger function of a slice */
void XMC_CCU8_SLICE_StopConfig(XMC_CCU8_SLICE_t *const slice,
                               const XMC_CCU8_SLICE_EVENT_t event,
                               const XMC_CCU8_SLICE_END_MODE_t end_mode)
{
 8027f26:	b480      	push	{r7}
 8027f28:	b085      	sub	sp, #20
 8027f2a:	af00      	add	r7, sp, #0
 8027f2c:	6078      	str	r0, [r7, #4]
 8027f2e:	460b      	mov	r3, r1
 8027f30:	70fb      	strb	r3, [r7, #3]
 8027f32:	4613      	mov	r3, r2
 8027f34:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid End Mode", XMC_CCU8_SLICE_CHECK_END_MODE(end_mode));

  cmc = slice->CMC;
 8027f36:	687b      	ldr	r3, [r7, #4]
 8027f38:	685b      	ldr	r3, [r3, #4]
 8027f3a:	60fb      	str	r3, [r7, #12]
  /* First, Bind the event with the stop function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_ENDS_Msk);
 8027f3c:	68fb      	ldr	r3, [r7, #12]
 8027f3e:	f023 030c 	bic.w	r3, r3, #12
 8027f42:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_ENDS_Pos;
 8027f44:	78fb      	ldrb	r3, [r7, #3]
 8027f46:	009b      	lsls	r3, r3, #2
 8027f48:	68fa      	ldr	r2, [r7, #12]
 8027f4a:	4313      	orrs	r3, r2
 8027f4c:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8027f4e:	687b      	ldr	r3, [r7, #4]
 8027f50:	68fa      	ldr	r2, [r7, #12]
 8027f52:	605a      	str	r2, [r3, #4]

  /* Configure the stop mode */
  tc = slice->TC;
 8027f54:	687b      	ldr	r3, [r7, #4]
 8027f56:	695b      	ldr	r3, [r3, #20]
 8027f58:	60bb      	str	r3, [r7, #8]
  tc &= ~((uint32_t) CCU8_CC8_TC_ENDM_Msk);
 8027f5a:	68bb      	ldr	r3, [r7, #8]
 8027f5c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8027f60:	60bb      	str	r3, [r7, #8]
  tc |= ((uint32_t) end_mode) << CCU8_CC8_TC_ENDM_Pos;
 8027f62:	78bb      	ldrb	r3, [r7, #2]
 8027f64:	021b      	lsls	r3, r3, #8
 8027f66:	68ba      	ldr	r2, [r7, #8]
 8027f68:	4313      	orrs	r3, r2
 8027f6a:	60bb      	str	r3, [r7, #8]

  slice->TC = tc;
 8027f6c:	687b      	ldr	r3, [r7, #4]
 8027f6e:	68ba      	ldr	r2, [r7, #8]
 8027f70:	615a      	str	r2, [r3, #20]
}
 8027f72:	bf00      	nop
 8027f74:	3714      	adds	r7, #20
 8027f76:	46bd      	mov	sp, r7
 8027f78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027f7c:	4770      	bx	lr

08027f7e <XMC_CCU8_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
 8027f7e:	b480      	push	{r7}
 8027f80:	b089      	sub	sp, #36	; 0x24
 8027f82:	af00      	add	r7, sp, #0
 8027f84:	60f8      	str	r0, [r7, #12]
 8027f86:	460b      	mov	r3, r1
 8027f88:	607a      	str	r2, [r7, #4]
 8027f8a:	72fb      	strb	r3, [r7, #11]
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8027f8c:	7afb      	ldrb	r3, [r7, #11]
 8027f8e:	3b01      	subs	r3, #1
 8027f90:	77fb      	strb	r3, [r7, #31]
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8027f92:	68fb      	ldr	r3, [r7, #12]
 8027f94:	681b      	ldr	r3, [r3, #0]
 8027f96:	61bb      	str	r3, [r7, #24]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8027f98:	7ffb      	ldrb	r3, [r7, #31]
 8027f9a:	005b      	lsls	r3, r3, #1
 8027f9c:	b2db      	uxtb	r3, r3
 8027f9e:	3310      	adds	r3, #16
 8027fa0:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8027fa2:	7dfb      	ldrb	r3, [r7, #23]
 8027fa4:	2203      	movs	r2, #3
 8027fa6:	fa02 f303 	lsl.w	r3, r2, r3
 8027faa:	43db      	mvns	r3, r3
 8027fac:	69ba      	ldr	r2, [r7, #24]
 8027fae:	4013      	ands	r3, r2
 8027fb0:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->edge) << pos;
 8027fb2:	687b      	ldr	r3, [r7, #4]
 8027fb4:	785b      	ldrb	r3, [r3, #1]
 8027fb6:	461a      	mov	r2, r3
 8027fb8:	7dfb      	ldrb	r3, [r7, #23]
 8027fba:	fa02 f303 	lsl.w	r3, r2, r3
 8027fbe:	69ba      	ldr	r2, [r7, #24]
 8027fc0:	4313      	orrs	r3, r2
 8027fc2:	61bb      	str	r3, [r7, #24]

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
 8027fc4:	7ffb      	ldrb	r3, [r7, #31]
 8027fc6:	3316      	adds	r3, #22
 8027fc8:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8027fca:	7dfb      	ldrb	r3, [r7, #23]
 8027fcc:	2201      	movs	r2, #1
 8027fce:	fa02 f303 	lsl.w	r3, r2, r3
 8027fd2:	43db      	mvns	r3, r3
 8027fd4:	69ba      	ldr	r2, [r7, #24]
 8027fd6:	4013      	ands	r3, r2
 8027fd8:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) (config->level)) << pos;
 8027fda:	687b      	ldr	r3, [r7, #4]
 8027fdc:	789b      	ldrb	r3, [r3, #2]
 8027fde:	461a      	mov	r2, r3
 8027fe0:	7dfb      	ldrb	r3, [r7, #23]
 8027fe2:	fa02 f303 	lsl.w	r3, r2, r3
 8027fe6:	69ba      	ldr	r2, [r7, #24]
 8027fe8:	4313      	orrs	r3, r2
 8027fea:	61bb      	str	r3, [r7, #24]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8027fec:	7ffb      	ldrb	r3, [r7, #31]
 8027fee:	005b      	lsls	r3, r3, #1
 8027ff0:	b2db      	uxtb	r3, r3
 8027ff2:	3319      	adds	r3, #25
 8027ff4:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8027ff6:	7dfb      	ldrb	r3, [r7, #23]
 8027ff8:	2203      	movs	r2, #3
 8027ffa:	fa02 f303 	lsl.w	r3, r2, r3
 8027ffe:	43db      	mvns	r3, r3
 8028000:	69ba      	ldr	r2, [r7, #24]
 8028002:	4013      	ands	r3, r2
 8028004:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->duration) << pos;
 8028006:	687b      	ldr	r3, [r7, #4]
 8028008:	78db      	ldrb	r3, [r3, #3]
 802800a:	461a      	mov	r2, r3
 802800c:	7dfb      	ldrb	r3, [r7, #23]
 802800e:	fa02 f303 	lsl.w	r3, r2, r3
 8028012:	69ba      	ldr	r2, [r7, #24]
 8028014:	4313      	orrs	r3, r2
 8028016:	61bb      	str	r3, [r7, #24]

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 8028018:	7ffb      	ldrb	r3, [r7, #31]
 802801a:	009b      	lsls	r3, r3, #2
 802801c:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 802801e:	7dfb      	ldrb	r3, [r7, #23]
 8028020:	220f      	movs	r2, #15
 8028022:	fa02 f303 	lsl.w	r3, r2, r3
 8028026:	43db      	mvns	r3, r3
 8028028:	69ba      	ldr	r2, [r7, #24]
 802802a:	4013      	ands	r3, r2
 802802c:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->mapped_input) << pos;
 802802e:	687b      	ldr	r3, [r7, #4]
 8028030:	781b      	ldrb	r3, [r3, #0]
 8028032:	461a      	mov	r2, r3
 8028034:	7dfb      	ldrb	r3, [r7, #23]
 8028036:	fa02 f303 	lsl.w	r3, r2, r3
 802803a:	69ba      	ldr	r2, [r7, #24]
 802803c:	4313      	orrs	r3, r2
 802803e:	61bb      	str	r3, [r7, #24]

  slice->INS = ins;
 8028040:	68fb      	ldr	r3, [r7, #12]
 8028042:	69ba      	ldr	r2, [r7, #24]
 8028044:	601a      	str	r2, [r3, #0]
#endif
}
 8028046:	bf00      	nop
 8028048:	3724      	adds	r7, #36	; 0x24
 802804a:	46bd      	mov	sp, r7
 802804c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028050:	4770      	bx	lr

08028052 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:
  slice->TC = tc;
}

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
 8028052:	b480      	push	{r7}
 8028054:	b083      	sub	sp, #12
 8028056:	af00      	add	r7, sp, #0
 8028058:	6078      	str	r0, [r7, #4]
 802805a:	460b      	mov	r3, r1
 802805c:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 802805e:	887a      	ldrh	r2, [r7, #2]
 8028060:	687b      	ldr	r3, [r7, #4]
 8028062:	635a      	str	r2, [r3, #52]	; 0x34
}
 8028064:	bf00      	nop
 8028066:	370c      	adds	r7, #12
 8028068:	46bd      	mov	sp, r7
 802806a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802806e:	4770      	bx	lr

08028070 <XMC_CCU8_SLICE_SetTimerCompareMatch>:

/* Programs timer compare match value for channel 1 or 2 */
void XMC_CCU8_SLICE_SetTimerCompareMatch(XMC_CCU8_SLICE_t *const slice,
    const XMC_CCU8_SLICE_COMPARE_CHANNEL_t channel,
    const uint16_t compare_val)
{
 8028070:	b480      	push	{r7}
 8028072:	b083      	sub	sp, #12
 8028074:	af00      	add	r7, sp, #0
 8028076:	6078      	str	r0, [r7, #4]
 8028078:	460b      	mov	r3, r1
 802807a:	70fb      	strb	r3, [r7, #3]
 802807c:	4613      	mov	r3, r2
 802807e:	803b      	strh	r3, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 8028080:	78fb      	ldrb	r3, [r7, #3]
 8028082:	2b00      	cmp	r3, #0
 8028084:	d103      	bne.n	802808e <XMC_CCU8_SLICE_SetTimerCompareMatch+0x1e>
  {
    slice->CR1S = (uint32_t) compare_val;
 8028086:	883a      	ldrh	r2, [r7, #0]
 8028088:	687b      	ldr	r3, [r7, #4]
 802808a:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
  }
}
 802808c:	e002      	b.n	8028094 <XMC_CCU8_SLICE_SetTimerCompareMatch+0x24>
    slice->CR2S = (uint32_t) compare_val;
 802808e:	883a      	ldrh	r2, [r7, #0]
 8028090:	687b      	ldr	r3, [r7, #4]
 8028092:	645a      	str	r2, [r3, #68]	; 0x44
}
 8028094:	bf00      	nop
 8028096:	370c      	adds	r7, #12
 8028098:	46bd      	mov	sp, r7
 802809a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802809e:	4770      	bx	lr

080280a0 <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 80280a0:	b480      	push	{r7}
 80280a2:	b087      	sub	sp, #28
 80280a4:	af00      	add	r7, sp, #0
 80280a6:	6078      	str	r0, [r7, #4]
 80280a8:	460b      	mov	r3, r1
 80280aa:	70fb      	strb	r3, [r7, #3]
 80280ac:	4613      	mov	r3, r2
 80280ae:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 80280b0:	78fb      	ldrb	r3, [r7, #3]
 80280b2:	2b0b      	cmp	r3, #11
 80280b4:	d83b      	bhi.n	802812e <XMC_CCU8_SLICE_SetInterruptNode+0x8e>
 80280b6:	a201      	add	r2, pc, #4	; (adr r2, 80280bc <XMC_CCU8_SLICE_SetInterruptNode+0x1c>)
 80280b8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80280bc:	080280ed 	.word	0x080280ed
 80280c0:	080280ed 	.word	0x080280ed
 80280c4:	080280f7 	.word	0x080280f7
 80280c8:	080280f7 	.word	0x080280f7
 80280cc:	08028101 	.word	0x08028101
 80280d0:	08028101 	.word	0x08028101
 80280d4:	0802812f 	.word	0x0802812f
 80280d8:	0802812f 	.word	0x0802812f
 80280dc:	0802810b 	.word	0x0802810b
 80280e0:	08028117 	.word	0x08028117
 80280e4:	08028123 	.word	0x08028123
 80280e8:	08028123 	.word	0x08028123
  {
    case XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU8_CC8_SRS_POSR_Msk);
 80280ec:	2303      	movs	r3, #3
 80280ee:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_POSR_Pos;
 80280f0:	2300      	movs	r3, #0
 80280f2:	613b      	str	r3, [r7, #16]
      break;
 80280f4:	e020      	b.n	8028138 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1:
    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1:
      mask = ((uint32_t) CCU8_CC8_SRS_CM1SR_Msk);
 80280f6:	230c      	movs	r3, #12
 80280f8:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_CM1SR_Pos;
 80280fa:	2302      	movs	r3, #2
 80280fc:	613b      	str	r3, [r7, #16]
      break;
 80280fe:	e01b      	b.n	8028138 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2:
    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2:
      mask = ((uint32_t) CCU8_CC8_SRS_CM2SR_Msk);
 8028100:	2330      	movs	r3, #48	; 0x30
 8028102:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_CM2SR_Pos;
 8028104:	2304      	movs	r3, #4
 8028106:	613b      	str	r3, [r7, #16]
      break;
 8028108:	e016      	b.n	8028138 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU8_CC8_SRS_E0SR_Msk);
 802810a:	f44f 7340 	mov.w	r3, #768	; 0x300
 802810e:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E0SR_Pos;
 8028110:	2308      	movs	r3, #8
 8028112:	613b      	str	r3, [r7, #16]
      break;
 8028114:	e010      	b.n	8028138 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU8_CC8_SRS_E1SR_Msk);
 8028116:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 802811a:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E1SR_Pos;
 802811c:	230a      	movs	r3, #10
 802811e:	613b      	str	r3, [r7, #16]
      break;
 8028120:	e00a      	b.n	8028138 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU8_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
 8028122:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8028126:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E2SR_Pos;
 8028128:	230c      	movs	r3, #12
 802812a:	613b      	str	r3, [r7, #16]
      break;
 802812c:	e004      	b.n	8028138 <XMC_CCU8_SLICE_SetInterruptNode+0x98>
	  
	default:
	  mask = 0;
 802812e:	2300      	movs	r3, #0
 8028130:	617b      	str	r3, [r7, #20]
	  pos = 0;
 8028132:	2300      	movs	r3, #0
 8028134:	613b      	str	r3, [r7, #16]
	  break;
 8028136:	bf00      	nop
  }

  if (mask != 0)
 8028138:	697b      	ldr	r3, [r7, #20]
 802813a:	2b00      	cmp	r3, #0
 802813c:	d013      	beq.n	8028166 <XMC_CCU8_SLICE_SetInterruptNode+0xc6>
  {
    srs = slice->SRS;
 802813e:	687b      	ldr	r3, [r7, #4]
 8028140:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8028144:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 8028146:	697b      	ldr	r3, [r7, #20]
 8028148:	43db      	mvns	r3, r3
 802814a:	68fa      	ldr	r2, [r7, #12]
 802814c:	4013      	ands	r3, r2
 802814e:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 8028150:	78ba      	ldrb	r2, [r7, #2]
 8028152:	693b      	ldr	r3, [r7, #16]
 8028154:	fa02 f303 	lsl.w	r3, r2, r3
 8028158:	68fa      	ldr	r2, [r7, #12]
 802815a:	4313      	orrs	r3, r2
 802815c:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 802815e:	687b      	ldr	r3, [r7, #4]
 8028160:	68fa      	ldr	r2, [r7, #12]
 8028162:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 8028166:	bf00      	nop
 8028168:	371c      	adds	r7, #28
 802816a:	46bd      	mov	sp, r7
 802816c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028170:	4770      	bx	lr
 8028172:	bf00      	nop

08028174 <XMC_CCU8_SLICE_DeadTimeInit>:
}

/* Initializes Dead time configuration for the slice outputs */
void XMC_CCU8_SLICE_DeadTimeInit(XMC_CCU8_SLICE_t *const slice,
                                 const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const config)
{
 8028174:	b480      	push	{r7}
 8028176:	b083      	sub	sp, #12
 8028178:	af00      	add	r7, sp, #0
 802817a:	6078      	str	r0, [r7, #4]
 802817c:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureDeadTime:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* Program dead time value for channel 1 */
  slice->DC1R = config->dc1r;
 802817e:	683b      	ldr	r3, [r7, #0]
 8028180:	685a      	ldr	r2, [r3, #4]
 8028182:	687b      	ldr	r3, [r7, #4]
 8028184:	651a      	str	r2, [r3, #80]	; 0x50
  /* Program dead time value for channel 2 */
  slice->DC2R = config->dc2r;
 8028186:	683b      	ldr	r3, [r7, #0]
 8028188:	689a      	ldr	r2, [r3, #8]
 802818a:	687b      	ldr	r3, [r7, #4]
 802818c:	655a      	str	r2, [r3, #84]	; 0x54
  /* Program dead time control configuration */
  slice->DTC = config->dtc;
 802818e:	683b      	ldr	r3, [r7, #0]
 8028190:	681a      	ldr	r2, [r3, #0]
 8028192:	687b      	ldr	r3, [r7, #4]
 8028194:	64da      	str	r2, [r3, #76]	; 0x4c
}
 8028196:	bf00      	nop
 8028198:	370c      	adds	r7, #12
 802819a:	46bd      	mov	sp, r7
 802819c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281a0:	4770      	bx	lr

080281a2 <XMC_FCE_Init>:
/*
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
 80281a2:	b480      	push	{r7}
 80281a4:	b083      	sub	sp, #12
 80281a6:	af00      	add	r7, sp, #0
 80281a8:	6078      	str	r0, [r7, #4]
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 80281aa:	687b      	ldr	r3, [r7, #4]
 80281ac:	681b      	ldr	r3, [r3, #0]
 80281ae:	687a      	ldr	r2, [r7, #4]
 80281b0:	6852      	ldr	r2, [r2, #4]
 80281b2:	609a      	str	r2, [r3, #8]
  engine->kernel_ptr->CRC = engine->seedvalue;
 80281b4:	687b      	ldr	r3, [r7, #4]
 80281b6:	681b      	ldr	r3, [r3, #0]
 80281b8:	687a      	ldr	r2, [r7, #4]
 80281ba:	6892      	ldr	r2, [r2, #8]
 80281bc:	619a      	str	r2, [r3, #24]

  return XMC_FCE_STATUS_OK;
 80281be:	2300      	movs	r3, #0
}
 80281c0:	4618      	mov	r0, r3
 80281c2:	370c      	adds	r7, #12
 80281c4:	46bd      	mov	sp, r7
 80281c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80281ca:	4770      	bx	lr

080281cc <XMC_FCE_Enable>:

}

/* Enable FCE */
void XMC_FCE_Enable(void)
{
 80281cc:	b580      	push	{r7, lr}
 80281ce:	af00      	add	r7, sp, #0
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_FCE);
#endif

  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_FCE);
 80281d0:	4805      	ldr	r0, [pc, #20]	; (80281e8 <XMC_FCE_Enable+0x1c>)
 80281d2:	f7fe fae5 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>

  FCE->CLC &= (uint32_t)~FCE_CLC_DISR_Msk;
 80281d6:	4b05      	ldr	r3, [pc, #20]	; (80281ec <XMC_FCE_Enable+0x20>)
 80281d8:	681b      	ldr	r3, [r3, #0]
 80281da:	4a04      	ldr	r2, [pc, #16]	; (80281ec <XMC_FCE_Enable+0x20>)
 80281dc:	f023 0301 	bic.w	r3, r3, #1
 80281e0:	6013      	str	r3, [r2, #0]
}
 80281e2:	bf00      	nop
 80281e4:	bd80      	pop	{r7, pc}
 80281e6:	bf00      	nop
 80281e8:	20000040 	.word	0x20000040
 80281ec:	50020000 	.word	0x50020000

080281f0 <XMC_FCE_CalculateCRC32>:
/* Calculate and return the IEEE 802.3 Ethernet CRC32 checksum */
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
                                        uint32_t length,
                                        uint32_t *result)
{
 80281f0:	b480      	push	{r7}
 80281f2:	b087      	sub	sp, #28
 80281f4:	af00      	add	r7, sp, #0
 80281f6:	60f8      	str	r0, [r7, #12]
 80281f8:	60b9      	str	r1, [r7, #8]
 80281fa:	607a      	str	r2, [r7, #4]
 80281fc:	603b      	str	r3, [r7, #0]
  XMC_FCE_STATUS_t status = XMC_FCE_STATUS_OK;
 80281fe:	2300      	movs	r3, #0
 8028200:	75fb      	strb	r3, [r7, #23]
             (engine->kernel_ptr == XMC_FCE_CRC32_1)));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length field is empty", (length != 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length is not aligned", ((length & 0x3U) == 0));

  /* Check length is a multiple of 4 */
  if ((length == 0) || ((length & 0x3U) != 0U))
 8028202:	687b      	ldr	r3, [r7, #4]
 8028204:	2b00      	cmp	r3, #0
 8028206:	d004      	beq.n	8028212 <XMC_FCE_CalculateCRC32+0x22>
 8028208:	687b      	ldr	r3, [r7, #4]
 802820a:	f003 0303 	and.w	r3, r3, #3
 802820e:	2b00      	cmp	r3, #0
 8028210:	d00d      	beq.n	802822e <XMC_FCE_CalculateCRC32+0x3e>
  {
    status = XMC_FCE_STATUS_ERROR;
 8028212:	2302      	movs	r3, #2
 8028214:	75fb      	strb	r3, [r7, #23]
 8028216:	e012      	b.n	802823e <XMC_FCE_CalculateCRC32+0x4e>
  }
  else
  {
    while (0UL != length)
    {
      engine->kernel_ptr->IR = *data;
 8028218:	68fb      	ldr	r3, [r7, #12]
 802821a:	681b      	ldr	r3, [r3, #0]
 802821c:	68ba      	ldr	r2, [r7, #8]
 802821e:	6812      	ldr	r2, [r2, #0]
 8028220:	601a      	str	r2, [r3, #0]
      data++;
 8028222:	68bb      	ldr	r3, [r7, #8]
 8028224:	3304      	adds	r3, #4
 8028226:	60bb      	str	r3, [r7, #8]
      length -= 4U;
 8028228:	687b      	ldr	r3, [r7, #4]
 802822a:	3b04      	subs	r3, #4
 802822c:	607b      	str	r3, [r7, #4]
    while (0UL != length)
 802822e:	687b      	ldr	r3, [r7, #4]
 8028230:	2b00      	cmp	r3, #0
 8028232:	d1f1      	bne.n	8028218 <XMC_FCE_CalculateCRC32+0x28>
    }

    *result = engine->kernel_ptr->CRC;
 8028234:	68fb      	ldr	r3, [r7, #12]
 8028236:	681b      	ldr	r3, [r3, #0]
 8028238:	699a      	ldr	r2, [r3, #24]
 802823a:	683b      	ldr	r3, [r7, #0]
 802823c:	601a      	str	r2, [r3, #0]
  }

  return status;
 802823e:	7dfb      	ldrb	r3, [r7, #23]
}
 8028240:	4618      	mov	r0, r3
 8028242:	371c      	adds	r7, #28
 8028244:	46bd      	mov	sp, r7
 8028246:	f85d 7b04 	ldr.w	r7, [sp], #4
 802824a:	4770      	bx	lr

0802824c <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 802824c:	b480      	push	{r7}
 802824e:	b083      	sub	sp, #12
 8028250:	af00      	add	r7, sp, #0
 8028252:	6078      	str	r0, [r7, #4]
 8028254:	460b      	mov	r3, r1
 8028256:	70fb      	strb	r3, [r7, #3]
 8028258:	4613      	mov	r3, r2
 802825a:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 802825c:	687b      	ldr	r3, [r7, #4]
 802825e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8028260:	78fb      	ldrb	r3, [r7, #3]
 8028262:	005b      	lsls	r3, r3, #1
 8028264:	2103      	movs	r1, #3
 8028266:	fa01 f303 	lsl.w	r3, r1, r3
 802826a:	43db      	mvns	r3, r3
 802826c:	401a      	ands	r2, r3
 802826e:	687b      	ldr	r3, [r7, #4]
 8028270:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8028272:	687b      	ldr	r3, [r7, #4]
 8028274:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8028276:	78b9      	ldrb	r1, [r7, #2]
 8028278:	78fb      	ldrb	r3, [r7, #3]
 802827a:	005b      	lsls	r3, r3, #1
 802827c:	fa01 f303 	lsl.w	r3, r1, r3
 8028280:	431a      	orrs	r2, r3
 8028282:	687b      	ldr	r3, [r7, #4]
 8028284:	675a      	str	r2, [r3, #116]	; 0x74
}
 8028286:	bf00      	nop
 8028288:	370c      	adds	r7, #12
 802828a:	46bd      	mov	sp, r7
 802828c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028290:	4770      	bx	lr

08028292 <XMC_POSIF_Stop>:
{
 8028292:	b480      	push	{r7}
 8028294:	b083      	sub	sp, #12
 8028296:	af00      	add	r7, sp, #0
 8028298:	6078      	str	r0, [r7, #4]
  peripheral->PRUNC = (uint32_t)(POSIF_PRUNC_CRB_Msk | POSIF_PRUNC_CSM_Msk);
 802829a:	687b      	ldr	r3, [r7, #4]
 802829c:	2203      	movs	r2, #3
 802829e:	60da      	str	r2, [r3, #12]
}
 80282a0:	bf00      	nop
 80282a2:	370c      	adds	r7, #12
 80282a4:	46bd      	mov	sp, r7
 80282a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80282aa:	4770      	bx	lr

080282ac <XMC_POSIF_Enable>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to enable the POSIF module */
void XMC_POSIF_Enable(XMC_POSIF_t *const peripheral)
{
 80282ac:	b580      	push	{r7, lr}
 80282ae:	b082      	sub	sp, #8
 80282b0:	af00      	add	r7, sp, #0
 80282b2:	6078      	str	r0, [r7, #4]
#if UC_FAMILY == XMC4
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 80282b4:	2010      	movs	r0, #16
 80282b6:	f7fe fbaf 	bl	8026a18 <XMC_SCU_CLOCK_EnableClock>
#endif

  if (peripheral == POSIF0)
 80282ba:	687b      	ldr	r3, [r7, #4]
 80282bc:	4a09      	ldr	r2, [pc, #36]	; (80282e4 <XMC_POSIF_Enable+0x38>)
 80282be:	4293      	cmp	r3, r2
 80282c0:	d104      	bne.n	80282cc <XMC_POSIF_Enable+0x20>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_POSIF0);
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_POSIF0);
 80282c2:	f44f 7000 	mov.w	r0, #512	; 0x200
 80282c6:	f7fe fa6b 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_POSIF_Disable:Invalid module pointer", 0);
  }
}
 80282ca:	e007      	b.n	80282dc <XMC_POSIF_Enable+0x30>
  else if (peripheral == POSIF1)
 80282cc:	687b      	ldr	r3, [r7, #4]
 80282ce:	4a06      	ldr	r2, [pc, #24]	; (80282e8 <XMC_POSIF_Enable+0x3c>)
 80282d0:	4293      	cmp	r3, r2
 80282d2:	d103      	bne.n	80282dc <XMC_POSIF_Enable+0x30>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_POSIF1);
 80282d4:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80282d8:	f7fe fa62 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 80282dc:	bf00      	nop
 80282de:	3708      	adds	r7, #8
 80282e0:	46bd      	mov	sp, r7
 80282e2:	bd80      	pop	{r7, pc}
 80282e4:	40028000 	.word	0x40028000
 80282e8:	4002c000 	.word	0x4002c000

080282ec <XMC_POSIF_Init>:
  }
}

/* API to initialize POSIF global resources */
void XMC_POSIF_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_CONFIG_t *const config)
{
 80282ec:	b580      	push	{r7, lr}
 80282ee:	b082      	sub	sp, #8
 80282f0:	af00      	add	r7, sp, #0
 80282f2:	6078      	str	r0, [r7, #4]
 80282f4:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_POSIF_Init:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_Init:NULL Pointer", (config != (XMC_POSIF_CONFIG_t *)NULL) );

  /* Enable the POSIF module */
  XMC_POSIF_Enable(peripheral);
 80282f6:	6878      	ldr	r0, [r7, #4]
 80282f8:	f7ff ffd8 	bl	80282ac <XMC_POSIF_Enable>

  /* Stop POSIF */
  XMC_POSIF_Stop(peripheral);
 80282fc:	6878      	ldr	r0, [r7, #4]
 80282fe:	f7ff ffc8 	bl	8028292 <XMC_POSIF_Stop>

  /* Program the operational mode, input selectors and debounce filter */
  peripheral->PCONF = config->pconf;
 8028302:	683b      	ldr	r3, [r7, #0]
 8028304:	681a      	ldr	r2, [r3, #0]
 8028306:	687b      	ldr	r3, [r7, #4]
 8028308:	601a      	str	r2, [r3, #0]
}
 802830a:	bf00      	nop
 802830c:	3708      	adds	r7, #8
 802830e:	46bd      	mov	sp, r7
 8028310:	bd80      	pop	{r7, pc}

08028312 <XMC_POSIF_HSC_Init>:

/* API to initialize hall sensor interface */
XMC_POSIF_STATUS_t XMC_POSIF_HSC_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_HSC_CONFIG_t *const config)
{
 8028312:	b480      	push	{r7}
 8028314:	b085      	sub	sp, #20
 8028316:	af00      	add	r7, sp, #0
 8028318:	6078      	str	r0, [r7, #4]
 802831a:	6039      	str	r1, [r7, #0]
  XMC_POSIF_STATUS_t retval;

  XMC_ASSERT("XMC_POSIF_HSC_Init:Invalid module pointer\n", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_HSC_Init:NULL Pointer\n", (config != (XMC_POSIF_HSC_CONFIG_t *)NULL) );

  if (XMC_POSIF_MODE_HALL_SENSOR == (XMC_POSIF_MODE_t)((peripheral->PCONF) & (uint32_t)POSIF_PCONF_FSEL_Msk) )
 802831c:	687b      	ldr	r3, [r7, #4]
 802831e:	681b      	ldr	r3, [r3, #0]
 8028320:	b2db      	uxtb	r3, r3
 8028322:	f003 0303 	and.w	r3, r3, #3
 8028326:	2b00      	cmp	r3, #0
 8028328:	d109      	bne.n	802833e <XMC_POSIF_HSC_Init+0x2c>
  {
    peripheral->PCONF |= config->hall_config;
 802832a:	687b      	ldr	r3, [r7, #4]
 802832c:	681a      	ldr	r2, [r3, #0]
 802832e:	683b      	ldr	r3, [r7, #0]
 8028330:	681b      	ldr	r3, [r3, #0]
 8028332:	431a      	orrs	r2, r3
 8028334:	687b      	ldr	r3, [r7, #4]
 8028336:	601a      	str	r2, [r3, #0]
    retval = XMC_POSIF_STATUS_OK;
 8028338:	2300      	movs	r3, #0
 802833a:	73fb      	strb	r3, [r7, #15]
 802833c:	e001      	b.n	8028342 <XMC_POSIF_HSC_Init+0x30>
  }
  else
  {
    retval = XMC_POSIF_STATUS_ERROR;
 802833e:	2301      	movs	r3, #1
 8028340:	73fb      	strb	r3, [r7, #15]
  }
  return retval;
 8028342:	7bfb      	ldrb	r3, [r7, #15]
}
 8028344:	4618      	mov	r0, r3
 8028346:	3714      	adds	r7, #20
 8028348:	46bd      	mov	sp, r7
 802834a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802834e:	4770      	bx	lr

08028350 <XMC_POSIF_MCM_Init>:

/* API to initialize multi-channel mode.
 * This is used in Hall mode, standalone multi-channel mode and quadrature with multi-channel mode
 */
XMC_POSIF_STATUS_t XMC_POSIF_MCM_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_MCM_CONFIG_t *const config)
{
 8028350:	b480      	push	{r7}
 8028352:	b085      	sub	sp, #20
 8028354:	af00      	add	r7, sp, #0
 8028356:	6078      	str	r0, [r7, #4]
 8028358:	6039      	str	r1, [r7, #0]
  XMC_POSIF_STATUS_t retval;

  XMC_ASSERT("XMC_POSIF_MCM_Init:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_MCM_Init:NULL Pointer", (config != (XMC_POSIF_MCM_CONFIG_t *)NULL) );

  if ((XMC_POSIF_MODE_t)((peripheral->PCONF) & (uint32_t)POSIF_PCONF_FSEL_Msk) != XMC_POSIF_MODE_QD)
 802835a:	687b      	ldr	r3, [r7, #4]
 802835c:	681b      	ldr	r3, [r3, #0]
 802835e:	b2db      	uxtb	r3, r3
 8028360:	f003 0303 	and.w	r3, r3, #3
 8028364:	2b01      	cmp	r3, #1
 8028366:	d009      	beq.n	802837c <XMC_POSIF_MCM_Init+0x2c>
  {
    peripheral->PCONF |= config->mcm_config;
 8028368:	687b      	ldr	r3, [r7, #4]
 802836a:	681a      	ldr	r2, [r3, #0]
 802836c:	683b      	ldr	r3, [r7, #0]
 802836e:	681b      	ldr	r3, [r3, #0]
 8028370:	431a      	orrs	r2, r3
 8028372:	687b      	ldr	r3, [r7, #4]
 8028374:	601a      	str	r2, [r3, #0]
    retval = XMC_POSIF_STATUS_OK;
 8028376:	2300      	movs	r3, #0
 8028378:	73fb      	strb	r3, [r7, #15]
 802837a:	e001      	b.n	8028380 <XMC_POSIF_MCM_Init+0x30>
  }
  else
  {
    retval = XMC_POSIF_STATUS_ERROR;
 802837c:	2301      	movs	r3, #1
 802837e:	73fb      	strb	r3, [r7, #15]
  }
  return retval;
 8028380:	7bfb      	ldrb	r3, [r7, #15]
}
 8028382:	4618      	mov	r0, r3
 8028384:	3714      	adds	r7, #20
 8028386:	46bd      	mov	sp, r7
 8028388:	f85d 7b04 	ldr.w	r7, [sp], #4
 802838c:	4770      	bx	lr

0802838e <XMC_POSIF_SetInterruptNode>:
  peripheral->PCONF = ((peripheral->PCONF & ~(uint32_t)XMC_POSIF_PCONF_INSEL_Msk) | reg);
}

/* API to select an interrupt node */
void XMC_POSIF_SetInterruptNode(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event, const XMC_POSIF_SR_ID_t sr)
{
 802838e:	b480      	push	{r7}
 8028390:	b085      	sub	sp, #20
 8028392:	af00      	add	r7, sp, #0
 8028394:	6078      	str	r0, [r7, #4]
 8028396:	460b      	mov	r3, r1
 8028398:	70fb      	strb	r3, [r7, #3]
 802839a:	4613      	mov	r3, r2
 802839c:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Wrong IRQ event", (event <= XMC_POSIF_IRQ_EVENT_PCLK) );
  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Wrong SR ID", (sr <= XMC_POSIF_SR_ID_1) );

  reg = peripheral->PFLGE;
 802839e:	687b      	ldr	r3, [r7, #4]
 80283a0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80283a2:	60fb      	str	r3, [r7, #12]
  reg &= ~((uint32_t)1 << ((uint32_t)event + (uint32_t)POSIF_PFLGE_CHESEL_Pos));
 80283a4:	78fb      	ldrb	r3, [r7, #3]
 80283a6:	3310      	adds	r3, #16
 80283a8:	2201      	movs	r2, #1
 80283aa:	fa02 f303 	lsl.w	r3, r2, r3
 80283ae:	43db      	mvns	r3, r3
 80283b0:	68fa      	ldr	r2, [r7, #12]
 80283b2:	4013      	ands	r3, r2
 80283b4:	60fb      	str	r3, [r7, #12]
  reg |= (uint32_t)sr << ((uint32_t)event + (uint32_t)POSIF_PFLGE_CHESEL_Pos);
 80283b6:	78ba      	ldrb	r2, [r7, #2]
 80283b8:	78fb      	ldrb	r3, [r7, #3]
 80283ba:	3310      	adds	r3, #16
 80283bc:	fa02 f303 	lsl.w	r3, r2, r3
 80283c0:	68fa      	ldr	r2, [r7, #12]
 80283c2:	4313      	orrs	r3, r2
 80283c4:	60fb      	str	r3, [r7, #12]
  peripheral->PFLGE = reg;
 80283c6:	687b      	ldr	r3, [r7, #4]
 80283c8:	68fa      	ldr	r2, [r7, #12]
 80283ca:	675a      	str	r2, [r3, #116]	; 0x74
}
 80283cc:	bf00      	nop
 80283ce:	3714      	adds	r7, #20
 80283d0:	46bd      	mov	sp, r7
 80283d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80283d6:	4770      	bx	lr

080283d8 <XMC_VADC_GROUP_ExternalMuxControlInit>:
{
 80283d8:	b480      	push	{r7}
 80283da:	b085      	sub	sp, #20
 80283dc:	af00      	add	r7, sp, #0
 80283de:	6078      	str	r0, [r7, #4]
 80283e0:	6039      	str	r1, [r7, #0]
  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 80283e2:	783b      	ldrb	r3, [r7, #0]
 80283e4:	f3c3 0302 	ubfx	r3, r3, #0, #3
 80283e8:	b2db      	uxtb	r3, r3
 80283ea:	461a      	mov	r2, r3
                ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 80283ec:	78bb      	ldrb	r3, [r7, #2]
 80283ee:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80283f2:	b2db      	uxtb	r3, r3
 80283f4:	041b      	lsls	r3, r3, #16
  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 80283f6:	4313      	orrs	r3, r2
 80283f8:	60fb      	str	r3, [r7, #12]
  group_ptr->EMUXCTR  = emux_config;
 80283fa:	687b      	ldr	r3, [r7, #4]
 80283fc:	68fa      	ldr	r2, [r7, #12]
 80283fe:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 8028402:	78fb      	ldrb	r3, [r7, #3]
 8028404:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8028408:	b2db      	uxtb	r3, r3
 802840a:	071a      	lsls	r2, r3, #28
                ((uint32_t)emux_cfg.emux_mode  << (uint32_t)VADC_G_EMUXCTR_EMUXMODE_Pos) |
 802840c:	78fb      	ldrb	r3, [r7, #3]
 802840e:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8028412:	b2db      	uxtb	r3, r3
 8028414:	069b      	lsls	r3, r3, #26
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 8028416:	431a      	orrs	r2, r3
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);
 8028418:	78fb      	ldrb	r3, [r7, #3]
 802841a:	f3c3 1340 	ubfx	r3, r3, #5, #1
 802841e:	b2db      	uxtb	r3, r3
 8028420:	075b      	lsls	r3, r3, #29
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 8028422:	4313      	orrs	r3, r2
 8028424:	60fb      	str	r3, [r7, #12]
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 8028426:	687b      	ldr	r3, [r7, #4]
 8028428:	f8d3 21f0 	ldr.w	r2, [r3, #496]	; 0x1f0
 802842c:	68fb      	ldr	r3, [r7, #12]
 802842e:	4313      	orrs	r3, r2
 8028430:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8028434:	687b      	ldr	r3, [r7, #4]
 8028436:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
}
 802843a:	bf00      	nop
 802843c:	3714      	adds	r7, #20
 802843e:	46bd      	mov	sp, r7
 8028440:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028444:	4770      	bx	lr

08028446 <XMC_VADC_GROUP_BackgroundEnableArbitrationSlot>:
{
 8028446:	b480      	push	{r7}
 8028448:	b083      	sub	sp, #12
 802844a:	af00      	add	r7, sp, #0
 802844c:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN2_Msk;
 802844e:	687b      	ldr	r3, [r7, #4]
 8028450:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8028454:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 8028458:	687b      	ldr	r3, [r7, #4]
 802845a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 802845e:	bf00      	nop
 8028460:	370c      	adds	r7, #12
 8028462:	46bd      	mov	sp, r7
 8028464:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028468:	4770      	bx	lr

0802846a <XMC_VADC_GROUP_BackgroundDisableArbitrationSlot>:
{
 802846a:	b480      	push	{r7}
 802846c:	b083      	sub	sp, #12
 802846e:	af00      	add	r7, sp, #0
 8028470:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN2_Msk);
 8028472:	687b      	ldr	r3, [r7, #4]
 8028474:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8028478:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 802847c:	687b      	ldr	r3, [r7, #4]
 802847e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8028482:	bf00      	nop
 8028484:	370c      	adds	r7, #12
 8028486:	46bd      	mov	sp, r7
 8028488:	f85d 7b04 	ldr.w	r7, [sp], #4
 802848c:	4770      	bx	lr

0802848e <XMC_VADC_GROUP_QueueEnableArbitrationSlot>:
{
 802848e:	b480      	push	{r7}
 8028490:	b083      	sub	sp, #12
 8028492:	af00      	add	r7, sp, #0
 8028494:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8028496:	687b      	ldr	r3, [r7, #4]
 8028498:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 802849c:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 80284a0:	687b      	ldr	r3, [r7, #4]
 80284a2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80284a6:	bf00      	nop
 80284a8:	370c      	adds	r7, #12
 80284aa:	46bd      	mov	sp, r7
 80284ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80284b0:	4770      	bx	lr

080284b2 <XMC_VADC_GROUP_QueueDisableArbitrationSlot>:
{
 80284b2:	b480      	push	{r7}
 80284b4:	b083      	sub	sp, #12
 80284b6:	af00      	add	r7, sp, #0
 80284b8:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 80284ba:	687b      	ldr	r3, [r7, #4]
 80284bc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80284c0:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 80284c4:	687b      	ldr	r3, [r7, #4]
 80284c6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80284ca:	bf00      	nop
 80284cc:	370c      	adds	r7, #12
 80284ce:	46bd      	mov	sp, r7
 80284d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80284d4:	4770      	bx	lr

080284d6 <XMC_VADC_GLOBAL_EnableModule>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/*API to enable the VADC Module*/
void XMC_VADC_GLOBAL_EnableModule(void)
{
 80284d6:	b580      	push	{r7, lr}
 80284d8:	af00      	add	r7, sp, #0
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 80284da:	2001      	movs	r0, #1
 80284dc:	f7fe f960 	bl	80267a0 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
}
 80284e0:	bf00      	nop
 80284e2:	bd80      	pop	{r7, pc}

080284e4 <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 80284e4:	b580      	push	{r7, lr}
 80284e6:	b082      	sub	sp, #8
 80284e8:	af00      	add	r7, sp, #0
 80284ea:	6078      	str	r0, [r7, #4]
 80284ec:	6039      	str	r1, [r7, #0]
#if (UC_SERIES == XMC14)
  XMC_SCU_CLOCK_SetAdcClockSrc(XMC_SCU_CLOCK_ADCCLKSRC_48MHZ);
#endif

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();
 80284ee:	f7ff fff2 	bl	80284d6 <XMC_VADC_GLOBAL_EnableModule>

  global_ptr->CLC = (uint32_t)(config->clc);
 80284f2:	683b      	ldr	r3, [r7, #0]
 80284f4:	695a      	ldr	r2, [r3, #20]
 80284f6:	687b      	ldr	r3, [r7, #4]
 80284f8:	601a      	str	r2, [r3, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 80284fa:	683b      	ldr	r3, [r7, #0]
 80284fc:	685b      	ldr	r3, [r3, #4]
 80284fe:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8028502:	687b      	ldr	r3, [r7, #4]
 8028504:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 8028508:	683b      	ldr	r3, [r7, #0]
 802850a:	689a      	ldr	r2, [r3, #8]
 802850c:	687b      	ldr	r3, [r7, #4]
 802850e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 8028512:	683b      	ldr	r3, [r7, #0]
 8028514:	68da      	ldr	r2, [r3, #12]
 8028516:	687b      	ldr	r3, [r7, #4]
 8028518:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 802851c:	683b      	ldr	r3, [r7, #0]
 802851e:	691a      	ldr	r2, [r3, #16]
 8028520:	687b      	ldr	r3, [r7, #4]
 8028522:	f8c3 2280 	str.w	r2, [r3, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 8028526:	683b      	ldr	r3, [r7, #0]
 8028528:	681a      	ldr	r2, [r3, #0]
 802852a:	687b      	ldr	r3, [r7, #4]
 802852c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

  /* From the Errata sheet of XMC1100 V1.7*/
  XMC_VADC_CONV_ENABLE_FOR_XMC11 = 1U;
#endif

}
 8028530:	bf00      	nop
 8028532:	3708      	adds	r7, #8
 8028534:	46bd      	mov	sp, r7
 8028536:	bd80      	pop	{r7, pc}

08028538 <XMC_VADC_GLOBAL_InputClassInit>:

/* API to Set the Global IClass registers*/
void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLASS_t config,
                                    const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8028538:	b480      	push	{r7}
 802853a:	b085      	sub	sp, #20
 802853c:	af00      	add	r7, sp, #0
 802853e:	60f8      	str	r0, [r7, #12]
 8028540:	60b9      	str	r1, [r7, #8]
 8028542:	603b      	str	r3, [r7, #0]
 8028544:	4613      	mov	r3, r2
 8028546:	71fb      	strb	r3, [r7, #7]
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 8028548:	79fb      	ldrb	r3, [r7, #7]
 802854a:	2b00      	cmp	r3, #0
 802854c:	d109      	bne.n	8028562 <XMC_VADC_GLOBAL_InputClassInit+0x2a>
  {
#endif
    XMC_UNUSED_ARG(conv_type);
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 802854e:	68ba      	ldr	r2, [r7, #8]
 8028550:	f240 731f 	movw	r3, #1823	; 0x71f
 8028554:	4013      	ands	r3, r2
 8028556:	68fa      	ldr	r2, [r7, #12]
 8028558:	6839      	ldr	r1, [r7, #0]
 802855a:	3128      	adds	r1, #40	; 0x28
 802855c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
  }
#endif
}
 8028560:	e007      	b.n	8028572 <XMC_VADC_GLOBAL_InputClassInit+0x3a>
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 8028562:	68ba      	ldr	r2, [r7, #8]
 8028564:	4b06      	ldr	r3, [pc, #24]	; (8028580 <XMC_VADC_GLOBAL_InputClassInit+0x48>)
 8028566:	4013      	ands	r3, r2
 8028568:	68fa      	ldr	r2, [r7, #12]
 802856a:	6839      	ldr	r1, [r7, #0]
 802856c:	3128      	adds	r1, #40	; 0x28
 802856e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8028572:	bf00      	nop
 8028574:	3714      	adds	r7, #20
 8028576:	46bd      	mov	sp, r7
 8028578:	f85d 7b04 	ldr.w	r7, [sp], #4
 802857c:	4770      	bx	lr
 802857e:	bf00      	nop
 8028580:	071f0000 	.word	0x071f0000

08028584 <XMC_VADC_GLOBAL_StartupCalibration>:

/* API to enable startup calibration feature */
void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
{
 8028584:	b480      	push	{r7}
 8028586:	b085      	sub	sp, #20
 8028588:	af00      	add	r7, sp, #0
 802858a:	6078      	str	r0, [r7, #4]
  VADC_G_TypeDef *group_ptr;
#endif

  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 802858c:	687b      	ldr	r3, [r7, #4]
 802858e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8028592:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8028596:	687b      	ldr	r3, [r7, #4]
 8028598:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 802859c:	2300      	movs	r3, #0
 802859e:	73fb      	strb	r3, [r7, #15]
 80285a0:	e017      	b.n	80285d2 <XMC_VADC_GLOBAL_StartupCalibration+0x4e>
  {
    group_ptr = g_xmc_vadc_group_array[i];
 80285a2:	7bfb      	ldrb	r3, [r7, #15]
 80285a4:	4a10      	ldr	r2, [pc, #64]	; (80285e8 <XMC_VADC_GLOBAL_StartupCalibration+0x64>)
 80285a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80285aa:	60bb      	str	r3, [r7, #8]
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 80285ac:	68bb      	ldr	r3, [r7, #8]
 80285ae:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80285b2:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80285b6:	2b00      	cmp	r3, #0
 80285b8:	d008      	beq.n	80285cc <XMC_VADC_GLOBAL_StartupCalibration+0x48>
      while ((group_ptr->ARBCFG & (uint32_t)VADC_G_ARBCFG_CALS_Msk) == 0)
      {
        __NOP();
      }
#endif
      while ((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 80285ba:	e000      	b.n	80285be <XMC_VADC_GLOBAL_StartupCalibration+0x3a>
      {
        __NOP();
 80285bc:	bf00      	nop
      while ((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 80285be:	68bb      	ldr	r3, [r7, #8]
 80285c0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80285c4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80285c8:	2b00      	cmp	r3, #0
 80285ca:	d1f7      	bne.n	80285bc <XMC_VADC_GLOBAL_StartupCalibration+0x38>
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80285cc:	7bfb      	ldrb	r3, [r7, #15]
 80285ce:	3301      	adds	r3, #1
 80285d0:	73fb      	strb	r3, [r7, #15]
 80285d2:	7bfb      	ldrb	r3, [r7, #15]
 80285d4:	2b03      	cmp	r3, #3
 80285d6:	d9e4      	bls.n	80285a2 <XMC_VADC_GLOBAL_StartupCalibration+0x1e>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    __NOP();
  }
#endif
}
 80285d8:	bf00      	nop
 80285da:	bf00      	nop
 80285dc:	3714      	adds	r7, #20
 80285de:	46bd      	mov	sp, r7
 80285e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80285e4:	4770      	bx	lr
 80285e6:	bf00      	nop
 80285e8:	0802b0dc 	.word	0x0802b0dc

080285ec <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode>:
  global_ptr->GLOBEVNP |= (uint32_t)(node << VADC_GLOBEVNP_REV0NP_Pos);
}

/* API to bind request source event with a service request line */
void XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC_VADC_SR_t sr)
{
 80285ec:	b480      	push	{r7}
 80285ee:	b085      	sub	sp, #20
 80285f0:	af00      	add	r7, sp, #0
 80285f2:	6078      	str	r0, [r7, #4]
 80285f4:	460b      	mov	r3, r1
 80285f6:	70fb      	strb	r3, [r7, #3]
  uint32_t node;

  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:Wrong Module Pointer", (global_ptr == VADC))

  if (sr >= XMC_VADC_SR_SHARED_SR0)
 80285f8:	78fb      	ldrb	r3, [r7, #3]
 80285fa:	2b03      	cmp	r3, #3
 80285fc:	d903      	bls.n	8028606 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode+0x1a>
  {
    node = (uint32_t)sr - (uint32_t)XMC_VADC_SR_SHARED_SR0;
 80285fe:	78fb      	ldrb	r3, [r7, #3]
 8028600:	3b04      	subs	r3, #4
 8028602:	60fb      	str	r3, [r7, #12]
 8028604:	e001      	b.n	802860a <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode+0x1e>
  }
  else
  {
    node = (uint32_t)sr;
 8028606:	78fb      	ldrb	r3, [r7, #3]
 8028608:	60fb      	str	r3, [r7, #12]
  }

  global_ptr->GLOBEVNP &= ~((uint32_t)VADC_GLOBEVNP_SEV0NP_Msk);
 802860a:	687b      	ldr	r3, [r7, #4]
 802860c:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8028610:	f023 020f 	bic.w	r2, r3, #15
 8028614:	687b      	ldr	r3, [r7, #4]
 8028616:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  global_ptr->GLOBEVNP |= (uint32_t) (node << VADC_GLOBEVNP_SEV0NP_Pos);
 802861a:	687b      	ldr	r3, [r7, #4]
 802861c:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 8028620:	68fb      	ldr	r3, [r7, #12]
 8028622:	431a      	orrs	r2, r3
 8028624:	687b      	ldr	r3, [r7, #4]
 8028626:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
}
 802862a:	bf00      	nop
 802862c:	3714      	adds	r7, #20
 802862e:	46bd      	mov	sp, r7
 8028630:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028634:	4770      	bx	lr

08028636 <XMC_VADC_GROUP_Init>:

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8028636:	b580      	push	{r7, lr}
 8028638:	b082      	sub	sp, #8
 802863a:	af00      	add	r7, sp, #0
 802863c:	6078      	str	r0, [r7, #4]
 802863e:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_Init:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Program the input classes */
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
 8028640:	6839      	ldr	r1, [r7, #0]
 8028642:	2300      	movs	r3, #0
 8028644:	2200      	movs	r2, #0
 8028646:	6849      	ldr	r1, [r1, #4]
 8028648:	6878      	ldr	r0, [r7, #4]
 802864a:	f000 f828 	bl	802869e <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
 802864e:	6839      	ldr	r1, [r7, #0]
 8028650:	2300      	movs	r3, #0
 8028652:	2201      	movs	r2, #1
 8028654:	6849      	ldr	r1, [r1, #4]
 8028656:	6878      	ldr	r0, [r7, #4]
 8028658:	f000 f821 	bl	802869e <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
 802865c:	6839      	ldr	r1, [r7, #0]
 802865e:	2301      	movs	r3, #1
 8028660:	2200      	movs	r2, #0
 8028662:	6889      	ldr	r1, [r1, #8]
 8028664:	6878      	ldr	r0, [r7, #4]
 8028666:	f000 f81a 	bl	802869e <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);
 802866a:	6839      	ldr	r1, [r7, #0]
 802866c:	2301      	movs	r3, #1
 802866e:	2201      	movs	r2, #1
 8028670:	6889      	ldr	r1, [r1, #8]
 8028672:	6878      	ldr	r0, [r7, #4]
 8028674:	f000 f813 	bl	802869e <XMC_VADC_GROUP_InputClassInit>

  group_ptr->ARBCFG = config->g_arbcfg;
 8028678:	683b      	ldr	r3, [r7, #0]
 802867a:	691a      	ldr	r2, [r3, #16]
 802867c:	687b      	ldr	r3, [r7, #4]
 802867e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  group_ptr->BOUND = config->g_bound;
 8028682:	683b      	ldr	r3, [r7, #0]
 8028684:	68da      	ldr	r2, [r3, #12]
 8028686:	687b      	ldr	r3, [r7, #4]
 8028688:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

  /* External mux configuration */
  XMC_VADC_GROUP_ExternalMuxControlInit(group_ptr, config->emux_config);
 802868c:	683b      	ldr	r3, [r7, #0]
 802868e:	6819      	ldr	r1, [r3, #0]
 8028690:	6878      	ldr	r0, [r7, #4]
 8028692:	f7ff fea1 	bl	80283d8 <XMC_VADC_GROUP_ExternalMuxControlInit>

}
 8028696:	bf00      	nop
 8028698:	3708      	adds	r7, #8
 802869a:	46bd      	mov	sp, r7
 802869c:	bd80      	pop	{r7, pc}

0802869e <XMC_VADC_GROUP_InputClassInit>:

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                   const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 802869e:	b480      	push	{r7}
 80286a0:	b08d      	sub	sp, #52	; 0x34
 80286a2:	af00      	add	r7, sp, #0
 80286a4:	60f8      	str	r0, [r7, #12]
 80286a6:	60b9      	str	r1, [r7, #8]
 80286a8:	603b      	str	r3, [r7, #0]
 80286aa:	4613      	mov	r3, r2
 80286ac:	71fb      	strb	r3, [r7, #7]

  /*
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 80286ae:	79fb      	ldrb	r3, [r7, #7]
 80286b0:	2b00      	cmp	r3, #0
 80286b2:	d113      	bne.n	80286dc <XMC_VADC_GROUP_InputClassInit+0x3e>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
 80286b4:	2308      	movs	r3, #8
 80286b6:	62fb      	str	r3, [r7, #44]	; 0x2c
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
 80286b8:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 80286bc:	627b      	str	r3, [r7, #36]	; 0x24
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
 80286be:	2300      	movs	r3, #0
 80286c0:	62bb      	str	r3, [r7, #40]	; 0x28
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
 80286c2:	231f      	movs	r3, #31
 80286c4:	623b      	str	r3, [r7, #32]
    sample_time      = (uint32_t) config.sample_time_std_conv;
 80286c6:	7a3b      	ldrb	r3, [r7, #8]
 80286c8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80286cc:	b2db      	uxtb	r3, r3
 80286ce:	61fb      	str	r3, [r7, #28]
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 80286d0:	7a7b      	ldrb	r3, [r7, #9]
 80286d2:	f3c3 0302 	ubfx	r3, r3, #0, #3
 80286d6:	b2db      	uxtb	r3, r3
 80286d8:	76fb      	strb	r3, [r7, #27]
 80286da:	e013      	b.n	8028704 <XMC_VADC_GROUP_InputClassInit+0x66>
  }
  else
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
 80286dc:	2318      	movs	r3, #24
 80286de:	62fb      	str	r3, [r7, #44]	; 0x2c
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
 80286e0:	f04f 63e0 	mov.w	r3, #117440512	; 0x7000000
 80286e4:	627b      	str	r3, [r7, #36]	; 0x24
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
 80286e6:	2310      	movs	r3, #16
 80286e8:	62bb      	str	r3, [r7, #40]	; 0x28
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
 80286ea:	f44f 13f8 	mov.w	r3, #2031616	; 0x1f0000
 80286ee:	623b      	str	r3, [r7, #32]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80286f0:	7abb      	ldrb	r3, [r7, #10]
 80286f2:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80286f6:	b2db      	uxtb	r3, r3
 80286f8:	61fb      	str	r3, [r7, #28]
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 80286fa:	7afb      	ldrb	r3, [r7, #11]
 80286fc:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8028700:	b2db      	uxtb	r3, r3
 8028702:	76fb      	strb	r3, [r7, #27]
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8028704:	68fb      	ldr	r3, [r7, #12]
 8028706:	683a      	ldr	r2, [r7, #0]
 8028708:	3228      	adds	r2, #40	; 0x28
 802870a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802870e:	617b      	str	r3, [r7, #20]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8028710:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8028712:	43db      	mvns	r3, r3
 8028714:	697a      	ldr	r2, [r7, #20]
 8028716:	4013      	ands	r3, r2
 8028718:	617b      	str	r3, [r7, #20]
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802871a:	7efa      	ldrb	r2, [r7, #27]
 802871c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802871e:	fa02 f303 	lsl.w	r3, r2, r3
 8028722:	697a      	ldr	r2, [r7, #20]
 8028724:	4313      	orrs	r3, r2
 8028726:	617b      	str	r3, [r7, #20]
  conv_class &= ~(sample_time_mask);
 8028728:	6a3b      	ldr	r3, [r7, #32]
 802872a:	43db      	mvns	r3, r3
 802872c:	697a      	ldr	r2, [r7, #20]
 802872e:	4013      	ands	r3, r2
 8028730:	617b      	str	r3, [r7, #20]
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8028732:	69fa      	ldr	r2, [r7, #28]
 8028734:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8028736:	fa02 f303 	lsl.w	r3, r2, r3
 802873a:	697a      	ldr	r2, [r7, #20]
 802873c:	4313      	orrs	r3, r2
 802873e:	617b      	str	r3, [r7, #20]
  group_ptr->ICLASS[set_num] = conv_class;
 8028740:	68fb      	ldr	r3, [r7, #12]
 8028742:	683a      	ldr	r2, [r7, #0]
 8028744:	3228      	adds	r2, #40	; 0x28
 8028746:	6979      	ldr	r1, [r7, #20]
 8028748:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 802874c:	bf00      	nop
 802874e:	3734      	adds	r7, #52	; 0x34
 8028750:	46bd      	mov	sp, r7
 8028752:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028756:	4770      	bx	lr

08028758 <XMC_VADC_GROUP_SetPowerMode>:

/* API which sets the power mode of analog converter of a VADC group */
void XMC_VADC_GROUP_SetPowerMode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_POWERMODE_t power_mode)
{
 8028758:	b480      	push	{r7}
 802875a:	b085      	sub	sp, #20
 802875c:	af00      	add	r7, sp, #0
 802875e:	6078      	str	r0, [r7, #4]
 8028760:	460b      	mov	r3, r1
 8028762:	70fb      	strb	r3, [r7, #3]
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 8028764:	687b      	ldr	r3, [r7, #4]
 8028766:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 802876a:	60fb      	str	r3, [r7, #12]

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 802876c:	68fb      	ldr	r3, [r7, #12]
 802876e:	f023 0303 	bic.w	r3, r3, #3
 8028772:	60fb      	str	r3, [r7, #12]
  arbcfg |= (uint32_t)power_mode;
 8028774:	78fb      	ldrb	r3, [r7, #3]
 8028776:	68fa      	ldr	r2, [r7, #12]
 8028778:	4313      	orrs	r3, r2
 802877a:	60fb      	str	r3, [r7, #12]

  group_ptr->ARBCFG = arbcfg;
 802877c:	687b      	ldr	r3, [r7, #4]
 802877e:	68fa      	ldr	r2, [r7, #12]
 8028780:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 8028784:	bf00      	nop
 8028786:	3714      	adds	r7, #20
 8028788:	46bd      	mov	sp, r7
 802878a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802878e:	4770      	bx	lr

08028790 <XMC_VADC_GROUP_SetBoundaries>:
  return ( (XMC_VADC_GROUP_STATE_t)arbcfg);
}

/* API to set boundaries for conversion results */
void XMC_VADC_GROUP_SetBoundaries(XMC_VADC_GROUP_t *const group_ptr, const uint32_t boundary0, const uint32_t boundary1)
{
 8028790:	b480      	push	{r7}
 8028792:	b087      	sub	sp, #28
 8028794:	af00      	add	r7, sp, #0
 8028796:	60f8      	str	r0, [r7, #12]
 8028798:	60b9      	str	r1, [r7, #8]
 802879a:	607a      	str	r2, [r7, #4]
  uint32_t bound;

  XMC_ASSERT("XMC_VADC_GROUP_SetBoundaries:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Program the Boundary registers */
  bound  = group_ptr->BOUND;
 802879c:	68fb      	ldr	r3, [r7, #12]
 802879e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 80287a2:	617b      	str	r3, [r7, #20]
  bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY0_Msk);
 80287a4:	697b      	ldr	r3, [r7, #20]
 80287a6:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80287aa:	f023 030f 	bic.w	r3, r3, #15
 80287ae:	617b      	str	r3, [r7, #20]
  bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY1_Msk);
 80287b0:	697b      	ldr	r3, [r7, #20]
 80287b2:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 80287b6:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 80287ba:	617b      	str	r3, [r7, #20]
  bound |= (uint32_t) ((uint32_t) boundary0 << VADC_G_BOUND_BOUNDARY0_Pos);
 80287bc:	697a      	ldr	r2, [r7, #20]
 80287be:	68bb      	ldr	r3, [r7, #8]
 80287c0:	4313      	orrs	r3, r2
 80287c2:	617b      	str	r3, [r7, #20]
  bound |= (uint32_t) ((uint32_t) boundary1 << VADC_G_BOUND_BOUNDARY1_Pos);
 80287c4:	687b      	ldr	r3, [r7, #4]
 80287c6:	041b      	lsls	r3, r3, #16
 80287c8:	697a      	ldr	r2, [r7, #20]
 80287ca:	4313      	orrs	r3, r2
 80287cc:	617b      	str	r3, [r7, #20]
  group_ptr->BOUND = bound;
 80287ce:	68fb      	ldr	r3, [r7, #12]
 80287d0:	697a      	ldr	r2, [r7, #20]
 80287d2:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
 80287d6:	bf00      	nop
 80287d8:	371c      	adds	r7, #28
 80287da:	46bd      	mov	sp, r7
 80287dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80287e0:	4770      	bx	lr
	...

080287e4 <XMC_VADC_GLOBAL_BackgroundInit>:
}
#endif

/* API to initialize background scan request source hardware */
void XMC_VADC_GLOBAL_BackgroundInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_BACKGROUND_CONFIG_t *config)
{
 80287e4:	b580      	push	{r7, lr}
 80287e6:	b086      	sub	sp, #24
 80287e8:	af00      	add	r7, sp, #0
 80287ea:	6078      	str	r0, [r7, #4]
 80287ec:	6039      	str	r1, [r7, #0]
#endif

  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundInit:Wrong Module Pointer", (global_ptr == VADC))

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80287ee:	2300      	movs	r3, #0
 80287f0:	75fb      	strb	r3, [r7, #23]
 80287f2:	e009      	b.n	8028808 <XMC_VADC_GLOBAL_BackgroundInit+0x24>
  {
    XMC_VADC_GROUP_BackgroundDisableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
 80287f4:	7dfb      	ldrb	r3, [r7, #23]
 80287f6:	4a3a      	ldr	r2, [pc, #232]	; (80288e0 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 80287f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80287fc:	4618      	mov	r0, r3
 80287fe:	f7ff fe34 	bl	802846a <XMC_VADC_GROUP_BackgroundDisableArbitrationSlot>
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8028802:	7dfb      	ldrb	r3, [r7, #23]
 8028804:	3301      	adds	r3, #1
 8028806:	75fb      	strb	r3, [r7, #23]
 8028808:	7dfb      	ldrb	r3, [r7, #23]
 802880a:	2b03      	cmp	r3, #3
 802880c:	d9f2      	bls.n	80287f4 <XMC_VADC_GLOBAL_BackgroundInit+0x10>
  }

  conv_start_mask = (uint32_t) 0;
 802880e:	2300      	movs	r3, #0
 8028810:	613b      	str	r3, [r7, #16]
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8028812:	683b      	ldr	r3, [r7, #0]
 8028814:	781b      	ldrb	r3, [r3, #0]
 8028816:	f003 0303 	and.w	r3, r3, #3
 802881a:	b2db      	uxtb	r3, r3
 802881c:	2b00      	cmp	r3, #0
 802881e:	d002      	beq.n	8028826 <XMC_VADC_GLOBAL_BackgroundInit+0x42>
  {
    conv_start_mask = (uint32_t)VADC_G_ARBPR_CSM2_Msk;
 8028820:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8028824:	613b      	str	r3, [r7, #16]
  }

  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8028826:	2300      	movs	r3, #0
 8028828:	75fb      	strb	r3, [r7, #23]
 802882a:	e021      	b.n	8028870 <XMC_VADC_GLOBAL_BackgroundInit+0x8c>
  {
    reg = g_xmc_vadc_group_array[i]->ARBPR;
 802882c:	7dfb      	ldrb	r3, [r7, #23]
 802882e:	4a2c      	ldr	r2, [pc, #176]	; (80288e0 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8028830:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8028834:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8028838:	60fb      	str	r3, [r7, #12]

    reg &= ~(uint32_t)(VADC_G_ARBPR_PRIO2_Msk);
 802883a:	68fb      	ldr	r3, [r7, #12]
 802883c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8028840:	60fb      	str	r3, [r7, #12]

    /* Program the priority of the request source */
    reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO2_Pos);
 8028842:	683b      	ldr	r3, [r7, #0]
 8028844:	781b      	ldrb	r3, [r3, #0]
 8028846:	f3c3 0381 	ubfx	r3, r3, #2, #2
 802884a:	b2db      	uxtb	r3, r3
 802884c:	021b      	lsls	r3, r3, #8
 802884e:	68fa      	ldr	r2, [r7, #12]
 8028850:	4313      	orrs	r3, r2
 8028852:	60fb      	str	r3, [r7, #12]

    /* Program the start mode */
    reg |= conv_start_mask;
 8028854:	68fa      	ldr	r2, [r7, #12]
 8028856:	693b      	ldr	r3, [r7, #16]
 8028858:	4313      	orrs	r3, r2
 802885a:	60fb      	str	r3, [r7, #12]

    g_xmc_vadc_group_array[i]->ARBPR = reg;
 802885c:	7dfb      	ldrb	r3, [r7, #23]
 802885e:	4a20      	ldr	r2, [pc, #128]	; (80288e0 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8028860:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8028864:	68fa      	ldr	r2, [r7, #12]
 8028866:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 802886a:	7dfb      	ldrb	r3, [r7, #23]
 802886c:	3301      	adds	r3, #1
 802886e:	75fb      	strb	r3, [r7, #23]
 8028870:	7dfb      	ldrb	r3, [r7, #23]
 8028872:	2b03      	cmp	r3, #3
 8028874:	d9da      	bls.n	802882c <XMC_VADC_GLOBAL_BackgroundInit+0x48>

  }
#endif

  /* program BRSCTRL register */
  global_ptr->BRSCTRL = (uint32_t)(config->asctrl | (uint32_t)VADC_BRSCTRL_XTWC_Msk | (uint32_t)VADC_BRSCTRL_GTWC_Msk);
 8028876:	683b      	ldr	r3, [r7, #0]
 8028878:	685b      	ldr	r3, [r3, #4]
 802887a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802887e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8028882:	687a      	ldr	r2, [r7, #4]
 8028884:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

  /* program BRSMR register */
  global_ptr->BRSMR = (uint32_t)((config->asmr) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_BRSMR_ENGT_Pos));
 8028888:	683b      	ldr	r3, [r7, #0]
 802888a:	689b      	ldr	r3, [r3, #8]
 802888c:	f043 0201 	orr.w	r2, r3, #1
 8028890:	687b      	ldr	r3, [r7, #4]
 8028892:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8028896:	683b      	ldr	r3, [r7, #0]
 8028898:	781b      	ldrb	r3, [r3, #0]
 802889a:	f003 0303 	and.w	r3, r3, #3
 802889e:	b2db      	uxtb	r3, r3
 80288a0:	2b02      	cmp	r3, #2
 80288a2:	d107      	bne.n	80288b4 <XMC_VADC_GLOBAL_BackgroundInit+0xd0>
  {
    global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_RPTDIS_Msk;
 80288a4:	687b      	ldr	r3, [r7, #4]
 80288a6:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 80288aa:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80288ae:	687b      	ldr	r3, [r7, #4]
 80288b0:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  }
#endif

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80288b4:	2300      	movs	r3, #0
 80288b6:	75fb      	strb	r3, [r7, #23]
 80288b8:	e009      	b.n	80288ce <XMC_VADC_GLOBAL_BackgroundInit+0xea>
  {
    XMC_VADC_GROUP_BackgroundEnableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
 80288ba:	7dfb      	ldrb	r3, [r7, #23]
 80288bc:	4a08      	ldr	r2, [pc, #32]	; (80288e0 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 80288be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80288c2:	4618      	mov	r0, r3
 80288c4:	f7ff fdbf 	bl	8028446 <XMC_VADC_GROUP_BackgroundEnableArbitrationSlot>
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80288c8:	7dfb      	ldrb	r3, [r7, #23]
 80288ca:	3301      	adds	r3, #1
 80288cc:	75fb      	strb	r3, [r7, #23]
 80288ce:	7dfb      	ldrb	r3, [r7, #23]
 80288d0:	2b03      	cmp	r3, #3
 80288d2:	d9f2      	bls.n	80288ba <XMC_VADC_GLOBAL_BackgroundInit+0xd6>
  }
#endif

}
 80288d4:	bf00      	nop
 80288d6:	bf00      	nop
 80288d8:	3718      	adds	r7, #24
 80288da:	46bd      	mov	sp, r7
 80288dc:	bd80      	pop	{r7, pc}
 80288de:	bf00      	nop
 80288e0:	0802b0dc 	.word	0x0802b0dc

080288e4 <XMC_VADC_GROUP_QueueInit>:
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 80288e4:	b580      	push	{r7, lr}
 80288e6:	b084      	sub	sp, #16
 80288e8:	af00      	add	r7, sp, #0
 80288ea:	6078      	str	r0, [r7, #4]
 80288ec:	6039      	str	r1, [r7, #0]
  uint32_t          reg;

  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
 80288ee:	6878      	ldr	r0, [r7, #4]
 80288f0:	f7ff fddf 	bl	80284b2 <XMC_VADC_GROUP_QueueDisableArbitrationSlot>

  reg = group_ptr->ARBPR;
 80288f4:	687b      	ldr	r3, [r7, #4]
 80288f6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80288fa:	60fb      	str	r3, [r7, #12]

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 80288fc:	68fb      	ldr	r3, [r7, #12]
 80288fe:	f023 0303 	bic.w	r3, r3, #3
 8028902:	60fb      	str	r3, [r7, #12]
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8028904:	683b      	ldr	r3, [r7, #0]
 8028906:	781b      	ldrb	r3, [r3, #0]
 8028908:	f3c3 0381 	ubfx	r3, r3, #2, #2
 802890c:	b2db      	uxtb	r3, r3
 802890e:	461a      	mov	r2, r3
 8028910:	68fb      	ldr	r3, [r7, #12]
 8028912:	4313      	orrs	r3, r2
 8028914:	60fb      	str	r3, [r7, #12]

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8028916:	683b      	ldr	r3, [r7, #0]
 8028918:	781b      	ldrb	r3, [r3, #0]
 802891a:	f003 0303 	and.w	r3, r3, #3
 802891e:	b2db      	uxtb	r3, r3
 8028920:	2b00      	cmp	r3, #0
 8028922:	d003      	beq.n	802892c <XMC_VADC_GROUP_QueueInit+0x48>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 8028924:	68fb      	ldr	r3, [r7, #12]
 8028926:	f043 0308 	orr.w	r3, r3, #8
 802892a:	60fb      	str	r3, [r7, #12]
  }

  group_ptr->ARBPR = reg;
 802892c:	687b      	ldr	r3, [r7, #4]
 802892e:	68fa      	ldr	r2, [r7, #12]
 8028930:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0) | (uint32_t)(VADC_G_QCTRL0_XTWC_Msk) |
 8028934:	683b      	ldr	r3, [r7, #0]
 8028936:	685b      	ldr	r3, [r3, #4]
 8028938:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 802893c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8028940:	687a      	ldr	r2, [r7, #4]
 8028942:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
                                 (uint32_t)(VADC_G_QCTRL0_TMWC_Msk) |
                                 (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8028946:	683b      	ldr	r3, [r7, #0]
 8028948:	689b      	ldr	r3, [r3, #8]
 802894a:	f043 0201 	orr.w	r2, r3, #1
 802894e:	687b      	ldr	r3, [r7, #4]
 8028950:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8028954:	683b      	ldr	r3, [r7, #0]
 8028956:	781b      	ldrb	r3, [r3, #0]
 8028958:	f003 0303 	and.w	r3, r3, #3
 802895c:	b2db      	uxtb	r3, r3
 802895e:	2b02      	cmp	r3, #2
 8028960:	d107      	bne.n	8028972 <XMC_VADC_GROUP_QueueInit+0x8e>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8028962:	687b      	ldr	r3, [r7, #4]
 8028964:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8028968:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 802896c:	687b      	ldr	r3, [r7, #4]
 802896e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);
 8028972:	6878      	ldr	r0, [r7, #4]
 8028974:	f7ff fd8b 	bl	802848e <XMC_VADC_GROUP_QueueEnableArbitrationSlot>

}
 8028978:	bf00      	nop
 802897a:	3710      	adds	r7, #16
 802897c:	46bd      	mov	sp, r7
 802897e:	bd80      	pop	{r7, pc}

08028980 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8028980:	b480      	push	{r7}
 8028982:	b089      	sub	sp, #36	; 0x24
 8028984:	af00      	add	r7, sp, #0
 8028986:	60f8      	str	r0, [r7, #12]
 8028988:	60b9      	str	r1, [r7, #8]
 802898a:	607a      	str	r2, [r7, #4]


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))

  prio  = (uint32_t)config->channel_priority;
 802898c:	687b      	ldr	r3, [r7, #4]
 802898e:	7a1b      	ldrb	r3, [r3, #8]
 8028990:	61bb      	str	r3, [r7, #24]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8028992:	68fb      	ldr	r3, [r7, #12]
 8028994:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8028998:	617b      	str	r3, [r7, #20]
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 802899a:	2201      	movs	r2, #1
 802899c:	68bb      	ldr	r3, [r7, #8]
 802899e:	fa02 f303 	lsl.w	r3, r2, r3
 80289a2:	43db      	mvns	r3, r3
 80289a4:	697a      	ldr	r2, [r7, #20]
 80289a6:	4013      	ands	r3, r2
 80289a8:	617b      	str	r3, [r7, #20]
  ch_assign |= (uint32_t)(prio << ch_num);
 80289aa:	69ba      	ldr	r2, [r7, #24]
 80289ac:	68bb      	ldr	r3, [r7, #8]
 80289ae:	fa02 f303 	lsl.w	r3, r2, r3
 80289b2:	697a      	ldr	r2, [r7, #20]
 80289b4:	4313      	orrs	r3, r2
 80289b6:	617b      	str	r3, [r7, #20]
  group_ptr->CHASS = ch_assign;
 80289b8:	68fb      	ldr	r3, [r7, #12]
 80289ba:	697a      	ldr	r2, [r7, #20]
 80289bc:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 80289c0:	687b      	ldr	r3, [r7, #4]
 80289c2:	f993 3009 	ldrsb.w	r3, [r3, #9]
 80289c6:	2b00      	cmp	r3, #0
 80289c8:	db2a      	blt.n	8028a20 <XMC_VADC_GROUP_ChannelInit+0xa0>
  {
    mask = (uint32_t)0;
 80289ca:	2300      	movs	r3, #0
 80289cc:	61fb      	str	r3, [r7, #28]
    if ((uint32_t)1 == ch_num)
 80289ce:	68bb      	ldr	r3, [r7, #8]
 80289d0:	2b01      	cmp	r3, #1
 80289d2:	d10a      	bne.n	80289ea <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
 80289d4:	2308      	movs	r3, #8
 80289d6:	61fb      	str	r3, [r7, #28]
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 80289d8:	68fb      	ldr	r3, [r7, #12]
 80289da:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80289de:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 80289e2:	68fb      	ldr	r3, [r7, #12]
 80289e4:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
 80289e8:	e00c      	b.n	8028a04 <XMC_VADC_GROUP_ChannelInit+0x84>
    }
    else if ((uint32_t)0 == ch_num)
 80289ea:	68bb      	ldr	r3, [r7, #8]
 80289ec:	2b00      	cmp	r3, #0
 80289ee:	d109      	bne.n	8028a04 <XMC_VADC_GROUP_ChannelInit+0x84>
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
 80289f0:	2300      	movs	r3, #0
 80289f2:	61fb      	str	r3, [r7, #28]
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 80289f4:	68fb      	ldr	r3, [r7, #12]
 80289f6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80289fa:	f023 021f 	bic.w	r2, r3, #31
 80289fe:	68fb      	ldr	r3, [r7, #12]
 8028a00:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 8028a04:	68fb      	ldr	r3, [r7, #12]
 8028a06:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8028a0a:	687a      	ldr	r2, [r7, #4]
 8028a0c:	f992 2009 	ldrsb.w	r2, [r2, #9]
 8028a10:	4611      	mov	r1, r2
 8028a12:	69fa      	ldr	r2, [r7, #28]
 8028a14:	fa01 f202 	lsl.w	r2, r1, r2
 8028a18:	431a      	orrs	r2, r3
 8028a1a:	68fb      	ldr	r3, [r7, #12]
 8028a1c:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 8028a20:	68fb      	ldr	r3, [r7, #12]
 8028a22:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 8028a26:	687b      	ldr	r3, [r7, #4]
 8028a28:	685b      	ldr	r3, [r3, #4]
 8028a2a:	431a      	orrs	r2, r3
 8028a2c:	68fb      	ldr	r3, [r7, #12]
 8028a2e:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 8028a32:	687b      	ldr	r3, [r7, #4]
 8028a34:	6819      	ldr	r1, [r3, #0]
 8028a36:	68fb      	ldr	r3, [r7, #12]
 8028a38:	68ba      	ldr	r2, [r7, #8]
 8028a3a:	3280      	adds	r2, #128	; 0x80
 8028a3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

}
 8028a40:	bf00      	nop
 8028a42:	3724      	adds	r7, #36	; 0x24
 8028a44:	46bd      	mov	sp, r7
 8028a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028a4a:	4770      	bx	lr

08028a4c <XMC_VADC_GROUP_ChannelSetEventInterruptNode>:

/* API to bind channel event with a service request (NVIC Node) */
void XMC_VADC_GROUP_ChannelSetEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t ch_num,
    const XMC_VADC_SR_t sr)
{
 8028a4c:	b480      	push	{r7}
 8028a4e:	b087      	sub	sp, #28
 8028a50:	af00      	add	r7, sp, #0
 8028a52:	60f8      	str	r0, [r7, #12]
 8028a54:	60b9      	str	r1, [r7, #8]
 8028a56:	4613      	mov	r3, r2
 8028a58:	71fb      	strb	r3, [r7, #7]
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Channel Number",
             ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  route_mask  = group_ptr->CEVNP0;
 8028a5a:	68fb      	ldr	r3, [r7, #12]
 8028a5c:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8028a60:	617b      	str	r3, [r7, #20]
  route_mask &= ~((uint32_t)15 << (ch_num * (uint32_t)4));
 8028a62:	68bb      	ldr	r3, [r7, #8]
 8028a64:	009b      	lsls	r3, r3, #2
 8028a66:	220f      	movs	r2, #15
 8028a68:	fa02 f303 	lsl.w	r3, r2, r3
 8028a6c:	43db      	mvns	r3, r3
 8028a6e:	697a      	ldr	r2, [r7, #20]
 8028a70:	4013      	ands	r3, r2
 8028a72:	617b      	str	r3, [r7, #20]
  route_mask |= (uint32_t)( (uint32_t)sr << (ch_num * (uint32_t)4));
 8028a74:	79fa      	ldrb	r2, [r7, #7]
 8028a76:	68bb      	ldr	r3, [r7, #8]
 8028a78:	009b      	lsls	r3, r3, #2
 8028a7a:	fa02 f303 	lsl.w	r3, r2, r3
 8028a7e:	697a      	ldr	r2, [r7, #20]
 8028a80:	4313      	orrs	r3, r2
 8028a82:	617b      	str	r3, [r7, #20]
  group_ptr->CEVNP0 = route_mask;
 8028a84:	68fb      	ldr	r3, [r7, #12]
 8028a86:	697a      	ldr	r2, [r7, #20]
 8028a88:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
}
 8028a8c:	bf00      	nop
 8028a8e:	371c      	adds	r7, #28
 8028a90:	46bd      	mov	sp, r7
 8028a92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028a96:	4770      	bx	lr

08028a98 <_init>:
  }
}

/* Init */
void _init(void)
{}
 8028a98:	b480      	push	{r7}
 8028a9a:	af00      	add	r7, sp, #0
 8028a9c:	bf00      	nop
 8028a9e:	46bd      	mov	sp, r7
 8028aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028aa4:	4770      	bx	lr
	...

08028aa8 <__NVIC_GetPriorityGrouping>:
{
 8028aa8:	b480      	push	{r7}
 8028aaa:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8028aac:	4b04      	ldr	r3, [pc, #16]	; (8028ac0 <__NVIC_GetPriorityGrouping+0x18>)
 8028aae:	68db      	ldr	r3, [r3, #12]
 8028ab0:	0a1b      	lsrs	r3, r3, #8
 8028ab2:	f003 0307 	and.w	r3, r3, #7
}
 8028ab6:	4618      	mov	r0, r3
 8028ab8:	46bd      	mov	sp, r7
 8028aba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028abe:	4770      	bx	lr
 8028ac0:	e000ed00 	.word	0xe000ed00

08028ac4 <__NVIC_SetPriority>:
{
 8028ac4:	b480      	push	{r7}
 8028ac6:	b083      	sub	sp, #12
 8028ac8:	af00      	add	r7, sp, #0
 8028aca:	4603      	mov	r3, r0
 8028acc:	6039      	str	r1, [r7, #0]
 8028ace:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8028ad0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8028ad4:	2b00      	cmp	r3, #0
 8028ad6:	db0a      	blt.n	8028aee <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028ad8:	683b      	ldr	r3, [r7, #0]
 8028ada:	b2da      	uxtb	r2, r3
 8028adc:	490c      	ldr	r1, [pc, #48]	; (8028b10 <__NVIC_SetPriority+0x4c>)
 8028ade:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8028ae2:	0092      	lsls	r2, r2, #2
 8028ae4:	b2d2      	uxtb	r2, r2
 8028ae6:	440b      	add	r3, r1
 8028ae8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8028aec:	e00a      	b.n	8028b04 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028aee:	683b      	ldr	r3, [r7, #0]
 8028af0:	b2da      	uxtb	r2, r3
 8028af2:	4908      	ldr	r1, [pc, #32]	; (8028b14 <__NVIC_SetPriority+0x50>)
 8028af4:	79fb      	ldrb	r3, [r7, #7]
 8028af6:	f003 030f 	and.w	r3, r3, #15
 8028afa:	3b04      	subs	r3, #4
 8028afc:	0092      	lsls	r2, r2, #2
 8028afe:	b2d2      	uxtb	r2, r2
 8028b00:	440b      	add	r3, r1
 8028b02:	761a      	strb	r2, [r3, #24]
}
 8028b04:	bf00      	nop
 8028b06:	370c      	adds	r7, #12
 8028b08:	46bd      	mov	sp, r7
 8028b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028b0e:	4770      	bx	lr
 8028b10:	e000e100 	.word	0xe000e100
 8028b14:	e000ed00 	.word	0xe000ed00

08028b18 <NVIC_EncodePriority>:
{
 8028b18:	b480      	push	{r7}
 8028b1a:	b089      	sub	sp, #36	; 0x24
 8028b1c:	af00      	add	r7, sp, #0
 8028b1e:	60f8      	str	r0, [r7, #12]
 8028b20:	60b9      	str	r1, [r7, #8]
 8028b22:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8028b24:	68fb      	ldr	r3, [r7, #12]
 8028b26:	f003 0307 	and.w	r3, r3, #7
 8028b2a:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8028b2c:	69fb      	ldr	r3, [r7, #28]
 8028b2e:	f1c3 0307 	rsb	r3, r3, #7
 8028b32:	2b06      	cmp	r3, #6
 8028b34:	bf28      	it	cs
 8028b36:	2306      	movcs	r3, #6
 8028b38:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8028b3a:	69fb      	ldr	r3, [r7, #28]
 8028b3c:	3306      	adds	r3, #6
 8028b3e:	2b06      	cmp	r3, #6
 8028b40:	d902      	bls.n	8028b48 <NVIC_EncodePriority+0x30>
 8028b42:	69fb      	ldr	r3, [r7, #28]
 8028b44:	3b01      	subs	r3, #1
 8028b46:	e000      	b.n	8028b4a <NVIC_EncodePriority+0x32>
 8028b48:	2300      	movs	r3, #0
 8028b4a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028b4c:	f04f 32ff 	mov.w	r2, #4294967295
 8028b50:	69bb      	ldr	r3, [r7, #24]
 8028b52:	fa02 f303 	lsl.w	r3, r2, r3
 8028b56:	43da      	mvns	r2, r3
 8028b58:	68bb      	ldr	r3, [r7, #8]
 8028b5a:	401a      	ands	r2, r3
 8028b5c:	697b      	ldr	r3, [r7, #20]
 8028b5e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8028b60:	f04f 31ff 	mov.w	r1, #4294967295
 8028b64:	697b      	ldr	r3, [r7, #20]
 8028b66:	fa01 f303 	lsl.w	r3, r1, r3
 8028b6a:	43d9      	mvns	r1, r3
 8028b6c:	687b      	ldr	r3, [r7, #4]
 8028b6e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028b70:	4313      	orrs	r3, r2
}
 8028b72:	4618      	mov	r0, r3
 8028b74:	3724      	adds	r7, #36	; 0x24
 8028b76:	46bd      	mov	sp, r7
 8028b78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028b7c:	4770      	bx	lr
	...

08028b80 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8028b80:	b580      	push	{r7, lr}
 8028b82:	b082      	sub	sp, #8
 8028b84:	af00      	add	r7, sp, #0
 8028b86:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8028b88:	687b      	ldr	r3, [r7, #4]
 8028b8a:	3b01      	subs	r3, #1
 8028b8c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8028b90:	d301      	bcc.n	8028b96 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8028b92:	2301      	movs	r3, #1
 8028b94:	e00f      	b.n	8028bb6 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8028b96:	4a0a      	ldr	r2, [pc, #40]	; (8028bc0 <SysTick_Config+0x40>)
 8028b98:	687b      	ldr	r3, [r7, #4]
 8028b9a:	3b01      	subs	r3, #1
 8028b9c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8028b9e:	213f      	movs	r1, #63	; 0x3f
 8028ba0:	f04f 30ff 	mov.w	r0, #4294967295
 8028ba4:	f7ff ff8e 	bl	8028ac4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8028ba8:	4b05      	ldr	r3, [pc, #20]	; (8028bc0 <SysTick_Config+0x40>)
 8028baa:	2200      	movs	r2, #0
 8028bac:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8028bae:	4b04      	ldr	r3, [pc, #16]	; (8028bc0 <SysTick_Config+0x40>)
 8028bb0:	2207      	movs	r2, #7
 8028bb2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8028bb4:	2300      	movs	r3, #0
}
 8028bb6:	4618      	mov	r0, r3
 8028bb8:	3708      	adds	r7, #8
 8028bba:	46bd      	mov	sp, r7
 8028bbc:	bd80      	pop	{r7, pc}
 8028bbe:	bf00      	nop
 8028bc0:	e000e010 	.word	0xe000e010

08028bc4 <SYSTIMER_lInsertTimerList>:
**********************************************************************************************************************/
/*
 * This function is called to insert a timer into the timer list.
 */
static void SYSTIMER_lInsertTimerList(uint32_t tbl_index)
{
 8028bc4:	b490      	push	{r4, r7}
 8028bc6:	b086      	sub	sp, #24
 8028bc8:	af00      	add	r7, sp, #0
 8028bca:	6078      	str	r0, [r7, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
 8028bcc:	2300      	movs	r3, #0
 8028bce:	73fb      	strb	r3, [r7, #15]
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 8028bd0:	496d      	ldr	r1, [pc, #436]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028bd2:	687a      	ldr	r2, [r7, #4]
 8028bd4:	4613      	mov	r3, r2
 8028bd6:	00db      	lsls	r3, r3, #3
 8028bd8:	4413      	add	r3, r2
 8028bda:	009b      	lsls	r3, r3, #2
 8028bdc:	440b      	add	r3, r1
 8028bde:	3318      	adds	r3, #24
 8028be0:	681b      	ldr	r3, [r3, #0]
 8028be2:	60bb      	str	r3, [r7, #8]
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
 8028be4:	4b69      	ldr	r3, [pc, #420]	; (8028d8c <SYSTIMER_lInsertTimerList+0x1c8>)
 8028be6:	681b      	ldr	r3, [r3, #0]
 8028be8:	2b00      	cmp	r3, #0
 8028bea:	d109      	bne.n	8028c00 <SYSTIMER_lInsertTimerList+0x3c>
  {
    /* Set this as first Timer */
    g_timer_list = &g_timer_tbl[tbl_index];
 8028bec:	687a      	ldr	r2, [r7, #4]
 8028bee:	4613      	mov	r3, r2
 8028bf0:	00db      	lsls	r3, r3, #3
 8028bf2:	4413      	add	r3, r2
 8028bf4:	009b      	lsls	r3, r3, #2
 8028bf6:	4a64      	ldr	r2, [pc, #400]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028bf8:	4413      	add	r3, r2
 8028bfa:	4a64      	ldr	r2, [pc, #400]	; (8028d8c <SYSTIMER_lInsertTimerList+0x1c8>)
 8028bfc:	6013      	str	r3, [r2, #0]
      }
      /* Get the next item in timer list */
      object_ptr = object_ptr->next;
    }
  }
}
 8028bfe:	e0bd      	b.n	8028d7c <SYSTIMER_lInsertTimerList+0x1b8>
    object_ptr = g_timer_list;
 8028c00:	4b62      	ldr	r3, [pc, #392]	; (8028d8c <SYSTIMER_lInsertTimerList+0x1c8>)
 8028c02:	681b      	ldr	r3, [r3, #0]
 8028c04:	617b      	str	r3, [r7, #20]
    delta_ticks = timer_count;
 8028c06:	68bb      	ldr	r3, [r7, #8]
 8028c08:	613b      	str	r3, [r7, #16]
    while ((NULL != object_ptr) && (false == found_flag))
 8028c0a:	e0ad      	b.n	8028d68 <SYSTIMER_lInsertTimerList+0x1a4>
      delta_ticks -= (int32_t)object_ptr->count;
 8028c0c:	697b      	ldr	r3, [r7, #20]
 8028c0e:	699b      	ldr	r3, [r3, #24]
 8028c10:	461a      	mov	r2, r3
 8028c12:	693b      	ldr	r3, [r7, #16]
 8028c14:	1a9b      	subs	r3, r3, r2
 8028c16:	613b      	str	r3, [r7, #16]
      if (delta_ticks <= 0)
 8028c18:	693b      	ldr	r3, [r7, #16]
 8028c1a:	2b00      	cmp	r3, #0
 8028c1c:	dc7b      	bgt.n	8028d16 <SYSTIMER_lInsertTimerList+0x152>
        if (NULL != object_ptr->prev)
 8028c1e:	697b      	ldr	r3, [r7, #20]
 8028c20:	685b      	ldr	r3, [r3, #4]
 8028c22:	2b00      	cmp	r3, #0
 8028c24:	d027      	beq.n	8028c76 <SYSTIMER_lInsertTimerList+0xb2>
          object_ptr->prev->next = &g_timer_tbl[tbl_index];
 8028c26:	697b      	ldr	r3, [r7, #20]
 8028c28:	6859      	ldr	r1, [r3, #4]
 8028c2a:	687a      	ldr	r2, [r7, #4]
 8028c2c:	4613      	mov	r3, r2
 8028c2e:	00db      	lsls	r3, r3, #3
 8028c30:	4413      	add	r3, r2
 8028c32:	009b      	lsls	r3, r3, #2
 8028c34:	4a54      	ldr	r2, [pc, #336]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028c36:	4413      	add	r3, r2
 8028c38:	600b      	str	r3, [r1, #0]
          g_timer_tbl[tbl_index].prev = object_ptr->prev;
 8028c3a:	697b      	ldr	r3, [r7, #20]
 8028c3c:	6859      	ldr	r1, [r3, #4]
 8028c3e:	4852      	ldr	r0, [pc, #328]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028c40:	687a      	ldr	r2, [r7, #4]
 8028c42:	4613      	mov	r3, r2
 8028c44:	00db      	lsls	r3, r3, #3
 8028c46:	4413      	add	r3, r2
 8028c48:	009b      	lsls	r3, r3, #2
 8028c4a:	4403      	add	r3, r0
 8028c4c:	3304      	adds	r3, #4
 8028c4e:	6019      	str	r1, [r3, #0]
          g_timer_tbl[tbl_index].next = object_ptr;
 8028c50:	494d      	ldr	r1, [pc, #308]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028c52:	687a      	ldr	r2, [r7, #4]
 8028c54:	4613      	mov	r3, r2
 8028c56:	00db      	lsls	r3, r3, #3
 8028c58:	4413      	add	r3, r2
 8028c5a:	009b      	lsls	r3, r3, #2
 8028c5c:	440b      	add	r3, r1
 8028c5e:	697a      	ldr	r2, [r7, #20]
 8028c60:	601a      	str	r2, [r3, #0]
          object_ptr->prev = &g_timer_tbl[tbl_index];
 8028c62:	687a      	ldr	r2, [r7, #4]
 8028c64:	4613      	mov	r3, r2
 8028c66:	00db      	lsls	r3, r3, #3
 8028c68:	4413      	add	r3, r2
 8028c6a:	009b      	lsls	r3, r3, #2
 8028c6c:	4a46      	ldr	r2, [pc, #280]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028c6e:	441a      	add	r2, r3
 8028c70:	697b      	ldr	r3, [r7, #20]
 8028c72:	605a      	str	r2, [r3, #4]
 8028c74:	e01c      	b.n	8028cb0 <SYSTIMER_lInsertTimerList+0xec>
          g_timer_tbl[tbl_index].next = g_timer_list;
 8028c76:	4b45      	ldr	r3, [pc, #276]	; (8028d8c <SYSTIMER_lInsertTimerList+0x1c8>)
 8028c78:	6819      	ldr	r1, [r3, #0]
 8028c7a:	4843      	ldr	r0, [pc, #268]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028c7c:	687a      	ldr	r2, [r7, #4]
 8028c7e:	4613      	mov	r3, r2
 8028c80:	00db      	lsls	r3, r3, #3
 8028c82:	4413      	add	r3, r2
 8028c84:	009b      	lsls	r3, r3, #2
 8028c86:	4403      	add	r3, r0
 8028c88:	6019      	str	r1, [r3, #0]
          g_timer_list->prev = &g_timer_tbl[tbl_index];
 8028c8a:	4b40      	ldr	r3, [pc, #256]	; (8028d8c <SYSTIMER_lInsertTimerList+0x1c8>)
 8028c8c:	6819      	ldr	r1, [r3, #0]
 8028c8e:	687a      	ldr	r2, [r7, #4]
 8028c90:	4613      	mov	r3, r2
 8028c92:	00db      	lsls	r3, r3, #3
 8028c94:	4413      	add	r3, r2
 8028c96:	009b      	lsls	r3, r3, #2
 8028c98:	4a3b      	ldr	r2, [pc, #236]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028c9a:	4413      	add	r3, r2
 8028c9c:	604b      	str	r3, [r1, #4]
          g_timer_list = &g_timer_tbl[tbl_index];
 8028c9e:	687a      	ldr	r2, [r7, #4]
 8028ca0:	4613      	mov	r3, r2
 8028ca2:	00db      	lsls	r3, r3, #3
 8028ca4:	4413      	add	r3, r2
 8028ca6:	009b      	lsls	r3, r3, #2
 8028ca8:	4a37      	ldr	r2, [pc, #220]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028caa:	4413      	add	r3, r2
 8028cac:	4a37      	ldr	r2, [pc, #220]	; (8028d8c <SYSTIMER_lInsertTimerList+0x1c8>)
 8028cae:	6013      	str	r3, [r2, #0]
        g_timer_tbl[tbl_index].count = g_timer_tbl[tbl_index].next->count + (uint32_t)delta_ticks;
 8028cb0:	4935      	ldr	r1, [pc, #212]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028cb2:	687a      	ldr	r2, [r7, #4]
 8028cb4:	4613      	mov	r3, r2
 8028cb6:	00db      	lsls	r3, r3, #3
 8028cb8:	4413      	add	r3, r2
 8028cba:	009b      	lsls	r3, r3, #2
 8028cbc:	440b      	add	r3, r1
 8028cbe:	681b      	ldr	r3, [r3, #0]
 8028cc0:	699a      	ldr	r2, [r3, #24]
 8028cc2:	693b      	ldr	r3, [r7, #16]
 8028cc4:	18d1      	adds	r1, r2, r3
 8028cc6:	4830      	ldr	r0, [pc, #192]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028cc8:	687a      	ldr	r2, [r7, #4]
 8028cca:	4613      	mov	r3, r2
 8028ccc:	00db      	lsls	r3, r3, #3
 8028cce:	4413      	add	r3, r2
 8028cd0:	009b      	lsls	r3, r3, #2
 8028cd2:	4403      	add	r3, r0
 8028cd4:	3318      	adds	r3, #24
 8028cd6:	6019      	str	r1, [r3, #0]
        g_timer_tbl[tbl_index].next->count  -= g_timer_tbl[tbl_index].count;
 8028cd8:	492b      	ldr	r1, [pc, #172]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028cda:	687a      	ldr	r2, [r7, #4]
 8028cdc:	4613      	mov	r3, r2
 8028cde:	00db      	lsls	r3, r3, #3
 8028ce0:	4413      	add	r3, r2
 8028ce2:	009b      	lsls	r3, r3, #2
 8028ce4:	440b      	add	r3, r1
 8028ce6:	681b      	ldr	r3, [r3, #0]
 8028ce8:	6998      	ldr	r0, [r3, #24]
 8028cea:	4927      	ldr	r1, [pc, #156]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028cec:	687a      	ldr	r2, [r7, #4]
 8028cee:	4613      	mov	r3, r2
 8028cf0:	00db      	lsls	r3, r3, #3
 8028cf2:	4413      	add	r3, r2
 8028cf4:	009b      	lsls	r3, r3, #2
 8028cf6:	440b      	add	r3, r1
 8028cf8:	3318      	adds	r3, #24
 8028cfa:	6819      	ldr	r1, [r3, #0]
 8028cfc:	4c22      	ldr	r4, [pc, #136]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028cfe:	687a      	ldr	r2, [r7, #4]
 8028d00:	4613      	mov	r3, r2
 8028d02:	00db      	lsls	r3, r3, #3
 8028d04:	4413      	add	r3, r2
 8028d06:	009b      	lsls	r3, r3, #2
 8028d08:	4423      	add	r3, r4
 8028d0a:	681b      	ldr	r3, [r3, #0]
 8028d0c:	1a42      	subs	r2, r0, r1
 8028d0e:	619a      	str	r2, [r3, #24]
        found_flag = true;
 8028d10:	2301      	movs	r3, #1
 8028d12:	73fb      	strb	r3, [r7, #15]
 8028d14:	e025      	b.n	8028d62 <SYSTIMER_lInsertTimerList+0x19e>
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
 8028d16:	693b      	ldr	r3, [r7, #16]
 8028d18:	2b00      	cmp	r3, #0
 8028d1a:	dd22      	ble.n	8028d62 <SYSTIMER_lInsertTimerList+0x19e>
 8028d1c:	697b      	ldr	r3, [r7, #20]
 8028d1e:	681b      	ldr	r3, [r3, #0]
 8028d20:	2b00      	cmp	r3, #0
 8028d22:	d11e      	bne.n	8028d62 <SYSTIMER_lInsertTimerList+0x19e>
          g_timer_tbl[tbl_index].prev = object_ptr;
 8028d24:	4918      	ldr	r1, [pc, #96]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d26:	687a      	ldr	r2, [r7, #4]
 8028d28:	4613      	mov	r3, r2
 8028d2a:	00db      	lsls	r3, r3, #3
 8028d2c:	4413      	add	r3, r2
 8028d2e:	009b      	lsls	r3, r3, #2
 8028d30:	440b      	add	r3, r1
 8028d32:	3304      	adds	r3, #4
 8028d34:	697a      	ldr	r2, [r7, #20]
 8028d36:	601a      	str	r2, [r3, #0]
          object_ptr->next = &g_timer_tbl[tbl_index];
 8028d38:	687a      	ldr	r2, [r7, #4]
 8028d3a:	4613      	mov	r3, r2
 8028d3c:	00db      	lsls	r3, r3, #3
 8028d3e:	4413      	add	r3, r2
 8028d40:	009b      	lsls	r3, r3, #2
 8028d42:	4a11      	ldr	r2, [pc, #68]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d44:	441a      	add	r2, r3
 8028d46:	697b      	ldr	r3, [r7, #20]
 8028d48:	601a      	str	r2, [r3, #0]
          g_timer_tbl[tbl_index].count = (uint32_t)delta_ticks;
 8028d4a:	6939      	ldr	r1, [r7, #16]
 8028d4c:	480e      	ldr	r0, [pc, #56]	; (8028d88 <SYSTIMER_lInsertTimerList+0x1c4>)
 8028d4e:	687a      	ldr	r2, [r7, #4]
 8028d50:	4613      	mov	r3, r2
 8028d52:	00db      	lsls	r3, r3, #3
 8028d54:	4413      	add	r3, r2
 8028d56:	009b      	lsls	r3, r3, #2
 8028d58:	4403      	add	r3, r0
 8028d5a:	3318      	adds	r3, #24
 8028d5c:	6019      	str	r1, [r3, #0]
          found_flag = true;
 8028d5e:	2301      	movs	r3, #1
 8028d60:	73fb      	strb	r3, [r7, #15]
      object_ptr = object_ptr->next;
 8028d62:	697b      	ldr	r3, [r7, #20]
 8028d64:	681b      	ldr	r3, [r3, #0]
 8028d66:	617b      	str	r3, [r7, #20]
    while ((NULL != object_ptr) && (false == found_flag))
 8028d68:	697b      	ldr	r3, [r7, #20]
 8028d6a:	2b00      	cmp	r3, #0
 8028d6c:	d006      	beq.n	8028d7c <SYSTIMER_lInsertTimerList+0x1b8>
 8028d6e:	7bfb      	ldrb	r3, [r7, #15]
 8028d70:	f083 0301 	eor.w	r3, r3, #1
 8028d74:	b2db      	uxtb	r3, r3
 8028d76:	2b00      	cmp	r3, #0
 8028d78:	f47f af48 	bne.w	8028c0c <SYSTIMER_lInsertTimerList+0x48>
}
 8028d7c:	bf00      	nop
 8028d7e:	3718      	adds	r7, #24
 8028d80:	46bd      	mov	sp, r7
 8028d82:	bc90      	pop	{r4, r7}
 8028d84:	4770      	bx	lr
 8028d86:	bf00      	nop
 8028d88:	20000fc8 	.word	0x20000fc8
 8028d8c:	200010e8 	.word	0x200010e8

08028d90 <SYSTIMER_lRemoveTimerList>:

/*
 * This function is called to remove a timer from the timer list. 
 */
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
 8028d90:	b480      	push	{r7}
 8028d92:	b085      	sub	sp, #20
 8028d94:	af00      	add	r7, sp, #0
 8028d96:	6078      	str	r0, [r7, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
 8028d98:	687a      	ldr	r2, [r7, #4]
 8028d9a:	4613      	mov	r3, r2
 8028d9c:	00db      	lsls	r3, r3, #3
 8028d9e:	4413      	add	r3, r2
 8028da0:	009b      	lsls	r3, r3, #2
 8028da2:	4a29      	ldr	r2, [pc, #164]	; (8028e48 <SYSTIMER_lRemoveTimerList+0xb8>)
 8028da4:	4413      	add	r3, r2
 8028da6:	60fb      	str	r3, [r7, #12]
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8028da8:	68fb      	ldr	r3, [r7, #12]
 8028daa:	685b      	ldr	r3, [r3, #4]
 8028dac:	2b00      	cmp	r3, #0
 8028dae:	d107      	bne.n	8028dc0 <SYSTIMER_lRemoveTimerList+0x30>
 8028db0:	68fb      	ldr	r3, [r7, #12]
 8028db2:	681b      	ldr	r3, [r3, #0]
 8028db4:	2b00      	cmp	r3, #0
 8028db6:	d103      	bne.n	8028dc0 <SYSTIMER_lRemoveTimerList+0x30>
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 8028db8:	4b24      	ldr	r3, [pc, #144]	; (8028e4c <SYSTIMER_lRemoveTimerList+0xbc>)
 8028dba:	2200      	movs	r2, #0
 8028dbc:	601a      	str	r2, [r3, #0]
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
    object_ptr->next = NULL;
    object_ptr->prev = NULL;
  }
}
 8028dbe:	e03d      	b.n	8028e3c <SYSTIMER_lRemoveTimerList+0xac>
  else if (NULL == object_ptr->prev)
 8028dc0:	68fb      	ldr	r3, [r7, #12]
 8028dc2:	685b      	ldr	r3, [r3, #4]
 8028dc4:	2b00      	cmp	r3, #0
 8028dc6:	d114      	bne.n	8028df2 <SYSTIMER_lRemoveTimerList+0x62>
    g_timer_list  = object_ptr->next;
 8028dc8:	68fb      	ldr	r3, [r7, #12]
 8028dca:	681b      	ldr	r3, [r3, #0]
 8028dcc:	4a1f      	ldr	r2, [pc, #124]	; (8028e4c <SYSTIMER_lRemoveTimerList+0xbc>)
 8028dce:	6013      	str	r3, [r2, #0]
    g_timer_list->prev = NULL;
 8028dd0:	4b1e      	ldr	r3, [pc, #120]	; (8028e4c <SYSTIMER_lRemoveTimerList+0xbc>)
 8028dd2:	681b      	ldr	r3, [r3, #0]
 8028dd4:	2200      	movs	r2, #0
 8028dd6:	605a      	str	r2, [r3, #4]
    g_timer_list->count += object_ptr->count;
 8028dd8:	4b1c      	ldr	r3, [pc, #112]	; (8028e4c <SYSTIMER_lRemoveTimerList+0xbc>)
 8028dda:	681b      	ldr	r3, [r3, #0]
 8028ddc:	6999      	ldr	r1, [r3, #24]
 8028dde:	68fb      	ldr	r3, [r7, #12]
 8028de0:	699a      	ldr	r2, [r3, #24]
 8028de2:	4b1a      	ldr	r3, [pc, #104]	; (8028e4c <SYSTIMER_lRemoveTimerList+0xbc>)
 8028de4:	681b      	ldr	r3, [r3, #0]
 8028de6:	440a      	add	r2, r1
 8028de8:	619a      	str	r2, [r3, #24]
    object_ptr->next    = NULL;
 8028dea:	68fb      	ldr	r3, [r7, #12]
 8028dec:	2200      	movs	r2, #0
 8028dee:	601a      	str	r2, [r3, #0]
}
 8028df0:	e024      	b.n	8028e3c <SYSTIMER_lRemoveTimerList+0xac>
  else if (NULL == object_ptr->next)
 8028df2:	68fb      	ldr	r3, [r7, #12]
 8028df4:	681b      	ldr	r3, [r3, #0]
 8028df6:	2b00      	cmp	r3, #0
 8028df8:	d107      	bne.n	8028e0a <SYSTIMER_lRemoveTimerList+0x7a>
    object_ptr->prev->next = NULL;
 8028dfa:	68fb      	ldr	r3, [r7, #12]
 8028dfc:	685b      	ldr	r3, [r3, #4]
 8028dfe:	2200      	movs	r2, #0
 8028e00:	601a      	str	r2, [r3, #0]
    object_ptr->prev = NULL;
 8028e02:	68fb      	ldr	r3, [r7, #12]
 8028e04:	2200      	movs	r2, #0
 8028e06:	605a      	str	r2, [r3, #4]
}
 8028e08:	e018      	b.n	8028e3c <SYSTIMER_lRemoveTimerList+0xac>
    object_ptr->prev->next  =  object_ptr->next;
 8028e0a:	68fb      	ldr	r3, [r7, #12]
 8028e0c:	685b      	ldr	r3, [r3, #4]
 8028e0e:	68fa      	ldr	r2, [r7, #12]
 8028e10:	6812      	ldr	r2, [r2, #0]
 8028e12:	601a      	str	r2, [r3, #0]
    object_ptr->next->prev  =  object_ptr->prev;
 8028e14:	68fb      	ldr	r3, [r7, #12]
 8028e16:	681b      	ldr	r3, [r3, #0]
 8028e18:	68fa      	ldr	r2, [r7, #12]
 8028e1a:	6852      	ldr	r2, [r2, #4]
 8028e1c:	605a      	str	r2, [r3, #4]
    object_ptr->next->count += object_ptr->count;
 8028e1e:	68fb      	ldr	r3, [r7, #12]
 8028e20:	681b      	ldr	r3, [r3, #0]
 8028e22:	6999      	ldr	r1, [r3, #24]
 8028e24:	68fb      	ldr	r3, [r7, #12]
 8028e26:	699a      	ldr	r2, [r3, #24]
 8028e28:	68fb      	ldr	r3, [r7, #12]
 8028e2a:	681b      	ldr	r3, [r3, #0]
 8028e2c:	440a      	add	r2, r1
 8028e2e:	619a      	str	r2, [r3, #24]
    object_ptr->next = NULL;
 8028e30:	68fb      	ldr	r3, [r7, #12]
 8028e32:	2200      	movs	r2, #0
 8028e34:	601a      	str	r2, [r3, #0]
    object_ptr->prev = NULL;
 8028e36:	68fb      	ldr	r3, [r7, #12]
 8028e38:	2200      	movs	r2, #0
 8028e3a:	605a      	str	r2, [r3, #4]
}
 8028e3c:	bf00      	nop
 8028e3e:	3714      	adds	r7, #20
 8028e40:	46bd      	mov	sp, r7
 8028e42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028e46:	4770      	bx	lr
 8028e48:	20000fc8 	.word	0x20000fc8
 8028e4c:	200010e8 	.word	0x200010e8

08028e50 <SYSTIMER_lTimerHandler>:

/*
 * Handler function called from SysTick event handler.
 */
static void SYSTIMER_lTimerHandler(void)
{
 8028e50:	b580      	push	{r7, lr}
 8028e52:	b082      	sub	sp, #8
 8028e54:	af00      	add	r7, sp, #0
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
 8028e56:	4b30      	ldr	r3, [pc, #192]	; (8028f18 <SYSTIMER_lTimerHandler+0xc8>)
 8028e58:	681b      	ldr	r3, [r3, #0]
 8028e5a:	607b      	str	r3, [r7, #4]
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8028e5c:	e04e      	b.n	8028efc <SYSTIMER_lTimerHandler+0xac>
  {
    if (true == object_ptr->delete_swtmr)
 8028e5e:	687b      	ldr	r3, [r7, #4]
 8028e60:	f893 3020 	ldrb.w	r3, [r3, #32]
 8028e64:	2b00      	cmp	r3, #0
 8028e66:	d013      	beq.n	8028e90 <SYSTIMER_lTimerHandler+0x40>
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8028e68:	687b      	ldr	r3, [r7, #4]
 8028e6a:	695b      	ldr	r3, [r3, #20]
 8028e6c:	4618      	mov	r0, r3
 8028e6e:	f7ff ff8f 	bl	8028d90 <SYSTIMER_lRemoveTimerList>
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 8028e72:	687b      	ldr	r3, [r7, #4]
 8028e74:	2200      	movs	r2, #0
 8028e76:	735a      	strb	r2, [r3, #13]
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 8028e78:	687b      	ldr	r3, [r7, #4]
 8028e7a:	695b      	ldr	r3, [r3, #20]
 8028e7c:	2201      	movs	r2, #1
 8028e7e:	fa02 f303 	lsl.w	r3, r2, r3
 8028e82:	43da      	mvns	r2, r3
 8028e84:	4b25      	ldr	r3, [pc, #148]	; (8028f1c <SYSTIMER_lTimerHandler+0xcc>)
 8028e86:	681b      	ldr	r3, [r3, #0]
 8028e88:	4013      	ands	r3, r2
 8028e8a:	4a24      	ldr	r2, [pc, #144]	; (8028f1c <SYSTIMER_lTimerHandler+0xcc>)
 8028e8c:	6013      	str	r3, [r2, #0]
 8028e8e:	e032      	b.n	8028ef6 <SYSTIMER_lTimerHandler+0xa6>
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
 8028e90:	687b      	ldr	r3, [r7, #4]
 8028e92:	7b1b      	ldrb	r3, [r3, #12]
 8028e94:	2b00      	cmp	r3, #0
 8028e96:	d112      	bne.n	8028ebe <SYSTIMER_lTimerHandler+0x6e>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8028e98:	687b      	ldr	r3, [r7, #4]
 8028e9a:	7b5b      	ldrb	r3, [r3, #13]
 8028e9c:	2b01      	cmp	r3, #1
 8028e9e:	d12a      	bne.n	8028ef6 <SYSTIMER_lTimerHandler+0xa6>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8028ea0:	687b      	ldr	r3, [r7, #4]
 8028ea2:	695b      	ldr	r3, [r3, #20]
 8028ea4:	4618      	mov	r0, r3
 8028ea6:	f7ff ff73 	bl	8028d90 <SYSTIMER_lRemoveTimerList>
        /* Set timer status as SYSTIMER_STATE_STOPPED */
        object_ptr->state = SYSTIMER_STATE_STOPPED;
 8028eaa:	687b      	ldr	r3, [r7, #4]
 8028eac:	2202      	movs	r2, #2
 8028eae:	735a      	strb	r2, [r3, #13]
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 8028eb0:	687b      	ldr	r3, [r7, #4]
 8028eb2:	689b      	ldr	r3, [r3, #8]
 8028eb4:	687a      	ldr	r2, [r7, #4]
 8028eb6:	6912      	ldr	r2, [r2, #16]
 8028eb8:	4610      	mov	r0, r2
 8028eba:	4798      	blx	r3
 8028ebc:	e01b      	b.n	8028ef6 <SYSTIMER_lTimerHandler+0xa6>
      }
    }
    /* Check whether timer is periodic timer */
    else if (SYSTIMER_MODE_PERIODIC == object_ptr->mode)
 8028ebe:	687b      	ldr	r3, [r7, #4]
 8028ec0:	7b1b      	ldrb	r3, [r3, #12]
 8028ec2:	2b01      	cmp	r3, #1
 8028ec4:	d122      	bne.n	8028f0c <SYSTIMER_lTimerHandler+0xbc>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8028ec6:	687b      	ldr	r3, [r7, #4]
 8028ec8:	7b5b      	ldrb	r3, [r3, #13]
 8028eca:	2b01      	cmp	r3, #1
 8028ecc:	d113      	bne.n	8028ef6 <SYSTIMER_lTimerHandler+0xa6>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8028ece:	687b      	ldr	r3, [r7, #4]
 8028ed0:	695b      	ldr	r3, [r3, #20]
 8028ed2:	4618      	mov	r0, r3
 8028ed4:	f7ff ff5c 	bl	8028d90 <SYSTIMER_lRemoveTimerList>
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8028ed8:	687b      	ldr	r3, [r7, #4]
 8028eda:	69da      	ldr	r2, [r3, #28]
 8028edc:	687b      	ldr	r3, [r7, #4]
 8028ede:	619a      	str	r2, [r3, #24]
        /* Insert timer into timer list */
        SYSTIMER_lInsertTimerList((uint32_t)object_ptr->id);
 8028ee0:	687b      	ldr	r3, [r7, #4]
 8028ee2:	695b      	ldr	r3, [r3, #20]
 8028ee4:	4618      	mov	r0, r3
 8028ee6:	f7ff fe6d 	bl	8028bc4 <SYSTIMER_lInsertTimerList>
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 8028eea:	687b      	ldr	r3, [r7, #4]
 8028eec:	689b      	ldr	r3, [r3, #8]
 8028eee:	687a      	ldr	r2, [r7, #4]
 8028ef0:	6912      	ldr	r2, [r2, #16]
 8028ef2:	4610      	mov	r0, r2
 8028ef4:	4798      	blx	r3
    else
    {
      break;
    }
    /* Get first item of timer list */
    object_ptr = g_timer_list;
 8028ef6:	4b08      	ldr	r3, [pc, #32]	; (8028f18 <SYSTIMER_lTimerHandler+0xc8>)
 8028ef8:	681b      	ldr	r3, [r3, #0]
 8028efa:	607b      	str	r3, [r7, #4]
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8028efc:	687b      	ldr	r3, [r7, #4]
 8028efe:	2b00      	cmp	r3, #0
 8028f00:	d005      	beq.n	8028f0e <SYSTIMER_lTimerHandler+0xbe>
 8028f02:	687b      	ldr	r3, [r7, #4]
 8028f04:	699b      	ldr	r3, [r3, #24]
 8028f06:	2b00      	cmp	r3, #0
 8028f08:	d0a9      	beq.n	8028e5e <SYSTIMER_lTimerHandler+0xe>
  }
}
 8028f0a:	e000      	b.n	8028f0e <SYSTIMER_lTimerHandler+0xbe>
      break;
 8028f0c:	bf00      	nop
}
 8028f0e:	bf00      	nop
 8028f10:	3708      	adds	r7, #8
 8028f12:	46bd      	mov	sp, r7
 8028f14:	bd80      	pop	{r7, pc}
 8028f16:	bf00      	nop
 8028f18:	200010e8 	.word	0x200010e8
 8028f1c:	200010ec 	.word	0x200010ec

08028f20 <SysTick_Handler>:

/*
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
 8028f20:	b580      	push	{r7, lr}
 8028f22:	b082      	sub	sp, #8
 8028f24:	af00      	add	r7, sp, #0
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 8028f26:	4b0f      	ldr	r3, [pc, #60]	; (8028f64 <SysTick_Handler+0x44>)
 8028f28:	681b      	ldr	r3, [r3, #0]
 8028f2a:	607b      	str	r3, [r7, #4]
  g_systick_count++;
 8028f2c:	4b0e      	ldr	r3, [pc, #56]	; (8028f68 <SysTick_Handler+0x48>)
 8028f2e:	681b      	ldr	r3, [r3, #0]
 8028f30:	3301      	adds	r3, #1
 8028f32:	4a0d      	ldr	r2, [pc, #52]	; (8028f68 <SysTick_Handler+0x48>)
 8028f34:	6013      	str	r3, [r2, #0]

  if (NULL != object_ptr)
 8028f36:	687b      	ldr	r3, [r7, #4]
 8028f38:	2b00      	cmp	r3, #0
 8028f3a:	d00e      	beq.n	8028f5a <SysTick_Handler+0x3a>
  {
    if (object_ptr->count > 1UL)
 8028f3c:	687b      	ldr	r3, [r7, #4]
 8028f3e:	699b      	ldr	r3, [r3, #24]
 8028f40:	2b01      	cmp	r3, #1
 8028f42:	d905      	bls.n	8028f50 <SysTick_Handler+0x30>
    {
      object_ptr->count--;
 8028f44:	687b      	ldr	r3, [r7, #4]
 8028f46:	699b      	ldr	r3, [r3, #24]
 8028f48:	1e5a      	subs	r2, r3, #1
 8028f4a:	687b      	ldr	r3, [r7, #4]
 8028f4c:	619a      	str	r2, [r3, #24]
    {
      object_ptr->count = 0U;
      SYSTIMER_lTimerHandler();
    }
  }
}
 8028f4e:	e004      	b.n	8028f5a <SysTick_Handler+0x3a>
      object_ptr->count = 0U;
 8028f50:	687b      	ldr	r3, [r7, #4]
 8028f52:	2200      	movs	r2, #0
 8028f54:	619a      	str	r2, [r3, #24]
      SYSTIMER_lTimerHandler();
 8028f56:	f7ff ff7b 	bl	8028e50 <SYSTIMER_lTimerHandler>
}
 8028f5a:	bf00      	nop
 8028f5c:	3708      	adds	r7, #8
 8028f5e:	46bd      	mov	sp, r7
 8028f60:	bd80      	pop	{r7, pc}
 8028f62:	bf00      	nop
 8028f64:	200010e8 	.word	0x200010e8
 8028f68:	200010f0 	.word	0x200010f0

08028f6c <SYSTIMER_Init>:

/*
 * Initialization function which initializes the SYSTIMER APP, configures SysTick timer and SysTick exception.
 */
SYSTIMER_STATUS_t SYSTIMER_Init(SYSTIMER_t *handle)
{
 8028f6c:	b580      	push	{r7, lr}
 8028f6e:	b084      	sub	sp, #16
 8028f70:	af00      	add	r7, sp, #0
 8028f72:	6078      	str	r0, [r7, #4]
  SYSTIMER_STATUS_t status = SYSTIMER_STATUS_SUCCESS;
 8028f74:	2300      	movs	r3, #0
 8028f76:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("SYSTIMER_Init: SYSTIMER APP handle pointer uninitialized", (handle != NULL));

  /* Check APP initialization status to ensure whether SYSTIMER_Init called or not, initialize SYSTIMER if
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
 8028f78:	687b      	ldr	r3, [r7, #4]
 8028f7a:	781b      	ldrb	r3, [r3, #0]
 8028f7c:	f083 0301 	eor.w	r3, r3, #1
 8028f80:	b2db      	uxtb	r3, r3
 8028f82:	2b00      	cmp	r3, #0
 8028f84:	d021      	beq.n	8028fca <SYSTIMER_Init+0x5e>
  {
    /* Initialize the header of the list */
    g_timer_list = NULL;
 8028f86:	4b13      	ldr	r3, [pc, #76]	; (8028fd4 <SYSTIMER_Init+0x68>)
 8028f88:	2200      	movs	r2, #0
 8028f8a:	601a      	str	r2, [r3, #0]
    /* Initialize SysTick timer */
    status = (SYSTIMER_STATUS_t)SysTick_Config((uint32_t)(SYSTIMER_SYSTICK_CLOCK * SYSTIMER_TICK_PERIOD));
 8028f8c:	f642 60e0 	movw	r0, #12000	; 0x2ee0
 8028f90:	f7ff fdf6 	bl	8028b80 <SysTick_Config>
 8028f94:	4603      	mov	r3, r0
 8028f96:	73fb      	strb	r3, [r7, #15]

    if (SYSTIMER_STATUS_FAILURE == status)
 8028f98:	7bfb      	ldrb	r3, [r7, #15]
 8028f9a:	2b01      	cmp	r3, #1
 8028f9c:	d015      	beq.n	8028fca <SYSTIMER_Init+0x5e>
    }
    else
    {
#if (UC_FAMILY == XMC4)
      /* setting of First SW Timer period is always and subpriority value for XMC4000 devices */
      NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(
 8028f9e:	f7ff fd83 	bl	8028aa8 <__NVIC_GetPriorityGrouping>
 8028fa2:	4603      	mov	r3, r0
 8028fa4:	2200      	movs	r2, #0
 8028fa6:	213f      	movs	r1, #63	; 0x3f
 8028fa8:	4618      	mov	r0, r3
 8028faa:	f7ff fdb5 	bl	8028b18 <NVIC_EncodePriority>
 8028fae:	4603      	mov	r3, r0
 8028fb0:	4619      	mov	r1, r3
 8028fb2:	f04f 30ff 	mov.w	r0, #4294967295
 8028fb6:	f7ff fd85 	bl	8028ac4 <__NVIC_SetPriority>
      NVIC_GetPriorityGrouping(), SYSTIMER_PRIORITY, SYSTIMER_SUBPRIORITY));
#elif (UC_FAMILY == XMC1)
      /* setting of priority value for XMC1000 devices */
      NVIC_SetPriority(SysTick_IRQn, SYSTIMER_PRIORITY);
#endif      
      g_timer_tracker = 0U;
 8028fba:	4b07      	ldr	r3, [pc, #28]	; (8028fd8 <SYSTIMER_Init+0x6c>)
 8028fbc:	2200      	movs	r2, #0
 8028fbe:	601a      	str	r2, [r3, #0]
      /* Update the Initialization status of the SYSTIMER APP instance */
      handle->init_status = true;
 8028fc0:	687b      	ldr	r3, [r7, #4]
 8028fc2:	2201      	movs	r2, #1
 8028fc4:	701a      	strb	r2, [r3, #0]
      status = SYSTIMER_STATUS_SUCCESS;
 8028fc6:	2300      	movs	r3, #0
 8028fc8:	73fb      	strb	r3, [r7, #15]
    }
  }

  return (status);
 8028fca:	7bfb      	ldrb	r3, [r7, #15]
}
 8028fcc:	4618      	mov	r0, r3
 8028fce:	3710      	adds	r7, #16
 8028fd0:	46bd      	mov	sp, r7
 8028fd2:	bd80      	pop	{r7, pc}
 8028fd4:	200010e8 	.word	0x200010e8
 8028fd8:	200010ec 	.word	0x200010ec

08028fdc <SYSTIMER_CreateTimer>:
  uint32_t period,
  SYSTIMER_MODE_t mode,
  SYSTIMER_CALLBACK_t callback,
  void  *args
)
{
 8028fdc:	b480      	push	{r7}
 8028fde:	b089      	sub	sp, #36	; 0x24
 8028fe0:	af00      	add	r7, sp, #0
 8028fe2:	60f8      	str	r0, [r7, #12]
 8028fe4:	607a      	str	r2, [r7, #4]
 8028fe6:	603b      	str	r3, [r7, #0]
 8028fe8:	460b      	mov	r3, r1
 8028fea:	72fb      	strb	r3, [r7, #11]
  uint32_t id = 0U;
 8028fec:	2300      	movs	r3, #0
 8028fee:	61fb      	str	r3, [r7, #28]
  uint32_t count = 0U;
 8028ff0:	2300      	movs	r3, #0
 8028ff2:	61bb      	str	r3, [r7, #24]
  uint32_t period_ratio = 0U;
 8028ff4:	2300      	movs	r3, #0
 8028ff6:	617b      	str	r3, [r7, #20]
            ((period >= SYSTIMER_TICK_PERIOD_US) && (period > 0U) && (period <= 0xFFFFFFFFU)));
  XMC_ASSERT("SYSTIMER_CreateTimer: Timer creation failure due to invalid timer mode",
            ((SYSTIMER_MODE_ONE_SHOT == mode) || (SYSTIMER_MODE_PERIODIC == mode)));
  XMC_ASSERT("SYSTIMER_CreateTimer: Can not create software without user callback", (NULL != callback));
  
  if (period < SYSTIMER_TICK_PERIOD_US)
 8028ff8:	68fb      	ldr	r3, [r7, #12]
 8028ffa:	2b63      	cmp	r3, #99	; 0x63
 8028ffc:	d802      	bhi.n	8029004 <SYSTIMER_CreateTimer+0x28>
  {
    id = 0U;
 8028ffe:	2300      	movs	r3, #0
 8029000:	61fb      	str	r3, [r7, #28]
 8029002:	e07c      	b.n	80290fe <SYSTIMER_CreateTimer+0x122>
  }
  else
  {
    for (count = 0U; count < SYSTIMER_CFG_MAX_TMR; count++)
 8029004:	2300      	movs	r3, #0
 8029006:	61bb      	str	r3, [r7, #24]
 8029008:	e076      	b.n	80290f8 <SYSTIMER_CreateTimer+0x11c>
    {
      /* Check for free timer ID */
      if (0U == (g_timer_tracker & (1U << count)))
 802900a:	2201      	movs	r2, #1
 802900c:	69bb      	ldr	r3, [r7, #24]
 802900e:	409a      	lsls	r2, r3
 8029010:	4b3e      	ldr	r3, [pc, #248]	; (802910c <SYSTIMER_CreateTimer+0x130>)
 8029012:	681b      	ldr	r3, [r3, #0]
 8029014:	4013      	ands	r3, r2
 8029016:	2b00      	cmp	r3, #0
 8029018:	d16b      	bne.n	80290f2 <SYSTIMER_CreateTimer+0x116>
      {
        /* If yes, assign ID to this timer */
        g_timer_tracker |= (1U << count);
 802901a:	2201      	movs	r2, #1
 802901c:	69bb      	ldr	r3, [r7, #24]
 802901e:	409a      	lsls	r2, r3
 8029020:	4b3a      	ldr	r3, [pc, #232]	; (802910c <SYSTIMER_CreateTimer+0x130>)
 8029022:	681b      	ldr	r3, [r3, #0]
 8029024:	4313      	orrs	r3, r2
 8029026:	4a39      	ldr	r2, [pc, #228]	; (802910c <SYSTIMER_CreateTimer+0x130>)
 8029028:	6013      	str	r3, [r2, #0]
        /* Initialize the timer as per input values */
        g_timer_tbl[count].id     = count;
 802902a:	4939      	ldr	r1, [pc, #228]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 802902c:	69ba      	ldr	r2, [r7, #24]
 802902e:	4613      	mov	r3, r2
 8029030:	00db      	lsls	r3, r3, #3
 8029032:	4413      	add	r3, r2
 8029034:	009b      	lsls	r3, r3, #2
 8029036:	440b      	add	r3, r1
 8029038:	3314      	adds	r3, #20
 802903a:	69ba      	ldr	r2, [r7, #24]
 802903c:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].mode   = mode;
 802903e:	4934      	ldr	r1, [pc, #208]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 8029040:	69ba      	ldr	r2, [r7, #24]
 8029042:	4613      	mov	r3, r2
 8029044:	00db      	lsls	r3, r3, #3
 8029046:	4413      	add	r3, r2
 8029048:	009b      	lsls	r3, r3, #2
 802904a:	440b      	add	r3, r1
 802904c:	330c      	adds	r3, #12
 802904e:	7afa      	ldrb	r2, [r7, #11]
 8029050:	701a      	strb	r2, [r3, #0]
        g_timer_tbl[count].state  = SYSTIMER_STATE_STOPPED;
 8029052:	492f      	ldr	r1, [pc, #188]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 8029054:	69ba      	ldr	r2, [r7, #24]
 8029056:	4613      	mov	r3, r2
 8029058:	00db      	lsls	r3, r3, #3
 802905a:	4413      	add	r3, r2
 802905c:	009b      	lsls	r3, r3, #2
 802905e:	440b      	add	r3, r1
 8029060:	330d      	adds	r3, #13
 8029062:	2202      	movs	r2, #2
 8029064:	701a      	strb	r2, [r3, #0]
        period_ratio = (uint32_t)(period / SYSTIMER_TICK_PERIOD_US);
 8029066:	68fb      	ldr	r3, [r7, #12]
 8029068:	4a2a      	ldr	r2, [pc, #168]	; (8029114 <SYSTIMER_CreateTimer+0x138>)
 802906a:	fba2 2303 	umull	r2, r3, r2, r3
 802906e:	095b      	lsrs	r3, r3, #5
 8029070:	617b      	str	r3, [r7, #20]
        g_timer_tbl[count].count  = (period_ratio + HW_TIMER_ADDITIONAL_CNT);
 8029072:	697b      	ldr	r3, [r7, #20]
 8029074:	1c59      	adds	r1, r3, #1
 8029076:	4826      	ldr	r0, [pc, #152]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 8029078:	69ba      	ldr	r2, [r7, #24]
 802907a:	4613      	mov	r3, r2
 802907c:	00db      	lsls	r3, r3, #3
 802907e:	4413      	add	r3, r2
 8029080:	009b      	lsls	r3, r3, #2
 8029082:	4403      	add	r3, r0
 8029084:	3318      	adds	r3, #24
 8029086:	6019      	str	r1, [r3, #0]
        g_timer_tbl[count].reload  = period_ratio;
 8029088:	4921      	ldr	r1, [pc, #132]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 802908a:	69ba      	ldr	r2, [r7, #24]
 802908c:	4613      	mov	r3, r2
 802908e:	00db      	lsls	r3, r3, #3
 8029090:	4413      	add	r3, r2
 8029092:	009b      	lsls	r3, r3, #2
 8029094:	440b      	add	r3, r1
 8029096:	331c      	adds	r3, #28
 8029098:	697a      	ldr	r2, [r7, #20]
 802909a:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].callback = callback;
 802909c:	491c      	ldr	r1, [pc, #112]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 802909e:	69ba      	ldr	r2, [r7, #24]
 80290a0:	4613      	mov	r3, r2
 80290a2:	00db      	lsls	r3, r3, #3
 80290a4:	4413      	add	r3, r2
 80290a6:	009b      	lsls	r3, r3, #2
 80290a8:	440b      	add	r3, r1
 80290aa:	3308      	adds	r3, #8
 80290ac:	687a      	ldr	r2, [r7, #4]
 80290ae:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].args = args;
 80290b0:	4917      	ldr	r1, [pc, #92]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 80290b2:	69ba      	ldr	r2, [r7, #24]
 80290b4:	4613      	mov	r3, r2
 80290b6:	00db      	lsls	r3, r3, #3
 80290b8:	4413      	add	r3, r2
 80290ba:	009b      	lsls	r3, r3, #2
 80290bc:	440b      	add	r3, r1
 80290be:	3310      	adds	r3, #16
 80290c0:	683a      	ldr	r2, [r7, #0]
 80290c2:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].prev   = NULL;
 80290c4:	4912      	ldr	r1, [pc, #72]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 80290c6:	69ba      	ldr	r2, [r7, #24]
 80290c8:	4613      	mov	r3, r2
 80290ca:	00db      	lsls	r3, r3, #3
 80290cc:	4413      	add	r3, r2
 80290ce:	009b      	lsls	r3, r3, #2
 80290d0:	440b      	add	r3, r1
 80290d2:	3304      	adds	r3, #4
 80290d4:	2200      	movs	r2, #0
 80290d6:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].next   = NULL;
 80290d8:	490d      	ldr	r1, [pc, #52]	; (8029110 <SYSTIMER_CreateTimer+0x134>)
 80290da:	69ba      	ldr	r2, [r7, #24]
 80290dc:	4613      	mov	r3, r2
 80290de:	00db      	lsls	r3, r3, #3
 80290e0:	4413      	add	r3, r2
 80290e2:	009b      	lsls	r3, r3, #2
 80290e4:	440b      	add	r3, r1
 80290e6:	2200      	movs	r2, #0
 80290e8:	601a      	str	r2, [r3, #0]
        id = count + 1U;
 80290ea:	69bb      	ldr	r3, [r7, #24]
 80290ec:	3301      	adds	r3, #1
 80290ee:	61fb      	str	r3, [r7, #28]
        break;
 80290f0:	e005      	b.n	80290fe <SYSTIMER_CreateTimer+0x122>
    for (count = 0U; count < SYSTIMER_CFG_MAX_TMR; count++)
 80290f2:	69bb      	ldr	r3, [r7, #24]
 80290f4:	3301      	adds	r3, #1
 80290f6:	61bb      	str	r3, [r7, #24]
 80290f8:	69bb      	ldr	r3, [r7, #24]
 80290fa:	2b07      	cmp	r3, #7
 80290fc:	d985      	bls.n	802900a <SYSTIMER_CreateTimer+0x2e>
      }
    }

  }

  return (id);
 80290fe:	69fb      	ldr	r3, [r7, #28]
}  
 8029100:	4618      	mov	r0, r3
 8029102:	3724      	adds	r7, #36	; 0x24
 8029104:	46bd      	mov	sp, r7
 8029106:	f85d 7b04 	ldr.w	r7, [sp], #4
 802910a:	4770      	bx	lr
 802910c:	200010ec 	.word	0x200010ec
 8029110:	20000fc8 	.word	0x20000fc8
 8029114:	51eb851f 	.word	0x51eb851f

08029118 <SYSTIMER_StartTimer>:

/*
 *  API to start the software timer.
 */
SYSTIMER_STATUS_t SYSTIMER_StartTimer(uint32_t id)
{
 8029118:	b580      	push	{r7, lr}
 802911a:	b084      	sub	sp, #16
 802911c:	af00      	add	r7, sp, #0
 802911e:	6078      	str	r0, [r7, #4]
  SYSTIMER_STATUS_t status;
  status = SYSTIMER_STATUS_FAILURE;
 8029120:	2301      	movs	r3, #1
 8029122:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("SYSTIMER_StartTimer: Failure in timer restart operation due to invalid timer ID",
            ((id <= SYSTIMER_CFG_MAX_TMR) && (id > 0U)));
  XMC_ASSERT("SYSTIMER_StartTimer: Error during start of software timer", (0U != (g_timer_tracker & (1U << (id - 1U)))));
  
  /* Check if timer is running */
  if (SYSTIMER_STATE_STOPPED == g_timer_tbl[id - 1U].state)
 8029124:	687b      	ldr	r3, [r7, #4]
 8029126:	1e5a      	subs	r2, r3, #1
 8029128:	491a      	ldr	r1, [pc, #104]	; (8029194 <SYSTIMER_StartTimer+0x7c>)
 802912a:	4613      	mov	r3, r2
 802912c:	00db      	lsls	r3, r3, #3
 802912e:	4413      	add	r3, r2
 8029130:	009b      	lsls	r3, r3, #2
 8029132:	440b      	add	r3, r1
 8029134:	330d      	adds	r3, #13
 8029136:	781b      	ldrb	r3, [r3, #0]
 8029138:	2b02      	cmp	r3, #2
 802913a:	d126      	bne.n	802918a <SYSTIMER_StartTimer+0x72>
  {
    g_timer_tbl[id - 1U].count = (g_timer_tbl[id - 1U].reload + HW_TIMER_ADDITIONAL_CNT);
 802913c:	687b      	ldr	r3, [r7, #4]
 802913e:	1e5a      	subs	r2, r3, #1
 8029140:	4914      	ldr	r1, [pc, #80]	; (8029194 <SYSTIMER_StartTimer+0x7c>)
 8029142:	4613      	mov	r3, r2
 8029144:	00db      	lsls	r3, r3, #3
 8029146:	4413      	add	r3, r2
 8029148:	009b      	lsls	r3, r3, #2
 802914a:	440b      	add	r3, r1
 802914c:	331c      	adds	r3, #28
 802914e:	681b      	ldr	r3, [r3, #0]
 8029150:	687a      	ldr	r2, [r7, #4]
 8029152:	3a01      	subs	r2, #1
 8029154:	1c59      	adds	r1, r3, #1
 8029156:	480f      	ldr	r0, [pc, #60]	; (8029194 <SYSTIMER_StartTimer+0x7c>)
 8029158:	4613      	mov	r3, r2
 802915a:	00db      	lsls	r3, r3, #3
 802915c:	4413      	add	r3, r2
 802915e:	009b      	lsls	r3, r3, #2
 8029160:	4403      	add	r3, r0
 8029162:	3318      	adds	r3, #24
 8029164:	6019      	str	r1, [r3, #0]
    /* set timer status as SYSTIMER_STATE_RUNNING */
    g_timer_tbl[id - 1U].state = SYSTIMER_STATE_RUNNING;
 8029166:	687b      	ldr	r3, [r7, #4]
 8029168:	1e5a      	subs	r2, r3, #1
 802916a:	490a      	ldr	r1, [pc, #40]	; (8029194 <SYSTIMER_StartTimer+0x7c>)
 802916c:	4613      	mov	r3, r2
 802916e:	00db      	lsls	r3, r3, #3
 8029170:	4413      	add	r3, r2
 8029172:	009b      	lsls	r3, r3, #2
 8029174:	440b      	add	r3, r1
 8029176:	330d      	adds	r3, #13
 8029178:	2201      	movs	r2, #1
 802917a:	701a      	strb	r2, [r3, #0]
    /* Insert this timer into timer list */
    SYSTIMER_lInsertTimerList((id - 1U));
 802917c:	687b      	ldr	r3, [r7, #4]
 802917e:	3b01      	subs	r3, #1
 8029180:	4618      	mov	r0, r3
 8029182:	f7ff fd1f 	bl	8028bc4 <SYSTIMER_lInsertTimerList>
    status = SYSTIMER_STATUS_SUCCESS;
 8029186:	2300      	movs	r3, #0
 8029188:	73fb      	strb	r3, [r7, #15]
  }

  return (status);
 802918a:	7bfb      	ldrb	r3, [r7, #15]
}
 802918c:	4618      	mov	r0, r3
 802918e:	3710      	adds	r7, #16
 8029190:	46bd      	mov	sp, r7
 8029192:	bd80      	pop	{r7, pc}
 8029194:	20000fc8 	.word	0x20000fc8

08029198 <XMC_CCU4_EnableClock>:
{
 8029198:	b480      	push	{r7}
 802919a:	b083      	sub	sp, #12
 802919c:	af00      	add	r7, sp, #0
 802919e:	6078      	str	r0, [r7, #4]
 80291a0:	460b      	mov	r3, r1
 80291a2:	70fb      	strb	r3, [r7, #3]
  module->GIDLC = ((uint32_t) 1) << slice_number;
 80291a4:	78fb      	ldrb	r3, [r7, #3]
 80291a6:	2201      	movs	r2, #1
 80291a8:	409a      	lsls	r2, r3
 80291aa:	687b      	ldr	r3, [r7, #4]
 80291ac:	60da      	str	r2, [r3, #12]
}
 80291ae:	bf00      	nop
 80291b0:	370c      	adds	r7, #12
 80291b2:	46bd      	mov	sp, r7
 80291b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80291b8:	4770      	bx	lr

080291ba <XMC_CCU4_SLICE_EnableTrap>:
{
 80291ba:	b480      	push	{r7}
 80291bc:	b083      	sub	sp, #12
 80291be:	af00      	add	r7, sp, #0
 80291c0:	6078      	str	r0, [r7, #4]
  slice->TC |= (uint32_t) CCU4_CC4_TC_TRAPE_Msk;
 80291c2:	687b      	ldr	r3, [r7, #4]
 80291c4:	695b      	ldr	r3, [r3, #20]
 80291c6:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 80291ca:	687b      	ldr	r3, [r7, #4]
 80291cc:	615a      	str	r2, [r3, #20]
}
 80291ce:	bf00      	nop
 80291d0:	370c      	adds	r7, #12
 80291d2:	46bd      	mov	sp, r7
 80291d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80291d8:	4770      	bx	lr

080291da <XMC_CCU4_SLICE_StartTimer>:
{
 80291da:	b480      	push	{r7}
 80291dc:	b083      	sub	sp, #12
 80291de:	af00      	add	r7, sp, #0
 80291e0:	6078      	str	r0, [r7, #4]
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 80291e2:	687b      	ldr	r3, [r7, #4]
 80291e4:	2201      	movs	r2, #1
 80291e6:	60da      	str	r2, [r3, #12]
}
 80291e8:	bf00      	nop
 80291ea:	370c      	adds	r7, #12
 80291ec:	46bd      	mov	sp, r7
 80291ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80291f2:	4770      	bx	lr

080291f4 <XMC_CCU4_SLICE_StopTimer>:
{
 80291f4:	b480      	push	{r7}
 80291f6:	b083      	sub	sp, #12
 80291f8:	af00      	add	r7, sp, #0
 80291fa:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 80291fc:	687b      	ldr	r3, [r7, #4]
 80291fe:	2201      	movs	r2, #1
 8029200:	611a      	str	r2, [r3, #16]
}
 8029202:	bf00      	nop
 8029204:	370c      	adds	r7, #12
 8029206:	46bd      	mov	sp, r7
 8029208:	f85d 7b04 	ldr.w	r7, [sp], #4
 802920c:	4770      	bx	lr

0802920e <XMC_CCU4_SLICE_ClearTimer>:
{
 802920e:	b480      	push	{r7}
 8029210:	b083      	sub	sp, #12
 8029212:	af00      	add	r7, sp, #0
 8029214:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8029216:	687b      	ldr	r3, [r7, #4]
 8029218:	2202      	movs	r2, #2
 802921a:	611a      	str	r2, [r3, #16]
}
 802921c:	bf00      	nop
 802921e:	370c      	adds	r7, #12
 8029220:	46bd      	mov	sp, r7
 8029222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029226:	4770      	bx	lr

08029228 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
{
 8029228:	b480      	push	{r7}
 802922a:	b083      	sub	sp, #12
 802922c:	af00      	add	r7, sp, #0
 802922e:	6078      	str	r0, [r7, #4]
 8029230:	460b      	mov	r3, r1
 8029232:	807b      	strh	r3, [r7, #2]
  slice->PRS = (uint32_t) period_val;
 8029234:	887a      	ldrh	r2, [r7, #2]
 8029236:	687b      	ldr	r3, [r7, #4]
 8029238:	635a      	str	r2, [r3, #52]	; 0x34
}
 802923a:	bf00      	nop
 802923c:	370c      	adds	r7, #12
 802923e:	46bd      	mov	sp, r7
 8029240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029244:	4770      	bx	lr

08029246 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
{
 8029246:	b480      	push	{r7}
 8029248:	b083      	sub	sp, #12
 802924a:	af00      	add	r7, sp, #0
 802924c:	6078      	str	r0, [r7, #4]
 802924e:	460b      	mov	r3, r1
 8029250:	807b      	strh	r3, [r7, #2]
  slice->CRS = (uint32_t) compare_val;
 8029252:	887a      	ldrh	r2, [r7, #2]
 8029254:	687b      	ldr	r3, [r7, #4]
 8029256:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8029258:	bf00      	nop
 802925a:	370c      	adds	r7, #12
 802925c:	46bd      	mov	sp, r7
 802925e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029262:	4770      	bx	lr

08029264 <XMC_CCU4_EnableShadowTransfer>:
{
 8029264:	b480      	push	{r7}
 8029266:	b083      	sub	sp, #12
 8029268:	af00      	add	r7, sp, #0
 802926a:	6078      	str	r0, [r7, #4]
 802926c:	6039      	str	r1, [r7, #0]
  module->GCSS = (uint32_t)shadow_transfer_msk;
 802926e:	687b      	ldr	r3, [r7, #4]
 8029270:	683a      	ldr	r2, [r7, #0]
 8029272:	611a      	str	r2, [r3, #16]
}
 8029274:	bf00      	nop
 8029276:	370c      	adds	r7, #12
 8029278:	46bd      	mov	sp, r7
 802927a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802927e:	4770      	bx	lr

08029280 <XMC_CCU4_SLICE_EnableEvent>:
{
 8029280:	b480      	push	{r7}
 8029282:	b083      	sub	sp, #12
 8029284:	af00      	add	r7, sp, #0
 8029286:	6078      	str	r0, [r7, #4]
 8029288:	460b      	mov	r3, r1
 802928a:	70fb      	strb	r3, [r7, #3]
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 802928c:	687b      	ldr	r3, [r7, #4]
 802928e:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8029292:	78fb      	ldrb	r3, [r7, #3]
 8029294:	2101      	movs	r1, #1
 8029296:	fa01 f303 	lsl.w	r3, r1, r3
 802929a:	431a      	orrs	r2, r3
 802929c:	687b      	ldr	r3, [r7, #4]
 802929e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 80292a2:	bf00      	nop
 80292a4:	370c      	adds	r7, #12
 80292a6:	46bd      	mov	sp, r7
 80292a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80292ac:	4770      	bx	lr

080292ae <XMC_CCU4_SLICE_ClearEvent>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_EnableEvent()<BR> XMC_CCU4_SLICE_SetEvent()<BR> XMC_CCU4_SLICE_GetEvent().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 80292ae:	b480      	push	{r7}
 80292b0:	b083      	sub	sp, #12
 80292b2:	af00      	add	r7, sp, #0
 80292b4:	6078      	str	r0, [r7, #4]
 80292b6:	460b      	mov	r3, r1
 80292b8:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR = ((uint32_t) 1) << ((uint32_t) event);
 80292ba:	78fb      	ldrb	r3, [r7, #3]
 80292bc:	2201      	movs	r2, #1
 80292be:	409a      	lsls	r2, r3
 80292c0:	687b      	ldr	r3, [r7, #4]
 80292c2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
 80292c6:	bf00      	nop
 80292c8:	370c      	adds	r7, #12
 80292ca:	46bd      	mov	sp, r7
 80292cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80292d0:	4770      	bx	lr

080292d2 <PWM_CCU4_Init>:
  return version;
}

/* This function initializes the app */
PWM_CCU4_STATUS_t PWM_CCU4_Init(PWM_CCU4_t* handle_ptr)
{
 80292d2:	b580      	push	{r7, lr}
 80292d4:	b086      	sub	sp, #24
 80292d6:	af00      	add	r7, sp, #0
 80292d8:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;
  GLOBAL_CCU4_STATUS_t status_ccu4_global;
  uint32_t frequency_module;
  uint32_t prescalar;

  status = PWM_CCU4_STATUS_FAILURE;
 80292da:	2301      	movs	r3, #1
 80292dc:	75fb      	strb	r3, [r7, #23]
  status_ccu4_global = GLOBAL_CCU4_STATUS_FAILURE;
 80292de:	2301      	movs	r3, #1
 80292e0:	75bb      	strb	r3, [r7, #22]
  XMC_ASSERT("PWM_CCU4_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU4_STATE_UNINITIALIZED == handle_ptr->state)
 80292e2:	687b      	ldr	r3, [r7, #4]
 80292e4:	7f1b      	ldrb	r3, [r3, #28]
 80292e6:	2b00      	cmp	r3, #0
 80292e8:	f040 808a 	bne.w	8029400 <PWM_CCU4_Init+0x12e>
  {
    /* Initialize consumed Apps */
    status_ccu4_global = GLOBAL_CCU4_Init(handle_ptr->config_ptr->global_ccu4_handle);
 80292ec:	687b      	ldr	r3, [r7, #4]
 80292ee:	681b      	ldr	r3, [r3, #0]
 80292f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80292f2:	4618      	mov	r0, r3
 80292f4:	f000 fb7f 	bl	80299f6 <GLOBAL_CCU4_Init>
 80292f8:	4603      	mov	r3, r0
 80292fa:	75bb      	strb	r3, [r7, #22]

    /* Initialize CCU4x_CC4y slice */
    if (GLOBAL_CCU4_STATUS_SUCCESS == status_ccu4_global)
 80292fc:	7dbb      	ldrb	r3, [r7, #22]
 80292fe:	2b00      	cmp	r3, #0
 8029300:	d17a      	bne.n	80293f8 <PWM_CCU4_Init+0x126>
    {
      XMC_DEBUG("PWM_CCU4_Init:Initilizing slice");

      /* Configure CCU4x_CC4y slice as timer */
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr);
 8029302:	687b      	ldr	r3, [r7, #4]
 8029304:	689a      	ldr	r2, [r3, #8]
 8029306:	687b      	ldr	r3, [r7, #4]
 8029308:	681b      	ldr	r3, [r3, #0]
 802930a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802930c:	4619      	mov	r1, r3
 802930e:	4610      	mov	r0, r2
 8029310:	f7fe fa0b 	bl	802772a <XMC_CCU4_SLICE_CompareInit>
      /* Set period match value of the timer  */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->period_value);
 8029314:	687b      	ldr	r3, [r7, #4]
 8029316:	689a      	ldr	r2, [r3, #8]
 8029318:	687b      	ldr	r3, [r7, #4]
 802931a:	681b      	ldr	r3, [r3, #0]
 802931c:	885b      	ldrh	r3, [r3, #2]
 802931e:	4619      	mov	r1, r3
 8029320:	4610      	mov	r0, r2
 8029322:	f7ff ff81 	bl	8029228 <XMC_CCU4_SLICE_SetTimerPeriodMatch>

      /* Set timer compare match value for channel 1 */
      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t) handle_ptr->config_ptr->compare_value);
 8029326:	687b      	ldr	r3, [r7, #4]
 8029328:	689a      	ldr	r2, [r3, #8]
 802932a:	687b      	ldr	r3, [r7, #4]
 802932c:	681b      	ldr	r3, [r3, #0]
 802932e:	889b      	ldrh	r3, [r3, #4]
 8029330:	4619      	mov	r1, r3
 8029332:	4610      	mov	r0, r2
 8029334:	f7ff ff87 	bl	8029246 <XMC_CCU4_SLICE_SetTimerCompareMatch>

      if (1U == handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->mcm_enable)
 8029338:	687b      	ldr	r3, [r7, #4]
 802933a:	681b      	ldr	r3, [r3, #0]
 802933c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802933e:	78db      	ldrb	r3, [r3, #3]
 8029340:	f003 0302 	and.w	r3, r3, #2
 8029344:	b2db      	uxtb	r3, r3
 8029346:	2b00      	cmp	r3, #0
 8029348:	d008      	beq.n	802935c <PWM_CCU4_Init+0x8a>
      {
        XMC_CCU4_SetMultiChannelShadowTransferMode(handle_ptr->ccu4_module_ptr,
 802934a:	687b      	ldr	r3, [r7, #4]
 802934c:	685a      	ldr	r2, [r3, #4]
                                                   (uint32_t) handle_ptr->config_ptr->mcm_shadow_txfr_mode);
 802934e:	687b      	ldr	r3, [r7, #4]
 8029350:	681b      	ldr	r3, [r3, #0]
 8029352:	6b5b      	ldr	r3, [r3, #52]	; 0x34
        XMC_CCU4_SetMultiChannelShadowTransferMode(handle_ptr->ccu4_module_ptr,
 8029354:	4619      	mov	r1, r3
 8029356:	4610      	mov	r0, r2
 8029358:	f7fe f9cb 	bl	80276f2 <XMC_CCU4_SetMultiChannelShadowTransferMode>
        XMC_CCU4_SLICE_EnableCascadedShadowTransfer(handle_ptr->ccu4_slice_ptr);
      }
#endif

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->shadow_txfr_msk);
 802935c:	687b      	ldr	r3, [r7, #4]
 802935e:	685a      	ldr	r2, [r3, #4]
 8029360:	687b      	ldr	r3, [r7, #4]
 8029362:	691b      	ldr	r3, [r3, #16]
 8029364:	4619      	mov	r1, r3
 8029366:	4610      	mov	r0, r2
 8029368:	f7ff ff7c 	bl	8029264 <XMC_CCU4_EnableShadowTransfer>
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->dither_shadow_txfr_msk);
 802936c:	687b      	ldr	r3, [r7, #4]
 802936e:	685a      	ldr	r2, [r3, #4]
 8029370:	687b      	ldr	r3, [r7, #4]
 8029372:	695b      	ldr	r3, [r3, #20]
 8029374:	4619      	mov	r1, r3
 8029376:	4610      	mov	r0, r2
 8029378:	f7ff ff74 	bl	8029264 <XMC_CCU4_EnableShadowTransfer>

      /* Configure events */
      PWM_CCU4_lConfigure_Events(handle_ptr);
 802937c:	6878      	ldr	r0, [r7, #4]
 802937e:	f000 f8da 	bl	8029536 <PWM_CCU4_lConfigure_Events>

      /* Enable the interrupts */
      PWM_CCU4_lInit_Interrupt(handle_ptr);
 8029382:	6878      	ldr	r0, [r7, #4]
 8029384:	f000 f843 	bl	802940e <PWM_CCU4_lInit_Interrupt>

      /*Initializes the GPIO*/
      if ((bool) true == handle_ptr->config_ptr->gpio_ch_out_enable)
 8029388:	687b      	ldr	r3, [r7, #4]
 802938a:	681b      	ldr	r3, [r3, #0]
 802938c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8029390:	2b00      	cmp	r3, #0
 8029392:	d00c      	beq.n	80293ae <PWM_CCU4_Init+0xdc>
      {
        XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch_out_ptr, handle_ptr->config_ptr->gpio_ch_out_pin,
 8029394:	687b      	ldr	r3, [r7, #4]
 8029396:	681b      	ldr	r3, [r3, #0]
 8029398:	6c18      	ldr	r0, [r3, #64]	; 0x40
 802939a:	687b      	ldr	r3, [r7, #4]
 802939c:	681b      	ldr	r3, [r3, #0]
 802939e:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
                      handle_ptr->config_ptr->gpio_ch_out_config_ptr);
 80293a2:	687b      	ldr	r3, [r7, #4]
 80293a4:	681b      	ldr	r3, [r3, #0]
        XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch_out_ptr, handle_ptr->config_ptr->gpio_ch_out_pin,
 80293a6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80293a8:	461a      	mov	r2, r3
 80293aa:	f7fd f889 	bl	80264c0 <XMC_GPIO_Init>
      }

      frequency_module = handle_ptr->config_ptr->global_ccu4_handle->module_frequency;
 80293ae:	687b      	ldr	r3, [r7, #4]
 80293b0:	681b      	ldr	r3, [r3, #0]
 80293b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80293b4:	681b      	ldr	r3, [r3, #0]
 80293b6:	613b      	str	r3, [r7, #16]
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->prescaler_initval;
 80293b8:	687b      	ldr	r3, [r7, #4]
 80293ba:	681b      	ldr	r3, [r3, #0]
 80293bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80293be:	791b      	ldrb	r3, [r3, #4]
 80293c0:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80293c4:	b2db      	uxtb	r3, r3
 80293c6:	60fb      	str	r3, [r7, #12]
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
 80293c8:	693a      	ldr	r2, [r7, #16]
 80293ca:	68fb      	ldr	r3, [r7, #12]
 80293cc:	fa22 f303 	lsr.w	r3, r2, r3
 80293d0:	613b      	str	r3, [r7, #16]
      handle_ptr->frequency_tclk = frequency_module;
 80293d2:	687b      	ldr	r3, [r7, #4]
 80293d4:	693a      	ldr	r2, [r7, #16]
 80293d6:	621a      	str	r2, [r3, #32]

      handle_ptr->state = PWM_CCU4_STATE_INITIALIZED;
 80293d8:	687b      	ldr	r3, [r7, #4]
 80293da:	2201      	movs	r2, #1
 80293dc:	771a      	strb	r2, [r3, #28]
      status = PWM_CCU4_STATUS_SUCCESS;
 80293de:	2300      	movs	r3, #0
 80293e0:	75fb      	strb	r3, [r7, #23]

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 80293e2:	687b      	ldr	r3, [r7, #4]
 80293e4:	681b      	ldr	r3, [r3, #0]
 80293e6:	781b      	ldrb	r3, [r3, #0]
 80293e8:	2b00      	cmp	r3, #0
 80293ea:	d00b      	beq.n	8029404 <PWM_CCU4_Init+0x132>
      {
        status = PWM_CCU4_Start(handle_ptr);
 80293ec:	6878      	ldr	r0, [r7, #4]
 80293ee:	f000 f97b 	bl	80296e8 <PWM_CCU4_Start>
 80293f2:	4603      	mov	r3, r0
 80293f4:	75fb      	strb	r3, [r7, #23]
 80293f6:	e005      	b.n	8029404 <PWM_CCU4_Init+0x132>
      }
    }
    else
    {
      handle_ptr->state = PWM_CCU4_STATE_UNINITIALIZED;
 80293f8:	687b      	ldr	r3, [r7, #4]
 80293fa:	2200      	movs	r2, #0
 80293fc:	771a      	strb	r2, [r3, #28]
 80293fe:	e001      	b.n	8029404 <PWM_CCU4_Init+0x132>
    }

  }
  else
  {
    status = PWM_CCU4_STATUS_ALREADY_INITIALIZED;
 8029400:	2302      	movs	r3, #2
 8029402:	75fb      	strb	r3, [r7, #23]
    XMC_DEBUG("PWM_CCU4_Init:PWM_CCU4_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
 8029404:	7dfb      	ldrb	r3, [r7, #23]
} /* end of PWM_CCU4_Init() api */
 8029406:	4618      	mov	r0, r3
 8029408:	3718      	adds	r7, #24
 802940a:	46bd      	mov	sp, r7
 802940c:	bd80      	pop	{r7, pc}

0802940e <PWM_CCU4_lInit_Interrupt>:

static void PWM_CCU4_lInit_Interrupt(PWM_CCU4_t* handle_ptr)
{
 802940e:	b580      	push	{r7, lr}
 8029410:	b082      	sub	sp, #8
 8029412:	af00      	add	r7, sp, #0
 8029414:	6078      	str	r0, [r7, #4]

  /* Enable events. Bind event to corresponding service request node.Enable Interrupts. The user may choose to 
   disable the interrupts by LLD calls. */
  if ((bool) true == handle_ptr->config_ptr->int_per_match)
 8029416:	687b      	ldr	r3, [r7, #4]
 8029418:	681b      	ldr	r3, [r3, #0]
 802941a:	799b      	ldrb	r3, [r3, #6]
 802941c:	2b00      	cmp	r3, #0
 802941e:	d00e      	beq.n	802943e <PWM_CCU4_lInit_Interrupt+0x30>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt period match enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8029420:	687b      	ldr	r3, [r7, #4]
 8029422:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_per_match);
 8029424:	687b      	ldr	r3, [r7, #4]
 8029426:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8029428:	7b5b      	ldrb	r3, [r3, #13]
 802942a:	461a      	mov	r2, r3
 802942c:	2100      	movs	r1, #0
 802942e:	f7fe fc49 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8029432:	687b      	ldr	r3, [r7, #4]
 8029434:	689b      	ldr	r3, [r3, #8]
 8029436:	2100      	movs	r1, #0
 8029438:	4618      	mov	r0, r3
 802943a:	f7ff ff21 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp_match_up)
 802943e:	687b      	ldr	r3, [r7, #4]
 8029440:	681b      	ldr	r3, [r3, #0]
 8029442:	79db      	ldrb	r3, [r3, #7]
 8029444:	2b00      	cmp	r3, #0
 8029446:	d00e      	beq.n	8029466 <PWM_CCU4_lInit_Interrupt+0x58>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt compare match up enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
 8029448:	687b      	ldr	r3, [r7, #4]
 802944a:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_cmp_match_up);
 802944c:	687b      	ldr	r3, [r7, #4]
 802944e:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
 8029450:	7b9b      	ldrb	r3, [r3, #14]
 8029452:	461a      	mov	r2, r3
 8029454:	2102      	movs	r1, #2
 8029456:	f7fe fc35 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 802945a:	687b      	ldr	r3, [r7, #4]
 802945c:	689b      	ldr	r3, [r3, #8]
 802945e:	2102      	movs	r1, #2
 8029460:	4618      	mov	r0, r3
 8029462:	f7ff ff0d 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp_match_down)
 8029466:	687b      	ldr	r3, [r7, #4]
 8029468:	681b      	ldr	r3, [r3, #0]
 802946a:	7a1b      	ldrb	r3, [r3, #8]
 802946c:	2b00      	cmp	r3, #0
 802946e:	d00e      	beq.n	802948e <PWM_CCU4_lInit_Interrupt+0x80>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt compare match down enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN,
 8029470:	687b      	ldr	r3, [r7, #4]
 8029472:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_cmp_match_down);
 8029474:	687b      	ldr	r3, [r7, #4]
 8029476:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN,
 8029478:	7bdb      	ldrb	r3, [r3, #15]
 802947a:	461a      	mov	r2, r3
 802947c:	2103      	movs	r1, #3
 802947e:	f7fe fc21 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN);
 8029482:	687b      	ldr	r3, [r7, #4]
 8029484:	689b      	ldr	r3, [r3, #8]
 8029486:	2103      	movs	r1, #3
 8029488:	4618      	mov	r0, r3
 802948a:	f7ff fef9 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_one_match_down)
 802948e:	687b      	ldr	r3, [r7, #4]
 8029490:	681b      	ldr	r3, [r3, #0]
 8029492:	7a5b      	ldrb	r3, [r3, #9]
 8029494:	2b00      	cmp	r3, #0
 8029496:	d00e      	beq.n	80294b6 <PWM_CCU4_lInit_Interrupt+0xa8>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt one match enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH,
 8029498:	687b      	ldr	r3, [r7, #4]
 802949a:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_one_match_down);
 802949c:	687b      	ldr	r3, [r7, #4]
 802949e:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH,
 80294a0:	7c1b      	ldrb	r3, [r3, #16]
 80294a2:	461a      	mov	r2, r3
 80294a4:	2101      	movs	r1, #1
 80294a6:	f7fe fc0d 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH);
 80294aa:	687b      	ldr	r3, [r7, #4]
 80294ac:	689b      	ldr	r3, [r3, #8]
 80294ae:	2101      	movs	r1, #1
 80294b0:	4618      	mov	r0, r3
 80294b2:	f7ff fee5 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e0)
 80294b6:	687b      	ldr	r3, [r7, #4]
 80294b8:	681b      	ldr	r3, [r3, #0]
 80294ba:	7a9b      	ldrb	r3, [r3, #10]
 80294bc:	2b00      	cmp	r3, #0
 80294be:	d00e      	beq.n	80294de <PWM_CCU4_lInit_Interrupt+0xd0>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 0 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
 80294c0:	687b      	ldr	r3, [r7, #4]
 80294c2:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e0);
 80294c4:	687b      	ldr	r3, [r7, #4]
 80294c6:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
 80294c8:	7c5b      	ldrb	r3, [r3, #17]
 80294ca:	461a      	mov	r2, r3
 80294cc:	2108      	movs	r1, #8
 80294ce:	f7fe fbf9 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0);
 80294d2:	687b      	ldr	r3, [r7, #4]
 80294d4:	689b      	ldr	r3, [r3, #8]
 80294d6:	2108      	movs	r1, #8
 80294d8:	4618      	mov	r0, r3
 80294da:	f7ff fed1 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e1)
 80294de:	687b      	ldr	r3, [r7, #4]
 80294e0:	681b      	ldr	r3, [r3, #0]
 80294e2:	7adb      	ldrb	r3, [r3, #11]
 80294e4:	2b00      	cmp	r3, #0
 80294e6:	d00e      	beq.n	8029506 <PWM_CCU4_lInit_Interrupt+0xf8>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 1 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1,
 80294e8:	687b      	ldr	r3, [r7, #4]
 80294ea:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e1);
 80294ec:	687b      	ldr	r3, [r7, #4]
 80294ee:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1,
 80294f0:	7c9b      	ldrb	r3, [r3, #18]
 80294f2:	461a      	mov	r2, r3
 80294f4:	2109      	movs	r1, #9
 80294f6:	f7fe fbe5 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1);
 80294fa:	687b      	ldr	r3, [r7, #4]
 80294fc:	689b      	ldr	r3, [r3, #8]
 80294fe:	2109      	movs	r1, #9
 8029500:	4618      	mov	r0, r3
 8029502:	f7ff febd 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e2)
 8029506:	687b      	ldr	r3, [r7, #4]
 8029508:	681b      	ldr	r3, [r3, #0]
 802950a:	7b1b      	ldrb	r3, [r3, #12]
 802950c:	2b00      	cmp	r3, #0
 802950e:	d00e      	beq.n	802952e <PWM_CCU4_lInit_Interrupt+0x120>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 2 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2,
 8029510:	687b      	ldr	r3, [r7, #4]
 8029512:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e2);
 8029514:	687b      	ldr	r3, [r7, #4]
 8029516:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2,
 8029518:	7cdb      	ldrb	r3, [r3, #19]
 802951a:	461a      	mov	r2, r3
 802951c:	210a      	movs	r1, #10
 802951e:	f7fe fbd1 	bl	8027cc4 <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2);
 8029522:	687b      	ldr	r3, [r7, #4]
 8029524:	689b      	ldr	r3, [r3, #8]
 8029526:	210a      	movs	r1, #10
 8029528:	4618      	mov	r0, r3
 802952a:	f7ff fea9 	bl	8029280 <XMC_CCU4_SLICE_EnableEvent>
  }
}
 802952e:	bf00      	nop
 8029530:	3708      	adds	r7, #8
 8029532:	46bd      	mov	sp, r7
 8029534:	bd80      	pop	{r7, pc}

08029536 <PWM_CCU4_lConfigure_Events>:

static void PWM_CCU4_lConfigure_Events(PWM_CCU4_t* handle_ptr)
{
 8029536:	b580      	push	{r7, lr}
 8029538:	b082      	sub	sp, #8
 802953a:	af00      	add	r7, sp, #0
 802953c:	6078      	str	r0, [r7, #4]

  /* Configure slice to a external event 0 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0,
 802953e:	687b      	ldr	r3, [r7, #4]
 8029540:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event0_config_ptr);
 8029542:	687b      	ldr	r3, [r7, #4]
 8029544:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0,
 8029546:	695b      	ldr	r3, [r3, #20]
 8029548:	461a      	mov	r2, r3
 802954a:	2101      	movs	r1, #1
 802954c:	f7fe fb20 	bl	8027b90 <XMC_CCU4_SLICE_ConfigureEvent>

  /* Configure slice to a external event 1 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1,
 8029550:	687b      	ldr	r3, [r7, #4]
 8029552:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event1_config_ptr);
 8029554:	687b      	ldr	r3, [r7, #4]
 8029556:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1,
 8029558:	699b      	ldr	r3, [r3, #24]
 802955a:	461a      	mov	r2, r3
 802955c:	2102      	movs	r1, #2
 802955e:	f7fe fb17 	bl	8027b90 <XMC_CCU4_SLICE_ConfigureEvent>

  /* Configure slice to a external event 2 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_2,
 8029562:	687b      	ldr	r3, [r7, #4]
 8029564:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event2_config_ptr);
 8029566:	687b      	ldr	r3, [r7, #4]
 8029568:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_2,
 802956a:	69db      	ldr	r3, [r3, #28]
 802956c:	461a      	mov	r2, r3
 802956e:	2103      	movs	r1, #3
 8029570:	f7fe fb0e 	bl	8027b90 <XMC_CCU4_SLICE_ConfigureEvent>

  /* External signal controls start of the timer */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
 8029574:	687b      	ldr	r3, [r7, #4]
 8029576:	681b      	ldr	r3, [r3, #0]
 8029578:	f893 3020 	ldrb.w	r3, [r3, #32]
 802957c:	2b00      	cmp	r3, #0
 802957e:	d00c      	beq.n	802959a <PWM_CCU4_lConfigure_Events+0x64>
  {
    XMC_CCU4_SLICE_StartConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 8029580:	687b      	ldr	r3, [r7, #4]
 8029582:	6898      	ldr	r0, [r3, #8]
 8029584:	687b      	ldr	r3, [r7, #4]
 8029586:	681b      	ldr	r3, [r3, #0]
 8029588:	f893 1020 	ldrb.w	r1, [r3, #32]
                               handle_ptr->config_ptr->ext_start_mode);
 802958c:	687b      	ldr	r3, [r7, #4]
 802958e:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_StartConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 8029590:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8029594:	461a      	mov	r2, r3
 8029596:	f7fe f926 	bl	80277e6 <XMC_CCU4_SLICE_StartConfig>
  }

  /* External signal can stop the timer */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
 802959a:	687b      	ldr	r3, [r7, #4]
 802959c:	681b      	ldr	r3, [r3, #0]
 802959e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80295a2:	2b00      	cmp	r3, #0
 80295a4:	d00c      	beq.n	80295c0 <PWM_CCU4_lConfigure_Events+0x8a>
  {
    XMC_CCU4_SLICE_StopConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 80295a6:	687b      	ldr	r3, [r7, #4]
 80295a8:	6898      	ldr	r0, [r3, #8]
 80295aa:	687b      	ldr	r3, [r7, #4]
 80295ac:	681b      	ldr	r3, [r3, #0]
 80295ae:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
                              handle_ptr->config_ptr->ext_stop_mode);
 80295b2:	687b      	ldr	r3, [r7, #4]
 80295b4:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_StopConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 80295b6:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 80295ba:	461a      	mov	r2, r3
 80295bc:	f7fe f941 	bl	8027842 <XMC_CCU4_SLICE_StopConfig>
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
 80295c0:	687b      	ldr	r3, [r7, #4]
 80295c2:	681b      	ldr	r3, [r3, #0]
 80295c4:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80295c8:	2b00      	cmp	r3, #0
 80295ca:	d009      	beq.n	80295e0 <PWM_CCU4_lConfigure_Events+0xaa>
  {
    XMC_CCU4_SLICE_DirectionConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
 80295cc:	687b      	ldr	r3, [r7, #4]
 80295ce:	689a      	ldr	r2, [r3, #8]
 80295d0:	687b      	ldr	r3, [r7, #4]
 80295d2:	681b      	ldr	r3, [r3, #0]
 80295d4:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80295d8:	4619      	mov	r1, r3
 80295da:	4610      	mov	r0, r2
 80295dc:	f7fe fa09 	bl	80279f2 <XMC_CCU4_SLICE_DirectionConfig>
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
 80295e0:	687b      	ldr	r3, [r7, #4]
 80295e2:	681b      	ldr	r3, [r3, #0]
 80295e4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80295e8:	2b00      	cmp	r3, #0
 80295ea:	d009      	beq.n	8029600 <PWM_CCU4_lConfigure_Events+0xca>
  {
    XMC_CCU4_SLICE_GateConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
 80295ec:	687b      	ldr	r3, [r7, #4]
 80295ee:	689a      	ldr	r2, [r3, #8]
 80295f0:	687b      	ldr	r3, [r7, #4]
 80295f2:	681b      	ldr	r3, [r3, #0]
 80295f4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80295f8:	4619      	mov	r1, r3
 80295fa:	4610      	mov	r0, r2
 80295fc:	f7fe f9c3 	bl	8027986 <XMC_CCU4_SLICE_GateConfig>
  }
  /* Timer increments on external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
 8029600:	687b      	ldr	r3, [r7, #4]
 8029602:	681b      	ldr	r3, [r3, #0]
 8029604:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8029608:	2b00      	cmp	r3, #0
 802960a:	d009      	beq.n	8029620 <PWM_CCU4_lConfigure_Events+0xea>
  {
    XMC_CCU4_SLICE_CountConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_count_event);
 802960c:	687b      	ldr	r3, [r7, #4]
 802960e:	689a      	ldr	r2, [r3, #8]
 8029610:	687b      	ldr	r3, [r7, #4]
 8029612:	681b      	ldr	r3, [r3, #0]
 8029614:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8029618:	4619      	mov	r1, r3
 802961a:	4610      	mov	r0, r2
 802961c:	f7fe f998 	bl	8027950 <XMC_CCU4_SLICE_CountConfig>
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
 8029620:	687b      	ldr	r3, [r7, #4]
 8029622:	681b      	ldr	r3, [r3, #0]
 8029624:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8029628:	2b00      	cmp	r3, #0
 802962a:	d009      	beq.n	8029640 <PWM_CCU4_lConfigure_Events+0x10a>
  {
    XMC_CCU4_SLICE_LoadConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_load_event);
 802962c:	687b      	ldr	r3, [r7, #4]
 802962e:	689a      	ldr	r2, [r3, #8]
 8029630:	687b      	ldr	r3, [r7, #4]
 8029632:	681b      	ldr	r3, [r3, #0]
 8029634:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8029638:	4619      	mov	r1, r3
 802963a:	4610      	mov	r0, r2
 802963c:	f7fe f92d 	bl	802789a <XMC_CCU4_SLICE_LoadConfig>
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
 8029640:	687b      	ldr	r3, [r7, #4]
 8029642:	681b      	ldr	r3, [r3, #0]
 8029644:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8029648:	2b00      	cmp	r3, #0
 802964a:	d00f      	beq.n	802966c <PWM_CCU4_lConfigure_Events+0x136>
  {
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 802964c:	687b      	ldr	r3, [r7, #4]
 802964e:	6898      	ldr	r0, [r3, #8]
 8029650:	687b      	ldr	r3, [r7, #4]
 8029652:	681b      	ldr	r3, [r3, #0]
 8029654:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
                                    handle_ptr->config_ptr->ext_mod_mode, handle_ptr->config_ptr->ext_mod_sync);
 8029658:	687b      	ldr	r3, [r7, #4]
 802965a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 802965c:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
                                    handle_ptr->config_ptr->ext_mod_mode, handle_ptr->config_ptr->ext_mod_sync);
 8029660:	687b      	ldr	r3, [r7, #4]
 8029662:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 8029664:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8029668:	f7fe f932 	bl	80278d0 <XMC_CCU4_SLICE_ModulationConfig>
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU4_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 802966c:	687b      	ldr	r3, [r7, #4]
 802966e:	681b      	ldr	r3, [r3, #0]
 8029670:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8029674:	2b03      	cmp	r3, #3
 8029676:	d117      	bne.n	80296a8 <PWM_CCU4_lConfigure_Events+0x172>
  {
    XMC_CCU4_SLICE_TrapConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 8029678:	687b      	ldr	r3, [r7, #4]
 802967a:	6898      	ldr	r0, [r3, #8]
 802967c:	687b      	ldr	r3, [r7, #4]
 802967e:	681b      	ldr	r3, [r3, #0]
 8029680:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
                              handle_ptr->config_ptr->ext_trap_sync);
 8029684:	687b      	ldr	r3, [r7, #4]
 8029686:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_TrapConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 8029688:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 802968c:	461a      	mov	r2, r3
 802968e:	f7fe f9e3 	bl	8027a58 <XMC_CCU4_SLICE_TrapConfig>

    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 8029692:	687b      	ldr	r3, [r7, #4]
 8029694:	681b      	ldr	r3, [r3, #0]
 8029696:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 802969a:	2b00      	cmp	r3, #0
 802969c:	d004      	beq.n	80296a8 <PWM_CCU4_lConfigure_Events+0x172>
    {
      XMC_CCU4_SLICE_EnableTrap(handle_ptr->ccu4_slice_ptr);
 802969e:	687b      	ldr	r3, [r7, #4]
 80296a0:	689b      	ldr	r3, [r3, #8]
 80296a2:	4618      	mov	r0, r3
 80296a4:	f7ff fd89 	bl	80291ba <XMC_CCU4_SLICE_EnableTrap>
    }
  }
  if ((XMC_CCU4_SLICE_EVENT_1 == handle_ptr->config_ptr->ext_override_edge_event) && (XMC_CCU4_SLICE_EVENT_2
 80296a8:	687b      	ldr	r3, [r7, #4]
 80296aa:	681b      	ldr	r3, [r3, #0]
 80296ac:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 80296b0:	2b02      	cmp	r3, #2
 80296b2:	d115      	bne.n	80296e0 <PWM_CCU4_lConfigure_Events+0x1aa>
      == handle_ptr->config_ptr->ext_override_level_event))
 80296b4:	687b      	ldr	r3, [r7, #4]
 80296b6:	681b      	ldr	r3, [r3, #0]
 80296b8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
  if ((XMC_CCU4_SLICE_EVENT_1 == handle_ptr->config_ptr->ext_override_edge_event) && (XMC_CCU4_SLICE_EVENT_2
 80296bc:	2b03      	cmp	r3, #3
 80296be:	d10f      	bne.n	80296e0 <PWM_CCU4_lConfigure_Events+0x1aa>
  {
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 80296c0:	687b      	ldr	r3, [r7, #4]
 80296c2:	6898      	ldr	r0, [r3, #8]
                                                   handle_ptr->config_ptr->event1_config_ptr,
 80296c4:	687b      	ldr	r3, [r7, #4]
 80296c6:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 80296c8:	6999      	ldr	r1, [r3, #24]
                                                   handle_ptr->config_ptr->event2_config_ptr);
 80296ca:	687b      	ldr	r3, [r7, #4]
 80296cc:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 80296ce:	69db      	ldr	r3, [r3, #28]
 80296d0:	461a      	mov	r2, r3
 80296d2:	f7fe f9fb 	bl	8027acc <XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent>
    XMC_CCU4_SLICE_StatusBitOverrideConfig(handle_ptr->ccu4_slice_ptr);
 80296d6:	687b      	ldr	r3, [r7, #4]
 80296d8:	689b      	ldr	r3, [r3, #8]
 80296da:	4618      	mov	r0, r3
 80296dc:	f7fe f9a4 	bl	8027a28 <XMC_CCU4_SLICE_StatusBitOverrideConfig>
  }

}
 80296e0:	bf00      	nop
 80296e2:	3708      	adds	r7, #8
 80296e4:	46bd      	mov	sp, r7
 80296e6:	bd80      	pop	{r7, pc}

080296e8 <PWM_CCU4_Start>:
/**********************************************************************************************************/
/*Starts the CCU4_CC4 slice. This needs to be called even if external start is configured.*/
PWM_CCU4_STATUS_t PWM_CCU4_Start(PWM_CCU4_t* handle_ptr)
{
 80296e8:	b580      	push	{r7, lr}
 80296ea:	b084      	sub	sp, #16
 80296ec:	af00      	add	r7, sp, #0
 80296ee:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;

  status = PWM_CCU4_STATUS_FAILURE;
 80296f0:	2301      	movs	r3, #1
 80296f2:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("PWM_CCU4_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU4_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU4_STATE_STOPPED == handle_ptr->state))
 80296f4:	687b      	ldr	r3, [r7, #4]
 80296f6:	7f1b      	ldrb	r3, [r3, #28]
 80296f8:	2b01      	cmp	r3, #1
 80296fa:	d003      	beq.n	8029704 <PWM_CCU4_Start+0x1c>
 80296fc:	687b      	ldr	r3, [r7, #4]
 80296fe:	7f1b      	ldrb	r3, [r3, #28]
 8029700:	2b03      	cmp	r3, #3
 8029702:	d117      	bne.n	8029734 <PWM_CCU4_Start+0x4c>
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU4_EnableClock(handle_ptr->ccu4_module_ptr, handle_ptr->slice_number);
 8029704:	687b      	ldr	r3, [r7, #4]
 8029706:	685a      	ldr	r2, [r3, #4]
 8029708:	687b      	ldr	r3, [r7, #4]
 802970a:	7b5b      	ldrb	r3, [r3, #13]
 802970c:	4619      	mov	r1, r3
 802970e:	4610      	mov	r0, r2
 8029710:	f7ff fd42 	bl	8029198 <XMC_CCU4_EnableClock>

    if (XMC_CCU4_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8029714:	687b      	ldr	r3, [r7, #4]
 8029716:	681b      	ldr	r3, [r3, #0]
 8029718:	f893 3020 	ldrb.w	r3, [r3, #32]
 802971c:	2b00      	cmp	r3, #0
 802971e:	d104      	bne.n	802972a <PWM_CCU4_Start+0x42>
    {
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 8029720:	687b      	ldr	r3, [r7, #4]
 8029722:	689b      	ldr	r3, [r3, #8]
 8029724:	4618      	mov	r0, r3
 8029726:	f7ff fd58 	bl	80291da <XMC_CCU4_SLICE_StartTimer>
    }

    handle_ptr->state = PWM_CCU4_STATE_RUNNING;
 802972a:	687b      	ldr	r3, [r7, #4]
 802972c:	2202      	movs	r2, #2
 802972e:	771a      	strb	r2, [r3, #28]
    status = PWM_CCU4_STATUS_SUCCESS;
 8029730:	2300      	movs	r3, #0
 8029732:	73fb      	strb	r3, [r7, #15]
    XMC_DEBUG("PWM_CCU4_Start:start PWM");
  }
  return (status);
 8029734:	7bfb      	ldrb	r3, [r7, #15]
} /* end of PWM_CCU4_Start() api */
 8029736:	4618      	mov	r0, r3
 8029738:	3710      	adds	r7, #16
 802973a:	46bd      	mov	sp, r7
 802973c:	bd80      	pop	{r7, pc}

0802973e <PWM_CCU4_Stop>:
/**********************************************************************************************************/
/*Stops the CCU4_CC4 slice. */
PWM_CCU4_STATUS_t PWM_CCU4_Stop(PWM_CCU4_t* handle_ptr)
{
 802973e:	b580      	push	{r7, lr}
 8029740:	b084      	sub	sp, #16
 8029742:	af00      	add	r7, sp, #0
 8029744:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;

  status = PWM_CCU4_STATUS_FAILURE;
 8029746:	2301      	movs	r3, #1
 8029748:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("PWM_CCU4_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU4_STATE_UNINITIALIZED != handle_ptr->state)
 802974a:	687b      	ldr	r3, [r7, #4]
 802974c:	7f1b      	ldrb	r3, [r3, #28]
 802974e:	2b00      	cmp	r3, #0
 8029750:	d00e      	beq.n	8029770 <PWM_CCU4_Stop+0x32>
  {
    XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
 8029752:	687b      	ldr	r3, [r7, #4]
 8029754:	689b      	ldr	r3, [r3, #8]
 8029756:	4618      	mov	r0, r3
 8029758:	f7ff fd4c 	bl	80291f4 <XMC_CCU4_SLICE_StopTimer>
    XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 802975c:	687b      	ldr	r3, [r7, #4]
 802975e:	689b      	ldr	r3, [r3, #8]
 8029760:	4618      	mov	r0, r3
 8029762:	f7ff fd54 	bl	802920e <XMC_CCU4_SLICE_ClearTimer>

    handle_ptr->state = PWM_CCU4_STATE_STOPPED;
 8029766:	687b      	ldr	r3, [r7, #4]
 8029768:	2203      	movs	r2, #3
 802976a:	771a      	strb	r2, [r3, #28]
    status = PWM_CCU4_STATUS_SUCCESS;
 802976c:	2300      	movs	r3, #0
 802976e:	73fb      	strb	r3, [r7, #15]
    XMC_DEBUG("PWM_CCU4_Stop:stop PWM");
  }
  return (status);
 8029770:	7bfb      	ldrb	r3, [r7, #15]

} /* end of PWM_CCU4_Stop() api */
 8029772:	4618      	mov	r0, r3
 8029774:	3710      	adds	r7, #16
 8029776:	46bd      	mov	sp, r7
 8029778:	bd80      	pop	{r7, pc}
	...

0802977c <PWM_CCU4_SetFreqAndDutyCycle>:

/**********************************************************************************************************/

/*Sets the frequency and duty cycle for CCU4_CC4 slice Symmetric Mode. */
PWM_CCU4_STATUS_t PWM_CCU4_SetFreqAndDutyCycle(PWM_CCU4_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t duty)
{
 802977c:	b580      	push	{r7, lr}
 802977e:	b088      	sub	sp, #32
 8029780:	af00      	add	r7, sp, #0
 8029782:	60f8      	str	r0, [r7, #12]
 8029784:	60b9      	str	r1, [r7, #8]
 8029786:	607a      	str	r2, [r7, #4]
  PWM_CCU4_STATUS_t status;
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare;

  status = PWM_CCU4_STATUS_FAILURE;
 8029788:	2301      	movs	r3, #1
 802978a:	77fb      	strb	r3, [r7, #31]
  frequency_tclk = 0U;
 802978c:	2300      	movs	r3, #0
 802978e:	617b      	str	r3, [r7, #20]
  XMC_ASSERT("PWM_CCU4_SetFreqAndDutyCycle:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU4_STATE_UNINITIALIZED != handle_ptr->state)
 8029790:	68fb      	ldr	r3, [r7, #12]
 8029792:	7f1b      	ldrb	r3, [r3, #28]
 8029794:	2b00      	cmp	r3, #0
 8029796:	d04d      	beq.n	8029834 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
  {
    if (0U == pwm_freq_hz)
 8029798:	68bb      	ldr	r3, [r7, #8]
 802979a:	2b00      	cmp	r3, #0
 802979c:	d04a      	beq.n	8029834 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
    {
      XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycleSymmetric:cannot set frequency 0Hz");
    }
    else if (duty > PWM_CCU4_SYM_DUTY_MAX)
 802979e:	687b      	ldr	r3, [r7, #4]
 80297a0:	f242 7210 	movw	r2, #10000	; 0x2710
 80297a4:	4293      	cmp	r3, r2
 80297a6:	d845      	bhi.n	8029834 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
    {
      XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycle:duty > 100%%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
 80297a8:	68fb      	ldr	r3, [r7, #12]
 80297aa:	6a1b      	ldr	r3, [r3, #32]
 80297ac:	617b      	str	r3, [r7, #20]
      period = frequency_tclk / pwm_freq_hz;
 80297ae:	697a      	ldr	r2, [r7, #20]
 80297b0:	68bb      	ldr	r3, [r7, #8]
 80297b2:	fbb2 f3f3 	udiv	r3, r2, r3
 80297b6:	61bb      	str	r3, [r7, #24]

      if ((uint32_t) XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->timer_mode)
 80297b8:	68fb      	ldr	r3, [r7, #12]
 80297ba:	681b      	ldr	r3, [r3, #0]
 80297bc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80297be:	781b      	ldrb	r3, [r3, #0]
 80297c0:	f003 0301 	and.w	r3, r3, #1
 80297c4:	b2db      	uxtb	r3, r3
 80297c6:	2b00      	cmp	r3, #0
 80297c8:	d002      	beq.n	80297d0 <PWM_CCU4_SetFreqAndDutyCycle+0x54>
      {
        period = period >> 1U;/*divide by 2*/
 80297ca:	69bb      	ldr	r3, [r7, #24]
 80297cc:	085b      	lsrs	r3, r3, #1
 80297ce:	61bb      	str	r3, [r7, #24]
      }

      if ((period != 0U) && (period <= PWM_CCU4_MAX_TIMER_COUNT))
 80297d0:	69bb      	ldr	r3, [r7, #24]
 80297d2:	2b00      	cmp	r3, #0
 80297d4:	d02e      	beq.n	8029834 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
 80297d6:	69bb      	ldr	r3, [r7, #24]
 80297d8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80297dc:	d22a      	bcs.n	8029834 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare = ((period * (PWM_CCU4_DUTY_FULL_SCALE - duty)) / PWM_CCU4_DUTY_FULL_SCALE);
 80297de:	687b      	ldr	r3, [r7, #4]
 80297e0:	f5c3 531c 	rsb	r3, r3, #9984	; 0x2700
 80297e4:	3310      	adds	r3, #16
 80297e6:	69ba      	ldr	r2, [r7, #24]
 80297e8:	fb02 f303 	mul.w	r3, r2, r3
 80297ec:	4a14      	ldr	r2, [pc, #80]	; (8029840 <PWM_CCU4_SetFreqAndDutyCycle+0xc4>)
 80297ee:	fba2 2303 	umull	r2, r3, r2, r3
 80297f2:	0b5b      	lsrs	r3, r3, #13
 80297f4:	613b      	str	r3, [r7, #16]

        XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, (uint16_t)(period - 1U));
 80297f6:	68fb      	ldr	r3, [r7, #12]
 80297f8:	689a      	ldr	r2, [r3, #8]
 80297fa:	69bb      	ldr	r3, [r7, #24]
 80297fc:	b29b      	uxth	r3, r3
 80297fe:	3b01      	subs	r3, #1
 8029800:	b29b      	uxth	r3, r3
 8029802:	4619      	mov	r1, r3
 8029804:	4610      	mov	r0, r2
 8029806:	f7ff fd0f 	bl	8029228 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
        XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t) compare);
 802980a:	68fb      	ldr	r3, [r7, #12]
 802980c:	689b      	ldr	r3, [r3, #8]
 802980e:	693a      	ldr	r2, [r7, #16]
 8029810:	b292      	uxth	r2, r2
 8029812:	4611      	mov	r1, r2
 8029814:	4618      	mov	r0, r3
 8029816:	f7ff fd16 	bl	8029246 <XMC_CCU4_SLICE_SetTimerCompareMatch>

        XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->shadow_txfr_msk);
 802981a:	68fb      	ldr	r3, [r7, #12]
 802981c:	685a      	ldr	r2, [r3, #4]
 802981e:	68fb      	ldr	r3, [r7, #12]
 8029820:	691b      	ldr	r3, [r3, #16]
 8029822:	4619      	mov	r1, r3
 8029824:	4610      	mov	r0, r2
 8029826:	f7ff fd1d 	bl	8029264 <XMC_CCU4_EnableShadowTransfer>

        handle_ptr->sym_duty = duty;
 802982a:	68fb      	ldr	r3, [r7, #12]
 802982c:	687a      	ldr	r2, [r7, #4]
 802982e:	625a      	str	r2, [r3, #36]	; 0x24

        XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycle:frequency set");
        status = PWM_CCU4_STATUS_SUCCESS;
 8029830:	2300      	movs	r3, #0
 8029832:	77fb      	strb	r3, [r7, #31]
      }
    }
  }
  return (status);
 8029834:	7ffb      	ldrb	r3, [r7, #31]

}/* end of PWM_CCU4_SetFreqAndDutyCycle() api */
 8029836:	4618      	mov	r0, r3
 8029838:	3720      	adds	r7, #32
 802983a:	46bd      	mov	sp, r7
 802983c:	bd80      	pop	{r7, pc}
 802983e:	bf00      	nop
 8029840:	d1b71759 	.word	0xd1b71759

08029844 <PWM_CCU4_ClearEvent>:

/**********************************************************************************************************/

/*Acknowledges the interrupt of  CCU4_CC4 slice. */
void PWM_CCU4_ClearEvent(PWM_CCU4_t* handle_ptr, XMC_CCU4_SLICE_IRQ_ID_t pwm_interrupt)
{
 8029844:	b580      	push	{r7, lr}
 8029846:	b082      	sub	sp, #8
 8029848:	af00      	add	r7, sp, #0
 802984a:	6078      	str	r0, [r7, #4]
 802984c:	460b      	mov	r3, r1
 802984e:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("PWM_CCU4_ClearEvent:handle_ptr NULL", (handle_ptr != NULL));
  XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, pwm_interrupt);
 8029850:	687b      	ldr	r3, [r7, #4]
 8029852:	689b      	ldr	r3, [r3, #8]
 8029854:	78fa      	ldrb	r2, [r7, #3]
 8029856:	4611      	mov	r1, r2
 8029858:	4618      	mov	r0, r3
 802985a:	f7ff fd28 	bl	80292ae <XMC_CCU4_SLICE_ClearEvent>
  XMC_DEBUG("PWM_CCU4_ClearEvent:Acknowledge Interrupt");
} /* end of PWM_CCU4_ClearEvent() api */
 802985e:	bf00      	nop
 8029860:	3708      	adds	r7, #8
 8029862:	46bd      	mov	sp, r7
 8029864:	bd80      	pop	{r7, pc}
	...

08029868 <__NVIC_GetPriorityGrouping>:
{
 8029868:	b480      	push	{r7}
 802986a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802986c:	4b04      	ldr	r3, [pc, #16]	; (8029880 <__NVIC_GetPriorityGrouping+0x18>)
 802986e:	68db      	ldr	r3, [r3, #12]
 8029870:	0a1b      	lsrs	r3, r3, #8
 8029872:	f003 0307 	and.w	r3, r3, #7
}
 8029876:	4618      	mov	r0, r3
 8029878:	46bd      	mov	sp, r7
 802987a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802987e:	4770      	bx	lr
 8029880:	e000ed00 	.word	0xe000ed00

08029884 <__NVIC_EnableIRQ>:
{
 8029884:	b480      	push	{r7}
 8029886:	b083      	sub	sp, #12
 8029888:	af00      	add	r7, sp, #0
 802988a:	4603      	mov	r3, r0
 802988c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802988e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8029892:	2b00      	cmp	r3, #0
 8029894:	db0b      	blt.n	80298ae <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8029896:	79fb      	ldrb	r3, [r7, #7]
 8029898:	f003 021f 	and.w	r2, r3, #31
 802989c:	4907      	ldr	r1, [pc, #28]	; (80298bc <__NVIC_EnableIRQ+0x38>)
 802989e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80298a2:	095b      	lsrs	r3, r3, #5
 80298a4:	2001      	movs	r0, #1
 80298a6:	fa00 f202 	lsl.w	r2, r0, r2
 80298aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80298ae:	bf00      	nop
 80298b0:	370c      	adds	r7, #12
 80298b2:	46bd      	mov	sp, r7
 80298b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80298b8:	4770      	bx	lr
 80298ba:	bf00      	nop
 80298bc:	e000e100 	.word	0xe000e100

080298c0 <__NVIC_SetPriority>:
{
 80298c0:	b480      	push	{r7}
 80298c2:	b083      	sub	sp, #12
 80298c4:	af00      	add	r7, sp, #0
 80298c6:	4603      	mov	r3, r0
 80298c8:	6039      	str	r1, [r7, #0]
 80298ca:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80298cc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80298d0:	2b00      	cmp	r3, #0
 80298d2:	db0a      	blt.n	80298ea <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80298d4:	683b      	ldr	r3, [r7, #0]
 80298d6:	b2da      	uxtb	r2, r3
 80298d8:	490c      	ldr	r1, [pc, #48]	; (802990c <__NVIC_SetPriority+0x4c>)
 80298da:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80298de:	0092      	lsls	r2, r2, #2
 80298e0:	b2d2      	uxtb	r2, r2
 80298e2:	440b      	add	r3, r1
 80298e4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80298e8:	e00a      	b.n	8029900 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80298ea:	683b      	ldr	r3, [r7, #0]
 80298ec:	b2da      	uxtb	r2, r3
 80298ee:	4908      	ldr	r1, [pc, #32]	; (8029910 <__NVIC_SetPriority+0x50>)
 80298f0:	79fb      	ldrb	r3, [r7, #7]
 80298f2:	f003 030f 	and.w	r3, r3, #15
 80298f6:	3b04      	subs	r3, #4
 80298f8:	0092      	lsls	r2, r2, #2
 80298fa:	b2d2      	uxtb	r2, r2
 80298fc:	440b      	add	r3, r1
 80298fe:	761a      	strb	r2, [r3, #24]
}
 8029900:	bf00      	nop
 8029902:	370c      	adds	r7, #12
 8029904:	46bd      	mov	sp, r7
 8029906:	f85d 7b04 	ldr.w	r7, [sp], #4
 802990a:	4770      	bx	lr
 802990c:	e000e100 	.word	0xe000e100
 8029910:	e000ed00 	.word	0xe000ed00

08029914 <NVIC_EncodePriority>:
{
 8029914:	b480      	push	{r7}
 8029916:	b089      	sub	sp, #36	; 0x24
 8029918:	af00      	add	r7, sp, #0
 802991a:	60f8      	str	r0, [r7, #12]
 802991c:	60b9      	str	r1, [r7, #8]
 802991e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8029920:	68fb      	ldr	r3, [r7, #12]
 8029922:	f003 0307 	and.w	r3, r3, #7
 8029926:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8029928:	69fb      	ldr	r3, [r7, #28]
 802992a:	f1c3 0307 	rsb	r3, r3, #7
 802992e:	2b06      	cmp	r3, #6
 8029930:	bf28      	it	cs
 8029932:	2306      	movcs	r3, #6
 8029934:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8029936:	69fb      	ldr	r3, [r7, #28]
 8029938:	3306      	adds	r3, #6
 802993a:	2b06      	cmp	r3, #6
 802993c:	d902      	bls.n	8029944 <NVIC_EncodePriority+0x30>
 802993e:	69fb      	ldr	r3, [r7, #28]
 8029940:	3b01      	subs	r3, #1
 8029942:	e000      	b.n	8029946 <NVIC_EncodePriority+0x32>
 8029944:	2300      	movs	r3, #0
 8029946:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8029948:	f04f 32ff 	mov.w	r2, #4294967295
 802994c:	69bb      	ldr	r3, [r7, #24]
 802994e:	fa02 f303 	lsl.w	r3, r2, r3
 8029952:	43da      	mvns	r2, r3
 8029954:	68bb      	ldr	r3, [r7, #8]
 8029956:	401a      	ands	r2, r3
 8029958:	697b      	ldr	r3, [r7, #20]
 802995a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802995c:	f04f 31ff 	mov.w	r1, #4294967295
 8029960:	697b      	ldr	r3, [r7, #20]
 8029962:	fa01 f303 	lsl.w	r3, r1, r3
 8029966:	43d9      	mvns	r1, r3
 8029968:	687b      	ldr	r3, [r7, #4]
 802996a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802996c:	4313      	orrs	r3, r2
}
 802996e:	4618      	mov	r0, r3
 8029970:	3724      	adds	r7, #36	; 0x24
 8029972:	46bd      	mov	sp, r7
 8029974:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029978:	4770      	bx	lr

0802997a <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
 802997a:	b580      	push	{r7, lr}
 802997c:	b082      	sub	sp, #8
 802997e:	af00      	add	r7, sp, #0
 8029980:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
 8029982:	687b      	ldr	r3, [r7, #4]
 8029984:	f993 3000 	ldrsb.w	r3, [r3]
 8029988:	4618      	mov	r0, r3
 802998a:	f7ff ff7b 	bl	8029884 <__NVIC_EnableIRQ>
}
 802998e:	bf00      	nop
 8029990:	3708      	adds	r7, #8
 8029992:	46bd      	mov	sp, r7
 8029994:	bd80      	pop	{r7, pc}

08029996 <INTERRUPT_Init>:

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 8029996:	b590      	push	{r4, r7, lr}
 8029998:	b083      	sub	sp, #12
 802999a:	af00      	add	r7, sp, #0
 802999c:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 802999e:	687b      	ldr	r3, [r7, #4]
 80299a0:	f993 4000 	ldrsb.w	r4, [r3]
 80299a4:	f7ff ff60 	bl	8029868 <__NVIC_GetPriorityGrouping>
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
 80299a8:	687b      	ldr	r3, [r7, #4]
 80299aa:	785b      	ldrb	r3, [r3, #1]
  NVIC_SetPriority(handler->node,
 80299ac:	4619      	mov	r1, r3
                                       handler->subpriority));
 80299ae:	687b      	ldr	r3, [r7, #4]
 80299b0:	789b      	ldrb	r3, [r3, #2]
  NVIC_SetPriority(handler->node,
 80299b2:	461a      	mov	r2, r3
 80299b4:	f7ff ffae 	bl	8029914 <NVIC_EncodePriority>
 80299b8:	4603      	mov	r3, r0
 80299ba:	4619      	mov	r1, r3
 80299bc:	4620      	mov	r0, r4
 80299be:	f7ff ff7f 	bl	80298c0 <__NVIC_SetPriority>
  if (handler->enable_at_init == true)
 80299c2:	687b      	ldr	r3, [r7, #4]
 80299c4:	78db      	ldrb	r3, [r3, #3]
 80299c6:	2b00      	cmp	r3, #0
 80299c8:	d002      	beq.n	80299d0 <INTERRUPT_Init+0x3a>
  {
    INTERRUPT_Enable(handler);
 80299ca:	6878      	ldr	r0, [r7, #4]
 80299cc:	f7ff ffd5 	bl	802997a <INTERRUPT_Enable>
  {
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
 80299d0:	2300      	movs	r3, #0
}
 80299d2:	4618      	mov	r0, r3
 80299d4:	370c      	adds	r7, #12
 80299d6:	46bd      	mov	sp, r7
 80299d8:	bd90      	pop	{r4, r7, pc}

080299da <XMC_CCU4_StartPrescaler>:
{
 80299da:	b480      	push	{r7}
 80299dc:	b083      	sub	sp, #12
 80299de:	af00      	add	r7, sp, #0
 80299e0:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 80299e2:	687b      	ldr	r3, [r7, #4]
 80299e4:	f44f 7280 	mov.w	r2, #256	; 0x100
 80299e8:	60da      	str	r2, [r3, #12]
}
 80299ea:	bf00      	nop
 80299ec:	370c      	adds	r7, #12
 80299ee:	46bd      	mov	sp, r7
 80299f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80299f4:	4770      	bx	lr

080299f6 <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 80299f6:	b580      	push	{r7, lr}
 80299f8:	b082      	sub	sp, #8
 80299fa:	af00      	add	r7, sp, #0
 80299fc:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 80299fe:	687b      	ldr	r3, [r7, #4]
 8029a00:	7b5b      	ldrb	r3, [r3, #13]
 8029a02:	f083 0301 	eor.w	r3, r3, #1
 8029a06:	b2db      	uxtb	r3, r3
 8029a08:	2b00      	cmp	r3, #0
 8029a0a:	d00f      	beq.n	8029a2c <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 8029a0c:	687b      	ldr	r3, [r7, #4]
 8029a0e:	689a      	ldr	r2, [r3, #8]
 8029a10:	687b      	ldr	r3, [r7, #4]
 8029a12:	7b1b      	ldrb	r3, [r3, #12]
 8029a14:	4619      	mov	r1, r3
 8029a16:	4610      	mov	r0, r2
 8029a18:	f7fd fe4c 	bl	80276b4 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 8029a1c:	687b      	ldr	r3, [r7, #4]
 8029a1e:	689b      	ldr	r3, [r3, #8]
 8029a20:	4618      	mov	r0, r3
 8029a22:	f7ff ffda 	bl	80299da <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8029a26:	687b      	ldr	r3, [r7, #4]
 8029a28:	2201      	movs	r2, #1
 8029a2a:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
 8029a2c:	2300      	movs	r3, #0
}
 8029a2e:	4618      	mov	r0, r3
 8029a30:	3708      	adds	r7, #8
 8029a32:	46bd      	mov	sp, r7
 8029a34:	bd80      	pop	{r7, pc}

08029a36 <GLOBAL_CAN_Init>:
  return (version);
}

/*  Function to initialize the CAN Peripheral module clock.  */
GLOBAL_CAN_STATUS_t GLOBAL_CAN_Init(GLOBAL_CAN_t *handle)
{
 8029a36:	b580      	push	{r7, lr}
 8029a38:	b084      	sub	sp, #16
 8029a3a:	af00      	add	r7, sp, #0
 8029a3c:	6078      	str	r0, [r7, #4]
  GLOBAL_CAN_STATUS_t status = GLOBAL_CAN_STATUS_SUCCESS;
 8029a3e:	2300      	movs	r3, #0
 8029a40:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("GLOBAL_CAN_Init: handle null", handle != NULL);

  if (handle->init_status != true)
 8029a42:	687b      	ldr	r3, [r7, #4]
 8029a44:	7a5b      	ldrb	r3, [r3, #9]
 8029a46:	f083 0301 	eor.w	r3, r3, #1
 8029a4a:	b2db      	uxtb	r3, r3
 8029a4c:	2b00      	cmp	r3, #0
 8029a4e:	d00c      	beq.n	8029a6a <GLOBAL_CAN_Init+0x34>
  {
#if defined(MULTICAN_PLUS)
    XMC_CAN_InitEx(handle->canglobal_ptr, (XMC_CAN_CANCLKSRC_t)handle->can_clock_src, handle->can_frequency);
#else
    XMC_CAN_InitEx(handle->canglobal_ptr, XMC_CAN_CANCLKSRC_FPERI, handle->can_frequency);
 8029a50:	687b      	ldr	r3, [r7, #4]
 8029a52:	6858      	ldr	r0, [r3, #4]
 8029a54:	687b      	ldr	r3, [r7, #4]
 8029a56:	681b      	ldr	r3, [r3, #0]
 8029a58:	461a      	mov	r2, r3
 8029a5a:	2101      	movs	r1, #1
 8029a5c:	f7fd fb7e 	bl	802715c <XMC_CAN_InitEx>
#endif
    handle->init_status = true;
 8029a60:	687b      	ldr	r3, [r7, #4]
 8029a62:	2201      	movs	r2, #1
 8029a64:	725a      	strb	r2, [r3, #9]
    status = GLOBAL_CAN_STATUS_SUCCESS;
 8029a66:	2300      	movs	r3, #0
 8029a68:	73fb      	strb	r3, [r7, #15]
  }
  return (status);
 8029a6a:	7bfb      	ldrb	r3, [r7, #15]

}
 8029a6c:	4618      	mov	r0, r3
 8029a6e:	3710      	adds	r7, #16
 8029a70:	46bd      	mov	sp, r7
 8029a72:	bd80      	pop	{r7, pc}

08029a74 <XMC_VADC_GLOBAL_DisablePostCalibration>:
{
 8029a74:	b480      	push	{r7}
 8029a76:	b083      	sub	sp, #12
 8029a78:	af00      	add	r7, sp, #0
 8029a7a:	6078      	str	r0, [r7, #4]
 8029a7c:	6039      	str	r1, [r7, #0]
  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 8029a7e:	687b      	ldr	r3, [r7, #4]
 8029a80:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8029a84:	683b      	ldr	r3, [r7, #0]
 8029a86:	3310      	adds	r3, #16
 8029a88:	2101      	movs	r1, #1
 8029a8a:	fa01 f303 	lsl.w	r3, r1, r3
 8029a8e:	431a      	orrs	r2, r3
 8029a90:	687b      	ldr	r3, [r7, #4]
 8029a92:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 8029a96:	bf00      	nop
 8029a98:	370c      	adds	r7, #12
 8029a9a:	46bd      	mov	sp, r7
 8029a9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029aa0:	4770      	bx	lr

08029aa2 <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 8029aa2:	b580      	push	{r7, lr}
 8029aa4:	b084      	sub	sp, #16
 8029aa6:	af00      	add	r7, sp, #0
 8029aa8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL));
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 8029aaa:	687b      	ldr	r3, [r7, #4]
 8029aac:	7e1b      	ldrb	r3, [r3, #24]
 8029aae:	2b02      	cmp	r3, #2
 8029ab0:	d148      	bne.n	8029b44 <GLOBAL_ADC_Init+0xa2>
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 8029ab2:	687b      	ldr	r3, [r7, #4]
 8029ab4:	695a      	ldr	r2, [r3, #20]
 8029ab6:	687b      	ldr	r3, [r7, #4]
 8029ab8:	691b      	ldr	r3, [r3, #16]
 8029aba:	4619      	mov	r1, r3
 8029abc:	4610      	mov	r0, r2
 8029abe:	f7fe fd11 	bl	80284e4 <XMC_VADC_GLOBAL_Init>

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8029ac2:	2300      	movs	r3, #0
 8029ac4:	60fb      	str	r3, [r7, #12]
 8029ac6:	e02e      	b.n	8029b26 <GLOBAL_ADC_Init+0x84>
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 8029ac8:	687b      	ldr	r3, [r7, #4]
 8029aca:	68fa      	ldr	r2, [r7, #12]
 8029acc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029ad0:	6818      	ldr	r0, [r3, #0]
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);
 8029ad2:	687b      	ldr	r3, [r7, #4]
 8029ad4:	68fa      	ldr	r2, [r7, #12]
 8029ad6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 8029ada:	685b      	ldr	r3, [r3, #4]
 8029adc:	4619      	mov	r1, r3
 8029ade:	f7fe fdaa 	bl	8028636 <XMC_VADC_GROUP_Init>

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 8029ae2:	687b      	ldr	r3, [r7, #4]
 8029ae4:	68fa      	ldr	r2, [r7, #12]
 8029ae6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029aea:	681b      	ldr	r3, [r3, #0]
 8029aec:	2103      	movs	r1, #3
 8029aee:	4618      	mov	r0, r3
 8029af0:	f7fe fe32 	bl	8028758 <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 8029af4:	687b      	ldr	r3, [r7, #4]
 8029af6:	68fa      	ldr	r2, [r7, #12]
 8029af8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029afc:	7a1b      	ldrb	r3, [r3, #8]
 8029afe:	f083 0301 	eor.w	r3, r3, #1
 8029b02:	b2db      	uxtb	r3, r3
 8029b04:	2b00      	cmp	r3, #0
 8029b06:	d005      	beq.n	8029b14 <GLOBAL_ADC_Init+0x72>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 8029b08:	687b      	ldr	r3, [r7, #4]
 8029b0a:	695b      	ldr	r3, [r3, #20]
 8029b0c:	68f9      	ldr	r1, [r7, #12]
 8029b0e:	4618      	mov	r0, r3
 8029b10:	f7ff ffb0 	bl	8029a74 <XMC_VADC_GLOBAL_DisablePostCalibration>

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 8029b14:	687b      	ldr	r3, [r7, #4]
 8029b16:	68fa      	ldr	r2, [r7, #12]
 8029b18:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8029b1c:	2200      	movs	r2, #0
 8029b1e:	725a      	strb	r2, [r3, #9]
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8029b20:	68fb      	ldr	r3, [r7, #12]
 8029b22:	3301      	adds	r3, #1
 8029b24:	60fb      	str	r3, [r7, #12]
 8029b26:	68fb      	ldr	r3, [r7, #12]
 8029b28:	2b03      	cmp	r3, #3
 8029b2a:	d9cd      	bls.n	8029ac8 <GLOBAL_ADC_Init+0x26>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 8029b2c:	687b      	ldr	r3, [r7, #4]
 8029b2e:	7e5b      	ldrb	r3, [r3, #25]
 8029b30:	2b00      	cmp	r3, #0
 8029b32:	d004      	beq.n	8029b3e <GLOBAL_ADC_Init+0x9c>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 8029b34:	687b      	ldr	r3, [r7, #4]
 8029b36:	695b      	ldr	r3, [r3, #20]
 8029b38:	4618      	mov	r0, r3
 8029b3a:	f7fe fd23 	bl	8028584 <XMC_VADC_GLOBAL_StartupCalibration>
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 8029b3e:	687b      	ldr	r3, [r7, #4]
 8029b40:	2200      	movs	r2, #0
 8029b42:	761a      	strb	r2, [r3, #24]
  }
  return (handle_ptr->init_state);
 8029b44:	687b      	ldr	r3, [r7, #4]
 8029b46:	7e1b      	ldrb	r3, [r3, #24]
}
 8029b48:	4618      	mov	r0, r3
 8029b4a:	3710      	adds	r7, #16
 8029b4c:	46bd      	mov	sp, r7
 8029b4e:	bd80      	pop	{r7, pc}

08029b50 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8029b50:	b580      	push	{r7, lr}
 8029b52:	b082      	sub	sp, #8
 8029b54:	af00      	add	r7, sp, #0
 8029b56:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 8029b58:	687b      	ldr	r3, [r7, #4]
 8029b5a:	6818      	ldr	r0, [r3, #0]
 8029b5c:	687b      	ldr	r3, [r7, #4]
 8029b5e:	7c19      	ldrb	r1, [r3, #16]
 8029b60:	687b      	ldr	r3, [r7, #4]
 8029b62:	3304      	adds	r3, #4
 8029b64:	461a      	mov	r2, r3
 8029b66:	f7fc fcab 	bl	80264c0 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8029b6a:	687b      	ldr	r3, [r7, #4]
 8029b6c:	6818      	ldr	r0, [r3, #0]
 8029b6e:	687b      	ldr	r3, [r7, #4]
 8029b70:	7c19      	ldrb	r1, [r3, #16]
 8029b72:	687b      	ldr	r3, [r7, #4]
 8029b74:	7c5b      	ldrb	r3, [r3, #17]
 8029b76:	461a      	mov	r2, r3
 8029b78:	f7fe fb68 	bl	802824c <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
 8029b7c:	2300      	movs	r3, #0
}
 8029b7e:	4618      	mov	r0, r3
 8029b80:	3708      	adds	r7, #8
 8029b82:	46bd      	mov	sp, r7
 8029b84:	bd80      	pop	{r7, pc}
	...

08029b88 <__NVIC_SetPriorityGrouping>:
{
 8029b88:	b480      	push	{r7}
 8029b8a:	b085      	sub	sp, #20
 8029b8c:	af00      	add	r7, sp, #0
 8029b8e:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8029b90:	687b      	ldr	r3, [r7, #4]
 8029b92:	f003 0307 	and.w	r3, r3, #7
 8029b96:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8029b98:	4b0c      	ldr	r3, [pc, #48]	; (8029bcc <__NVIC_SetPriorityGrouping+0x44>)
 8029b9a:	68db      	ldr	r3, [r3, #12]
 8029b9c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8029b9e:	68ba      	ldr	r2, [r7, #8]
 8029ba0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8029ba4:	4013      	ands	r3, r2
 8029ba6:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8029ba8:	68fb      	ldr	r3, [r7, #12]
 8029baa:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8029bac:	68bb      	ldr	r3, [r7, #8]
 8029bae:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8029bb0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8029bb4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8029bb8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8029bba:	4a04      	ldr	r2, [pc, #16]	; (8029bcc <__NVIC_SetPriorityGrouping+0x44>)
 8029bbc:	68bb      	ldr	r3, [r7, #8]
 8029bbe:	60d3      	str	r3, [r2, #12]
}
 8029bc0:	bf00      	nop
 8029bc2:	3714      	adds	r7, #20
 8029bc4:	46bd      	mov	sp, r7
 8029bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029bca:	4770      	bx	lr
 8029bcc:	e000ed00 	.word	0xe000ed00

08029bd0 <SystemCoreSetup>:
  .initialized = false
};	


void SystemCoreSetup(void)
{
 8029bd0:	b580      	push	{r7, lr}
 8029bd2:	b082      	sub	sp, #8
 8029bd4:	af00      	add	r7, sp, #0
  uint32_t temp;

  NVIC_SetPriorityGrouping(1U);
 8029bd6:	2001      	movs	r0, #1
 8029bd8:	f7ff ffd6 	bl	8029b88 <__NVIC_SetPriorityGrouping>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8029bdc:	b672      	cpsid	i
}
 8029bde:	bf00      	nop
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 8029be0:	4b22      	ldr	r3, [pc, #136]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029be2:	4a23      	ldr	r2, [pc, #140]	; (8029c70 <SystemCoreSetup+0xa0>)
 8029be4:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8029be6:	f3bf 8f4f 	dsb	sy
}
 8029bea:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8029bec:	b662      	cpsie	i
}
 8029bee:	bf00      	nop

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8029bf0:	4b1e      	ldr	r3, [pc, #120]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029bf2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8029bf6:	4a1d      	ldr	r2, [pc, #116]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029bf8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8029bfc:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8029c00:	4b1c      	ldr	r3, [pc, #112]	; (8029c74 <SystemCoreSetup+0xa4>)
 8029c02:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8029c06:	695b      	ldr	r3, [r3, #20]
 8029c08:	607b      	str	r3, [r7, #4]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8029c0a:	687b      	ldr	r3, [r7, #4]
 8029c0c:	f023 030f 	bic.w	r3, r3, #15
 8029c10:	607b      	str	r3, [r7, #4]
  temp |= PMU_FLASH_WS;
 8029c12:	687b      	ldr	r3, [r7, #4]
 8029c14:	f043 0303 	orr.w	r3, r3, #3
 8029c18:	607b      	str	r3, [r7, #4]
  FLASH0->FCON = temp;
 8029c1a:	4b16      	ldr	r3, [pc, #88]	; (8029c74 <SystemCoreSetup+0xa4>)
 8029c1c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8029c20:	461a      	mov	r2, r3
 8029c22:	687b      	ldr	r3, [r7, #4]
 8029c24:	6153      	str	r3, [r2, #20]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 8029c26:	4b11      	ldr	r3, [pc, #68]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c28:	695b      	ldr	r3, [r3, #20]
 8029c2a:	4a10      	ldr	r2, [pc, #64]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c2c:	f023 0310 	bic.w	r3, r3, #16
 8029c30:	6153      	str	r3, [r2, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 8029c32:	4b0e      	ldr	r3, [pc, #56]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c34:	695b      	ldr	r3, [r3, #20]
 8029c36:	4a0d      	ldr	r2, [pc, #52]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c38:	f023 0308 	bic.w	r3, r3, #8
 8029c3c:	6153      	str	r3, [r2, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8029c3e:	4b0b      	ldr	r3, [pc, #44]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029c42:	4a0a      	ldr	r2, [pc, #40]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c44:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8029c48:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 8029c4a:	4b08      	ldr	r3, [pc, #32]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029c4e:	4a07      	ldr	r2, [pc, #28]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c50:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8029c54:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 8029c56:	4b05      	ldr	r3, [pc, #20]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029c5a:	4a04      	ldr	r2, [pc, #16]	; (8029c6c <SystemCoreSetup+0x9c>)
 8029c5c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8029c60:	6253      	str	r3, [r2, #36]	; 0x24
}
 8029c62:	bf00      	nop
 8029c64:	3708      	adds	r7, #8
 8029c66:	46bd      	mov	sp, r7
 8029c68:	bd80      	pop	{r7, pc}
 8029c6a:	bf00      	nop
 8029c6c:	e000ed00 	.word	0xe000ed00
 8029c70:	08020400 	.word	0x08020400
 8029c74:	58001000 	.word	0x58001000

08029c78 <CLOCK_XMC4_Init>:

/*
 * API to initialize the CLOCK_XMC4 APP TRAP events
 */
CLOCK_XMC4_STATUS_t CLOCK_XMC4_Init(CLOCK_XMC4_t *handle)
{
 8029c78:	b480      	push	{r7}
 8029c7a:	b085      	sub	sp, #20
 8029c7c:	af00      	add	r7, sp, #0
 8029c7e:	6078      	str	r0, [r7, #4]
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;
 8029c80:	2300      	movs	r3, #0
 8029c82:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8029c84:	687b      	ldr	r3, [r7, #4]
 8029c86:	2201      	movs	r2, #1
 8029c88:	701a      	strb	r2, [r3, #0]

  return (status);
 8029c8a:	7bfb      	ldrb	r3, [r7, #15]
}
 8029c8c:	4618      	mov	r0, r3
 8029c8e:	3714      	adds	r7, #20
 8029c90:	46bd      	mov	sp, r7
 8029c92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029c96:	4770      	bx	lr

08029c98 <OSCHP_GetFrequency>:

#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
 8029c98:	b480      	push	{r7}
 8029c9a:	af00      	add	r7, sp, #0
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
 8029c9c:	4b02      	ldr	r3, [pc, #8]	; (8029ca8 <OSCHP_GetFrequency+0x10>)
}
 8029c9e:	4618      	mov	r0, r3
 8029ca0:	46bd      	mov	sp, r7
 8029ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029ca6:	4770      	bx	lr
 8029ca8:	007a1200 	.word	0x007a1200

08029cac <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8029cac:	b5b0      	push	{r4, r5, r7, lr}
 8029cae:	b086      	sub	sp, #24
 8029cb0:	af00      	add	r7, sp, #0
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8029cb2:	4b13      	ldr	r3, [pc, #76]	; (8029d00 <SystemCoreClockSetup+0x54>)
 8029cb4:	1d3c      	adds	r4, r7, #4
 8029cb6:	461d      	mov	r5, r3
 8029cb8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8029cba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8029cbc:	682b      	ldr	r3, [r5, #0]
 8029cbe:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 8029cc0:	1d3b      	adds	r3, r7, #4
 8029cc2:	4618      	mov	r0, r3
 8029cc4:	f7fc fcfe 	bl	80266c4 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 8029cc8:	2000      	movs	r0, #0
 8029cca:	f7fc fdf5 	bl	80268b8 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 8029cce:	2000      	movs	r0, #0
 8029cd0:	f7fc fda8 	bl	8026824 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 8029cd4:	2004      	movs	r0, #4
 8029cd6:	f7fc fe5d 	bl	8026994 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_EnableUsbPll();
 8029cda:	f7fc fead 	bl	8026a38 <XMC_SCU_CLOCK_EnableUsbPll>
  XMC_SCU_CLOCK_StartUsbPll(1U, 48U);
 8029cde:	2130      	movs	r1, #48	; 0x30
 8029ce0:	2001      	movs	r0, #1
 8029ce2:	f7fc febb 	bl	8026a5c <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_OFI);
 8029ce6:	2000      	movs	r0, #0
 8029ce8:	f7fc fdb0 	bl	802684c <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 8029cec:	2001      	movs	r0, #1
 8029cee:	f7fc fe7d 	bl	80269ec <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 8029cf2:	2001      	movs	r0, #1
 8029cf4:	f7fc fe64 	bl	80269c0 <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 8029cf8:	bf00      	nop
 8029cfa:	3718      	adds	r7, #24
 8029cfc:	46bd      	mov	sp, r7
 8029cfe:	bdb0      	pop	{r4, r5, r7, pc}
 8029d00:	0802b4ec 	.word	0x0802b4ec

08029d04 <XMC_CAN_NODE_SetEventNodePointer>:
{
 8029d04:	b480      	push	{r7}
 8029d06:	b085      	sub	sp, #20
 8029d08:	af00      	add	r7, sp, #0
 8029d0a:	60f8      	str	r0, [r7, #12]
 8029d0c:	460b      	mov	r3, r1
 8029d0e:	607a      	str	r2, [r7, #4]
 8029d10:	72fb      	strb	r3, [r7, #11]
  can_node->NIPR = (uint32_t)((can_node->NIPR) & ~(uint32_t)(CAN_NODE_NIPR_Msk << (uint32_t)ptr_event)) | (service_request << (uint32_t)ptr_event);
 8029d12:	68fb      	ldr	r3, [r7, #12]
 8029d14:	689a      	ldr	r2, [r3, #8]
 8029d16:	7afb      	ldrb	r3, [r7, #11]
 8029d18:	2107      	movs	r1, #7
 8029d1a:	fa01 f303 	lsl.w	r3, r1, r3
 8029d1e:	43db      	mvns	r3, r3
 8029d20:	401a      	ands	r2, r3
 8029d22:	7afb      	ldrb	r3, [r7, #11]
 8029d24:	6879      	ldr	r1, [r7, #4]
 8029d26:	fa01 f303 	lsl.w	r3, r1, r3
 8029d2a:	431a      	orrs	r2, r3
 8029d2c:	68fb      	ldr	r3, [r7, #12]
 8029d2e:	609a      	str	r2, [r3, #8]
}
 8029d30:	bf00      	nop
 8029d32:	3714      	adds	r7, #20
 8029d34:	46bd      	mov	sp, r7
 8029d36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029d3a:	4770      	bx	lr

08029d3c <XMC_CAN_NODE_SetReceiveInput>:
{
 8029d3c:	b480      	push	{r7}
 8029d3e:	b083      	sub	sp, #12
 8029d40:	af00      	add	r7, sp, #0
 8029d42:	6078      	str	r0, [r7, #4]
 8029d44:	460b      	mov	r3, r1
 8029d46:	70fb      	strb	r3, [r7, #3]
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 8029d48:	687b      	ldr	r3, [r7, #4]
 8029d4a:	68db      	ldr	r3, [r3, #12]
 8029d4c:	f023 0207 	bic.w	r2, r3, #7
                   (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Msk);
 8029d50:	78fb      	ldrb	r3, [r7, #3]
 8029d52:	f003 0307 	and.w	r3, r3, #7
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 8029d56:	431a      	orrs	r2, r3
 8029d58:	687b      	ldr	r3, [r7, #4]
 8029d5a:	60da      	str	r2, [r3, #12]
}
 8029d5c:	bf00      	nop
 8029d5e:	370c      	adds	r7, #12
 8029d60:	46bd      	mov	sp, r7
 8029d62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029d66:	4770      	bx	lr

08029d68 <XMC_CAN_NODE_EnableLoopBack>:
{
 8029d68:	b480      	push	{r7}
 8029d6a:	b083      	sub	sp, #12
 8029d6c:	af00      	add	r7, sp, #0
 8029d6e:	6078      	str	r0, [r7, #4]
  can_node->NPCR |= (uint32_t)CAN_NODE_NPCR_LBM_Msk;
 8029d70:	687b      	ldr	r3, [r7, #4]
 8029d72:	68db      	ldr	r3, [r3, #12]
 8029d74:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8029d78:	687b      	ldr	r3, [r7, #4]
 8029d7a:	60da      	str	r2, [r3, #12]
}
 8029d7c:	bf00      	nop
 8029d7e:	370c      	adds	r7, #12
 8029d80:	46bd      	mov	sp, r7
 8029d82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029d86:	4770      	bx	lr

08029d88 <XMC_CAN_NODE_GetStatus>:
{
 8029d88:	b480      	push	{r7}
 8029d8a:	b083      	sub	sp, #12
 8029d8c:	af00      	add	r7, sp, #0
 8029d8e:	6078      	str	r0, [r7, #4]
  return ((can_node->NSR));
 8029d90:	687b      	ldr	r3, [r7, #4]
 8029d92:	685b      	ldr	r3, [r3, #4]
}
 8029d94:	4618      	mov	r0, r3
 8029d96:	370c      	adds	r7, #12
 8029d98:	46bd      	mov	sp, r7
 8029d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029d9e:	4770      	bx	lr

08029da0 <XMC_CAN_NODE_EnableConfigurationChange>:
{
 8029da0:	b480      	push	{r7}
 8029da2:	b083      	sub	sp, #12
 8029da4:	af00      	add	r7, sp, #0
 8029da6:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8029da8:	687b      	ldr	r3, [r7, #4]
 8029daa:	681b      	ldr	r3, [r3, #0]
 8029dac:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8029db0:	687b      	ldr	r3, [r7, #4]
 8029db2:	601a      	str	r2, [r3, #0]
}
 8029db4:	bf00      	nop
 8029db6:	370c      	adds	r7, #12
 8029db8:	46bd      	mov	sp, r7
 8029dba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029dbe:	4770      	bx	lr

08029dc0 <XMC_CAN_NODE_DisableConfigurationChange>:
{
 8029dc0:	b480      	push	{r7}
 8029dc2:	b083      	sub	sp, #12
 8029dc4:	af00      	add	r7, sp, #0
 8029dc6:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 8029dc8:	687b      	ldr	r3, [r7, #4]
 8029dca:	681b      	ldr	r3, [r3, #0]
 8029dcc:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8029dd0:	687b      	ldr	r3, [r7, #4]
 8029dd2:	601a      	str	r2, [r3, #0]
}
 8029dd4:	bf00      	nop
 8029dd6:	370c      	adds	r7, #12
 8029dd8:	46bd      	mov	sp, r7
 8029dda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029dde:	4770      	bx	lr

08029de0 <XMC_CAN_NODE_SetInitBit>:
 * XMC_CAN_NODE_ResetInitBit()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_SetInitBit(XMC_CAN_NODE_t *const can_node)
{
 8029de0:	b480      	push	{r7}
 8029de2:	b083      	sub	sp, #12
 8029de4:	af00      	add	r7, sp, #0
 8029de6:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_INIT_Msk;
 8029de8:	687b      	ldr	r3, [r7, #4]
 8029dea:	681b      	ldr	r3, [r3, #0]
 8029dec:	f043 0201 	orr.w	r2, r3, #1
 8029df0:	687b      	ldr	r3, [r7, #4]
 8029df2:	601a      	str	r2, [r3, #0]
}
 8029df4:	bf00      	nop
 8029df6:	370c      	adds	r7, #12
 8029df8:	46bd      	mov	sp, r7
 8029dfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029dfe:	4770      	bx	lr

08029e00 <XMC_CAN_NODE_ResetInitBit>:
 * \par<b>Related API's:</b><br>
 * XMC_CAN_NODE_SetInitBit()
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_ResetInitBit(XMC_CAN_NODE_t *const can_node)
{
 8029e00:	b480      	push	{r7}
 8029e02:	b083      	sub	sp, #12
 8029e04:	af00      	add	r7, sp, #0
 8029e06:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_INIT_Msk;
 8029e08:	687b      	ldr	r3, [r7, #4]
 8029e0a:	681b      	ldr	r3, [r3, #0]
 8029e0c:	f023 0201 	bic.w	r2, r3, #1
 8029e10:	687b      	ldr	r3, [r7, #4]
 8029e12:	601a      	str	r2, [r3, #0]
}
 8029e14:	bf00      	nop
 8029e16:	370c      	adds	r7, #12
 8029e18:	46bd      	mov	sp, r7
 8029e1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029e1e:	4770      	bx	lr

08029e20 <XMC_CAN_NODE_ReSetAnalyzerMode>:
 * XMC_CAN_NODE_SetAnalyzerMode()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_ReSetAnalyzerMode(XMC_CAN_NODE_t *const can_node)
{
 8029e20:	b480      	push	{r7}
 8029e22:	b083      	sub	sp, #12
 8029e24:	af00      	add	r7, sp, #0
 8029e26:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CALM_Msk;
 8029e28:	687b      	ldr	r3, [r7, #4]
 8029e2a:	681b      	ldr	r3, [r3, #0]
 8029e2c:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8029e30:	687b      	ldr	r3, [r7, #4]
 8029e32:	601a      	str	r2, [r3, #0]
}
 8029e34:	bf00      	nop
 8029e36:	370c      	adds	r7, #12
 8029e38:	46bd      	mov	sp, r7
 8029e3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029e3e:	4770      	bx	lr

08029e40 <XMC_CAN_MO_SetEventNodePointer>:
 */

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
    const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
    const uint32_t service_request)
{
 8029e40:	b480      	push	{r7}
 8029e42:	b085      	sub	sp, #20
 8029e44:	af00      	add	r7, sp, #0
 8029e46:	60f8      	str	r0, [r7, #12]
 8029e48:	460b      	mov	r3, r1
 8029e4a:	607a      	str	r2, [r7, #4]
 8029e4c:	72fb      	strb	r3, [r7, #11]
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 8029e4e:	68fb      	ldr	r3, [r7, #12]
 8029e50:	681b      	ldr	r3, [r3, #0]
 8029e52:	689a      	ldr	r2, [r3, #8]
 8029e54:	7afb      	ldrb	r3, [r7, #11]
 8029e56:	2107      	movs	r1, #7
 8029e58:	fa01 f303 	lsl.w	r3, r1, r3
 8029e5c:	43db      	mvns	r3, r3
 8029e5e:	ea02 0103 	and.w	r1, r2, r3
                              (service_request << (uint32_t)can_mo_ptr_int);
 8029e62:	7afb      	ldrb	r3, [r7, #11]
 8029e64:	687a      	ldr	r2, [r7, #4]
 8029e66:	409a      	lsls	r2, r3
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 8029e68:	68fb      	ldr	r3, [r7, #12]
 8029e6a:	681b      	ldr	r3, [r3, #0]
 8029e6c:	430a      	orrs	r2, r1
 8029e6e:	609a      	str	r2, [r3, #8]
}
 8029e70:	bf00      	nop
 8029e72:	3714      	adds	r7, #20
 8029e74:	46bd      	mov	sp, r7
 8029e76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029e7a:	4770      	bx	lr

08029e7c <XMC_CAN_MO_EnableEvent>:
 *
 */

__STATIC_INLINE void XMC_CAN_MO_EnableEvent(const XMC_CAN_MO_t *const can_mo,
    const uint32_t event)
{
 8029e7c:	b480      	push	{r7}
 8029e7e:	b083      	sub	sp, #12
 8029e80:	af00      	add	r7, sp, #0
 8029e82:	6078      	str	r0, [r7, #4]
 8029e84:	6039      	str	r1, [r7, #0]
  can_mo->can_mo_ptr->MOFCR |= event;
 8029e86:	687b      	ldr	r3, [r7, #4]
 8029e88:	681b      	ldr	r3, [r3, #0]
 8029e8a:	6819      	ldr	r1, [r3, #0]
 8029e8c:	687b      	ldr	r3, [r7, #4]
 8029e8e:	681b      	ldr	r3, [r3, #0]
 8029e90:	683a      	ldr	r2, [r7, #0]
 8029e92:	430a      	orrs	r2, r1
 8029e94:	601a      	str	r2, [r3, #0]
}
 8029e96:	bf00      	nop
 8029e98:	370c      	adds	r7, #12
 8029e9a:	46bd      	mov	sp, r7
 8029e9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029ea0:	4770      	bx	lr

08029ea2 <CAN_NODE_MO_EnableTxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableTxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
 8029ea2:	b580      	push	{r7, lr}
 8029ea4:	b082      	sub	sp, #8
 8029ea6:	af00      	add	r7, sp, #0
 8029ea8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableTxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_TRANSMIT);
 8029eaa:	687b      	ldr	r3, [r7, #4]
 8029eac:	681b      	ldr	r3, [r3, #0]
 8029eae:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8029eb2:	4618      	mov	r0, r3
 8029eb4:	f7ff ffe2 	bl	8029e7c <XMC_CAN_MO_EnableEvent>
}
 8029eb8:	bf00      	nop
 8029eba:	3708      	adds	r7, #8
 8029ebc:	46bd      	mov	sp, r7
 8029ebe:	bd80      	pop	{r7, pc}

08029ec0 <CAN_NODE_MO_EnableRxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableRxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
 8029ec0:	b580      	push	{r7, lr}
 8029ec2:	b082      	sub	sp, #8
 8029ec4:	af00      	add	r7, sp, #0
 8029ec6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableRxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_RECEIVE);
 8029ec8:	687b      	ldr	r3, [r7, #4]
 8029eca:	681b      	ldr	r3, [r3, #0]
 8029ecc:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8029ed0:	4618      	mov	r0, r3
 8029ed2:	f7ff ffd3 	bl	8029e7c <XMC_CAN_MO_EnableEvent>
}
 8029ed6:	bf00      	nop
 8029ed8:	3708      	adds	r7, #8
 8029eda:	46bd      	mov	sp, r7
 8029edc:	bd80      	pop	{r7, pc}

08029ede <CAN_NODE_SetNodeEvents>:
  * @param  handle is a pointer pointing to APP data structure.
  * @return None
  */

static void CAN_NODE_SetNodeEvents(const CAN_NODE_t *handle)
{
 8029ede:	b580      	push	{r7, lr}
 8029ee0:	b084      	sub	sp, #16
 8029ee2:	af00      	add	r7, sp, #0
 8029ee4:	6078      	str	r0, [r7, #4]
  uint32_t lnode_event = 0U;
 8029ee6:	2300      	movs	r3, #0
 8029ee8:	60fb      	str	r3, [r7, #12]

  XMC_ASSERT("CAN_NODE_lInit: handle null", handle != NULL);

  CAN_NODE_SetNodePointer(handle); /* set node service pointer */
 8029eea:	6878      	ldr	r0, [r7, #4]
 8029eec:	f000 f831 	bl	8029f52 <CAN_NODE_SetNodePointer>

  if (handle->txok_event_enable == true)
 8029ef0:	687b      	ldr	r3, [r7, #4]
 8029ef2:	f893 30a4 	ldrb.w	r3, [r3, #164]	; 0xa4
 8029ef6:	2b00      	cmp	r3, #0
 8029ef8:	d003      	beq.n	8029f02 <CAN_NODE_SetNodeEvents+0x24>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_TX_INT;
 8029efa:	68fb      	ldr	r3, [r7, #12]
 8029efc:	f043 0302 	orr.w	r3, r3, #2
 8029f00:	60fb      	str	r3, [r7, #12]
  }
  if (handle->lec_event_enable == true)
 8029f02:	687b      	ldr	r3, [r7, #4]
 8029f04:	f893 30a3 	ldrb.w	r3, [r3, #163]	; 0xa3
 8029f08:	2b00      	cmp	r3, #0
 8029f0a:	d003      	beq.n	8029f14 <CAN_NODE_SetNodeEvents+0x36>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_LEC;
 8029f0c:	68fb      	ldr	r3, [r7, #12]
 8029f0e:	f043 0304 	orr.w	r3, r3, #4
 8029f12:	60fb      	str	r3, [r7, #12]
  }
  if (handle->alert_event_enable == true)
 8029f14:	687b      	ldr	r3, [r7, #4]
 8029f16:	f893 30a5 	ldrb.w	r3, [r3, #165]	; 0xa5
 8029f1a:	2b00      	cmp	r3, #0
 8029f1c:	d003      	beq.n	8029f26 <CAN_NODE_SetNodeEvents+0x48>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_ALERT;
 8029f1e:	68fb      	ldr	r3, [r7, #12]
 8029f20:	f043 0308 	orr.w	r3, r3, #8
 8029f24:	60fb      	str	r3, [r7, #12]
  }
  XMC_CAN_NODE_EnableEvent(handle->node_ptr, (XMC_CAN_NODE_EVENT_t)lnode_event);
 8029f26:	687b      	ldr	r3, [r7, #4]
 8029f28:	685b      	ldr	r3, [r3, #4]
 8029f2a:	68f9      	ldr	r1, [r7, #12]
 8029f2c:	4618      	mov	r0, r3
 8029f2e:	f7fd fb56 	bl	80275de <XMC_CAN_NODE_EnableEvent>

  if (handle->framecount_event_enable == true)
 8029f32:	687b      	ldr	r3, [r7, #4]
 8029f34:	f893 30a6 	ldrb.w	r3, [r3, #166]	; 0xa6
 8029f38:	2b00      	cmp	r3, #0
 8029f3a:	d006      	beq.n	8029f4a <CAN_NODE_SetNodeEvents+0x6c>
  {
    XMC_CAN_NODE_EnableEvent(handle->node_ptr, XMC_CAN_NODE_EVENT_CFCIE);
 8029f3c:	687b      	ldr	r3, [r7, #4]
 8029f3e:	685b      	ldr	r3, [r3, #4]
 8029f40:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8029f44:	4618      	mov	r0, r3
 8029f46:	f7fd fb4a 	bl	80275de <XMC_CAN_NODE_EnableEvent>
  }

}
 8029f4a:	bf00      	nop
 8029f4c:	3710      	adds	r7, #16
 8029f4e:	46bd      	mov	sp, r7
 8029f50:	bd80      	pop	{r7, pc}

08029f52 <CAN_NODE_SetNodePointer>:
  * @brief  Function to set the Node event pointer
  *
  */

static void CAN_NODE_SetNodePointer(const CAN_NODE_t *handle)
{
 8029f52:	b580      	push	{r7, lr}
 8029f54:	b082      	sub	sp, #8
 8029f56:	af00      	add	r7, sp, #0
 8029f58:	6078      	str	r0, [r7, #4]

  XMC_ASSERT("CAN_NODE_SetNodePointer: handle null", handle != NULL);

  /* Configured the node event pointer for the alert event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
 8029f5a:	687b      	ldr	r3, [r7, #4]
 8029f5c:	6858      	ldr	r0, [r3, #4]
                                                        handle->node_sr_ptr->alert_event_sr);
 8029f5e:	687b      	ldr	r3, [r7, #4]
 8029f60:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8029f64:	781b      	ldrb	r3, [r3, #0]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
 8029f66:	461a      	mov	r2, r3
 8029f68:	2100      	movs	r1, #0
 8029f6a:	f7ff fecb 	bl	8029d04 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the LEC event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
 8029f6e:	687b      	ldr	r3, [r7, #4]
 8029f70:	6858      	ldr	r0, [r3, #4]
                                                         handle->node_sr_ptr->lec_event_sr);
 8029f72:	687b      	ldr	r3, [r7, #4]
 8029f74:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8029f78:	785b      	ldrb	r3, [r3, #1]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
 8029f7a:	461a      	mov	r2, r3
 8029f7c:	2104      	movs	r1, #4
 8029f7e:	f7ff fec1 	bl	8029d04 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the TXOK event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
 8029f82:	687b      	ldr	r3, [r7, #4]
 8029f84:	6858      	ldr	r0, [r3, #4]
                                                               handle->node_sr_ptr->txok_event_sr);
 8029f86:	687b      	ldr	r3, [r7, #4]
 8029f88:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8029f8c:	789b      	ldrb	r3, [r3, #2]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
 8029f8e:	461a      	mov	r2, r3
 8029f90:	2108      	movs	r1, #8
 8029f92:	f7ff feb7 	bl	8029d04 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the Frame counter event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
 8029f96:	687b      	ldr	r3, [r7, #4]
 8029f98:	6858      	ldr	r0, [r3, #4]
                                                             handle->node_sr_ptr->framecount_event_sr);
 8029f9a:	687b      	ldr	r3, [r7, #4]
 8029f9c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8029fa0:	78db      	ldrb	r3, [r3, #3]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
 8029fa2:	461a      	mov	r2, r3
 8029fa4:	210c      	movs	r1, #12
 8029fa6:	f7ff fead 	bl	8029d04 <XMC_CAN_NODE_SetEventNodePointer>

}
 8029faa:	bf00      	nop
 8029fac:	3708      	adds	r7, #8
 8029fae:	46bd      	mov	sp, r7
 8029fb0:	bd80      	pop	{r7, pc}

08029fb2 <CAN_NODE_MO_Init>:
  XMC_CAN_NODE_NominalBitTimeConfigure(can_node, can_bit_time);
}

/*  Function to initialize the CAN MO based on UI configuration. */
void CAN_NODE_MO_Init(const CAN_NODE_LMO_t *lmo_ptr)
{
 8029fb2:	b580      	push	{r7, lr}
 8029fb4:	b082      	sub	sp, #8
 8029fb6:	af00      	add	r7, sp, #0
 8029fb8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_Init: lmo_ptr null", lmo_ptr != NULL);

  XMC_CAN_MO_Config(lmo_ptr->mo_ptr);
 8029fba:	687b      	ldr	r3, [r7, #4]
 8029fbc:	681b      	ldr	r3, [r3, #0]
 8029fbe:	4618      	mov	r0, r3
 8029fc0:	f7fd f942 	bl	8027248 <XMC_CAN_MO_Config>

  if (lmo_ptr->tx_event_enable == true)
 8029fc4:	687b      	ldr	r3, [r7, #4]
 8029fc6:	79db      	ldrb	r3, [r3, #7]
 8029fc8:	2b00      	cmp	r3, #0
 8029fca:	d00a      	beq.n	8029fe2 <CAN_NODE_MO_Init+0x30>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_TRANSMIT, lmo_ptr->tx_sr);
 8029fcc:	687b      	ldr	r3, [r7, #4]
 8029fce:	6818      	ldr	r0, [r3, #0]
 8029fd0:	687b      	ldr	r3, [r7, #4]
 8029fd2:	795b      	ldrb	r3, [r3, #5]
 8029fd4:	461a      	mov	r2, r3
 8029fd6:	2104      	movs	r1, #4
 8029fd8:	f7ff ff32 	bl	8029e40 <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableTxEvent(lmo_ptr);
 8029fdc:	6878      	ldr	r0, [r7, #4]
 8029fde:	f7ff ff60 	bl	8029ea2 <CAN_NODE_MO_EnableTxEvent>
  }
  if (lmo_ptr->rx_event_enable == true)
 8029fe2:	687b      	ldr	r3, [r7, #4]
 8029fe4:	7a1b      	ldrb	r3, [r3, #8]
 8029fe6:	2b00      	cmp	r3, #0
 8029fe8:	d00a      	beq.n	802a000 <CAN_NODE_MO_Init+0x4e>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_RECEIVE, lmo_ptr->rx_sr);
 8029fea:	687b      	ldr	r3, [r7, #4]
 8029fec:	6818      	ldr	r0, [r3, #0]
 8029fee:	687b      	ldr	r3, [r7, #4]
 8029ff0:	799b      	ldrb	r3, [r3, #6]
 8029ff2:	461a      	mov	r2, r3
 8029ff4:	2100      	movs	r1, #0
 8029ff6:	f7ff ff23 	bl	8029e40 <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableRxEvent(lmo_ptr);
 8029ffa:	6878      	ldr	r0, [r7, #4]
 8029ffc:	f7ff ff60 	bl	8029ec0 <CAN_NODE_MO_EnableRxEvent>
  }

}
 802a000:	bf00      	nop
 802a002:	3708      	adds	r7, #8
 802a004:	46bd      	mov	sp, r7
 802a006:	bd80      	pop	{r7, pc}

0802a008 <CAN_NODE_MO_Transmit>:

/* Function to transmit the can MO frame.  */
CAN_NODE_STATUS_t CAN_NODE_MO_Transmit(const CAN_NODE_LMO_t *lmo_ptr)
{
 802a008:	b580      	push	{r7, lr}
 802a00a:	b084      	sub	sp, #16
 802a00c:	af00      	add	r7, sp, #0
 802a00e:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a010:	2300      	movs	r3, #0
 802a012:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("CAN_NODE_MO_Transmit: lmo_ptr null", lmo_ptr != NULL);

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_Transmit(lmo_ptr->mo_ptr);
 802a014:	687b      	ldr	r3, [r7, #4]
 802a016:	681b      	ldr	r3, [r3, #0]
 802a018:	4618      	mov	r0, r3
 802a01a:	f7fd f9e9 	bl	80273f0 <XMC_CAN_MO_Transmit>
 802a01e:	4603      	mov	r3, r0
 802a020:	73fb      	strb	r3, [r7, #15]
  return (status);
 802a022:	7bfb      	ldrb	r3, [r7, #15]
}
 802a024:	4618      	mov	r0, r3
 802a026:	3710      	adds	r7, #16
 802a028:	46bd      	mov	sp, r7
 802a02a:	bd80      	pop	{r7, pc}

0802a02c <CAN_NODE_MO_Receive>:

/* Function to read the received CAN message from the selected message object. */
CAN_NODE_STATUS_t CAN_NODE_MO_Receive( CAN_NODE_LMO_t *lmo_ptr)
{
 802a02c:	b580      	push	{r7, lr}
 802a02e:	b084      	sub	sp, #16
 802a030:	af00      	add	r7, sp, #0
 802a032:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a034:	2300      	movs	r3, #0
 802a036:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("CAN_NODE_MO_Receive: lmo_ptr null", lmo_ptr != NULL);

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_Receive(lmo_ptr->mo_ptr);
 802a038:	687b      	ldr	r3, [r7, #4]
 802a03a:	681b      	ldr	r3, [r3, #0]
 802a03c:	4618      	mov	r0, r3
 802a03e:	f7fd fa05 	bl	802744c <XMC_CAN_MO_Receive>
 802a042:	4603      	mov	r3, r0
 802a044:	73fb      	strb	r3, [r7, #15]
  return (status);
 802a046:	7bfb      	ldrb	r3, [r7, #15]
}
 802a048:	4618      	mov	r0, r3
 802a04a:	3710      	adds	r7, #16
 802a04c:	46bd      	mov	sp, r7
 802a04e:	bd80      	pop	{r7, pc}

0802a050 <CAN_NODE_MO_UpdateData>:
  return (status);
}

/* Function to updates the data for the CAN Message Object. */
CAN_NODE_STATUS_t CAN_NODE_MO_UpdateData(const CAN_NODE_LMO_t *const lmo_ptr, uint8_t *array_data)
{
 802a050:	b580      	push	{r7, lr}
 802a052:	b084      	sub	sp, #16
 802a054:	af00      	add	r7, sp, #0
 802a056:	6078      	str	r0, [r7, #4]
 802a058:	6039      	str	r1, [r7, #0]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a05a:	2300      	movs	r3, #0
 802a05c:	73fb      	strb	r3, [r7, #15]
  uint32_t *data_pointer = (uint32_t*) array_data;
 802a05e:	683b      	ldr	r3, [r7, #0]
 802a060:	60bb      	str	r3, [r7, #8]

  XMC_ASSERT("CAN_NODE_MO_UpdateData: lmo_ptr null", lmo_ptr != NULL);

  lmo_ptr->mo_ptr->can_data[0U] = *data_pointer;
 802a062:	687b      	ldr	r3, [r7, #4]
 802a064:	681b      	ldr	r3, [r3, #0]
 802a066:	68ba      	ldr	r2, [r7, #8]
 802a068:	6812      	ldr	r2, [r2, #0]
 802a06a:	611a      	str	r2, [r3, #16]
  lmo_ptr->mo_ptr->can_data[1U] = *(data_pointer + 1U);
 802a06c:	687b      	ldr	r3, [r7, #4]
 802a06e:	681b      	ldr	r3, [r3, #0]
 802a070:	68ba      	ldr	r2, [r7, #8]
 802a072:	6852      	ldr	r2, [r2, #4]
 802a074:	615a      	str	r2, [r3, #20]

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_UpdateData(lmo_ptr->mo_ptr);
 802a076:	687b      	ldr	r3, [r7, #4]
 802a078:	681b      	ldr	r3, [r3, #0]
 802a07a:	4618      	mov	r0, r3
 802a07c:	f7fd f980 	bl	8027380 <XMC_CAN_MO_UpdateData>
 802a080:	4603      	mov	r3, r0
 802a082:	73fb      	strb	r3, [r7, #15]
  return (status);
 802a084:	7bfb      	ldrb	r3, [r7, #15]
}
 802a086:	4618      	mov	r0, r3
 802a088:	3710      	adds	r7, #16
 802a08a:	46bd      	mov	sp, r7
 802a08c:	bd80      	pop	{r7, pc}

0802a08e <CAN_NODE_GetStatus>:

}

/* Function to read the current status of the CAN node  */
uint32_t CAN_NODE_GetStatus(const CAN_NODE_t* handle)
{
 802a08e:	b580      	push	{r7, lr}
 802a090:	b084      	sub	sp, #16
 802a092:	af00      	add	r7, sp, #0
 802a094:	6078      	str	r0, [r7, #4]
  uint32_t  status;

  XMC_ASSERT("CAN_NODE_GetStatus: handle null", handle != NULL);

  XMC_CAN_NODE_t *const can_node = handle->node_ptr;
 802a096:	687b      	ldr	r3, [r7, #4]
 802a098:	685b      	ldr	r3, [r3, #4]
 802a09a:	60fb      	str	r3, [r7, #12]

  status = XMC_CAN_NODE_GetStatus(can_node);
 802a09c:	68f8      	ldr	r0, [r7, #12]
 802a09e:	f7ff fe73 	bl	8029d88 <XMC_CAN_NODE_GetStatus>
 802a0a2:	60b8      	str	r0, [r7, #8]
  return (status);
 802a0a4:	68bb      	ldr	r3, [r7, #8]
}
 802a0a6:	4618      	mov	r0, r3
 802a0a8:	3710      	adds	r7, #16
 802a0aa:	46bd      	mov	sp, r7
 802a0ac:	bd80      	pop	{r7, pc}

0802a0ae <CAN_NODE_Init>:
/*  Function to initialize the CAN node by configuring the baud rate, can bus type (External or internal)
 *  and message objects.
 */

CAN_NODE_STATUS_t CAN_NODE_Init(const CAN_NODE_t* handle)
{
 802a0ae:	b580      	push	{r7, lr}
 802a0b0:	b086      	sub	sp, #24
 802a0b2:	af00      	add	r7, sp, #0
 802a0b4:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 802a0b6:	2300      	movs	r3, #0
 802a0b8:	75fb      	strb	r3, [r7, #23]
  uint32_t loop_count;
  const CAN_NODE_LMO_t *lmo_ptr;

  XMC_ASSERT("CAN_NODE_Init: handle null", handle != NULL);

  const CAN_NODE_GPIO_t *const lgpio_ptr = handle->gpio_out;
 802a0ba:	687b      	ldr	r3, [r7, #4]
 802a0bc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 802a0c0:	60fb      	str	r3, [r7, #12]

  /* Initialize the GLOBAL_CAN APP */
  status  = (CAN_NODE_STATUS_t)GLOBAL_CAN_Init(handle->global_ptr);
 802a0c2:	687b      	ldr	r3, [r7, #4]
 802a0c4:	681b      	ldr	r3, [r3, #0]
 802a0c6:	4618      	mov	r0, r3
 802a0c8:	f7ff fcb5 	bl	8029a36 <GLOBAL_CAN_Init>
 802a0cc:	4603      	mov	r3, r0
 802a0ce:	75fb      	strb	r3, [r7, #23]

  if (status == CAN_NODE_STATUS_SUCCESS)
 802a0d0:	7dfb      	ldrb	r3, [r7, #23]
 802a0d2:	2b00      	cmp	r3, #0
 802a0d4:	f040 8081 	bne.w	802a1da <CAN_NODE_Init+0x12c>
  {
    /* Initialize the GUI configured values for baud rate to NBTR Reg */
    if (XMC_CAN_NODE_NominalBitTimeConfigureEx(handle->node_ptr, handle->baudrate_config) == XMC_CAN_STATUS_SUCCESS)
 802a0d8:	687b      	ldr	r3, [r7, #4]
 802a0da:	685a      	ldr	r2, [r3, #4]
 802a0dc:	687b      	ldr	r3, [r7, #4]
 802a0de:	689b      	ldr	r3, [r3, #8]
 802a0e0:	4619      	mov	r1, r3
 802a0e2:	4610      	mov	r0, r2
 802a0e4:	f7fc ff3c 	bl	8026f60 <XMC_CAN_NODE_NominalBitTimeConfigureEx>
 802a0e8:	4603      	mov	r3, r0
 802a0ea:	2b00      	cmp	r3, #0
 802a0ec:	d172      	bne.n	802a1d4 <CAN_NODE_Init+0x126>
    {
      /* set CCE and INIT bit NCR for node configuration */

      XMC_CAN_NODE_EnableConfigurationChange(handle->node_ptr);
 802a0ee:	687b      	ldr	r3, [r7, #4]
 802a0f0:	685b      	ldr	r3, [r3, #4]
 802a0f2:	4618      	mov	r0, r3
 802a0f4:	f7ff fe54 	bl	8029da0 <XMC_CAN_NODE_EnableConfigurationChange>
      XMC_CAN_NODE_SetInitBit(handle->node_ptr);
 802a0f8:	687b      	ldr	r3, [r7, #4]
 802a0fa:	685b      	ldr	r3, [r3, #4]
 802a0fc:	4618      	mov	r0, r3
 802a0fe:	f7ff fe6f 	bl	8029de0 <XMC_CAN_NODE_SetInitBit>
      XMC_CAN_NODE_ReSetAnalyzerMode(handle->node_ptr);
 802a102:	687b      	ldr	r3, [r7, #4]
 802a104:	685b      	ldr	r3, [r3, #4]
 802a106:	4618      	mov	r0, r3
 802a108:	f7ff fe8a 	bl	8029e20 <XMC_CAN_NODE_ReSetAnalyzerMode>

      if (handle->loopback_enable == true) /* Loop back mode enabled */
 802a10c:	687b      	ldr	r3, [r7, #4]
 802a10e:	f893 30a7 	ldrb.w	r3, [r3, #167]	; 0xa7
 802a112:	2b00      	cmp	r3, #0
 802a114:	d005      	beq.n	802a122 <CAN_NODE_Init+0x74>
      {
        XMC_CAN_NODE_EnableLoopBack(handle->node_ptr);
 802a116:	687b      	ldr	r3, [r7, #4]
 802a118:	685b      	ldr	r3, [r3, #4]
 802a11a:	4618      	mov	r0, r3
 802a11c:	f7ff fe24 	bl	8029d68 <XMC_CAN_NODE_EnableLoopBack>
 802a120:	e016      	b.n	802a150 <CAN_NODE_Init+0xa2>
      }
      else
      {
        XMC_GPIO_Init(handle->gpio_in->port, handle->gpio_in->pin, handle->gpio_in_config);
 802a122:	687b      	ldr	r3, [r7, #4]
 802a124:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 802a128:	6818      	ldr	r0, [r3, #0]
 802a12a:	687b      	ldr	r3, [r7, #4]
 802a12c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 802a130:	7919      	ldrb	r1, [r3, #4]
 802a132:	687b      	ldr	r3, [r7, #4]
 802a134:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 802a138:	461a      	mov	r2, r3
 802a13a:	f7fc f9c1 	bl	80264c0 <XMC_GPIO_Init>
        XMC_CAN_NODE_SetReceiveInput(handle->node_ptr, handle->rx_signal);
 802a13e:	687b      	ldr	r3, [r7, #4]
 802a140:	685a      	ldr	r2, [r3, #4]
 802a142:	687b      	ldr	r3, [r7, #4]
 802a144:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
 802a148:	4619      	mov	r1, r3
 802a14a:	4610      	mov	r0, r2
 802a14c:	f7ff fdf6 	bl	8029d3c <XMC_CAN_NODE_SetReceiveInput>
      }
      CAN_NODE_SetNodeEvents(handle); /* API to enable node events */
 802a150:	6878      	ldr	r0, [r7, #4]
 802a152:	f7ff fec4 	bl	8029ede <CAN_NODE_SetNodeEvents>

      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
 802a156:	2300      	movs	r3, #0
 802a158:	613b      	str	r3, [r7, #16]
 802a15a:	e017      	b.n	802a18c <CAN_NODE_Init+0xde>
      {
        lmo_ptr = handle->lmobj_ptr[loop_count];
 802a15c:	687a      	ldr	r2, [r7, #4]
 802a15e:	693b      	ldr	r3, [r7, #16]
 802a160:	3302      	adds	r3, #2
 802a162:	009b      	lsls	r3, r3, #2
 802a164:	4413      	add	r3, r2
 802a166:	685b      	ldr	r3, [r3, #4]
 802a168:	60bb      	str	r3, [r7, #8]
        XMC_CAN_AllocateMOtoNodeList(handle->global_ptr->canglobal_ptr, handle->node_num, lmo_ptr->number);
 802a16a:	687b      	ldr	r3, [r7, #4]
 802a16c:	681b      	ldr	r3, [r3, #0]
 802a16e:	6858      	ldr	r0, [r3, #4]
 802a170:	687b      	ldr	r3, [r7, #4]
 802a172:	f893 10a1 	ldrb.w	r1, [r3, #161]	; 0xa1
 802a176:	68bb      	ldr	r3, [r7, #8]
 802a178:	791b      	ldrb	r3, [r3, #4]
 802a17a:	461a      	mov	r2, r3
 802a17c:	f7fc ff9a 	bl	80270b4 <XMC_CAN_AllocateMOtoNodeList>
        CAN_NODE_MO_Init(lmo_ptr);
 802a180:	68b8      	ldr	r0, [r7, #8]
 802a182:	f7ff ff16 	bl	8029fb2 <CAN_NODE_MO_Init>
      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
 802a186:	693b      	ldr	r3, [r7, #16]
 802a188:	3301      	adds	r3, #1
 802a18a:	613b      	str	r3, [r7, #16]
 802a18c:	687b      	ldr	r3, [r7, #4]
 802a18e:	f893 30a2 	ldrb.w	r3, [r3, #162]	; 0xa2
 802a192:	461a      	mov	r2, r3
 802a194:	693b      	ldr	r3, [r7, #16]
 802a196:	4293      	cmp	r3, r2
 802a198:	d3e0      	bcc.n	802a15c <CAN_NODE_Init+0xae>
      }
      /* reset CCE and INIT bit NCR for node configuration */
      XMC_CAN_NODE_DisableConfigurationChange(handle->node_ptr);
 802a19a:	687b      	ldr	r3, [r7, #4]
 802a19c:	685b      	ldr	r3, [r3, #4]
 802a19e:	4618      	mov	r0, r3
 802a1a0:	f7ff fe0e 	bl	8029dc0 <XMC_CAN_NODE_DisableConfigurationChange>
      XMC_CAN_NODE_ResetInitBit(handle->node_ptr);
 802a1a4:	687b      	ldr	r3, [r7, #4]
 802a1a6:	685b      	ldr	r3, [r3, #4]
 802a1a8:	4618      	mov	r0, r3
 802a1aa:	f7ff fe29 	bl	8029e00 <XMC_CAN_NODE_ResetInitBit>
      if (handle->loopback_enable == false)
 802a1ae:	687b      	ldr	r3, [r7, #4]
 802a1b0:	f893 30a7 	ldrb.w	r3, [r3, #167]	; 0xa7
 802a1b4:	f083 0301 	eor.w	r3, r3, #1
 802a1b8:	b2db      	uxtb	r3, r3
 802a1ba:	2b00      	cmp	r3, #0
 802a1bc:	d00f      	beq.n	802a1de <CAN_NODE_Init+0x130>
      {
        /* CAN transmit pin configuration */
        XMC_GPIO_Init(lgpio_ptr->port, lgpio_ptr->pin, handle->gpio_out_config);
 802a1be:	68fb      	ldr	r3, [r7, #12]
 802a1c0:	6818      	ldr	r0, [r3, #0]
 802a1c2:	68fb      	ldr	r3, [r7, #12]
 802a1c4:	7919      	ldrb	r1, [r3, #4]
 802a1c6:	687b      	ldr	r3, [r7, #4]
 802a1c8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 802a1cc:	461a      	mov	r2, r3
 802a1ce:	f7fc f977 	bl	80264c0 <XMC_GPIO_Init>
 802a1d2:	e004      	b.n	802a1de <CAN_NODE_Init+0x130>
      }
    }
    else
    {
      status = CAN_NODE_STATUS_FAILURE;
 802a1d4:	2301      	movs	r3, #1
 802a1d6:	75fb      	strb	r3, [r7, #23]
 802a1d8:	e001      	b.n	802a1de <CAN_NODE_Init+0x130>
    }
  }
  else
  {
    status = CAN_NODE_STATUS_FAILURE;
 802a1da:	2301      	movs	r3, #1
 802a1dc:	75fb      	strb	r3, [r7, #23]
  }

  return (status);
 802a1de:	7dfb      	ldrb	r3, [r7, #23]
}
 802a1e0:	4618      	mov	r0, r3
 802a1e2:	3718      	adds	r7, #24
 802a1e4:	46bd      	mov	sp, r7
 802a1e6:	bd80      	pop	{r7, pc}

0802a1e8 <XMC_GPIO_SetOutputLevel>:
{
 802a1e8:	b480      	push	{r7}
 802a1ea:	b085      	sub	sp, #20
 802a1ec:	af00      	add	r7, sp, #0
 802a1ee:	60f8      	str	r0, [r7, #12]
 802a1f0:	460b      	mov	r3, r1
 802a1f2:	607a      	str	r2, [r7, #4]
 802a1f4:	72fb      	strb	r3, [r7, #11]
  port->OMR = (uint32_t)level << pin;
 802a1f6:	7afb      	ldrb	r3, [r7, #11]
 802a1f8:	687a      	ldr	r2, [r7, #4]
 802a1fa:	409a      	lsls	r2, r3
 802a1fc:	68fb      	ldr	r3, [r7, #12]
 802a1fe:	605a      	str	r2, [r3, #4]
}
 802a200:	bf00      	nop
 802a202:	3714      	adds	r7, #20
 802a204:	46bd      	mov	sp, r7
 802a206:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a20a:	4770      	bx	lr

0802a20c <XMC_GPIO_GetInput>:
{
 802a20c:	b480      	push	{r7}
 802a20e:	b083      	sub	sp, #12
 802a210:	af00      	add	r7, sp, #0
 802a212:	6078      	str	r0, [r7, #4]
 802a214:	460b      	mov	r3, r1
 802a216:	70fb      	strb	r3, [r7, #3]
  return (((port->IN) >> pin) & 0x1U);
 802a218:	687b      	ldr	r3, [r7, #4]
 802a21a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802a21c:	78fb      	ldrb	r3, [r7, #3]
 802a21e:	fa22 f303 	lsr.w	r3, r2, r3
 802a222:	f003 0301 	and.w	r3, r3, #1
}
 802a226:	4618      	mov	r0, r3
 802a228:	370c      	adds	r7, #12
 802a22a:	46bd      	mov	sp, r7
 802a22c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a230:	4770      	bx	lr

0802a232 <BUS_IO_Init>:
* @param handle_ptr Pointer pointing to APP data structure.
* @return BUS_IO_STATUS_t BUS_IO APP status.
*/

BUS_IO_STATUS_t BUS_IO_Init(BUS_IO_t *const handle_ptr)
{
 802a232:	b580      	push	{r7, lr}
 802a234:	b084      	sub	sp, #16
 802a236:	af00      	add	r7, sp, #0
 802a238:	6078      	str	r0, [r7, #4]
  uint8_t i;

  XMC_ASSERT("BUS_IO_Init: handle_ptr null pointer", handle_ptr != NULL);

  if ((bool)false == handle_ptr->initialized)
 802a23a:	687b      	ldr	r3, [r7, #4]
 802a23c:	7c5b      	ldrb	r3, [r3, #17]
 802a23e:	f083 0301 	eor.w	r3, r3, #1
 802a242:	b2db      	uxtb	r3, r3
 802a244:	2b00      	cmp	r3, #0
 802a246:	d01e      	beq.n	802a286 <BUS_IO_Init+0x54>
  {
    /* Iterate the list of pins initializing the pin according to the gpio_config */
    for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a248:	2300      	movs	r3, #0
 802a24a:	73fb      	strb	r3, [r7, #15]
 802a24c:	e013      	b.n	802a276 <BUS_IO_Init+0x44>
    {
      /* Initializes input / output characteristics */
      XMC_GPIO_Init(handle_ptr->pin_array[i].gpio_port, handle_ptr->pin_array[i].gpio_pin, &handle_ptr->gpio_config);
 802a24e:	687b      	ldr	r3, [r7, #4]
 802a250:	681a      	ldr	r2, [r3, #0]
 802a252:	7bfb      	ldrb	r3, [r7, #15]
 802a254:	00db      	lsls	r3, r3, #3
 802a256:	4413      	add	r3, r2
 802a258:	6818      	ldr	r0, [r3, #0]
 802a25a:	687b      	ldr	r3, [r7, #4]
 802a25c:	681a      	ldr	r2, [r3, #0]
 802a25e:	7bfb      	ldrb	r3, [r7, #15]
 802a260:	00db      	lsls	r3, r3, #3
 802a262:	4413      	add	r3, r2
 802a264:	7919      	ldrb	r1, [r3, #4]
 802a266:	687b      	ldr	r3, [r7, #4]
 802a268:	3304      	adds	r3, #4
 802a26a:	461a      	mov	r2, r3
 802a26c:	f7fc f928 	bl	80264c0 <XMC_GPIO_Init>
    for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a270:	7bfb      	ldrb	r3, [r7, #15]
 802a272:	3301      	adds	r3, #1
 802a274:	73fb      	strb	r3, [r7, #15]
 802a276:	687b      	ldr	r3, [r7, #4]
 802a278:	7c1b      	ldrb	r3, [r3, #16]
 802a27a:	7bfa      	ldrb	r2, [r7, #15]
 802a27c:	429a      	cmp	r2, r3
 802a27e:	d3e6      	bcc.n	802a24e <BUS_IO_Init+0x1c>
    }
    handle_ptr->initialized = (bool)true;
 802a280:	687b      	ldr	r3, [r7, #4]
 802a282:	2201      	movs	r2, #1
 802a284:	745a      	strb	r2, [r3, #17]
  }
  return (BUS_IO_STATUS_OK);
 802a286:	2300      	movs	r3, #0
}
 802a288:	4618      	mov	r0, r3
 802a28a:	3710      	adds	r7, #16
 802a28c:	46bd      	mov	sp, r7
 802a28e:	bd80      	pop	{r7, pc}

0802a290 <BUS_IO_Read>:
  }
}

/* Function to read the bus pins state */
uint16_t BUS_IO_Read(BUS_IO_t *const handle_ptr)
{
 802a290:	b580      	push	{r7, lr}
 802a292:	b084      	sub	sp, #16
 802a294:	af00      	add	r7, sp, #0
 802a296:	6078      	str	r0, [r7, #4]
  uint8_t i;
  uint16_t count = 0U;
 802a298:	2300      	movs	r3, #0
 802a29a:	81bb      	strh	r3, [r7, #12]

  XMC_ASSERT("BUS_IO_Read: handle_ptr null pointer", handle_ptr != NULL);

  /* Iterate the list of pins reading the pin state and packing the result according the pin position in the list, from LSB to MSB */
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a29c:	2300      	movs	r3, #0
 802a29e:	73fb      	strb	r3, [r7, #15]
 802a2a0:	e019      	b.n	802a2d6 <BUS_IO_Read+0x46>
  {
    /* Reading a bus pin's state */
    count |= (uint16_t)(XMC_GPIO_GetInput(handle_ptr->pin_array[i].gpio_port, handle_ptr->pin_array[i].gpio_pin) << i);
 802a2a2:	687b      	ldr	r3, [r7, #4]
 802a2a4:	681a      	ldr	r2, [r3, #0]
 802a2a6:	7bfb      	ldrb	r3, [r7, #15]
 802a2a8:	00db      	lsls	r3, r3, #3
 802a2aa:	4413      	add	r3, r2
 802a2ac:	6818      	ldr	r0, [r3, #0]
 802a2ae:	687b      	ldr	r3, [r7, #4]
 802a2b0:	681a      	ldr	r2, [r3, #0]
 802a2b2:	7bfb      	ldrb	r3, [r7, #15]
 802a2b4:	00db      	lsls	r3, r3, #3
 802a2b6:	4413      	add	r3, r2
 802a2b8:	791b      	ldrb	r3, [r3, #4]
 802a2ba:	4619      	mov	r1, r3
 802a2bc:	f7ff ffa6 	bl	802a20c <XMC_GPIO_GetInput>
 802a2c0:	4602      	mov	r2, r0
 802a2c2:	7bfb      	ldrb	r3, [r7, #15]
 802a2c4:	fa02 f303 	lsl.w	r3, r2, r3
 802a2c8:	b29a      	uxth	r2, r3
 802a2ca:	89bb      	ldrh	r3, [r7, #12]
 802a2cc:	4313      	orrs	r3, r2
 802a2ce:	81bb      	strh	r3, [r7, #12]
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a2d0:	7bfb      	ldrb	r3, [r7, #15]
 802a2d2:	3301      	adds	r3, #1
 802a2d4:	73fb      	strb	r3, [r7, #15]
 802a2d6:	687b      	ldr	r3, [r7, #4]
 802a2d8:	7c1b      	ldrb	r3, [r3, #16]
 802a2da:	7bfa      	ldrb	r2, [r7, #15]
 802a2dc:	429a      	cmp	r2, r3
 802a2de:	d3e0      	bcc.n	802a2a2 <BUS_IO_Read+0x12>
  }
  return(count);
 802a2e0:	89bb      	ldrh	r3, [r7, #12]
}
 802a2e2:	4618      	mov	r0, r3
 802a2e4:	3710      	adds	r7, #16
 802a2e6:	46bd      	mov	sp, r7
 802a2e8:	bd80      	pop	{r7, pc}

0802a2ea <BUS_IO_Write>:

/* Function to set the pins bus state */
void BUS_IO_Write(BUS_IO_t *const handle_ptr, const uint16_t data)
{
 802a2ea:	b580      	push	{r7, lr}
 802a2ec:	b084      	sub	sp, #16
 802a2ee:	af00      	add	r7, sp, #0
 802a2f0:	6078      	str	r0, [r7, #4]
 802a2f2:	460b      	mov	r3, r1
 802a2f4:	807b      	strh	r3, [r7, #2]
  uint8_t i;
  const BUS_IO_PORT_PIN_t *bus_io_port_pin;

  XMC_ASSERT("BUS_IO_Write: handle_ptr null pointer", handle_ptr != NULL);

  bus_io_port_pin = handle_ptr->pin_array;
 802a2f6:	687b      	ldr	r3, [r7, #4]
 802a2f8:	681b      	ldr	r3, [r3, #0]
 802a2fa:	60bb      	str	r3, [r7, #8]
  /* Iterate the list of pins setting the pin state according the pin position in the list, , from LSB to MSB */
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a2fc:	2300      	movs	r3, #0
 802a2fe:	73fb      	strb	r3, [r7, #15]
 802a300:	e021      	b.n	802a346 <BUS_IO_Write+0x5c>
  {
    if (data & (uint16_t)((uint16_t)1 << i))
 802a302:	7bfb      	ldrb	r3, [r7, #15]
 802a304:	2201      	movs	r2, #1
 802a306:	fa02 f303 	lsl.w	r3, r2, r3
 802a30a:	b29a      	uxth	r2, r3
 802a30c:	887b      	ldrh	r3, [r7, #2]
 802a30e:	4013      	ands	r3, r2
 802a310:	b29b      	uxth	r3, r3
 802a312:	2b00      	cmp	r3, #0
 802a314:	d008      	beq.n	802a328 <BUS_IO_Write+0x3e>
    {
      XMC_GPIO_SetOutputLevel(bus_io_port_pin->gpio_port, bus_io_port_pin->gpio_pin, XMC_GPIO_OUTPUT_LEVEL_HIGH);
 802a316:	68bb      	ldr	r3, [r7, #8]
 802a318:	6818      	ldr	r0, [r3, #0]
 802a31a:	68bb      	ldr	r3, [r7, #8]
 802a31c:	791b      	ldrb	r3, [r3, #4]
 802a31e:	2201      	movs	r2, #1
 802a320:	4619      	mov	r1, r3
 802a322:	f7ff ff61 	bl	802a1e8 <XMC_GPIO_SetOutputLevel>
 802a326:	e008      	b.n	802a33a <BUS_IO_Write+0x50>
    }
    else
    {
      XMC_GPIO_SetOutputLevel(bus_io_port_pin->gpio_port, bus_io_port_pin->gpio_pin, XMC_GPIO_OUTPUT_LEVEL_LOW);
 802a328:	68bb      	ldr	r3, [r7, #8]
 802a32a:	6818      	ldr	r0, [r3, #0]
 802a32c:	68bb      	ldr	r3, [r7, #8]
 802a32e:	791b      	ldrb	r3, [r3, #4]
 802a330:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802a334:	4619      	mov	r1, r3
 802a336:	f7ff ff57 	bl	802a1e8 <XMC_GPIO_SetOutputLevel>
    }
   bus_io_port_pin++;
 802a33a:	68bb      	ldr	r3, [r7, #8]
 802a33c:	3308      	adds	r3, #8
 802a33e:	60bb      	str	r3, [r7, #8]
  for (i = 0U; i < handle_ptr->number_of_pins; i++)
 802a340:	7bfb      	ldrb	r3, [r7, #15]
 802a342:	3301      	adds	r3, #1
 802a344:	73fb      	strb	r3, [r7, #15]
 802a346:	687b      	ldr	r3, [r7, #4]
 802a348:	7c1b      	ldrb	r3, [r3, #16]
 802a34a:	7bfa      	ldrb	r2, [r7, #15]
 802a34c:	429a      	cmp	r2, r3
 802a34e:	d3d8      	bcc.n	802a302 <BUS_IO_Write+0x18>
  }
}
 802a350:	bf00      	nop
 802a352:	bf00      	nop
 802a354:	3710      	adds	r7, #16
 802a356:	46bd      	mov	sp, r7
 802a358:	bd80      	pop	{r7, pc}

0802a35a <ANALOG_IO_Init>:
 * Input Parameter  : Handler Pointer pointing to APP data structure.
 * Output Parameter : ANALOG_IO_STATUS_t (ANALOG_IO APP initialization status).
 */

ANALOG_IO_STATUS_t ANALOG_IO_Init(const ANALOG_IO_t *const handle)
{
 802a35a:	b580      	push	{r7, lr}
 802a35c:	b082      	sub	sp, #8
 802a35e:	af00      	add	r7, sp, #0
 802a360:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("ANALOG_IO_Init: Passed handler is a null pointer", handler != NULL);
  if (*(handle->state) == ANALOG_IO_STATE_NOT_INITIALIZED)
 802a362:	687b      	ldr	r3, [r7, #4]
 802a364:	685b      	ldr	r3, [r3, #4]
 802a366:	781b      	ldrb	r3, [r3, #0]
 802a368:	2b00      	cmp	r3, #0
 802a36a:	d10a      	bne.n	802a382 <ANALOG_IO_Init+0x28>
  {
    if (handle->config_ptr != NULL)
 802a36c:	687b      	ldr	r3, [r7, #4]
 802a36e:	681b      	ldr	r3, [r3, #0]
 802a370:	2b00      	cmp	r3, #0
 802a372:	d002      	beq.n	802a37a <ANALOG_IO_Init+0x20>
    {
      /* Instance specific initialization function call*/
      handle->config_ptr();
 802a374:	687b      	ldr	r3, [r7, #4]
 802a376:	681b      	ldr	r3, [r3, #0]
 802a378:	4798      	blx	r3
    }
    /* Set the state variable to initialized state*/
    *(handle->state) = ANALOG_IO_STATE_INITIALIZED;
 802a37a:	687b      	ldr	r3, [r7, #4]
 802a37c:	685b      	ldr	r3, [r3, #4]
 802a37e:	2201      	movs	r2, #1
 802a380:	701a      	strb	r2, [r3, #0]
  }
  return (ANALOG_IO_STATUS_OK);
 802a382:	2300      	movs	r3, #0
}
 802a384:	4618      	mov	r0, r3
 802a386:	3708      	adds	r7, #8
 802a388:	46bd      	mov	sp, r7
 802a38a:	bd80      	pop	{r7, pc}

0802a38c <__NVIC_GetPriorityGrouping>:
{
 802a38c:	b480      	push	{r7}
 802a38e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802a390:	4b04      	ldr	r3, [pc, #16]	; (802a3a4 <__NVIC_GetPriorityGrouping+0x18>)
 802a392:	68db      	ldr	r3, [r3, #12]
 802a394:	0a1b      	lsrs	r3, r3, #8
 802a396:	f003 0307 	and.w	r3, r3, #7
}
 802a39a:	4618      	mov	r0, r3
 802a39c:	46bd      	mov	sp, r7
 802a39e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a3a2:	4770      	bx	lr
 802a3a4:	e000ed00 	.word	0xe000ed00

0802a3a8 <__NVIC_EnableIRQ>:
{
 802a3a8:	b480      	push	{r7}
 802a3aa:	b083      	sub	sp, #12
 802a3ac:	af00      	add	r7, sp, #0
 802a3ae:	4603      	mov	r3, r0
 802a3b0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802a3b2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a3b6:	2b00      	cmp	r3, #0
 802a3b8:	db0b      	blt.n	802a3d2 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802a3ba:	79fb      	ldrb	r3, [r7, #7]
 802a3bc:	f003 021f 	and.w	r2, r3, #31
 802a3c0:	4907      	ldr	r1, [pc, #28]	; (802a3e0 <__NVIC_EnableIRQ+0x38>)
 802a3c2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a3c6:	095b      	lsrs	r3, r3, #5
 802a3c8:	2001      	movs	r0, #1
 802a3ca:	fa00 f202 	lsl.w	r2, r0, r2
 802a3ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 802a3d2:	bf00      	nop
 802a3d4:	370c      	adds	r7, #12
 802a3d6:	46bd      	mov	sp, r7
 802a3d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a3dc:	4770      	bx	lr
 802a3de:	bf00      	nop
 802a3e0:	e000e100 	.word	0xe000e100

0802a3e4 <__NVIC_SetPriority>:
{
 802a3e4:	b480      	push	{r7}
 802a3e6:	b083      	sub	sp, #12
 802a3e8:	af00      	add	r7, sp, #0
 802a3ea:	4603      	mov	r3, r0
 802a3ec:	6039      	str	r1, [r7, #0]
 802a3ee:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802a3f0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a3f4:	2b00      	cmp	r3, #0
 802a3f6:	db0a      	blt.n	802a40e <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802a3f8:	683b      	ldr	r3, [r7, #0]
 802a3fa:	b2da      	uxtb	r2, r3
 802a3fc:	490c      	ldr	r1, [pc, #48]	; (802a430 <__NVIC_SetPriority+0x4c>)
 802a3fe:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802a402:	0092      	lsls	r2, r2, #2
 802a404:	b2d2      	uxtb	r2, r2
 802a406:	440b      	add	r3, r1
 802a408:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 802a40c:	e00a      	b.n	802a424 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802a40e:	683b      	ldr	r3, [r7, #0]
 802a410:	b2da      	uxtb	r2, r3
 802a412:	4908      	ldr	r1, [pc, #32]	; (802a434 <__NVIC_SetPriority+0x50>)
 802a414:	79fb      	ldrb	r3, [r7, #7]
 802a416:	f003 030f 	and.w	r3, r3, #15
 802a41a:	3b04      	subs	r3, #4
 802a41c:	0092      	lsls	r2, r2, #2
 802a41e:	b2d2      	uxtb	r2, r2
 802a420:	440b      	add	r3, r1
 802a422:	761a      	strb	r2, [r3, #24]
}
 802a424:	bf00      	nop
 802a426:	370c      	adds	r7, #12
 802a428:	46bd      	mov	sp, r7
 802a42a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a42e:	4770      	bx	lr
 802a430:	e000e100 	.word	0xe000e100
 802a434:	e000ed00 	.word	0xe000ed00

0802a438 <NVIC_EncodePriority>:
{
 802a438:	b480      	push	{r7}
 802a43a:	b089      	sub	sp, #36	; 0x24
 802a43c:	af00      	add	r7, sp, #0
 802a43e:	60f8      	str	r0, [r7, #12]
 802a440:	60b9      	str	r1, [r7, #8]
 802a442:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 802a444:	68fb      	ldr	r3, [r7, #12]
 802a446:	f003 0307 	and.w	r3, r3, #7
 802a44a:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802a44c:	69fb      	ldr	r3, [r7, #28]
 802a44e:	f1c3 0307 	rsb	r3, r3, #7
 802a452:	2b06      	cmp	r3, #6
 802a454:	bf28      	it	cs
 802a456:	2306      	movcs	r3, #6
 802a458:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802a45a:	69fb      	ldr	r3, [r7, #28]
 802a45c:	3306      	adds	r3, #6
 802a45e:	2b06      	cmp	r3, #6
 802a460:	d902      	bls.n	802a468 <NVIC_EncodePriority+0x30>
 802a462:	69fb      	ldr	r3, [r7, #28]
 802a464:	3b01      	subs	r3, #1
 802a466:	e000      	b.n	802a46a <NVIC_EncodePriority+0x32>
 802a468:	2300      	movs	r3, #0
 802a46a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802a46c:	f04f 32ff 	mov.w	r2, #4294967295
 802a470:	69bb      	ldr	r3, [r7, #24]
 802a472:	fa02 f303 	lsl.w	r3, r2, r3
 802a476:	43da      	mvns	r2, r3
 802a478:	68bb      	ldr	r3, [r7, #8]
 802a47a:	401a      	ands	r2, r3
 802a47c:	697b      	ldr	r3, [r7, #20]
 802a47e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802a480:	f04f 31ff 	mov.w	r1, #4294967295
 802a484:	697b      	ldr	r3, [r7, #20]
 802a486:	fa01 f303 	lsl.w	r3, r1, r3
 802a48a:	43d9      	mvns	r1, r3
 802a48c:	687b      	ldr	r3, [r7, #4]
 802a48e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802a490:	4313      	orrs	r3, r2
}
 802a492:	4618      	mov	r0, r3
 802a494:	3724      	adds	r7, #36	; 0x24
 802a496:	46bd      	mov	sp, r7
 802a498:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a49c:	4770      	bx	lr

0802a49e <XMC_VADC_GLOBAL_BackgroundTriggerConversion>:
{
 802a49e:	b480      	push	{r7}
 802a4a0:	b083      	sub	sp, #12
 802a4a2:	af00      	add	r7, sp, #0
 802a4a4:	6078      	str	r0, [r7, #4]
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
 802a4a6:	687b      	ldr	r3, [r7, #4]
 802a4a8:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 802a4ac:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 802a4b0:	687b      	ldr	r3, [r7, #4]
 802a4b2:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
}
 802a4b6:	bf00      	nop
 802a4b8:	370c      	adds	r7, #12
 802a4ba:	46bd      	mov	sp, r7
 802a4bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a4c0:	4770      	bx	lr

0802a4c2 <XMC_VADC_GLOBAL_BackgroundAddChannelToSequence>:
{
 802a4c2:	b480      	push	{r7}
 802a4c4:	b085      	sub	sp, #20
 802a4c6:	af00      	add	r7, sp, #0
 802a4c8:	60f8      	str	r0, [r7, #12]
 802a4ca:	60b9      	str	r1, [r7, #8]
 802a4cc:	607a      	str	r2, [r7, #4]
  global_ptr->BRSSEL[grp_num] |= (uint32_t)((uint32_t)1 << ch_num);
 802a4ce:	68fb      	ldr	r3, [r7, #12]
 802a4d0:	68ba      	ldr	r2, [r7, #8]
 802a4d2:	3260      	adds	r2, #96	; 0x60
 802a4d4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 802a4d8:	2101      	movs	r1, #1
 802a4da:	687b      	ldr	r3, [r7, #4]
 802a4dc:	fa01 f303 	lsl.w	r3, r1, r3
 802a4e0:	ea42 0103 	orr.w	r1, r2, r3
 802a4e4:	68fb      	ldr	r3, [r7, #12]
 802a4e6:	68ba      	ldr	r2, [r7, #8]
 802a4e8:	3260      	adds	r2, #96	; 0x60
 802a4ea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 802a4ee:	bf00      	nop
 802a4f0:	3714      	adds	r7, #20
 802a4f2:	46bd      	mov	sp, r7
 802a4f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a4f8:	4770      	bx	lr

0802a4fa <XMC_VADC_GROUP_ResultInit>:
{
 802a4fa:	b480      	push	{r7}
 802a4fc:	b085      	sub	sp, #20
 802a4fe:	af00      	add	r7, sp, #0
 802a500:	60f8      	str	r0, [r7, #12]
 802a502:	60b9      	str	r1, [r7, #8]
 802a504:	607a      	str	r2, [r7, #4]
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 802a506:	687b      	ldr	r3, [r7, #4]
 802a508:	6819      	ldr	r1, [r3, #0]
 802a50a:	68fb      	ldr	r3, [r7, #12]
 802a50c:	68ba      	ldr	r2, [r7, #8]
 802a50e:	32a0      	adds	r2, #160	; 0xa0
 802a510:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 802a514:	bf00      	nop
 802a516:	3714      	adds	r7, #20
 802a518:	46bd      	mov	sp, r7
 802a51a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a51e:	4770      	bx	lr

0802a520 <XMC_VADC_GROUP_GetResult>:
{
 802a520:	b480      	push	{r7}
 802a522:	b083      	sub	sp, #12
 802a524:	af00      	add	r7, sp, #0
 802a526:	6078      	str	r0, [r7, #4]
 802a528:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 802a52a:	687b      	ldr	r3, [r7, #4]
 802a52c:	683a      	ldr	r2, [r7, #0]
 802a52e:	32c0      	adds	r2, #192	; 0xc0
 802a530:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a534:	b29b      	uxth	r3, r3
}
 802a536:	4618      	mov	r0, r3
 802a538:	370c      	adds	r7, #12
 802a53a:	46bd      	mov	sp, r7
 802a53c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a540:	4770      	bx	lr

0802a542 <ADC_MEASUREMENT_Init>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr)
{
 802a542:	b590      	push	{r4, r7, lr}
 802a544:	b085      	sub	sp, #20
 802a546:	af00      	add	r7, sp, #0
 802a548:	6078      	str	r0, [r7, #4]
  uint8_t j;
  ADC_MEASUREMENT_STATUS_t status;

  XMC_ASSERT("ADC_MEASUREMENT_Init:Invalid handle_ptr", (handle_ptr != NULL));

  if (ADC_MEASUREMENT_STATUS_UNINITIALIZED == handle_ptr->init_state)
 802a54a:	687b      	ldr	r3, [r7, #4]
 802a54c:	7e1b      	ldrb	r3, [r3, #24]
 802a54e:	2b02      	cmp	r3, #2
 802a550:	f040 809e 	bne.w	802a690 <ADC_MEASUREMENT_Init+0x14e>
  {
    /* Call the function to initialise Clock and ADC global functional units*/
    status = (ADC_MEASUREMENT_STATUS_t) GLOBAL_ADC_Init(handle_ptr->global_handle);
 802a554:	687b      	ldr	r3, [r7, #4]
 802a556:	68db      	ldr	r3, [r3, #12]
 802a558:	4618      	mov	r0, r3
 802a55a:	f7ff faa2 	bl	8029aa2 <GLOBAL_ADC_Init>
 802a55e:	4603      	mov	r3, r0
 802a560:	73bb      	strb	r3, [r7, #14]
  
    /*Initialize the Global Conversion class 0*/
    XMC_VADC_GLOBAL_InputClassInit(handle_ptr->global_handle->module_ptr,*handle_ptr->iclass_config_handle,
 802a562:	687b      	ldr	r3, [r7, #4]
 802a564:	68db      	ldr	r3, [r3, #12]
 802a566:	6958      	ldr	r0, [r3, #20]
 802a568:	687b      	ldr	r3, [r7, #4]
 802a56a:	6899      	ldr	r1, [r3, #8]
 802a56c:	2300      	movs	r3, #0
 802a56e:	2200      	movs	r2, #0
 802a570:	6809      	ldr	r1, [r1, #0]
 802a572:	f7fd ffe1 	bl	8028538 <XMC_VADC_GLOBAL_InputClassInit>
    XMC_VADC_GLOBAL_InputClassInit(handle_ptr->global_handle->module_ptr,*handle_ptr->iclass_config_handle,
                                      XMC_VADC_GROUP_CONV_STD,ADC_MEASUREMENT_ICLASS_NUM_XMC11);
#endif
  
    /* Initialize the Background Scan hardware */
    XMC_VADC_GLOBAL_BackgroundInit(handle_ptr->global_handle->module_ptr, handle_ptr->backgnd_config_handle);
 802a576:	687b      	ldr	r3, [r7, #4]
 802a578:	68db      	ldr	r3, [r3, #12]
 802a57a:	695a      	ldr	r2, [r3, #20]
 802a57c:	687b      	ldr	r3, [r7, #4]
 802a57e:	685b      	ldr	r3, [r3, #4]
 802a580:	4619      	mov	r1, r3
 802a582:	4610      	mov	r0, r2
 802a584:	f7fe f92e 	bl	80287e4 <XMC_VADC_GLOBAL_BackgroundInit>
#if (XMC_VADC_GROUP_AVAILABLE == 0U)
    /* Initialize the global result register */
    XMC_VADC_GLOBAL_ResultInit(handle_ptr->global_handle->module_ptr,handle_ptr->array->res_handle);
#endif

    for (j = (uint8_t)0; j < (uint8_t)ADC_MEASUREMENT_MAXCHANNELS; j++)
 802a588:	2300      	movs	r3, #0
 802a58a:	73fb      	strb	r3, [r7, #15]
 802a58c:	e039      	b.n	802a602 <ADC_MEASUREMENT_Init+0xc0>
    {
      indexed = handle_ptr->array->channel_array[j];
 802a58e:	687b      	ldr	r3, [r7, #4]
 802a590:	681b      	ldr	r3, [r3, #0]
 802a592:	7bfa      	ldrb	r2, [r7, #15]
 802a594:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a598:	60bb      	str	r3, [r7, #8]
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(indexed->group_handle,(uint32_t)indexed->ch_num, indexed->ch_handle);
 802a59a:	68bb      	ldr	r3, [r7, #8]
 802a59c:	6898      	ldr	r0, [r3, #8]
 802a59e:	68bb      	ldr	r3, [r7, #8]
 802a5a0:	7c5b      	ldrb	r3, [r3, #17]
 802a5a2:	4619      	mov	r1, r3
 802a5a4:	68bb      	ldr	r3, [r7, #8]
 802a5a6:	681b      	ldr	r3, [r3, #0]
 802a5a8:	461a      	mov	r2, r3
 802a5aa:	f7fe f9e9 	bl	8028980 <XMC_VADC_GROUP_ChannelInit>
  
      /* Initialize for configured result registers */
      XMC_VADC_GROUP_ResultInit(indexed->group_handle, (uint32_t)indexed->ch_handle->result_reg_number,
 802a5ae:	68bb      	ldr	r3, [r7, #8]
 802a5b0:	6898      	ldr	r0, [r3, #8]
 802a5b2:	68bb      	ldr	r3, [r7, #8]
 802a5b4:	681b      	ldr	r3, [r3, #0]
 802a5b6:	789b      	ldrb	r3, [r3, #2]
 802a5b8:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802a5bc:	b2db      	uxtb	r3, r3
 802a5be:	4619      	mov	r1, r3
                                indexed->res_handle);
 802a5c0:	68bb      	ldr	r3, [r7, #8]
 802a5c2:	685b      	ldr	r3, [r3, #4]
      XMC_VADC_GROUP_ResultInit(indexed->group_handle, (uint32_t)indexed->ch_handle->result_reg_number,
 802a5c4:	461a      	mov	r2, r3
 802a5c6:	f7ff ff98 	bl	802a4fa <XMC_VADC_GROUP_ResultInit>
#endif
      /* Add all channels into the Background Request Source Channel Select Register */
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 802a5ca:	687b      	ldr	r3, [r7, #4]
 802a5cc:	68db      	ldr	r3, [r3, #12]
 802a5ce:	6958      	ldr	r0, [r3, #20]
                                                     (uint32_t)indexed->group_index, (uint32_t)indexed->ch_num);
 802a5d0:	68bb      	ldr	r3, [r7, #8]
 802a5d2:	7c1b      	ldrb	r3, [r3, #16]
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 802a5d4:	4619      	mov	r1, r3
                                                     (uint32_t)indexed->group_index, (uint32_t)indexed->ch_num);
 802a5d6:	68bb      	ldr	r3, [r7, #8]
 802a5d8:	7c5b      	ldrb	r3, [r3, #17]
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 802a5da:	461a      	mov	r2, r3
 802a5dc:	f7ff ff71 	bl	802a4c2 <XMC_VADC_GLOBAL_BackgroundAddChannelToSequence>

#ifdef ADC_MEASUREMENT_ANALOG_IO_USED
      /* ANALOG_IO initialization for the channel*/
      if(indexed->analog_io_config != NULL)
 802a5e0:	68bb      	ldr	r3, [r7, #8]
 802a5e2:	68db      	ldr	r3, [r3, #12]
 802a5e4:	2b00      	cmp	r3, #0
 802a5e6:	d009      	beq.n	802a5fc <ADC_MEASUREMENT_Init+0xba>
      {
        status |= (ADC_MEASUREMENT_STATUS_t) ANALOG_IO_Init(indexed->analog_io_config);
 802a5e8:	68bb      	ldr	r3, [r7, #8]
 802a5ea:	68db      	ldr	r3, [r3, #12]
 802a5ec:	4618      	mov	r0, r3
 802a5ee:	f7ff feb4 	bl	802a35a <ANALOG_IO_Init>
 802a5f2:	4603      	mov	r3, r0
 802a5f4:	461a      	mov	r2, r3
 802a5f6:	7bbb      	ldrb	r3, [r7, #14]
 802a5f8:	4313      	orrs	r3, r2
 802a5fa:	73bb      	strb	r3, [r7, #14]
    for (j = (uint8_t)0; j < (uint8_t)ADC_MEASUREMENT_MAXCHANNELS; j++)
 802a5fc:	7bfb      	ldrb	r3, [r7, #15]
 802a5fe:	3301      	adds	r3, #1
 802a600:	73fb      	strb	r3, [r7, #15]
 802a602:	7bfb      	ldrb	r3, [r7, #15]
 802a604:	2b02      	cmp	r3, #2
 802a606:	d9c2      	bls.n	802a58e <ADC_MEASUREMENT_Init+0x4c>
      }
#endif
    }
#if(UC_SERIES != XMC11)
    if ((handle_ptr->backgnd_config_handle->req_src_interrupt) && (handle_ptr->req_src_intr_handle != NULL ))
 802a608:	687b      	ldr	r3, [r7, #4]
 802a60a:	685b      	ldr	r3, [r3, #4]
 802a60c:	7a1b      	ldrb	r3, [r3, #8]
 802a60e:	f003 0308 	and.w	r3, r3, #8
 802a612:	b2db      	uxtb	r3, r3
 802a614:	2b00      	cmp	r3, #0
 802a616:	d027      	beq.n	802a668 <ADC_MEASUREMENT_Init+0x126>
 802a618:	687b      	ldr	r3, [r7, #4]
 802a61a:	691b      	ldr	r3, [r3, #16]
 802a61c:	2b00      	cmp	r3, #0
 802a61e:	d023      	beq.n	802a668 <ADC_MEASUREMENT_Init+0x126>
    {
#if (UC_FAMILY == XMC1)
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
                        handle_ptr->req_src_intr_handle->priority);
#else
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 802a620:	687b      	ldr	r3, [r7, #4]
 802a622:	691b      	ldr	r3, [r3, #16]
 802a624:	681b      	ldr	r3, [r3, #0]
 802a626:	b25c      	sxtb	r4, r3
 802a628:	f7ff feb0 	bl	802a38c <__NVIC_GetPriorityGrouping>
                        NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                        handle_ptr->req_src_intr_handle->priority, handle_ptr->req_src_intr_handle->sub_priority));
 802a62c:	687b      	ldr	r3, [r7, #4]
 802a62e:	691b      	ldr	r3, [r3, #16]
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 802a630:	6859      	ldr	r1, [r3, #4]
                        handle_ptr->req_src_intr_handle->priority, handle_ptr->req_src_intr_handle->sub_priority));
 802a632:	687b      	ldr	r3, [r7, #4]
 802a634:	691b      	ldr	r3, [r3, #16]
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 802a636:	689b      	ldr	r3, [r3, #8]
 802a638:	461a      	mov	r2, r3
 802a63a:	f7ff fefd 	bl	802a438 <NVIC_EncodePriority>
 802a63e:	4603      	mov	r3, r0
 802a640:	4619      	mov	r1, r3
 802a642:	4620      	mov	r0, r4
 802a644:	f7ff fece 	bl	802a3e4 <__NVIC_SetPriority>
#endif
      /* Connect background Request Source Event to NVIC node */
      XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(handle_ptr->global_handle->module_ptr,
 802a648:	687b      	ldr	r3, [r7, #4]
 802a64a:	68db      	ldr	r3, [r3, #12]
 802a64c:	695a      	ldr	r2, [r3, #20]
                                                 (XMC_VADC_SR_t) handle_ptr->srv_req_node);
 802a64e:	687b      	ldr	r3, [r7, #4]
 802a650:	7e5b      	ldrb	r3, [r3, #25]
      XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(handle_ptr->global_handle->module_ptr,
 802a652:	4619      	mov	r1, r3
 802a654:	4610      	mov	r0, r2
 802a656:	f7fd ffc9 	bl	80285ec <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode>
    
      /* Enable Background Scan Request source IRQ */
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->req_src_intr_handle->node_id);
 802a65a:	687b      	ldr	r3, [r7, #4]
 802a65c:	691b      	ldr	r3, [r3, #16]
 802a65e:	681b      	ldr	r3, [r3, #0]
 802a660:	b25b      	sxtb	r3, r3
 802a662:	4618      	mov	r0, r3
 802a664:	f7ff fea0 	bl	802a3a8 <__NVIC_EnableIRQ>
    /* Enable Background Scan Request source IRQ */
    NVIC_EnableIRQ((IRQn_Type)handle_ptr->result_intr_handle->node_id);
#endif
#endif
    /* Mux Configuration is done*/
    if (handle_ptr->mux_config != NULL)
 802a668:	687b      	ldr	r3, [r7, #4]
 802a66a:	695b      	ldr	r3, [r3, #20]
 802a66c:	2b00      	cmp	r3, #0
 802a66e:	d002      	beq.n	802a676 <ADC_MEASUREMENT_Init+0x134>
    {
      (handle_ptr->mux_config)();
 802a670:	687b      	ldr	r3, [r7, #4]
 802a672:	695b      	ldr	r3, [r3, #20]
 802a674:	4798      	blx	r3
    }
  
    if (handle_ptr->start_conversion != (bool)false)
 802a676:	687b      	ldr	r3, [r7, #4]
 802a678:	7e9b      	ldrb	r3, [r3, #26]
 802a67a:	2b00      	cmp	r3, #0
 802a67c:	d005      	beq.n	802a68a <ADC_MEASUREMENT_Init+0x148>
    {
      /* Start conversion manually using load event trigger*/
      XMC_VADC_GLOBAL_BackgroundTriggerConversion(handle_ptr->global_handle->module_ptr);
 802a67e:	687b      	ldr	r3, [r7, #4]
 802a680:	68db      	ldr	r3, [r3, #12]
 802a682:	695b      	ldr	r3, [r3, #20]
 802a684:	4618      	mov	r0, r3
 802a686:	f7ff ff0a 	bl	802a49e <XMC_VADC_GLOBAL_BackgroundTriggerConversion>
    }
    handle_ptr->init_state = status;
 802a68a:	687b      	ldr	r3, [r7, #4]
 802a68c:	7bba      	ldrb	r2, [r7, #14]
 802a68e:	761a      	strb	r2, [r3, #24]
  }
  return (handle_ptr->init_state);
 802a690:	687b      	ldr	r3, [r7, #4]
 802a692:	7e1b      	ldrb	r3, [r3, #24]
}
 802a694:	4618      	mov	r0, r3
 802a696:	3714      	adds	r7, #20
 802a698:	46bd      	mov	sp, r7
 802a69a:	bd90      	pop	{r4, r7, pc}

0802a69c <ADC_MEASUREMENT_StartConversion>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* This API will Software trigger ADC Background request source and starts conversion*/
void ADC_MEASUREMENT_StartConversion(ADC_MEASUREMENT_t *const handle_ptr)
{
 802a69c:	b580      	push	{r7, lr}
 802a69e:	b082      	sub	sp, #8
 802a6a0:	af00      	add	r7, sp, #0
 802a6a2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("ADC_MEASUREMENT_Start:Invalid handle_ptr", (handle_ptr != NULL));

  /* Generate a load event to start background request source conversion*/
  XMC_VADC_GLOBAL_BackgroundTriggerConversion(handle_ptr->global_handle->module_ptr);
 802a6a4:	687b      	ldr	r3, [r7, #4]
 802a6a6:	68db      	ldr	r3, [r3, #12]
 802a6a8:	695b      	ldr	r3, [r3, #20]
 802a6aa:	4618      	mov	r0, r3
 802a6ac:	f7ff fef7 	bl	802a49e <XMC_VADC_GLOBAL_BackgroundTriggerConversion>
}
 802a6b0:	bf00      	nop
 802a6b2:	3708      	adds	r7, #8
 802a6b4:	46bd      	mov	sp, r7
 802a6b6:	bd80      	pop	{r7, pc}

0802a6b8 <ADC_MEASUREMENT_GetResult>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#if(XMC_VADC_GROUP_AVAILABLE == 1U)
/* This API will get the result of a conversion for a specific channel*/
XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr)
{
 802a6b8:	b580      	push	{r7, lr}
 802a6ba:	b084      	sub	sp, #16
 802a6bc:	af00      	add	r7, sp, #0
 802a6be:	6078      	str	r0, [r7, #4]
  XMC_VADC_RESULT_SIZE_t result;

  XMC_ASSERT("ADC_MEASUREMENT_GetResult:Invalid handle_ptr", (handle_ptr != NULL));

  result = XMC_VADC_GROUP_GetResult(handle_ptr->group_handle, handle_ptr->ch_handle->result_reg_number);
 802a6c0:	687b      	ldr	r3, [r7, #4]
 802a6c2:	689a      	ldr	r2, [r3, #8]
 802a6c4:	687b      	ldr	r3, [r7, #4]
 802a6c6:	681b      	ldr	r3, [r3, #0]
 802a6c8:	789b      	ldrb	r3, [r3, #2]
 802a6ca:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802a6ce:	b2db      	uxtb	r3, r3
 802a6d0:	4619      	mov	r1, r3
 802a6d2:	4610      	mov	r0, r2
 802a6d4:	f7ff ff24 	bl	802a520 <XMC_VADC_GROUP_GetResult>
 802a6d8:	4603      	mov	r3, r0
 802a6da:	81fb      	strh	r3, [r7, #14]

  return (result);
 802a6dc:	89fb      	ldrh	r3, [r7, #14]
}
 802a6de:	4618      	mov	r0, r3
 802a6e0:	3710      	adds	r7, #16
 802a6e2:	46bd      	mov	sp, r7
 802a6e4:	bd80      	pop	{r7, pc}
	...

0802a6e8 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
 802a6e8:	b580      	push	{r7, lr}
 802a6ea:	b082      	sub	sp, #8
 802a6ec:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
 802a6ee:	2300      	movs	r3, #0
 802a6f0:	71fb      	strb	r3, [r7, #7]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 802a6f2:	48aa      	ldr	r0, [pc, #680]	; (802a99c <DAVE_Init+0x2b4>)
 802a6f4:	f7ff fac0 	bl	8029c78 <CLOCK_XMC4_Init>
 802a6f8:	4603      	mov	r3, r0
 802a6fa:	71fb      	strb	r3, [r7, #7]

  if (init_status == DAVE_STATUS_SUCCESS)
 802a6fc:	79fb      	ldrb	r3, [r7, #7]
 802a6fe:	2b00      	cmp	r3, #0
 802a700:	d104      	bne.n	802a70c <DAVE_Init+0x24>
  {
	 /**  Initialization of DIGITAL_IO APP instance SERVICE_BUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&SERVICE_BUT); 
 802a702:	48a7      	ldr	r0, [pc, #668]	; (802a9a0 <DAVE_Init+0x2b8>)
 802a704:	f7ff fa24 	bl	8029b50 <DIGITAL_IO_Init>
 802a708:	4603      	mov	r3, r0
 802a70a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a70c:	79fb      	ldrb	r3, [r7, #7]
 802a70e:	2b00      	cmp	r3, #0
 802a710:	d104      	bne.n	802a71c <DAVE_Init+0x34>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_G */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_G); 
 802a712:	48a4      	ldr	r0, [pc, #656]	; (802a9a4 <DAVE_Init+0x2bc>)
 802a714:	f7ff fa1c 	bl	8029b50 <DIGITAL_IO_Init>
 802a718:	4603      	mov	r3, r0
 802a71a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a71c:	79fb      	ldrb	r3, [r7, #7]
 802a71e:	2b00      	cmp	r3, #0
 802a720:	d104      	bne.n	802a72c <DAVE_Init+0x44>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_Y */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_Y); 
 802a722:	48a1      	ldr	r0, [pc, #644]	; (802a9a8 <DAVE_Init+0x2c0>)
 802a724:	f7ff fa14 	bl	8029b50 <DIGITAL_IO_Init>
 802a728:	4603      	mov	r3, r0
 802a72a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a72c:	79fb      	ldrb	r3, [r7, #7]
 802a72e:	2b00      	cmp	r3, #0
 802a730:	d104      	bne.n	802a73c <DAVE_Init+0x54>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_R */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_R); 
 802a732:	489e      	ldr	r0, [pc, #632]	; (802a9ac <DAVE_Init+0x2c4>)
 802a734:	f7ff fa0c 	bl	8029b50 <DIGITAL_IO_Init>
 802a738:	4603      	mov	r3, r0
 802a73a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a73c:	79fb      	ldrb	r3, [r7, #7]
 802a73e:	2b00      	cmp	r3, #0
 802a740:	d104      	bne.n	802a74c <DAVE_Init+0x64>
  {
	 /**  Initialization of SYSTIMER APP instance SYSTIMER_0 */
	 init_status = (DAVE_STATUS_t)SYSTIMER_Init(&SYSTIMER_0); 
 802a742:	489b      	ldr	r0, [pc, #620]	; (802a9b0 <DAVE_Init+0x2c8>)
 802a744:	f7fe fc12 	bl	8028f6c <SYSTIMER_Init>
 802a748:	4603      	mov	r3, r0
 802a74a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a74c:	79fb      	ldrb	r3, [r7, #7]
 802a74e:	2b00      	cmp	r3, #0
 802a750:	d104      	bne.n	802a75c <DAVE_Init+0x74>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_EXT */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_EXT); 
 802a752:	4898      	ldr	r0, [pc, #608]	; (802a9b4 <DAVE_Init+0x2cc>)
 802a754:	f7ff fcab 	bl	802a0ae <CAN_NODE_Init>
 802a758:	4603      	mov	r3, r0
 802a75a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a75c:	79fb      	ldrb	r3, [r7, #7]
 802a75e:	2b00      	cmp	r3, #0
 802a760:	d104      	bne.n	802a76c <DAVE_Init+0x84>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_INT */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_INT); 
 802a762:	4895      	ldr	r0, [pc, #596]	; (802a9b8 <DAVE_Init+0x2d0>)
 802a764:	f7ff fca3 	bl	802a0ae <CAN_NODE_Init>
 802a768:	4603      	mov	r3, r0
 802a76a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a76c:	79fb      	ldrb	r3, [r7, #7]
 802a76e:	2b00      	cmp	r3, #0
 802a770:	d104      	bne.n	802a77c <DAVE_Init+0x94>
  {
	 /**  Initialization of INTERRUPT APP instance CAN1_RX_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN1_RX_INT); 
 802a772:	4892      	ldr	r0, [pc, #584]	; (802a9bc <DAVE_Init+0x2d4>)
 802a774:	f7ff f90f 	bl	8029996 <INTERRUPT_Init>
 802a778:	4603      	mov	r3, r0
 802a77a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a77c:	79fb      	ldrb	r3, [r7, #7]
 802a77e:	2b00      	cmp	r3, #0
 802a780:	d104      	bne.n	802a78c <DAVE_Init+0xa4>
  {
	 /**  Initialization of PWM_CCU4 APP instance CLUTCH_PWM */
	 init_status = (DAVE_STATUS_t)PWM_CCU4_Init(&CLUTCH_PWM); 
 802a782:	488f      	ldr	r0, [pc, #572]	; (802a9c0 <DAVE_Init+0x2d8>)
 802a784:	f7fe fda5 	bl	80292d2 <PWM_CCU4_Init>
 802a788:	4603      	mov	r3, r0
 802a78a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a78c:	79fb      	ldrb	r3, [r7, #7]
 802a78e:	2b00      	cmp	r3, #0
 802a790:	d104      	bne.n	802a79c <DAVE_Init+0xb4>
  {
	 /**  Initialization of INTERRUPT APP instance CLUTCH_INT_CMP */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CLUTCH_INT_CMP); 
 802a792:	488c      	ldr	r0, [pc, #560]	; (802a9c4 <DAVE_Init+0x2dc>)
 802a794:	f7ff f8ff 	bl	8029996 <INTERRUPT_Init>
 802a798:	4603      	mov	r3, r0
 802a79a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a79c:	79fb      	ldrb	r3, [r7, #7]
 802a79e:	2b00      	cmp	r3, #0
 802a7a0:	d104      	bne.n	802a7ac <DAVE_Init+0xc4>
  {
	 /**  Initialization of INTERRUPT APP instance CLUTCH_INT_OVF */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CLUTCH_INT_OVF); 
 802a7a2:	4889      	ldr	r0, [pc, #548]	; (802a9c8 <DAVE_Init+0x2e0>)
 802a7a4:	f7ff f8f7 	bl	8029996 <INTERRUPT_Init>
 802a7a8:	4603      	mov	r3, r0
 802a7aa:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a7ac:	79fb      	ldrb	r3, [r7, #7]
 802a7ae:	2b00      	cmp	r3, #0
 802a7b0:	d104      	bne.n	802a7bc <DAVE_Init+0xd4>
  {
	 /**  Initialization of DIGITAL_IO APP instance TRANS_OUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&TRANS_OUT); 
 802a7b2:	4886      	ldr	r0, [pc, #536]	; (802a9cc <DAVE_Init+0x2e4>)
 802a7b4:	f7ff f9cc 	bl	8029b50 <DIGITAL_IO_Init>
 802a7b8:	4603      	mov	r3, r0
 802a7ba:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a7bc:	79fb      	ldrb	r3, [r7, #7]
 802a7be:	2b00      	cmp	r3, #0
 802a7c0:	d104      	bne.n	802a7cc <DAVE_Init+0xe4>
  {
	 /**  Initialization of BUS_IO APP instance GROUP_IN */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&GROUP_IN); 
 802a7c2:	4883      	ldr	r0, [pc, #524]	; (802a9d0 <DAVE_Init+0x2e8>)
 802a7c4:	f7ff fd35 	bl	802a232 <BUS_IO_Init>
 802a7c8:	4603      	mov	r3, r0
 802a7ca:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a7cc:	79fb      	ldrb	r3, [r7, #7]
 802a7ce:	2b00      	cmp	r3, #0
 802a7d0:	d104      	bne.n	802a7dc <DAVE_Init+0xf4>
  {
	 /**  Initialization of BUS_IO APP instance GROUP_OUT */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&GROUP_OUT); 
 802a7d2:	4880      	ldr	r0, [pc, #512]	; (802a9d4 <DAVE_Init+0x2ec>)
 802a7d4:	f7ff fd2d 	bl	802a232 <BUS_IO_Init>
 802a7d8:	4603      	mov	r3, r0
 802a7da:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a7dc:	79fb      	ldrb	r3, [r7, #7]
 802a7de:	2b00      	cmp	r3, #0
 802a7e0:	d104      	bne.n	802a7ec <DAVE_Init+0x104>
  {
	 /**  Initialization of DIGITAL_IO APP instance GROUP_IN_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&GROUP_IN_EN); 
 802a7e2:	487d      	ldr	r0, [pc, #500]	; (802a9d8 <DAVE_Init+0x2f0>)
 802a7e4:	f7ff f9b4 	bl	8029b50 <DIGITAL_IO_Init>
 802a7e8:	4603      	mov	r3, r0
 802a7ea:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a7ec:	79fb      	ldrb	r3, [r7, #7]
 802a7ee:	2b00      	cmp	r3, #0
 802a7f0:	d104      	bne.n	802a7fc <DAVE_Init+0x114>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_NRES */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_NRES); 
 802a7f2:	487a      	ldr	r0, [pc, #488]	; (802a9dc <DAVE_Init+0x2f4>)
 802a7f4:	f7ff f9ac 	bl	8029b50 <DIGITAL_IO_Init>
 802a7f8:	4603      	mov	r3, r0
 802a7fa:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a7fc:	79fb      	ldrb	r3, [r7, #7]
 802a7fe:	2b00      	cmp	r3, #0
 802a800:	d104      	bne.n	802a80c <DAVE_Init+0x124>
  {
	 /**  Initialization of BUS_IO APP instance DI_PNP */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&DI_PNP); 
 802a802:	4877      	ldr	r0, [pc, #476]	; (802a9e0 <DAVE_Init+0x2f8>)
 802a804:	f7ff fd15 	bl	802a232 <BUS_IO_Init>
 802a808:	4603      	mov	r3, r0
 802a80a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a80c:	79fb      	ldrb	r3, [r7, #7]
 802a80e:	2b00      	cmp	r3, #0
 802a810:	d104      	bne.n	802a81c <DAVE_Init+0x134>
  {
	 /**  Initialization of BUS_IO APP instance DI_NPN */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&DI_NPN); 
 802a812:	4874      	ldr	r0, [pc, #464]	; (802a9e4 <DAVE_Init+0x2fc>)
 802a814:	f7ff fd0d 	bl	802a232 <BUS_IO_Init>
 802a818:	4603      	mov	r3, r0
 802a81a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a81c:	79fb      	ldrb	r3, [r7, #7]
 802a81e:	2b00      	cmp	r3, #0
 802a820:	d104      	bne.n	802a82c <DAVE_Init+0x144>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_1); 
 802a822:	4871      	ldr	r0, [pc, #452]	; (802a9e8 <DAVE_Init+0x300>)
 802a824:	f7ff f994 	bl	8029b50 <DIGITAL_IO_Init>
 802a828:	4603      	mov	r3, r0
 802a82a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a82c:	79fb      	ldrb	r3, [r7, #7]
 802a82e:	2b00      	cmp	r3, #0
 802a830:	d104      	bne.n	802a83c <DAVE_Init+0x154>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_2); 
 802a832:	486e      	ldr	r0, [pc, #440]	; (802a9ec <DAVE_Init+0x304>)
 802a834:	f7ff f98c 	bl	8029b50 <DIGITAL_IO_Init>
 802a838:	4603      	mov	r3, r0
 802a83a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a83c:	79fb      	ldrb	r3, [r7, #7]
 802a83e:	2b00      	cmp	r3, #0
 802a840:	d104      	bne.n	802a84c <DAVE_Init+0x164>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_3); 
 802a842:	486b      	ldr	r0, [pc, #428]	; (802a9f0 <DAVE_Init+0x308>)
 802a844:	f7ff f984 	bl	8029b50 <DIGITAL_IO_Init>
 802a848:	4603      	mov	r3, r0
 802a84a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a84c:	79fb      	ldrb	r3, [r7, #7]
 802a84e:	2b00      	cmp	r3, #0
 802a850:	d104      	bne.n	802a85c <DAVE_Init+0x174>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_4); 
 802a852:	4868      	ldr	r0, [pc, #416]	; (802a9f4 <DAVE_Init+0x30c>)
 802a854:	f7ff f97c 	bl	8029b50 <DIGITAL_IO_Init>
 802a858:	4603      	mov	r3, r0
 802a85a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a85c:	79fb      	ldrb	r3, [r7, #7]
 802a85e:	2b00      	cmp	r3, #0
 802a860:	d104      	bne.n	802a86c <DAVE_Init+0x184>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_1); 
 802a862:	4865      	ldr	r0, [pc, #404]	; (802a9f8 <DAVE_Init+0x310>)
 802a864:	f7ff f974 	bl	8029b50 <DIGITAL_IO_Init>
 802a868:	4603      	mov	r3, r0
 802a86a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a86c:	79fb      	ldrb	r3, [r7, #7]
 802a86e:	2b00      	cmp	r3, #0
 802a870:	d104      	bne.n	802a87c <DAVE_Init+0x194>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_2); 
 802a872:	4862      	ldr	r0, [pc, #392]	; (802a9fc <DAVE_Init+0x314>)
 802a874:	f7ff f96c 	bl	8029b50 <DIGITAL_IO_Init>
 802a878:	4603      	mov	r3, r0
 802a87a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a87c:	79fb      	ldrb	r3, [r7, #7]
 802a87e:	2b00      	cmp	r3, #0
 802a880:	d104      	bne.n	802a88c <DAVE_Init+0x1a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_3); 
 802a882:	485f      	ldr	r0, [pc, #380]	; (802aa00 <DAVE_Init+0x318>)
 802a884:	f7ff f964 	bl	8029b50 <DIGITAL_IO_Init>
 802a888:	4603      	mov	r3, r0
 802a88a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a88c:	79fb      	ldrb	r3, [r7, #7]
 802a88e:	2b00      	cmp	r3, #0
 802a890:	d104      	bne.n	802a89c <DAVE_Init+0x1b4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_4); 
 802a892:	485c      	ldr	r0, [pc, #368]	; (802aa04 <DAVE_Init+0x31c>)
 802a894:	f7ff f95c 	bl	8029b50 <DIGITAL_IO_Init>
 802a898:	4603      	mov	r3, r0
 802a89a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a89c:	79fb      	ldrb	r3, [r7, #7]
 802a89e:	2b00      	cmp	r3, #0
 802a8a0:	d104      	bne.n	802a8ac <DAVE_Init+0x1c4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_5); 
 802a8a2:	4859      	ldr	r0, [pc, #356]	; (802aa08 <DAVE_Init+0x320>)
 802a8a4:	f7ff f954 	bl	8029b50 <DIGITAL_IO_Init>
 802a8a8:	4603      	mov	r3, r0
 802a8aa:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8ac:	79fb      	ldrb	r3, [r7, #7]
 802a8ae:	2b00      	cmp	r3, #0
 802a8b0:	d104      	bne.n	802a8bc <DAVE_Init+0x1d4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_6); 
 802a8b2:	4856      	ldr	r0, [pc, #344]	; (802aa0c <DAVE_Init+0x324>)
 802a8b4:	f7ff f94c 	bl	8029b50 <DIGITAL_IO_Init>
 802a8b8:	4603      	mov	r3, r0
 802a8ba:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8bc:	79fb      	ldrb	r3, [r7, #7]
 802a8be:	2b00      	cmp	r3, #0
 802a8c0:	d104      	bne.n	802a8cc <DAVE_Init+0x1e4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_7); 
 802a8c2:	4853      	ldr	r0, [pc, #332]	; (802aa10 <DAVE_Init+0x328>)
 802a8c4:	f7ff f944 	bl	8029b50 <DIGITAL_IO_Init>
 802a8c8:	4603      	mov	r3, r0
 802a8ca:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8cc:	79fb      	ldrb	r3, [r7, #7]
 802a8ce:	2b00      	cmp	r3, #0
 802a8d0:	d104      	bne.n	802a8dc <DAVE_Init+0x1f4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_8 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_8); 
 802a8d2:	4850      	ldr	r0, [pc, #320]	; (802aa14 <DAVE_Init+0x32c>)
 802a8d4:	f7ff f93c 	bl	8029b50 <DIGITAL_IO_Init>
 802a8d8:	4603      	mov	r3, r0
 802a8da:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8dc:	79fb      	ldrb	r3, [r7, #7]
 802a8de:	2b00      	cmp	r3, #0
 802a8e0:	d104      	bne.n	802a8ec <DAVE_Init+0x204>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_NRES */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_NRES); 
 802a8e2:	484d      	ldr	r0, [pc, #308]	; (802aa18 <DAVE_Init+0x330>)
 802a8e4:	f7ff f934 	bl	8029b50 <DIGITAL_IO_Init>
 802a8e8:	4603      	mov	r3, r0
 802a8ea:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8ec:	79fb      	ldrb	r3, [r7, #7]
 802a8ee:	2b00      	cmp	r3, #0
 802a8f0:	d104      	bne.n	802a8fc <DAVE_Init+0x214>
  {
	 /**  Initialization of DIGITAL_IO APP instance DI_PNP_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DI_PNP_EN); 
 802a8f2:	484a      	ldr	r0, [pc, #296]	; (802aa1c <DAVE_Init+0x334>)
 802a8f4:	f7ff f92c 	bl	8029b50 <DIGITAL_IO_Init>
 802a8f8:	4603      	mov	r3, r0
 802a8fa:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a8fc:	79fb      	ldrb	r3, [r7, #7]
 802a8fe:	2b00      	cmp	r3, #0
 802a900:	d104      	bne.n	802a90c <DAVE_Init+0x224>
  {
	 /**  Initialization of DIGITAL_IO APP instance DI_NPN_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DI_NPN_EN); 
 802a902:	4847      	ldr	r0, [pc, #284]	; (802aa20 <DAVE_Init+0x338>)
 802a904:	f7ff f924 	bl	8029b50 <DIGITAL_IO_Init>
 802a908:	4603      	mov	r3, r0
 802a90a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a90c:	79fb      	ldrb	r3, [r7, #7]
 802a90e:	2b00      	cmp	r3, #0
 802a910:	d104      	bne.n	802a91c <DAVE_Init+0x234>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_POWER_EN1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_POWER_EN1); 
 802a912:	4844      	ldr	r0, [pc, #272]	; (802aa24 <DAVE_Init+0x33c>)
 802a914:	f7ff f91c 	bl	8029b50 <DIGITAL_IO_Init>
 802a918:	4603      	mov	r3, r0
 802a91a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a91c:	79fb      	ldrb	r3, [r7, #7]
 802a91e:	2b00      	cmp	r3, #0
 802a920:	d104      	bne.n	802a92c <DAVE_Init+0x244>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_POWER_EN2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_POWER_EN2); 
 802a922:	4841      	ldr	r0, [pc, #260]	; (802aa28 <DAVE_Init+0x340>)
 802a924:	f7ff f914 	bl	8029b50 <DIGITAL_IO_Init>
 802a928:	4603      	mov	r3, r0
 802a92a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a92c:	79fb      	ldrb	r3, [r7, #7]
 802a92e:	2b00      	cmp	r3, #0
 802a930:	d104      	bne.n	802a93c <DAVE_Init+0x254>
  {
	 /**  Initialization of DIGITAL_IO APP instance POWER_SWITCH */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&POWER_SWITCH); 
 802a932:	483e      	ldr	r0, [pc, #248]	; (802aa2c <DAVE_Init+0x344>)
 802a934:	f7ff f90c 	bl	8029b50 <DIGITAL_IO_Init>
 802a938:	4603      	mov	r3, r0
 802a93a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a93c:	79fb      	ldrb	r3, [r7, #7]
 802a93e:	2b00      	cmp	r3, #0
 802a940:	d104      	bne.n	802a94c <DAVE_Init+0x264>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_1); 
 802a942:	483b      	ldr	r0, [pc, #236]	; (802aa30 <DAVE_Init+0x348>)
 802a944:	f7ff f904 	bl	8029b50 <DIGITAL_IO_Init>
 802a948:	4603      	mov	r3, r0
 802a94a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a94c:	79fb      	ldrb	r3, [r7, #7]
 802a94e:	2b00      	cmp	r3, #0
 802a950:	d104      	bne.n	802a95c <DAVE_Init+0x274>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_2); 
 802a952:	4838      	ldr	r0, [pc, #224]	; (802aa34 <DAVE_Init+0x34c>)
 802a954:	f7ff f8fc 	bl	8029b50 <DIGITAL_IO_Init>
 802a958:	4603      	mov	r3, r0
 802a95a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a95c:	79fb      	ldrb	r3, [r7, #7]
 802a95e:	2b00      	cmp	r3, #0
 802a960:	d104      	bne.n	802a96c <DAVE_Init+0x284>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_3); 
 802a962:	4835      	ldr	r0, [pc, #212]	; (802aa38 <DAVE_Init+0x350>)
 802a964:	f7ff f8f4 	bl	8029b50 <DIGITAL_IO_Init>
 802a968:	4603      	mov	r3, r0
 802a96a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a96c:	79fb      	ldrb	r3, [r7, #7]
 802a96e:	2b00      	cmp	r3, #0
 802a970:	d104      	bne.n	802a97c <DAVE_Init+0x294>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_4); 
 802a972:	4832      	ldr	r0, [pc, #200]	; (802aa3c <DAVE_Init+0x354>)
 802a974:	f7ff f8ec 	bl	8029b50 <DIGITAL_IO_Init>
 802a978:	4603      	mov	r3, r0
 802a97a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a97c:	79fb      	ldrb	r3, [r7, #7]
 802a97e:	2b00      	cmp	r3, #0
 802a980:	d104      	bne.n	802a98c <DAVE_Init+0x2a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_5); 
 802a982:	482f      	ldr	r0, [pc, #188]	; (802aa40 <DAVE_Init+0x358>)
 802a984:	f7ff f8e4 	bl	8029b50 <DIGITAL_IO_Init>
 802a988:	4603      	mov	r3, r0
 802a98a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802a98c:	79fb      	ldrb	r3, [r7, #7]
 802a98e:	2b00      	cmp	r3, #0
 802a990:	d15c      	bne.n	802aa4c <DAVE_Init+0x364>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_6); 
 802a992:	482c      	ldr	r0, [pc, #176]	; (802aa44 <DAVE_Init+0x35c>)
 802a994:	f7ff f8dc 	bl	8029b50 <DIGITAL_IO_Init>
 802a998:	e056      	b.n	802aa48 <DAVE_Init+0x360>
 802a99a:	bf00      	nop
 802a99c:	200010f8 	.word	0x200010f8
 802a9a0:	0802b244 	.word	0x0802b244
 802a9a4:	0802b258 	.word	0x0802b258
 802a9a8:	0802b26c 	.word	0x0802b26c
 802a9ac:	0802b280 	.word	0x0802b280
 802a9b0:	200010f4 	.word	0x200010f4
 802a9b4:	0802b598 	.word	0x0802b598
 802a9b8:	0802b6d8 	.word	0x0802b6d8
 802a9bc:	0802b1b4 	.word	0x0802b1b4
 802a9c0:	20000264 	.word	0x20000264
 802a9c4:	0802b1b8 	.word	0x0802b1b8
 802a9c8:	0802b1bc 	.word	0x0802b1bc
 802a9cc:	0802b294 	.word	0x0802b294
 802a9d0:	20000520 	.word	0x20000520
 802a9d4:	20000534 	.word	0x20000534
 802a9d8:	0802b2a8 	.word	0x0802b2a8
 802a9dc:	0802b2bc 	.word	0x0802b2bc
 802a9e0:	20000548 	.word	0x20000548
 802a9e4:	2000055c 	.word	0x2000055c
 802a9e8:	0802b2d0 	.word	0x0802b2d0
 802a9ec:	0802b2e4 	.word	0x0802b2e4
 802a9f0:	0802b2f8 	.word	0x0802b2f8
 802a9f4:	0802b30c 	.word	0x0802b30c
 802a9f8:	0802b320 	.word	0x0802b320
 802a9fc:	0802b334 	.word	0x0802b334
 802aa00:	0802b348 	.word	0x0802b348
 802aa04:	0802b35c 	.word	0x0802b35c
 802aa08:	0802b370 	.word	0x0802b370
 802aa0c:	0802b384 	.word	0x0802b384
 802aa10:	0802b398 	.word	0x0802b398
 802aa14:	0802b3ac 	.word	0x0802b3ac
 802aa18:	0802b3c0 	.word	0x0802b3c0
 802aa1c:	0802b3d4 	.word	0x0802b3d4
 802aa20:	0802b3e8 	.word	0x0802b3e8
 802aa24:	0802b3fc 	.word	0x0802b3fc
 802aa28:	0802b410 	.word	0x0802b410
 802aa2c:	0802b424 	.word	0x0802b424
 802aa30:	0802b438 	.word	0x0802b438
 802aa34:	0802b44c 	.word	0x0802b44c
 802aa38:	0802b460 	.word	0x0802b460
 802aa3c:	0802b474 	.word	0x0802b474
 802aa40:	0802b488 	.word	0x0802b488
 802aa44:	0802b49c 	.word	0x0802b49c
 802aa48:	4603      	mov	r3, r0
 802aa4a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa4c:	79fb      	ldrb	r3, [r7, #7]
 802aa4e:	2b00      	cmp	r3, #0
 802aa50:	d104      	bne.n	802aa5c <DAVE_Init+0x374>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_7); 
 802aa52:	4831      	ldr	r0, [pc, #196]	; (802ab18 <DAVE_Init+0x430>)
 802aa54:	f7ff f87c 	bl	8029b50 <DIGITAL_IO_Init>
 802aa58:	4603      	mov	r3, r0
 802aa5a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa5c:	79fb      	ldrb	r3, [r7, #7]
 802aa5e:	2b00      	cmp	r3, #0
 802aa60:	d104      	bne.n	802aa6c <DAVE_Init+0x384>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_8 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_8); 
 802aa62:	482e      	ldr	r0, [pc, #184]	; (802ab1c <DAVE_Init+0x434>)
 802aa64:	f7ff f874 	bl	8029b50 <DIGITAL_IO_Init>
 802aa68:	4603      	mov	r3, r0
 802aa6a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa6c:	79fb      	ldrb	r3, [r7, #7]
 802aa6e:	2b00      	cmp	r3, #0
 802aa70:	d104      	bne.n	802aa7c <DAVE_Init+0x394>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_2_RESET_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_2_RESET_INT); 
 802aa72:	482b      	ldr	r0, [pc, #172]	; (802ab20 <DAVE_Init+0x438>)
 802aa74:	f7fe ff8f 	bl	8029996 <INTERRUPT_Init>
 802aa78:	4603      	mov	r3, r0
 802aa7a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa7c:	79fb      	ldrb	r3, [r7, #7]
 802aa7e:	2b00      	cmp	r3, #0
 802aa80:	d104      	bne.n	802aa8c <DAVE_Init+0x3a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance MOTOR_FAULT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&MOTOR_FAULT); 
 802aa82:	4828      	ldr	r0, [pc, #160]	; (802ab24 <DAVE_Init+0x43c>)
 802aa84:	f7ff f864 	bl	8029b50 <DIGITAL_IO_Init>
 802aa88:	4603      	mov	r3, r0
 802aa8a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa8c:	79fb      	ldrb	r3, [r7, #7]
 802aa8e:	2b00      	cmp	r3, #0
 802aa90:	d104      	bne.n	802aa9c <DAVE_Init+0x3b4>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_1_TRAP_SENSOR_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_1_TRAP_SENSOR_INT); 
 802aa92:	4825      	ldr	r0, [pc, #148]	; (802ab28 <DAVE_Init+0x440>)
 802aa94:	f7fe ff7f 	bl	8029996 <INTERRUPT_Init>
 802aa98:	4603      	mov	r3, r0
 802aa9a:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aa9c:	79fb      	ldrb	r3, [r7, #7]
 802aa9e:	2b00      	cmp	r3, #0
 802aaa0:	d104      	bne.n	802aaac <DAVE_Init+0x3c4>
  {
	 /**  Initialization of INTERRUPT APP instance SERV_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&SERV_INT); 
 802aaa2:	4822      	ldr	r0, [pc, #136]	; (802ab2c <DAVE_Init+0x444>)
 802aaa4:	f7fe ff77 	bl	8029996 <INTERRUPT_Init>
 802aaa8:	4603      	mov	r3, r0
 802aaaa:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aaac:	79fb      	ldrb	r3, [r7, #7]
 802aaae:	2b00      	cmp	r3, #0
 802aab0:	d104      	bne.n	802aabc <DAVE_Init+0x3d4>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_1_STOP_BUT_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_1_STOP_BUT_INT); 
 802aab2:	481f      	ldr	r0, [pc, #124]	; (802ab30 <DAVE_Init+0x448>)
 802aab4:	f7fe ff6f 	bl	8029996 <INTERRUPT_Init>
 802aab8:	4603      	mov	r3, r0
 802aaba:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aabc:	79fb      	ldrb	r3, [r7, #7]
 802aabe:	2b00      	cmp	r3, #0
 802aac0:	d104      	bne.n	802aacc <DAVE_Init+0x3e4>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_NODE_ALLERT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_NODE_ALLERT); 
 802aac2:	481c      	ldr	r0, [pc, #112]	; (802ab34 <DAVE_Init+0x44c>)
 802aac4:	f7fe ff67 	bl	8029996 <INTERRUPT_Init>
 802aac8:	4603      	mov	r3, r0
 802aaca:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aacc:	79fb      	ldrb	r3, [r7, #7]
 802aace:	2b00      	cmp	r3, #0
 802aad0:	d104      	bne.n	802aadc <DAVE_Init+0x3f4>
  {
	 /**  Initialization of ADC_MEASUREMENT APP instance ADC_MEASUREMENT_0 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_Init(&ADC_MEASUREMENT_0); 
 802aad2:	4819      	ldr	r0, [pc, #100]	; (802ab38 <DAVE_Init+0x450>)
 802aad4:	f7ff fd35 	bl	802a542 <ADC_MEASUREMENT_Init>
 802aad8:	4603      	mov	r3, r0
 802aada:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aadc:	79fb      	ldrb	r3, [r7, #7]
 802aade:	2b00      	cmp	r3, #0
 802aae0:	d104      	bne.n	802aaec <DAVE_Init+0x404>
  {
	 /**  Initialization of PWM_CCU4 APP instance BUZZ_PWM */
	 init_status = (DAVE_STATUS_t)PWM_CCU4_Init(&BUZZ_PWM); 
 802aae2:	4816      	ldr	r0, [pc, #88]	; (802ab3c <DAVE_Init+0x454>)
 802aae4:	f7fe fbf5 	bl	80292d2 <PWM_CCU4_Init>
 802aae8:	4603      	mov	r3, r0
 802aaea:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aaec:	79fb      	ldrb	r3, [r7, #7]
 802aaee:	2b00      	cmp	r3, #0
 802aaf0:	d104      	bne.n	802aafc <DAVE_Init+0x414>
  {
	 /**  Initialization of INTERRUPT APP instance BUZZ_INT_OVF */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&BUZZ_INT_OVF); 
 802aaf2:	4813      	ldr	r0, [pc, #76]	; (802ab40 <DAVE_Init+0x458>)
 802aaf4:	f7fe ff4f 	bl	8029996 <INTERRUPT_Init>
 802aaf8:	4603      	mov	r3, r0
 802aafa:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802aafc:	79fb      	ldrb	r3, [r7, #7]
 802aafe:	2b00      	cmp	r3, #0
 802ab00:	d104      	bne.n	802ab0c <DAVE_Init+0x424>
  {
	 /**  Initialization of INTERRUPT APP instance BUZZ_INT_CMP */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&BUZZ_INT_CMP); 
 802ab02:	4810      	ldr	r0, [pc, #64]	; (802ab44 <DAVE_Init+0x45c>)
 802ab04:	f7fe ff47 	bl	8029996 <INTERRUPT_Init>
 802ab08:	4603      	mov	r3, r0
 802ab0a:	71fb      	strb	r3, [r7, #7]
   }  
  return init_status;
 802ab0c:	79fb      	ldrb	r3, [r7, #7]
} /**  End of function DAVE_Init */
 802ab0e:	4618      	mov	r0, r3
 802ab10:	3708      	adds	r7, #8
 802ab12:	46bd      	mov	sp, r7
 802ab14:	bd80      	pop	{r7, pc}
 802ab16:	bf00      	nop
 802ab18:	0802b4b0 	.word	0x0802b4b0
 802ab1c:	0802b4c4 	.word	0x0802b4c4
 802ab20:	0802b1c0 	.word	0x0802b1c0
 802ab24:	0802b4d8 	.word	0x0802b4d8
 802ab28:	0802b1c4 	.word	0x0802b1c4
 802ab2c:	0802b1c8 	.word	0x0802b1c8
 802ab30:	0802b1cc 	.word	0x0802b1cc
 802ab34:	0802b1d0 	.word	0x0802b1d0
 802ab38:	200005dc 	.word	0x200005dc
 802ab3c:	2000028c 	.word	0x2000028c
 802ab40:	0802b1d4 	.word	0x0802b1d4
 802ab44:	0802b1d8 	.word	0x0802b1d8

0802ab48 <XMC_GPIO_SetOutputHigh>:
{
 802ab48:	b480      	push	{r7}
 802ab4a:	b083      	sub	sp, #12
 802ab4c:	af00      	add	r7, sp, #0
 802ab4e:	6078      	str	r0, [r7, #4]
 802ab50:	460b      	mov	r3, r1
 802ab52:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 802ab54:	78fb      	ldrb	r3, [r7, #3]
 802ab56:	2201      	movs	r2, #1
 802ab58:	409a      	lsls	r2, r3
 802ab5a:	687b      	ldr	r3, [r7, #4]
 802ab5c:	605a      	str	r2, [r3, #4]
}
 802ab5e:	bf00      	nop
 802ab60:	370c      	adds	r7, #12
 802ab62:	46bd      	mov	sp, r7
 802ab64:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ab68:	4770      	bx	lr

0802ab6a <XMC_GPIO_SetOutputLow>:
{
 802ab6a:	b480      	push	{r7}
 802ab6c:	b083      	sub	sp, #12
 802ab6e:	af00      	add	r7, sp, #0
 802ab70:	6078      	str	r0, [r7, #4]
 802ab72:	460b      	mov	r3, r1
 802ab74:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 802ab76:	78fb      	ldrb	r3, [r7, #3]
 802ab78:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802ab7c:	409a      	lsls	r2, r3
 802ab7e:	687b      	ldr	r3, [r7, #4]
 802ab80:	605a      	str	r2, [r3, #4]
}
 802ab82:	bf00      	nop
 802ab84:	370c      	adds	r7, #12
 802ab86:	46bd      	mov	sp, r7
 802ab88:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ab8c:	4770      	bx	lr

0802ab8e <XMC_GPIO_ToggleOutput>:
{
 802ab8e:	b480      	push	{r7}
 802ab90:	b083      	sub	sp, #12
 802ab92:	af00      	add	r7, sp, #0
 802ab94:	6078      	str	r0, [r7, #4]
 802ab96:	460b      	mov	r3, r1
 802ab98:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10001U << pin;
 802ab9a:	78fb      	ldrb	r3, [r7, #3]
 802ab9c:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 802aba0:	409a      	lsls	r2, r3
 802aba2:	687b      	ldr	r3, [r7, #4]
 802aba4:	605a      	str	r2, [r3, #4]
}
 802aba6:	bf00      	nop
 802aba8:	370c      	adds	r7, #12
 802abaa:	46bd      	mov	sp, r7
 802abac:	f85d 7b04 	ldr.w	r7, [sp], #4
 802abb0:	4770      	bx	lr

0802abb2 <DIGITAL_IO_SetOutputHigh>:
{
 802abb2:	b580      	push	{r7, lr}
 802abb4:	b082      	sub	sp, #8
 802abb6:	af00      	add	r7, sp, #0
 802abb8:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 802abba:	687b      	ldr	r3, [r7, #4]
 802abbc:	681a      	ldr	r2, [r3, #0]
 802abbe:	687b      	ldr	r3, [r7, #4]
 802abc0:	7c1b      	ldrb	r3, [r3, #16]
 802abc2:	4619      	mov	r1, r3
 802abc4:	4610      	mov	r0, r2
 802abc6:	f7ff ffbf 	bl	802ab48 <XMC_GPIO_SetOutputHigh>
}
 802abca:	bf00      	nop
 802abcc:	3708      	adds	r7, #8
 802abce:	46bd      	mov	sp, r7
 802abd0:	bd80      	pop	{r7, pc}

0802abd2 <DIGITAL_IO_SetOutputLow>:
{
 802abd2:	b580      	push	{r7, lr}
 802abd4:	b082      	sub	sp, #8
 802abd6:	af00      	add	r7, sp, #0
 802abd8:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 802abda:	687b      	ldr	r3, [r7, #4]
 802abdc:	681a      	ldr	r2, [r3, #0]
 802abde:	687b      	ldr	r3, [r7, #4]
 802abe0:	7c1b      	ldrb	r3, [r3, #16]
 802abe2:	4619      	mov	r1, r3
 802abe4:	4610      	mov	r0, r2
 802abe6:	f7ff ffc0 	bl	802ab6a <XMC_GPIO_SetOutputLow>
}
 802abea:	bf00      	nop
 802abec:	3708      	adds	r7, #8
 802abee:	46bd      	mov	sp, r7
 802abf0:	bd80      	pop	{r7, pc}

0802abf2 <DIGITAL_IO_ToggleOutput>:
{
 802abf2:	b580      	push	{r7, lr}
 802abf4:	b082      	sub	sp, #8
 802abf6:	af00      	add	r7, sp, #0
 802abf8:	6078      	str	r0, [r7, #4]
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 802abfa:	687b      	ldr	r3, [r7, #4]
 802abfc:	681a      	ldr	r2, [r3, #0]
 802abfe:	687b      	ldr	r3, [r7, #4]
 802ac00:	7c1b      	ldrb	r3, [r3, #16]
 802ac02:	4619      	mov	r1, r3
 802ac04:	4610      	mov	r0, r2
 802ac06:	f7ff ffc2 	bl	802ab8e <XMC_GPIO_ToggleOutput>
}
 802ac0a:	bf00      	nop
 802ac0c:	3708      	adds	r7, #8
 802ac0e:	46bd      	mov	sp, r7
 802ac10:	bd80      	pop	{r7, pc}
	...

0802ac14 <XMC_SCU_RESET_ClearDeviceResetReason>:
{
 802ac14:	b480      	push	{r7}
 802ac16:	af00      	add	r7, sp, #0
  SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_RSCLR_Msk;
 802ac18:	4b03      	ldr	r3, [pc, #12]	; (802ac28 <XMC_SCU_RESET_ClearDeviceResetReason+0x14>)
 802ac1a:	2201      	movs	r2, #1
 802ac1c:	609a      	str	r2, [r3, #8]
}
 802ac1e:	bf00      	nop
 802ac20:	46bd      	mov	sp, r7
 802ac22:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ac26:	4770      	bx	lr
 802ac28:	50004400 	.word	0x50004400

0802ac2c <CCU43_0_IRQHandler>:
extern uint8_t Can1Rx3Data[8];
//extern int32_t ExtCanOnline;


void ClutchCmpHandler (void)
{
 802ac2c:	b580      	push	{r7, lr}
 802ac2e:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&CLUTCH_PWM,XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 802ac30:	2102      	movs	r1, #2
 802ac32:	4804      	ldr	r0, [pc, #16]	; (802ac44 <CCU43_0_IRQHandler+0x18>)
 802ac34:	f7fe fe06 	bl	8029844 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputLow(&HS_SW_1);
 802ac38:	4803      	ldr	r0, [pc, #12]	; (802ac48 <CCU43_0_IRQHandler+0x1c>)
 802ac3a:	f7ff ffca 	bl	802abd2 <DIGITAL_IO_SetOutputLow>
	//DIGITAL_IO_SetOutputLow(&HS_SW_2);
}
 802ac3e:	bf00      	nop
 802ac40:	bd80      	pop	{r7, pc}
 802ac42:	bf00      	nop
 802ac44:	20000264 	.word	0x20000264
 802ac48:	0802b320 	.word	0x0802b320

0802ac4c <CCU43_1_IRQHandler>:
void ClutchOvfHandler(void)
{
 802ac4c:	b580      	push	{r7, lr}
 802ac4e:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&CLUTCH_PWM,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 802ac50:	2100      	movs	r1, #0
 802ac52:	4804      	ldr	r0, [pc, #16]	; (802ac64 <CCU43_1_IRQHandler+0x18>)
 802ac54:	f7fe fdf6 	bl	8029844 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputHigh(&HS_SW_1);
 802ac58:	4803      	ldr	r0, [pc, #12]	; (802ac68 <CCU43_1_IRQHandler+0x1c>)
 802ac5a:	f7ff ffaa 	bl	802abb2 <DIGITAL_IO_SetOutputHigh>
	//DIGITAL_IO_SetOutputHigh(&HS_SW_2);
}
 802ac5e:	bf00      	nop
 802ac60:	bd80      	pop	{r7, pc}
 802ac62:	bf00      	nop
 802ac64:	20000264 	.word	0x20000264
 802ac68:	0802b320 	.word	0x0802b320

0802ac6c <MCU_ProgramReset>:


void MCU_ProgramReset( void )
{
 802ac6c:	b580      	push	{r7, lr}
 802ac6e:	af00      	add	r7, sp, #0

	// clear the reset cause field for proper reset detection of the ssw
	XMC_SCU_RESET_ClearDeviceResetReason();
 802ac70:	f7ff ffd0 	bl	802ac14 <XMC_SCU_RESET_ClearDeviceResetReason>

	// set normal boot as boot mode in SWCON field of STCON register
	XMC_SCU_SetBootMode(XMC_SCU_BOOTMODE_NORMAL);
 802ac74:	2000      	movs	r0, #0
 802ac76:	f7fb fd15 	bl	80266a4 <XMC_SCU_SetBootMode>

	// trigger power on reset
	PPB->AIRCR = 1 << PPB_AIRCR_SYSRESETREQ_Pos |0x5FA<<PPB_AIRCR_VECTKEY_Pos | 0x1 << PPB_AIRCR_PRIGROUP_Pos;
 802ac7a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802ac7e:	4a02      	ldr	r2, [pc, #8]	; (802ac88 <MCU_ProgramReset+0x1c>)
 802ac80:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	while (1) {};
 802ac84:	e7fe      	b.n	802ac84 <MCU_ProgramReset+0x18>
 802ac86:	bf00      	nop
 802ac88:	05fa0104 	.word	0x05fa0104

0802ac8c <VADC0_C0_2_IRQHandler>:

} //MCU_ProgramReset()

void Adc_Measurement_Handler(void)
{
 802ac8c:	b580      	push	{r7, lr}
 802ac8e:	b082      	sub	sp, #8
 802ac90:	af00      	add	r7, sp, #0
	float temp = 0;
 802ac92:	f04f 0300 	mov.w	r3, #0
 802ac96:	607b      	str	r3, [r7, #4]

	Inputs.ActiveRubberLVal = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A_handle);
 802ac98:	480c      	ldr	r0, [pc, #48]	; (802accc <VADC0_C0_2_IRQHandler+0x40>)
 802ac9a:	f7ff fd0d 	bl	802a6b8 <ADC_MEASUREMENT_GetResult>
 802ac9e:	4603      	mov	r3, r0
 802aca0:	461a      	mov	r2, r3
 802aca2:	4b0b      	ldr	r3, [pc, #44]	; (802acd0 <VADC0_C0_2_IRQHandler+0x44>)
 802aca4:	811a      	strh	r2, [r3, #8]
	else
	{
		ActiveRubberL = 0;
	}
*/
    Inputs.ActiveRubberRVal = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_B_handle);
 802aca6:	480b      	ldr	r0, [pc, #44]	; (802acd4 <VADC0_C0_2_IRQHandler+0x48>)
 802aca8:	f7ff fd06 	bl	802a6b8 <ADC_MEASUREMENT_GetResult>
 802acac:	4603      	mov	r3, r0
 802acae:	461a      	mov	r2, r3
 802acb0:	4b07      	ldr	r3, [pc, #28]	; (802acd0 <VADC0_C0_2_IRQHandler+0x44>)
 802acb2:	815a      	strh	r2, [r3, #10]
    else
    {
        ActiveRubberR = 0;
    }
*/
   Inputs.InputPower = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_C_handle);
 802acb4:	4808      	ldr	r0, [pc, #32]	; (802acd8 <VADC0_C0_2_IRQHandler+0x4c>)
 802acb6:	f7ff fcff 	bl	802a6b8 <ADC_MEASUREMENT_GetResult>
 802acba:	4603      	mov	r3, r0
 802acbc:	461a      	mov	r2, r3
 802acbe:	4b04      	ldr	r3, [pc, #16]	; (802acd0 <VADC0_C0_2_IRQHandler+0x44>)
 802acc0:	819a      	strh	r2, [r3, #12]
   //temp = Inputs.InputPower;
   //temp = (1200 + (Inputs.InputPower - 1300)/20*18);
   //Inputs.InputPower = (uint16_t)temp;

   //Inputs.DriveCurrent = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_D_handle);
}
 802acc2:	bf00      	nop
 802acc4:	3708      	adds	r7, #8
 802acc6:	46bd      	mov	sp, r7
 802acc8:	bd80      	pop	{r7, pc}
 802acca:	bf00      	nop
 802accc:	2000057c 	.word	0x2000057c
 802acd0:	20000674 	.word	0x20000674
 802acd4:	2000059c 	.word	0x2000059c
 802acd8:	200005bc 	.word	0x200005bc

0802acdc <CAN0_1_IRQHandler>:
void ResetISRCan2Handler (void)
{
 802acdc:	b580      	push	{r7, lr}
 802acde:	b092      	sub	sp, #72	; 0x48
 802ace0:	af00      	add	r7, sp, #0
	char tempCanData[8] = {'C','M','D','_','B','O','O','T'};
 802ace2:	4a41      	ldr	r2, [pc, #260]	; (802ade8 <CAN0_1_IRQHandler+0x10c>)
 802ace4:	f107 0308 	add.w	r3, r7, #8
 802ace8:	e892 0003 	ldmia.w	r2, {r0, r1}
 802acec:	e883 0003 	stmia.w	r3, {r0, r1}
	char tempCanDataAddress[8] = {'R','E','S','E','T','_','0','0'};
 802acf0:	4a3e      	ldr	r2, [pc, #248]	; (802adec <CAN0_1_IRQHandler+0x110>)
 802acf2:	463b      	mov	r3, r7
 802acf4:	e892 0003 	ldmia.w	r2, {r0, r1}
 802acf8:	e883 0003 	stmia.w	r3, {r0, r1}
	uint8_t temp = 0;
 802acfc:	2300      	movs	r3, #0
 802acfe:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	//uint64_t temp_long = 0;

	DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 802ad02:	483b      	ldr	r0, [pc, #236]	; (802adf0 <CAN0_1_IRQHandler+0x114>)
 802ad04:	f7ff ff75 	bl	802abf2 <DIGITAL_IO_ToggleOutput>

	CAN_NODE_MO_Receive(&CAN_INT_LMO_08_Config);
 802ad08:	483a      	ldr	r0, [pc, #232]	; (802adf4 <CAN0_1_IRQHandler+0x118>)
 802ad0a:	f7ff f98f 	bl	802a02c <CAN_NODE_MO_Receive>

	if (CAN_INT_LMO_08_Config.mo_ptr->can_identifier == 0x06)
 802ad0e:	4b39      	ldr	r3, [pc, #228]	; (802adf4 <CAN0_1_IRQHandler+0x118>)
 802ad10:	681b      	ldr	r3, [r3, #0]
 802ad12:	685b      	ldr	r3, [r3, #4]
 802ad14:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802ad18:	2b06      	cmp	r3, #6
 802ad1a:	d117      	bne.n	802ad4c <CAN0_1_IRQHandler+0x70>
	{
		uint64_t ul1 = CAN_INT_LMO_08_Config.mo_ptr->can_data_long;
 802ad1c:	4b35      	ldr	r3, [pc, #212]	; (802adf4 <CAN0_1_IRQHandler+0x118>)
 802ad1e:	681b      	ldr	r3, [r3, #0]
 802ad20:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 802ad24:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

		uint64_t * p = (uint64_t *)(tempCanData);
 802ad28:	f107 0308 	add.w	r3, r7, #8
 802ad2c:	637b      	str	r3, [r7, #52]	; 0x34
		uint64_t ul2 = *p;
 802ad2e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802ad30:	e9d3 2300 	ldrd	r2, r3, [r3]
 802ad34:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

		if (ul1 == ul2)
 802ad38:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 802ad3c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 802ad40:	4299      	cmp	r1, r3
 802ad42:	bf08      	it	eq
 802ad44:	4290      	cmpeq	r0, r2
 802ad46:	d101      	bne.n	802ad4c <CAN0_1_IRQHandler+0x70>
		{
			MCU_ProgramReset();
 802ad48:	f7ff ff90 	bl	802ac6c <MCU_ProgramReset>
		}
	}

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_08_Config);
 802ad4c:	482a      	ldr	r0, [pc, #168]	; (802adf8 <CAN0_1_IRQHandler+0x11c>)
 802ad4e:	f7ff f96d 	bl	802a02c <CAN_NODE_MO_Receive>

	if (CAN_EXT_LMO_08_Config.mo_ptr->can_identifier == 0x06)
 802ad52:	4b29      	ldr	r3, [pc, #164]	; (802adf8 <CAN0_1_IRQHandler+0x11c>)
 802ad54:	681b      	ldr	r3, [r3, #0]
 802ad56:	685b      	ldr	r3, [r3, #4]
 802ad58:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802ad5c:	2b06      	cmp	r3, #6
 802ad5e:	d13f      	bne.n	802ade0 <CAN0_1_IRQHandler+0x104>
	{
		uint64_t ul1 = CAN_EXT_LMO_08_Config.mo_ptr->can_data_long;
 802ad60:	4b25      	ldr	r3, [pc, #148]	; (802adf8 <CAN0_1_IRQHandler+0x11c>)
 802ad62:	681b      	ldr	r3, [r3, #0]
 802ad64:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 802ad68:	e9c7 2308 	strd	r2, r3, [r7, #32]

		temp = (uint8_t)Presets.CAN_ADRESS; // calculate address
 802ad6c:	4b23      	ldr	r3, [pc, #140]	; (802adfc <CAN0_1_IRQHandler+0x120>)
 802ad6e:	689b      	ldr	r3, [r3, #8]
 802ad70:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		temp = temp/10;		// 00 - 90 from address (tens)
 802ad74:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802ad78:	4a21      	ldr	r2, [pc, #132]	; (802ae00 <CAN0_1_IRQHandler+0x124>)
 802ad7a:	fba2 2303 	umull	r2, r3, r2, r3
 802ad7e:	08db      	lsrs	r3, r3, #3
 802ad80:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		tempCanDataAddress[6] += temp; // add to string
 802ad84:	79ba      	ldrb	r2, [r7, #6]
 802ad86:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802ad8a:	4413      	add	r3, r2
 802ad8c:	b2db      	uxtb	r3, r3
 802ad8e:	71bb      	strb	r3, [r7, #6]

		temp = (uint8_t)Presets.CAN_ADRESS;
 802ad90:	4b1a      	ldr	r3, [pc, #104]	; (802adfc <CAN0_1_IRQHandler+0x120>)
 802ad92:	689b      	ldr	r3, [r3, #8]
 802ad94:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		temp = temp%10;	// 0 - 9 from address
 802ad98:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 802ad9c:	4b18      	ldr	r3, [pc, #96]	; (802ae00 <CAN0_1_IRQHandler+0x124>)
 802ad9e:	fba3 1302 	umull	r1, r3, r3, r2
 802ada2:	08d9      	lsrs	r1, r3, #3
 802ada4:	460b      	mov	r3, r1
 802ada6:	009b      	lsls	r3, r3, #2
 802ada8:	440b      	add	r3, r1
 802adaa:	005b      	lsls	r3, r3, #1
 802adac:	1ad3      	subs	r3, r2, r3
 802adae:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		tempCanDataAddress[7] += temp; // add to string
 802adb2:	79fa      	ldrb	r2, [r7, #7]
 802adb4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802adb8:	4413      	add	r3, r2
 802adba:	b2db      	uxtb	r3, r3
 802adbc:	71fb      	strb	r3, [r7, #7]

		uint64_t * p = (uint64_t *)(tempCanDataAddress);
 802adbe:	463b      	mov	r3, r7
 802adc0:	61fb      	str	r3, [r7, #28]
		uint64_t ul2 = *p;
 802adc2:	69fb      	ldr	r3, [r7, #28]
 802adc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 802adc8:	e9c7 2304 	strd	r2, r3, [r7, #16]

		if (ul1 == ul2)
 802adcc:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 802add0:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 802add4:	4299      	cmp	r1, r3
 802add6:	bf08      	it	eq
 802add8:	4290      	cmpeq	r0, r2
 802adda:	d101      	bne.n	802ade0 <CAN0_1_IRQHandler+0x104>
		{
			MCU_ProgramReset();
 802addc:	f7ff ff46 	bl	802ac6c <MCU_ProgramReset>
		}
	}

}
 802ade0:	bf00      	nop
 802ade2:	3748      	adds	r7, #72	; 0x48
 802ade4:	46bd      	mov	sp, r7
 802ade6:	bd80      	pop	{r7, pc}
 802ade8:	0802b84c 	.word	0x0802b84c
 802adec:	0802b854 	.word	0x0802b854
 802adf0:	0802b26c 	.word	0x0802b26c
 802adf4:	0802b6cc 	.word	0x0802b6cc
 802adf8:	0802b58c 	.word	0x0802b58c
 802adfc:	20000764 	.word	0x20000764
 802ae00:	cccccccd 	.word	0xcccccccd

0802ae04 <CAN0_2_IRQHandler>:

void ServiceISRHandler(void)
{
 802ae04:	b580      	push	{r7, lr}
 802ae06:	b082      	sub	sp, #8
 802ae08:	af00      	add	r7, sp, #0
	CAN_NODE_MO_Receive(&CAN_INT_LMO_06_Config);
 802ae0a:	4820      	ldr	r0, [pc, #128]	; (802ae8c <CAN0_2_IRQHandler+0x88>)
 802ae0c:	f7ff f90e 	bl	802a02c <CAN_NODE_MO_Receive>

	if (CAN_INT_LMO_06_Config.mo_ptr->can_identifier == 0x100)
 802ae10:	4b1e      	ldr	r3, [pc, #120]	; (802ae8c <CAN0_2_IRQHandler+0x88>)
 802ae12:	681b      	ldr	r3, [r3, #0]
 802ae14:	685b      	ldr	r3, [r3, #4]
 802ae16:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802ae1a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802ae1e:	d113      	bne.n	802ae48 <CAN0_2_IRQHandler+0x44>
	{
		for (int i = 0; i < 8; i++)
 802ae20:	2300      	movs	r3, #0
 802ae22:	607b      	str	r3, [r7, #4]
 802ae24:	e00d      	b.n	802ae42 <CAN0_2_IRQHandler+0x3e>
		{
			ServCanRxData1[i] = CAN_INT_LMO_06_Config.mo_ptr->can_data_byte[i];
 802ae26:	4b19      	ldr	r3, [pc, #100]	; (802ae8c <CAN0_2_IRQHandler+0x88>)
 802ae28:	681a      	ldr	r2, [r3, #0]
 802ae2a:	687b      	ldr	r3, [r7, #4]
 802ae2c:	4413      	add	r3, r2
 802ae2e:	3310      	adds	r3, #16
 802ae30:	7819      	ldrb	r1, [r3, #0]
 802ae32:	4a17      	ldr	r2, [pc, #92]	; (802ae90 <CAN0_2_IRQHandler+0x8c>)
 802ae34:	687b      	ldr	r3, [r7, #4]
 802ae36:	4413      	add	r3, r2
 802ae38:	460a      	mov	r2, r1
 802ae3a:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 802ae3c:	687b      	ldr	r3, [r7, #4]
 802ae3e:	3301      	adds	r3, #1
 802ae40:	607b      	str	r3, [r7, #4]
 802ae42:	687b      	ldr	r3, [r7, #4]
 802ae44:	2b07      	cmp	r3, #7
 802ae46:	ddee      	ble.n	802ae26 <CAN0_2_IRQHandler+0x22>
		}
	}
	if (CAN_INT_LMO_06_Config.mo_ptr->can_identifier == 0x101)
 802ae48:	4b10      	ldr	r3, [pc, #64]	; (802ae8c <CAN0_2_IRQHandler+0x88>)
 802ae4a:	681b      	ldr	r3, [r3, #0]
 802ae4c:	685b      	ldr	r3, [r3, #4]
 802ae4e:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 802ae52:	f240 1201 	movw	r2, #257	; 0x101
 802ae56:	4293      	cmp	r3, r2
 802ae58:	d113      	bne.n	802ae82 <CAN0_2_IRQHandler+0x7e>
	{
		for (int i = 0; i < 8; i++)
 802ae5a:	2300      	movs	r3, #0
 802ae5c:	603b      	str	r3, [r7, #0]
 802ae5e:	e00d      	b.n	802ae7c <CAN0_2_IRQHandler+0x78>
		{
			ServCanRxData2[i] = CAN_INT_LMO_06_Config.mo_ptr->can_data_byte[i];
 802ae60:	4b0a      	ldr	r3, [pc, #40]	; (802ae8c <CAN0_2_IRQHandler+0x88>)
 802ae62:	681a      	ldr	r2, [r3, #0]
 802ae64:	683b      	ldr	r3, [r7, #0]
 802ae66:	4413      	add	r3, r2
 802ae68:	3310      	adds	r3, #16
 802ae6a:	7819      	ldrb	r1, [r3, #0]
 802ae6c:	4a09      	ldr	r2, [pc, #36]	; (802ae94 <CAN0_2_IRQHandler+0x90>)
 802ae6e:	683b      	ldr	r3, [r7, #0]
 802ae70:	4413      	add	r3, r2
 802ae72:	460a      	mov	r2, r1
 802ae74:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++)
 802ae76:	683b      	ldr	r3, [r7, #0]
 802ae78:	3301      	adds	r3, #1
 802ae7a:	603b      	str	r3, [r7, #0]
 802ae7c:	683b      	ldr	r3, [r7, #0]
 802ae7e:	2b07      	cmp	r3, #7
 802ae80:	ddee      	ble.n	802ae60 <CAN0_2_IRQHandler+0x5c>
		}
	}
}
 802ae82:	bf00      	nop
 802ae84:	3708      	adds	r7, #8
 802ae86:	46bd      	mov	sp, r7
 802ae88:	bd80      	pop	{r7, pc}
 802ae8a:	bf00      	nop
 802ae8c:	0802b6b4 	.word	0x0802b6b4
 802ae90:	20000fb4 	.word	0x20000fb4
 802ae94:	20000fbc 	.word	0x20000fbc

0802ae98 <main>:

int main(void)
{
 802ae98:	b580      	push	{r7, lr}
 802ae9a:	b082      	sub	sp, #8
 802ae9c:	af00      	add	r7, sp, #0
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */
 802ae9e:	f7ff fc23 	bl	802a6e8 <DAVE_Init>
 802aea2:	4603      	mov	r3, r0
 802aea4:	71fb      	strb	r3, [r7, #7]

  if (status != DAVE_STATUS_SUCCESS)
 802aea6:	79fb      	ldrb	r3, [r7, #7]
 802aea8:	2b00      	cmp	r3, #0
 802aeaa:	d000      	beq.n	802aeae <main+0x16>
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
 802aeac:	e7fe      	b.n	802aeac <main+0x14>
    }
  }

  // Init Internal Retain Memory Code:

  E_EEPROM_XMC4_STATUS_t e_status = E_EEPROM_XMC4_Init( &RETAIN );
 802aeae:	481a      	ldr	r0, [pc, #104]	; (802af18 <main+0x80>)
 802aeb0:	f7fa ffdc 	bl	8025e6c <E_EEPROM_XMC4_Init>
 802aeb4:	4603      	mov	r3, r0
 802aeb6:	71bb      	strb	r3, [r7, #6]
    switch ( e_status ) {
 802aeb8:	79bb      	ldrb	r3, [r7, #6]
 802aeba:	2b04      	cmp	r3, #4
 802aebc:	d012      	beq.n	802aee4 <main+0x4c>
 802aebe:	2b04      	cmp	r3, #4
 802aec0:	dc1c      	bgt.n	802aefc <main+0x64>
 802aec2:	2b00      	cmp	r3, #0
 802aec4:	d002      	beq.n	802aecc <main+0x34>
 802aec6:	2b01      	cmp	r3, #1
 802aec8:	d00c      	beq.n	802aee4 <main+0x4c>
 802aeca:	e017      	b.n	802aefc <main+0x64>
    	case  E_EEPROM_XMC4_STATUS_OK: {
    		  if ( E_EEPROM_XMC4_IsFlashEmpty())
 802aecc:	f7fb f8e4 	bl	8026098 <E_EEPROM_XMC4_IsFlashEmpty>
 802aed0:	4603      	mov	r3, r0
 802aed2:	2b00      	cmp	r3, #0
 802aed4:	d002      	beq.n	802aedc <main+0x44>
    		  {
    			  SaveAllPresets(&DefaultPresets);
 802aed6:	4811      	ldr	r0, [pc, #68]	; (802af1c <main+0x84>)
 802aed8:	f7fa ff65 	bl	8025da6 <SaveAllPresets>
    		  } //if
    		  ReadAllPresets( &Presets );
 802aedc:	4810      	ldr	r0, [pc, #64]	; (802af20 <main+0x88>)
 802aede:	f7fa ff55 	bl	8025d8c <ReadAllPresets>
    		break;
 802aee2:	e015      	b.n	802af10 <main+0x78>
    	case E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA:
    	case E_EEPROM_XMC4_STATUS_ERASE_ERROR:
    	{
    		/* add here the memory error handler */

    		Presets = DefaultPresets; // for example...
 802aee4:	4a0e      	ldr	r2, [pc, #56]	; (802af20 <main+0x88>)
 802aee6:	4b0d      	ldr	r3, [pc, #52]	; (802af1c <main+0x84>)
 802aee8:	4610      	mov	r0, r2
 802aeea:	4619      	mov	r1, r3
 802aeec:	234c      	movs	r3, #76	; 0x4c
 802aeee:	461a      	mov	r2, r3
 802aef0:	f000 f852 	bl	802af98 <memcpy>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
 802aef4:	480b      	ldr	r0, [pc, #44]	; (802af24 <main+0x8c>)
 802aef6:	f7ff fe5c 	bl	802abb2 <DIGITAL_IO_SetOutputHigh>
    		break;
 802aefa:	e009      	b.n	802af10 <main+0x78>
    	}

    	default :
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
 802aefc:	4809      	ldr	r0, [pc, #36]	; (802af24 <main+0x8c>)
 802aefe:	f7ff fe58 	bl	802abb2 <DIGITAL_IO_SetOutputHigh>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 802af02:	4809      	ldr	r0, [pc, #36]	; (802af28 <main+0x90>)
 802af04:	f7ff fe55 	bl	802abb2 <DIGITAL_IO_SetOutputHigh>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_Y);
 802af08:	4808      	ldr	r0, [pc, #32]	; (802af2c <main+0x94>)
 802af0a:	f7ff fe52 	bl	802abb2 <DIGITAL_IO_SetOutputHigh>
    		break;
 802af0e:	bf00      	nop

    	} //switch

  MainAlgInit();
 802af10:	f7f9 f856 	bl	8023fc0 <MainAlgInit>

  /* Placeholder for user application code. The while loop below can be replaced with user application code. */
  while(1U)
 802af14:	e7fe      	b.n	802af14 <main+0x7c>
 802af16:	bf00      	nop
 802af18:	20000fb0 	.word	0x20000fb0
 802af1c:	0802b084 	.word	0x0802b084
 802af20:	20000764 	.word	0x20000764
 802af24:	0802b280 	.word	0x0802b280
 802af28:	0802b258 	.word	0x0802b258
 802af2c:	0802b26c 	.word	0x0802b26c

0802af30 <__libc_init_array>:
 802af30:	b570      	push	{r4, r5, r6, lr}
 802af32:	4d0d      	ldr	r5, [pc, #52]	; (802af68 <__libc_init_array+0x38>)
 802af34:	4c0d      	ldr	r4, [pc, #52]	; (802af6c <__libc_init_array+0x3c>)
 802af36:	1b64      	subs	r4, r4, r5
 802af38:	10a4      	asrs	r4, r4, #2
 802af3a:	2600      	movs	r6, #0
 802af3c:	42a6      	cmp	r6, r4
 802af3e:	d109      	bne.n	802af54 <__libc_init_array+0x24>
 802af40:	4d0b      	ldr	r5, [pc, #44]	; (802af70 <__libc_init_array+0x40>)
 802af42:	4c0c      	ldr	r4, [pc, #48]	; (802af74 <__libc_init_array+0x44>)
 802af44:	f7fd fda8 	bl	8028a98 <_init>
 802af48:	1b64      	subs	r4, r4, r5
 802af4a:	10a4      	asrs	r4, r4, #2
 802af4c:	2600      	movs	r6, #0
 802af4e:	42a6      	cmp	r6, r4
 802af50:	d105      	bne.n	802af5e <__libc_init_array+0x2e>
 802af52:	bd70      	pop	{r4, r5, r6, pc}
 802af54:	f855 3b04 	ldr.w	r3, [r5], #4
 802af58:	4798      	blx	r3
 802af5a:	3601      	adds	r6, #1
 802af5c:	e7ee      	b.n	802af3c <__libc_init_array+0xc>
 802af5e:	f855 3b04 	ldr.w	r3, [r5], #4
 802af62:	4798      	blx	r3
 802af64:	3601      	adds	r6, #1
 802af66:	e7f2      	b.n	802af4e <__libc_init_array+0x1e>
 802af68:	200005f8 	.word	0x200005f8
 802af6c:	200005f8 	.word	0x200005f8
 802af70:	200005f8 	.word	0x200005f8
 802af74:	200005f8 	.word	0x200005f8

0802af78 <memcmp>:
 802af78:	b510      	push	{r4, lr}
 802af7a:	3901      	subs	r1, #1
 802af7c:	4402      	add	r2, r0
 802af7e:	4290      	cmp	r0, r2
 802af80:	d101      	bne.n	802af86 <memcmp+0xe>
 802af82:	2000      	movs	r0, #0
 802af84:	e005      	b.n	802af92 <memcmp+0x1a>
 802af86:	7803      	ldrb	r3, [r0, #0]
 802af88:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802af8c:	42a3      	cmp	r3, r4
 802af8e:	d001      	beq.n	802af94 <memcmp+0x1c>
 802af90:	1b18      	subs	r0, r3, r4
 802af92:	bd10      	pop	{r4, pc}
 802af94:	3001      	adds	r0, #1
 802af96:	e7f2      	b.n	802af7e <memcmp+0x6>

0802af98 <memcpy>:
 802af98:	440a      	add	r2, r1
 802af9a:	4291      	cmp	r1, r2
 802af9c:	f100 33ff 	add.w	r3, r0, #4294967295
 802afa0:	d100      	bne.n	802afa4 <memcpy+0xc>
 802afa2:	4770      	bx	lr
 802afa4:	b510      	push	{r4, lr}
 802afa6:	f811 4b01 	ldrb.w	r4, [r1], #1
 802afaa:	f803 4f01 	strb.w	r4, [r3, #1]!
 802afae:	4291      	cmp	r1, r2
 802afb0:	d1f9      	bne.n	802afa6 <memcpy+0xe>
 802afb2:	bd10      	pop	{r4, pc}
 802afb4:	0000      	movs	r0, r0
	...

0802afb8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer>:
 802afb8:	f85f f000 	ldr.w	pc, [pc]	; 802afbc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer+0x4>
 802afbc:	10000c7d 	.word	0x10000c7d

0802afc0 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>:
 802afc0:	f85f f000 	ldr.w	pc, [pc]	; 802afc4 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer+0x4>
 802afc4:	10000f3d 	.word	0x10000f3d

0802afc8 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer>:
 802afc8:	f85f f000 	ldr.w	pc, [pc]	; 802afcc <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer+0x4>
 802afcc:	10001001 	.word	0x10001001

0802afd0 <__Motor0_BLDC_SCALAR_MSM_veneer>:
 802afd0:	f85f f000 	ldr.w	pc, [pc]	; 802afd4 <__Motor0_BLDC_SCALAR_MSM_veneer+0x4>
 802afd4:	10000ec9 	.word	0x10000ec9

0802afd8 <Motor0_BLDC_SCALAR_CCU8ExtStartEventConf>:
 802afd8:	00000107                                ....

0802afdc <Motor0_BLDC_SCALAR_CCU8ExtStopEventConf>:
 802afdc:	00000207                                ....

0802afe0 <Motor0_BLDC_SCALAR_CCU8CompareConf>:
 802afe0:	02000001 00000003 00000004 00000000     ................

0802aff0 <Motor0_BLDC_SCALAR_GPIO_PhU_High_Config>:
 802aff0:	00000098 00010000 00000000              ............

0802affc <Motor0_BLDC_SCALAR_GPIO_PhU_Low_Config>:
 802affc:	00000098 00010000 00000000              ............

0802b008 <Motor0_BLDC_SCALAR_GPIO_PhV_High_Config>:
 802b008:	00000098 00010000 00000000              ............

0802b014 <Motor0_BLDC_SCALAR_GPIO_PhV_Low_Config>:
 802b014:	00000098 00010000 00000000              ............

0802b020 <Motor0_BLDC_SCALAR_GPIO_PhW_High_Config>:
 802b020:	00000098 00010000 00000000              ............

0802b02c <Motor0_BLDC_SCALAR_GPIO_PhW_Low_Config>:
 802b02c:	00000098 00010000 00000000              ............

0802b038 <Motor0_BLDC_SCALAR_GPIO_Hall_Config>:
 802b038:	00000000 00010000 00000000              ............

0802b044 <Motor0_BLDC_SCALAR_GPIO_Inverter_Config>:
 802b044:	00000080 00010000 00000001              ............

0802b050 <Motor0_BLDC_SCALAR_POSIF_HALL_Config>:
 802b050:	00000010                                ....

0802b054 <Motor0_BLDC_SCALAR_POSIF_GLOBAL_Config>:
 802b054:	50000000                                ...P

0802b058 <Motor0_BLDC_SCALAR_POSIF_MCM_Config>:
 802b058:	00000000                                ....

0802b05c <Motor0_BLDC_SCALAR_VADC_GLOBAL_config>:
	...

0802b074 <Motor0_BLDC_SCALAR_VADC_GROUP_class0>:
 802b074:	00000001                                ....

0802b078 <Motor0_BLDC_SCALAR_VADC_QUEUE_3_cfg>:
 802b078:	00000000 00004800 00000004              .....H......

0802b084 <DefaultPresets>:
 802b084:	ffffffff 00000001 00000003 00000001     ................
 802b094:	00010005 00100245 00000000 000000c8     ....E...........
 802b0a4:	00000bb8 00000000 000007d0 000000c8     ................
 802b0b4:	000007d0 00000320 000000a0 00000320     .... ....... ...
 802b0c4:	00000320 000000a0 00000000               ...........

0802b0d0 <e_eeprom_xmc4_fce>:
 802b0d0:	50020020 00000700 00000000               ..P........

0802b0dc <g_xmc_vadc_group_array>:
 802b0dc:	40004400 40004800 40004c00 40005000     .D.@.H.@.L.@.P.@

0802b0ec <CLUTCH_PWM_timer_handle>:
 802b0ec:	00000000 00000006                       ........

0802b0f4 <CLUTCH_PWM_event0_config>:
 802b0f4:	00010000                                ....

0802b0f8 <CLUTCH_PWM_event1_config>:
 802b0f8:	00010000                                ....

0802b0fc <CLUTCH_PWM_event2_config>:
 802b0fc:	00010000                                ....

0802b100 <CLUTCH_PWM_config_handle>:
 802b100:	07520000 010103a9 00000000 00000100     ..R.............
 802b110:	00000001 0802b0f4 0802b0f8 0802b0fc     ................
	...
 802b12c:	01000000 00000000 10000000 0802b0ec     ................
	...
 802b14c:	200002b4                                ... 

0802b150 <BUZZ_PWM_timer_handle>:
 802b150:	00000000 00000006                       ........

0802b158 <BUZZ_PWM_event0_config>:
 802b158:	00010000                                ....

0802b15c <BUZZ_PWM_event1_config>:
 802b15c:	00010000                                ....

0802b160 <BUZZ_PWM_event2_config>:
 802b160:	00010000                                ....

0802b164 <BUZZ_PWM_config_handle>:
 802b164:	07520000 010103a9 00000000 03030200     ..R.............
 802b174:	00000002 0802b158 0802b15c 0802b160     ....X...\...`...
	...
 802b190:	01000000 00000000 20000000 0802b150     ........... P...
	...
 802b1b0:	200002b4                                ... 

0802b1b4 <CAN1_RX_INT>:
 802b1b4:	01003f52                                R?..

0802b1b8 <CLUTCH_INT_CMP>:
 802b1b8:	01003f38                                8?..

0802b1bc <CLUTCH_INT_OVF>:
 802b1bc:	01003f39                                9?..

0802b1c0 <CAN_2_RESET_INT>:
 802b1c0:	01003f4d                                M?..

0802b1c4 <CAN_1_TRAP_SENSOR_INT>:
 802b1c4:	01003f4f                                O?..

0802b1c8 <SERV_INT>:
 802b1c8:	01003f4e                                N?..

0802b1cc <CAN_1_STOP_BUT_INT>:
 802b1cc:	01003f51                                Q?..

0802b1d0 <CAN_NODE_ALLERT>:
 802b1d0:	01003f4c                                L?..

0802b1d4 <BUZZ_INT_OVF>:
 802b1d4:	01003f3a                                :?..

0802b1d8 <BUZZ_INT_CMP>:
 802b1d8:	01003f3b                                ;?..

0802b1dc <group_init_handle0>:
	...

0802b1f0 <group_init_handle1>:
	...

0802b204 <group_init_handle2>:
	...

0802b218 <group_init_handle3>:
	...

0802b22c <global_config>:
 802b22c:	00000000 00000003 00000000 00000000     ................
	...

0802b244 <SERVICE_BUT>:
 802b244:	48028f00 00000000 00000000 00000000     ...H............
 802b254:	00000002                                ....

0802b258 <STATUS_LED_G>:
 802b258:	48028300 00000080 00010000 00000004     ...H............
 802b268:	00000009                                ....

0802b26c <STATUS_LED_Y>:
 802b26c:	48028300 00000080 00010000 00000004     ...H............
 802b27c:	0000000a                                ....

0802b280 <STATUS_LED_R>:
 802b280:	48028300 00000080 00010000 00000004     ...H............
 802b290:	0000000b                                ....

0802b294 <TRANS_OUT>:
 802b294:	48028100 00000080 00010000 00000004     ...H............
 802b2a4:	0000000f                                ....

0802b2a8 <GROUP_IN_EN>:
 802b2a8:	48028200 00000080 00010000 00000000     ...H............
 802b2b8:	00000000                                ....

0802b2bc <LED_SW_NRES>:
 802b2bc:	48028000 00000080 00010000 00000004     ...H............
 802b2cc:	0000000e                                ....

0802b2d0 <LS_SW_1>:
 802b2d0:	48028000 00000080 00010000 00000004     ...H............
 802b2e0:	00000000                                ....

0802b2e4 <LS_SW_2>:
 802b2e4:	48028000 00000080 00010000 00000004     ...H............
 802b2f4:	0000000a                                ....

0802b2f8 <LS_SW_3>:
 802b2f8:	48028000 00000080 00010000 00000004     ...H............
 802b308:	00000009                                ....

0802b30c <LS_SW_4>:
 802b30c:	48028300 00000080 00010000 00000004     ...H............
 802b31c:	00000002                                ....

0802b320 <HS_SW_1>:
 802b320:	48028100 00000080 00010000 00000004     ...H............
 802b330:	0000000a                                ....

0802b334 <HS_SW_2>:
 802b334:	48028100 00000080 00010000 00000004     ...H............
 802b344:	0000000b                                ....

0802b348 <HS_SW_3>:
 802b348:	48028100 00000080 00010000 00000004     ...H............
 802b358:	0000000c                                ....

0802b35c <HS_SW_4>:
 802b35c:	48028100 00000080 00010000 00000004     ...H............
 802b36c:	0000000d                                ....

0802b370 <HS_SW_5>:
 802b370:	48028100 00000080 00010000 00000004     ...H............
 802b380:	0000000e                                ....

0802b384 <HS_SW_6>:
 802b384:	48028600 00000080 00010000 00000004     ...H............
 802b394:	00000000                                ....

0802b398 <HS_SW_7>:
 802b398:	48028600 00000080 00010000 00000004     ...H............
 802b3a8:	00000001                                ....

0802b3ac <HS_SW_8>:
 802b3ac:	48028600 00000080 00010000 00000004     ...H............
 802b3bc:	00000002                                ....

0802b3c0 <LS_SW_NRES>:
 802b3c0:	48028000 00000080 00010000 00000004     ...H............
 802b3d0:	0000000f                                ....

0802b3d4 <DI_PNP_EN>:
 802b3d4:	48028300 00000080 00010000 00000004     ...H............
 802b3e4:	00000008                                ....

0802b3e8 <DI_NPN_EN>:
 802b3e8:	48028300 00000080 00010000 00000004     ...H............
 802b3f8:	00000007                                ....

0802b3fc <LED_POWER_EN1>:
 802b3fc:	48028000 00000080 00010000 00000004     ...H............
 802b40c:	00000006                                ....

0802b410 <LED_POWER_EN2>:
 802b410:	48028000 00000080 00010000 00000004     ...H............
 802b420:	00000007                                ....

0802b424 <POWER_SWITCH>:
 802b424:	48028100 00000080 00010000 00000004     ...H............
 802b434:	00000006                                ....

0802b438 <LED_SW_1>:
 802b438:	48028400 00000080 00010000 00000004     ...H............
 802b448:	00000000                                ....

0802b44c <LED_SW_2>:
 802b44c:	48028400 00000080 00010000 00000004     ...H............
 802b45c:	00000001                                ....

0802b460 <LED_SW_3>:
 802b460:	48028400 00000080 00010000 00000004     ...H............
 802b470:	00000002                                ....

0802b474 <LED_SW_4>:
 802b474:	48028400 00000080 00010000 00000004     ...H............
 802b484:	00000003                                ....

0802b488 <LED_SW_5>:
 802b488:	48028400 00000080 00010000 00000004     ...H............
 802b498:	00000004                                ....

0802b49c <LED_SW_6>:
 802b49c:	48028400 00000080 00010000 00000004     ...H............
 802b4ac:	00000005                                ....

0802b4b0 <LED_SW_7>:
 802b4b0:	48028400 00000080 00010000 00000004     ...H............
 802b4c0:	00000006                                ....

0802b4c4 <LED_SW_8>:
 802b4c4:	48028400 00000080 00010000 00000004     ...H............
 802b4d4:	00000007                                ....

0802b4d8 <MOTOR_FAULT>:
 802b4d8:	48028f00 00000000 00000000 00000000     ...H............
 802b4e8:	0000000e 01040278 00010000 00000000     ....x...........
 802b4f8:	00010000 01010101                       ........

0802b500 <CAN_EXT_gpio_out>:
 802b500:	48028100 00000009                       ...H....

0802b508 <CAN_EXT_gpio_out_config>:
 802b508:	00000090 00000001 00000002              ............

0802b514 <CAN_EXT_gpio_in>:
 802b514:	48028100 00000008                       ...H....

0802b51c <CAN_EXT_gpio_in_config>:
	...

0802b528 <CAN_EXT_BitTimeConfig>:
 802b528:	07270e00 0001e848 00011f40              ..'.H...@...

0802b534 <CAN_EXT_sr>:
 802b534:	00000000                                ....

0802b538 <CAN_EXT_LMO_01_Config>:
 802b538:	20000320 00060021 00000001               .. !.......

0802b544 <CAN_EXT_LMO_02_Config>:
 802b544:	20000340 00000007 00000000              @.. ........

0802b550 <CAN_EXT_LMO_03_Config>:
 802b550:	20000360 00000008 00000000              `.. ........

0802b55c <CAN_EXT_LMO_04_Config>:
 802b55c:	20000380 00050020 00000001              ...  .......

0802b568 <CAN_EXT_LMO_05_Config>:
 802b568:	200003a0 0003001f 00000001              ... ........

0802b574 <CAN_EXT_LMO_06_Config>:
 802b574:	200003c0 00000005 00000000              ... ........

0802b580 <CAN_EXT_LMO_07_Config>:
 802b580:	200003e0 00000006 00000000              ... ........

0802b58c <CAN_EXT_LMO_08_Config>:
 802b58c:	20000400 0001001e 00000001              ... ........

0802b598 <CAN_EXT>:
 802b598:	200002c4 48014400 0802b528 0802b538     ... .D.H(...8...
 802b5a8:	0802b544 0802b550 0802b55c 0802b568     D...P...\...h...
 802b5b8:	0802b574 0802b580 0802b58c 00000000     t...............
	...
 802b624:	0802b534 0802b500 0802b508 0802b514     4...............
 802b634:	0802b51c 00080200 00010100              ............

0802b640 <CAN_INT_gpio_out>:
 802b640:	48028100 00000004                       ...H....

0802b648 <CAN_INT_gpio_out_config>:
 802b648:	00000090 00000001 00000002              ............

0802b654 <CAN_INT_gpio_in>:
 802b654:	48028100 00000005                       ...H....

0802b65c <CAN_INT_gpio_in_config>:
	...

0802b668 <CAN_INT_BitTimeConfig>:
 802b668:	07270e00 0001e848 00011f40              ..'.H...@...

0802b674 <CAN_INT_sr>:
 802b674:	00000000                                ....

0802b678 <CAN_INT_LMO_01_Config>:
 802b678:	20000420 0000003c 00000000               .. <.......

0802b684 <CAN_INT_LMO_02_Config>:
 802b684:	20000440 00000009 00000000              @.. ........

0802b690 <CAN_INT_LMO_03_Config>:
 802b690:	20000460 00000024 00000000              `.. $.......

0802b69c <CAN_INT_LMO_04_Config>:
 802b69c:	20000480 00000025 00000000              ... %.......

0802b6a8 <CAN_INT_LMO_05_Config>:
 802b6a8:	200004a0 00000026 00000000              ... &.......

0802b6b4 <CAN_INT_LMO_06_Config>:
 802b6b4:	200004c0 00020022 00000001              ... ".......

0802b6c0 <CAN_INT_LMO_07_Config>:
 802b6c0:	200004e0 00000027 00000000              ... '.......

0802b6cc <CAN_INT_LMO_08_Config>:
 802b6cc:	20000500 00010023 00000001              ... #.......

0802b6d8 <CAN_INT>:
 802b6d8:	200002c4 48014200 0802b668 0802b678     ... .B.Hh...x...
 802b6e8:	0802b684 0802b690 0802b69c 0802b6a8     ................
 802b6f8:	0802b6b4 0802b6c0 0802b6cc 00000000     ................
	...
 802b764:	0802b674 0802b640 0802b648 0802b654     t...@...H...T...
 802b774:	0802b65c 00080000 00000000              \...........

0802b780 <GROUP_IN_pin_list>:
 802b780:	48028500 00000000 48028500 00000001     ...H.......H....
 802b790:	48028500 00000002 48028500 00000003     ...H.......H....

0802b7a0 <GROUP_OUT_pin_list>:
 802b7a0:	48028500 00000004 48028500 00000005     ...H.......H....
 802b7b0:	48028500 00000006 48028500 00000007     ...H.......H....

0802b7c0 <DI_PNP_pin_list>:
 802b7c0:	48028e00 0000000f 48028e00 0000000e     ...H.......H....
 802b7d0:	48028e00 0000000d 48028e00 0000000c     ...H.......H....

0802b7e0 <DI_NPN_pin_list>:
 802b7e0:	48028f00 00000007 48028f00 00000006     ...H.......H....
 802b7f0:	48028f00 00000005 48028f00 00000004     ...H.......H....

0802b800 <RES_IN1>:
 802b800:	00000000 200010f9 48028f00 00000003     ....... ...H....

0802b810 <RES_IN2>:
 802b810:	00000000 200010fa 48028e00 00000007     ....... ...H....

0802b820 <DC_INPUT>:
 802b820:	00000000 200010fb 48028f00 0000000f     ....... ...H....

0802b830 <global_iclass_config>:
 802b830:	00000000                                ....

0802b834 <backgnd_rs_intr_handle>:
 802b834:	00000010 0000003f 00000000              ....?.......

0802b840 <backgnd_config>:
 802b840:	00000005 00000000 00000008 5f444d43     ............CMD_
 802b850:	544f4f42 45534552 30305f54              BOOTRESET_00

Disassembly of section .ram_code:

10000800 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect>:
/*
 * This function check the actual MCM register and modulate high side PWM output and
 * complementary PWM output for same leg. And keep other low side output is either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect(uint16_t mcm_val)
{
10000800:	b580      	push	{r7, lr}
10000802:	b084      	sub	sp, #16
10000804:	af00      	add	r7, sp, #0
10000806:	4603      	mov	r3, r0
10000808:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1000080a:	2300      	movs	r3, #0
1000080c:	73fb      	strb	r3, [r7, #15]
1000080e:	e040      	b.n	10000892 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x92>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000810:	7bfb      	ldrb	r3, [r7, #15]
10000812:	4a24      	ldr	r2, [pc, #144]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000814:	3308      	adds	r3, #8
10000816:	005b      	lsls	r3, r3, #1
10000818:	4413      	add	r3, r2
1000081a:	885a      	ldrh	r2, [r3, #2]
1000081c:	7bfb      	ldrb	r3, [r7, #15]
1000081e:	4921      	ldr	r1, [pc, #132]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000820:	3308      	adds	r3, #8
10000822:	005b      	lsls	r3, r3, #1
10000824:	440b      	add	r3, r1
10000826:	8859      	ldrh	r1, [r3, #2]
10000828:	88fb      	ldrh	r3, [r7, #6]
1000082a:	400b      	ands	r3, r1
1000082c:	b29b      	uxth	r3, r3
1000082e:	429a      	cmp	r2, r3
10000830:	d10d      	bne.n	1000084e <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x4e>
      /*
       * Dead Time Enable for Channel 1
       * Dead Time Enable for CC8yST1
       * Dead Time Enable for inverted CC8yST1
       */
      Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000832:	7bfb      	ldrb	r3, [r7, #15]
10000834:	4a1c      	ldr	r2, [pc, #112]	; (100008a8 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa8>)
10000836:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1000083a:	210d      	movs	r1, #13
1000083c:	4618      	mov	r0, r3
1000083e:	f000 fc8f 	bl	10001160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>

      /*Set the compare flag to set the inverse duty*/
       Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
10000842:	7bfb      	ldrb	r3, [r7, #15]
10000844:	4a17      	ldr	r2, [pc, #92]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000846:	4413      	add	r3, r2
10000848:	2203      	movs	r2, #3
1000084a:	739a      	strb	r2, [r3, #14]
1000084c:	e01e      	b.n	1000088c <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x8c>
    } /* End of high side switch is ON */

    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1000084e:	7bfb      	ldrb	r3, [r7, #15]
10000850:	4a14      	ldr	r2, [pc, #80]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000852:	3308      	adds	r3, #8
10000854:	005b      	lsls	r3, r3, #1
10000856:	4413      	add	r3, r2
10000858:	885b      	ldrh	r3, [r3, #2]
1000085a:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
1000085c:	88f9      	ldrh	r1, [r7, #6]
1000085e:	7bfb      	ldrb	r3, [r7, #15]
10000860:	4810      	ldr	r0, [pc, #64]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000862:	3308      	adds	r3, #8
10000864:	005b      	lsls	r3, r3, #1
10000866:	4403      	add	r3, r0
10000868:	885b      	ldrh	r3, [r3, #2]
1000086a:	005b      	lsls	r3, r3, #1
1000086c:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1000086e:	429a      	cmp	r2, r3
10000870:	d10c      	bne.n	1000088c <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x8c>
    {
      /* Disable dead time */
      Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000872:	7bfb      	ldrb	r3, [r7, #15]
10000874:	4a0c      	ldr	r2, [pc, #48]	; (100008a8 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa8>)
10000876:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1000087a:	210d      	movs	r1, #13
1000087c:	4618      	mov	r0, r3
1000087e:	f000 fc8f 	bl	100011a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>

      /*Set the compare flag to switch on completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
10000882:	7bfb      	ldrb	r3, [r7, #15]
10000884:	4a07      	ldr	r2, [pc, #28]	; (100008a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
10000886:	4413      	add	r3, r2
10000888:	2201      	movs	r2, #1
1000088a:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1000088c:	7bfb      	ldrb	r3, [r7, #15]
1000088e:	3301      	adds	r3, #1
10000890:	73fb      	strb	r3, [r7, #15]
10000892:	7bfb      	ldrb	r3, [r7, #15]
10000894:	2b02      	cmp	r3, #2
10000896:	d9bb      	bls.n	10000810 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x10>
    {
      /*do nothing*/
    }
  }

}
10000898:	bf00      	nop
1000089a:	bf00      	nop
1000089c:	3710      	adds	r7, #16
1000089e:	46bd      	mov	sp, r7
100008a0:	bd80      	pop	{r7, pc}
100008a2:	bf00      	nop
100008a4:	200000d0 	.word	0x200000d0
100008a8:	20000068 	.word	0x20000068

100008ac <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod>:
/*
 * This function check the actual MCM register and modulate high
 * side PWM output and keep low side output either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod(uint16_t mcm_val)
{
100008ac:	b480      	push	{r7}
100008ae:	b085      	sub	sp, #20
100008b0:	af00      	add	r7, sp, #0
100008b2:	4603      	mov	r3, r0
100008b4:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
100008b6:	2300      	movs	r3, #0
100008b8:	73fb      	strb	r3, [r7, #15]
100008ba:	e030      	b.n	1000091e <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x72>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
100008bc:	7bfb      	ldrb	r3, [r7, #15]
100008be:	4a1d      	ldr	r2, [pc, #116]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008c0:	3308      	adds	r3, #8
100008c2:	005b      	lsls	r3, r3, #1
100008c4:	4413      	add	r3, r2
100008c6:	885a      	ldrh	r2, [r3, #2]
100008c8:	7bfb      	ldrb	r3, [r7, #15]
100008ca:	491a      	ldr	r1, [pc, #104]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008cc:	3308      	adds	r3, #8
100008ce:	005b      	lsls	r3, r3, #1
100008d0:	440b      	add	r3, r1
100008d2:	8859      	ldrh	r1, [r3, #2]
100008d4:	88fb      	ldrh	r3, [r7, #6]
100008d6:	400b      	ands	r3, r1
100008d8:	b29b      	uxth	r3, r3
100008da:	429a      	cmp	r2, r3
100008dc:	d105      	bne.n	100008ea <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x3e>
    {
      /*Set the compare flag to set the inverse duty*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
100008de:	7bfb      	ldrb	r3, [r7, #15]
100008e0:	4a14      	ldr	r2, [pc, #80]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008e2:	4413      	add	r3, r2
100008e4:	2203      	movs	r2, #3
100008e6:	739a      	strb	r2, [r3, #14]
100008e8:	e016      	b.n	10000918 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x6c>

    } /* End of high side switch is ON */
    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
100008ea:	7bfb      	ldrb	r3, [r7, #15]
100008ec:	4a11      	ldr	r2, [pc, #68]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008ee:	3308      	adds	r3, #8
100008f0:	005b      	lsls	r3, r3, #1
100008f2:	4413      	add	r3, r2
100008f4:	885b      	ldrh	r3, [r3, #2]
100008f6:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
100008f8:	88f9      	ldrh	r1, [r7, #6]
100008fa:	7bfb      	ldrb	r3, [r7, #15]
100008fc:	480d      	ldr	r0, [pc, #52]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
100008fe:	3308      	adds	r3, #8
10000900:	005b      	lsls	r3, r3, #1
10000902:	4403      	add	r3, r0
10000904:	885b      	ldrh	r3, [r3, #2]
10000906:	005b      	lsls	r3, r3, #1
10000908:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1000090a:	429a      	cmp	r2, r3
1000090c:	d104      	bne.n	10000918 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x6c>
    {
      /*Set the compare flag to switch on completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
1000090e:	7bfb      	ldrb	r3, [r7, #15]
10000910:	4a08      	ldr	r2, [pc, #32]	; (10000934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
10000912:	4413      	add	r3, r2
10000914:	2201      	movs	r2, #1
10000916:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000918:	7bfb      	ldrb	r3, [r7, #15]
1000091a:	3301      	adds	r3, #1
1000091c:	73fb      	strb	r3, [r7, #15]
1000091e:	7bfb      	ldrb	r3, [r7, #15]
10000920:	2b02      	cmp	r3, #2
10000922:	d9cb      	bls.n	100008bc <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x10>
    else
    {
      /*do nothing*/
    }
  }
}
10000924:	bf00      	nop
10000926:	bf00      	nop
10000928:	3714      	adds	r7, #20
1000092a:	46bd      	mov	sp, r7
1000092c:	f85d 7b04 	ldr.w	r7, [sp], #4
10000930:	4770      	bx	lr
10000932:	bf00      	nop
10000934:	200000d0 	.word	0x200000d0

10000938 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod>:
/*
 * This function check the actual MCM register and modulate low side PWM output
 * and keep high side output either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod(uint16_t mcm_val)
{
10000938:	b480      	push	{r7}
1000093a:	b085      	sub	sp, #20
1000093c:	af00      	add	r7, sp, #0
1000093e:	4603      	mov	r3, r0
10000940:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000942:	2300      	movs	r3, #0
10000944:	73fb      	strb	r3, [r7, #15]
10000946:	e030      	b.n	100009aa <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x72>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000948:	7bfb      	ldrb	r3, [r7, #15]
1000094a:	4a1d      	ldr	r2, [pc, #116]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000094c:	3308      	adds	r3, #8
1000094e:	005b      	lsls	r3, r3, #1
10000950:	4413      	add	r3, r2
10000952:	885a      	ldrh	r2, [r3, #2]
10000954:	7bfb      	ldrb	r3, [r7, #15]
10000956:	491a      	ldr	r1, [pc, #104]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
10000958:	3308      	adds	r3, #8
1000095a:	005b      	lsls	r3, r3, #1
1000095c:	440b      	add	r3, r1
1000095e:	8859      	ldrh	r1, [r3, #2]
10000960:	88fb      	ldrh	r3, [r7, #6]
10000962:	400b      	ands	r3, r1
10000964:	b29b      	uxth	r3, r3
10000966:	429a      	cmp	r2, r3
10000968:	d105      	bne.n	10000976 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x3e>
    {
      /*Set the compare flag to switch off completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
1000096a:	7bfb      	ldrb	r3, [r7, #15]
1000096c:	4a14      	ldr	r2, [pc, #80]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000096e:	4413      	add	r3, r2
10000970:	2200      	movs	r2, #0
10000972:	739a      	strb	r2, [r3, #14]
10000974:	e016      	b.n	100009a4 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x6c>

    } /* End of high side switch is ON */
    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000976:	7bfb      	ldrb	r3, [r7, #15]
10000978:	4a11      	ldr	r2, [pc, #68]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000097a:	3308      	adds	r3, #8
1000097c:	005b      	lsls	r3, r3, #1
1000097e:	4413      	add	r3, r2
10000980:	885b      	ldrh	r3, [r3, #2]
10000982:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
10000984:	88f9      	ldrh	r1, [r7, #6]
10000986:	7bfb      	ldrb	r3, [r7, #15]
10000988:	480d      	ldr	r0, [pc, #52]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000098a:	3308      	adds	r3, #8
1000098c:	005b      	lsls	r3, r3, #1
1000098e:	4403      	add	r3, r0
10000990:	885b      	ldrh	r3, [r3, #2]
10000992:	005b      	lsls	r3, r3, #1
10000994:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000996:	429a      	cmp	r2, r3
10000998:	d104      	bne.n	100009a4 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x6c>
    {
     /*Set the compare flag to set the duty*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
1000099a:	7bfb      	ldrb	r3, [r7, #15]
1000099c:	4a08      	ldr	r2, [pc, #32]	; (100009c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1000099e:	4413      	add	r3, r2
100009a0:	2202      	movs	r2, #2
100009a2:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
100009a4:	7bfb      	ldrb	r3, [r7, #15]
100009a6:	3301      	adds	r3, #1
100009a8:	73fb      	strb	r3, [r7, #15]
100009aa:	7bfb      	ldrb	r3, [r7, #15]
100009ac:	2b02      	cmp	r3, #2
100009ae:	d9cb      	bls.n	10000948 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x10>
    {
      /*do nothing*/
    }
  }

}
100009b0:	bf00      	nop
100009b2:	bf00      	nop
100009b4:	3714      	adds	r7, #20
100009b6:	46bd      	mov	sp, r7
100009b8:	f85d 7b04 	ldr.w	r7, [sp], #4
100009bc:	4770      	bx	lr
100009be:	bf00      	nop
100009c0:	200000d0 	.word	0x200000d0

100009c4 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect>:
 * This function check the non conducting phase and modulate high side PWM output and complementary
 * PWM output for same leg based on the MCMS shadow register.
 * And keep other low side output is either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect(uint16_t mcm_val, uint16_t mcms_val)
{
100009c4:	b580      	push	{r7, lr}
100009c6:	b084      	sub	sp, #16
100009c8:	af00      	add	r7, sp, #0
100009ca:	4603      	mov	r3, r0
100009cc:	460a      	mov	r2, r1
100009ce:	80fb      	strh	r3, [r7, #6]
100009d0:	4613      	mov	r3, r2
100009d2:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
100009d4:	2300      	movs	r3, #0
100009d6:	73fb      	strb	r3, [r7, #15]
100009d8:	e038      	b.n	10000a4c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x88>
  {
    /* if phase is not conducting in current cycle */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
100009da:	7bfb      	ldrb	r3, [r7, #15]
100009dc:	4a1f      	ldr	r2, [pc, #124]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
100009de:	330c      	adds	r3, #12
100009e0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
100009e4:	88fb      	ldrh	r3, [r7, #6]
100009e6:	4013      	ands	r3, r2
100009e8:	b29b      	uxth	r3, r3
100009ea:	2b00      	cmp	r3, #0
100009ec:	d12b      	bne.n	10000a46 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x82>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
100009ee:	7bfb      	ldrb	r3, [r7, #15]
100009f0:	4a1a      	ldr	r2, [pc, #104]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
100009f2:	3308      	adds	r3, #8
100009f4:	005b      	lsls	r3, r3, #1
100009f6:	4413      	add	r3, r2
100009f8:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
100009fa:	7bfb      	ldrb	r3, [r7, #15]
100009fc:	4917      	ldr	r1, [pc, #92]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
100009fe:	3308      	adds	r3, #8
10000a00:	005b      	lsls	r3, r3, #1
10000a02:	440b      	add	r3, r1
10000a04:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000a06:	88bb      	ldrh	r3, [r7, #4]
10000a08:	400b      	ands	r3, r1
10000a0a:	b29b      	uxth	r3, r3
10000a0c:	429a      	cmp	r2, r3
10000a0e:	d10d      	bne.n	10000a2c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x68>
        /*
         * Dead Time Enable for Channel 1
         * Dead Time Enable for CC8yST1
         * Dead Time Enable for inverted CC8yST1
         */
        Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000a10:	7bfb      	ldrb	r3, [r7, #15]
10000a12:	4a13      	ldr	r2, [pc, #76]	; (10000a60 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x9c>)
10000a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
10000a18:	210d      	movs	r1, #13
10000a1a:	4618      	mov	r0, r3
10000a1c:	f000 fba0 	bl	10001160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>

        /*Set the compare flag to set the inverse duty*/
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
10000a20:	7bfb      	ldrb	r3, [r7, #15]
10000a22:	4a0e      	ldr	r2, [pc, #56]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
10000a24:	4413      	add	r3, r2
10000a26:	2203      	movs	r2, #3
10000a28:	739a      	strb	r2, [r3, #14]
10000a2a:	e00c      	b.n	10000a46 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x82>
      }
      /* if low side switch is ON*/
      else
      {
        /* Disable dead time */
        Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
10000a2c:	7bfb      	ldrb	r3, [r7, #15]
10000a2e:	4a0c      	ldr	r2, [pc, #48]	; (10000a60 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x9c>)
10000a30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
10000a34:	210d      	movs	r1, #13
10000a36:	4618      	mov	r0, r3
10000a38:	f000 fbb2 	bl	100011a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>

        /*Set the compare flag to switch on completely*/
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
10000a3c:	7bfb      	ldrb	r3, [r7, #15]
10000a3e:	4a07      	ldr	r2, [pc, #28]	; (10000a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
10000a40:	4413      	add	r3, r2
10000a42:	2201      	movs	r2, #1
10000a44:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000a46:	7bfb      	ldrb	r3, [r7, #15]
10000a48:	3301      	adds	r3, #1
10000a4a:	73fb      	strb	r3, [r7, #15]
10000a4c:	7bfb      	ldrb	r3, [r7, #15]
10000a4e:	2b02      	cmp	r3, #2
10000a50:	d9c3      	bls.n	100009da <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x16>
      }
    }
  }
}
10000a52:	bf00      	nop
10000a54:	bf00      	nop
10000a56:	3710      	adds	r7, #16
10000a58:	46bd      	mov	sp, r7
10000a5a:	bd80      	pop	{r7, pc}
10000a5c:	200000d0 	.word	0x200000d0
10000a60:	20000068 	.word	0x20000068

10000a64 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod>:
/*
 * This function check the non conducting phase and modulate high side PWM output and keep low side
 * output either high or low based on the MCMS shadow register.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod(uint16_t mcm_val, uint16_t mcms_val)
{
10000a64:	b480      	push	{r7}
10000a66:	b085      	sub	sp, #20
10000a68:	af00      	add	r7, sp, #0
10000a6a:	4603      	mov	r3, r0
10000a6c:	460a      	mov	r2, r1
10000a6e:	80fb      	strh	r3, [r7, #6]
10000a70:	4613      	mov	r3, r2
10000a72:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000a74:	2300      	movs	r3, #0
10000a76:	73fb      	strb	r3, [r7, #15]
10000a78:	e028      	b.n	10000acc <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x68>
  {
    /* if phase is not conducting */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
10000a7a:	7bfb      	ldrb	r3, [r7, #15]
10000a7c:	4a18      	ldr	r2, [pc, #96]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000a7e:	330c      	adds	r3, #12
10000a80:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
10000a84:	88fb      	ldrh	r3, [r7, #6]
10000a86:	4013      	ands	r3, r2
10000a88:	b29b      	uxth	r3, r3
10000a8a:	2b00      	cmp	r3, #0
10000a8c:	d11b      	bne.n	10000ac6 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x62>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000a8e:	7bfb      	ldrb	r3, [r7, #15]
10000a90:	4a13      	ldr	r2, [pc, #76]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000a92:	3308      	adds	r3, #8
10000a94:	005b      	lsls	r3, r3, #1
10000a96:	4413      	add	r3, r2
10000a98:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000a9a:	7bfb      	ldrb	r3, [r7, #15]
10000a9c:	4910      	ldr	r1, [pc, #64]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000a9e:	3308      	adds	r3, #8
10000aa0:	005b      	lsls	r3, r3, #1
10000aa2:	440b      	add	r3, r1
10000aa4:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000aa6:	88bb      	ldrh	r3, [r7, #4]
10000aa8:	400b      	ands	r3, r1
10000aaa:	b29b      	uxth	r3, r3
10000aac:	429a      	cmp	r2, r3
10000aae:	d105      	bne.n	10000abc <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x58>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
10000ab0:	7bfb      	ldrb	r3, [r7, #15]
10000ab2:	4a0b      	ldr	r2, [pc, #44]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000ab4:	4413      	add	r3, r2
10000ab6:	2203      	movs	r2, #3
10000ab8:	739a      	strb	r2, [r3, #14]
10000aba:	e004      	b.n	10000ac6 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x62>
      }
      /* if low side switch is ON */
      else
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
10000abc:	7bfb      	ldrb	r3, [r7, #15]
10000abe:	4a08      	ldr	r2, [pc, #32]	; (10000ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
10000ac0:	4413      	add	r3, r2
10000ac2:	2201      	movs	r2, #1
10000ac4:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000ac6:	7bfb      	ldrb	r3, [r7, #15]
10000ac8:	3301      	adds	r3, #1
10000aca:	73fb      	strb	r3, [r7, #15]
10000acc:	7bfb      	ldrb	r3, [r7, #15]
10000ace:	2b02      	cmp	r3, #2
10000ad0:	d9d3      	bls.n	10000a7a <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x16>
      }
    }
  }
}
10000ad2:	bf00      	nop
10000ad4:	bf00      	nop
10000ad6:	3714      	adds	r7, #20
10000ad8:	46bd      	mov	sp, r7
10000ada:	f85d 7b04 	ldr.w	r7, [sp], #4
10000ade:	4770      	bx	lr
10000ae0:	200000d0 	.word	0x200000d0

10000ae4 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod>:
/*
 * This function check the non conducting phase and modulate low side PWM output and keep high side
 * output either high or low based on the MCMS shadow register.
 */
void Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod(uint16_t mcm_val, uint16_t mcms_val)
{
10000ae4:	b480      	push	{r7}
10000ae6:	b085      	sub	sp, #20
10000ae8:	af00      	add	r7, sp, #0
10000aea:	4603      	mov	r3, r0
10000aec:	460a      	mov	r2, r1
10000aee:	80fb      	strh	r3, [r7, #6]
10000af0:	4613      	mov	r3, r2
10000af2:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000af4:	2300      	movs	r3, #0
10000af6:	73fb      	strb	r3, [r7, #15]
10000af8:	e03a      	b.n	10000b70 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x8c>
  {
    /* if phase is not conducting */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
10000afa:	7bfb      	ldrb	r3, [r7, #15]
10000afc:	4a21      	ldr	r2, [pc, #132]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000afe:	330c      	adds	r3, #12
10000b00:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
10000b04:	88fb      	ldrh	r3, [r7, #6]
10000b06:	4013      	ands	r3, r2
10000b08:	b29b      	uxth	r3, r3
10000b0a:	2b00      	cmp	r3, #0
10000b0c:	d12d      	bne.n	10000b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000b0e:	7bfb      	ldrb	r3, [r7, #15]
10000b10:	4a1c      	ldr	r2, [pc, #112]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b12:	3308      	adds	r3, #8
10000b14:	005b      	lsls	r3, r3, #1
10000b16:	4413      	add	r3, r2
10000b18:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
10000b1a:	7bfb      	ldrb	r3, [r7, #15]
10000b1c:	4919      	ldr	r1, [pc, #100]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b1e:	3308      	adds	r3, #8
10000b20:	005b      	lsls	r3, r3, #1
10000b22:	440b      	add	r3, r1
10000b24:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
10000b26:	88bb      	ldrh	r3, [r7, #4]
10000b28:	400b      	ands	r3, r1
10000b2a:	b29b      	uxth	r3, r3
10000b2c:	429a      	cmp	r2, r3
10000b2e:	d105      	bne.n	10000b3c <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x58>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
10000b30:	7bfb      	ldrb	r3, [r7, #15]
10000b32:	4a14      	ldr	r2, [pc, #80]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b34:	4413      	add	r3, r2
10000b36:	2200      	movs	r2, #0
10000b38:	739a      	strb	r2, [r3, #14]
10000b3a:	e016      	b.n	10000b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
      }
      /* if low side switch is ON */
      else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000b3c:	7bfb      	ldrb	r3, [r7, #15]
10000b3e:	4a11      	ldr	r2, [pc, #68]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b40:	3308      	adds	r3, #8
10000b42:	005b      	lsls	r3, r3, #1
10000b44:	4413      	add	r3, r2
10000b46:	885b      	ldrh	r3, [r3, #2]
10000b48:	005a      	lsls	r2, r3, #1
            (mcms_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
10000b4a:	88b9      	ldrh	r1, [r7, #4]
10000b4c:	7bfb      	ldrb	r3, [r7, #15]
10000b4e:	480d      	ldr	r0, [pc, #52]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b50:	3308      	adds	r3, #8
10000b52:	005b      	lsls	r3, r3, #1
10000b54:	4403      	add	r3, r0
10000b56:	885b      	ldrh	r3, [r3, #2]
10000b58:	005b      	lsls	r3, r3, #1
10000b5a:	400b      	ands	r3, r1
      else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
10000b5c:	429a      	cmp	r2, r3
10000b5e:	d104      	bne.n	10000b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
10000b60:	7bfb      	ldrb	r3, [r7, #15]
10000b62:	4a08      	ldr	r2, [pc, #32]	; (10000b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
10000b64:	4413      	add	r3, r2
10000b66:	2202      	movs	r2, #2
10000b68:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
10000b6a:	7bfb      	ldrb	r3, [r7, #15]
10000b6c:	3301      	adds	r3, #1
10000b6e:	73fb      	strb	r3, [r7, #15]
10000b70:	7bfb      	ldrb	r3, [r7, #15]
10000b72:	2b02      	cmp	r3, #2
10000b74:	d9c1      	bls.n	10000afa <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x16>
      {

      }
    }
  }
}
10000b76:	bf00      	nop
10000b78:	bf00      	nop
10000b7a:	3714      	adds	r7, #20
10000b7c:	46bd      	mov	sp, r7
10000b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
10000b82:	4770      	bx	lr
10000b84:	200000d0 	.word	0x200000d0

10000b88 <CCU80_0_IRQHandler>:
 * Control loop interrupt is based on the PWM frequency.\n
 * This ISR executes the control scheme (PI), direction control, current and voltage reading,
 * voltage compensation and updates the duty cycle of the PWM.
 */
RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_ControlLoop_ISR(void)
{
10000b88:	b580      	push	{r7, lr}
10000b8a:	b084      	sub	sp, #16
10000b8c:	af00      	add	r7, sp, #0
  int32_t voltage_output = 0;  /* output of the control scheme */
10000b8e:	2300      	movs	r3, #0
10000b90:	60fb      	str	r3, [r7, #12]
#endif /* end of #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U)) */

  /***************** Current Reading ***************************************/
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  /* Get the IDC Link instantaneous current value */
  Motor0_BLDC_SCALAR_GetCurrentValue(&direct_current);
10000b92:	1d3b      	adds	r3, r7, #4
10000b94:	4618      	mov	r0, r3
10000b96:	f000 faf7 	bl	10001188 <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer>
  Motor0_BLDC_SCALAR.motor_current = Motor0_BLDC_SCALAR.motor_set_direction * direct_current;
10000b9a:	4b36      	ldr	r3, [pc, #216]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000b9c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000b9e:	687a      	ldr	r2, [r7, #4]
10000ba0:	fb02 f303 	mul.w	r3, r2, r3
10000ba4:	4a33      	ldr	r2, [pc, #204]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000ba6:	6713      	str	r3, [r2, #112]	; 0x70
  #endif  /* end of #if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) */

  #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U))
  /* Get the IDC Link average current value */
  Motor0_BLDC_SCALAR_GetAverageCurrentValue(&avg_current);
10000ba8:	463b      	mov	r3, r7
10000baa:	4618      	mov	r0, r3
10000bac:	f000 fad4 	bl	10001158 <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer>
  Motor0_BLDC_SCALAR.motor_average_current = Motor0_BLDC_SCALAR.motor_set_direction * avg_current;
10000bb0:	4b30      	ldr	r3, [pc, #192]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bb2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000bb4:	683a      	ldr	r2, [r7, #0]
10000bb6:	fb02 f303 	mul.w	r3, r2, r3
10000bba:	4a2e      	ldr	r2, [pc, #184]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bbc:	6753      	str	r3, [r2, #116]	; 0x74
  #endif /* end of #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U))*/

  #if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  /* Over-current detection timing */
  if (Motor0_BLDC_SCALAR.overcurrent_counter != 0U)
10000bbe:	4b2d      	ldr	r3, [pc, #180]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bc0:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
10000bc4:	2b00      	cmp	r3, #0
10000bc6:	d006      	beq.n	10000bd6 <CCU80_0_IRQHandler+0x4e>
  {
    Motor0_BLDC_SCALAR.overcurrent_counter--;
10000bc8:	4b2a      	ldr	r3, [pc, #168]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bca:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
10000bce:	3b01      	subs	r3, #1
10000bd0:	4a28      	ldr	r2, [pc, #160]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bd2:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
#if (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_VOLTAGE_CTRL)
  /* Voltage control */
  Motor0_BLDC_SCALAR_VoltageControlScheme(&voltage_output);
#elif (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL)
  /* Speed control */
  Motor0_BLDC_SCALAR.speedcontrol_rate_counter++;
10000bd6:	4b27      	ldr	r3, [pc, #156]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bd8:	f893 30c3 	ldrb.w	r3, [r3, #195]	; 0xc3
10000bdc:	3301      	adds	r3, #1
10000bde:	b2da      	uxtb	r2, r3
10000be0:	4b24      	ldr	r3, [pc, #144]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000be2:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
  if (Motor0_BLDC_SCALAR.speedcontrol_rate_counter >= Motor0_BLDC_SCALAR.speedcontrol_rate)
10000be6:	4b23      	ldr	r3, [pc, #140]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000be8:	f893 20c3 	ldrb.w	r2, [r3, #195]	; 0xc3
10000bec:	4b21      	ldr	r3, [pc, #132]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000bee:	f893 30c2 	ldrb.w	r3, [r3, #194]	; 0xc2
10000bf2:	429a      	cmp	r2, r3
10000bf4:	d309      	bcc.n	10000c0a <CCU80_0_IRQHandler+0x82>
  {
    Motor0_BLDC_SCALAR_SpeedControlScheme(&voltage_output);
10000bf6:	f107 030c 	add.w	r3, r7, #12
10000bfa:	4618      	mov	r0, r3
10000bfc:	f000 faa4 	bl	10001148 <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer>
    Motor0_BLDC_SCALAR.speedcontrol_rate_counter = 0U;
10000c00:	4b1c      	ldr	r3, [pc, #112]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c02:	2200      	movs	r2, #0
10000c04:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
10000c08:	e002      	b.n	10000c10 <CCU80_0_IRQHandler+0x88>
  }
  else
  {
    voltage_output = Motor0_BLDC_SCALAR_SpeedControl_PI.uk;
10000c0a:	4b1b      	ldr	r3, [pc, #108]	; (10000c78 <CCU80_0_IRQHandler+0xf0>)
10000c0c:	681b      	ldr	r3, [r3, #0]
10000c0e:	60fb      	str	r3, [r7, #12]

  /*
   * Calculate absolute value of amplitude and
   * if seamless bi-directional control is enabled, change the direction of the rotation at the appropriate time.
   */
  Motor0_BLDC_SCALAR_DirectionControl(voltage_output, &duty_cycle);
10000c10:	68fb      	ldr	r3, [r7, #12]
10000c12:	f107 0208 	add.w	r2, r7, #8
10000c16:	4611      	mov	r1, r2
10000c18:	4618      	mov	r0, r3
10000c1a:	f000 fa6d 	bl	100010f8 <__Motor0_BLDC_SCALAR_DirectionControl_veneer>
#if ((MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE_SYNCHRECTI) || (MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE))
  /*
   * To avoid discharging of the bootstrap capacitor in high side modulation,
   * apply 100% voltage if voltage amplitude is greater than amplitude threshold limit
   */
  if (duty_cycle > Motor0_BLDC_SCALAR.amplitude_high_threshold)
10000c1e:	4b15      	ldr	r3, [pc, #84]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c20:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
10000c24:	68bb      	ldr	r3, [r7, #8]
10000c26:	429a      	cmp	r2, r3
10000c28:	d203      	bcs.n	10000c32 <CCU80_0_IRQHandler+0xaa>
  {
    duty_cycle = Motor0_BLDC_SCALAR.max_amplitude;
10000c2a:	4b12      	ldr	r3, [pc, #72]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c2c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
10000c30:	60bb      	str	r3, [r7, #8]
  }
#endif  /* end of #if ((MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE_SYNCHRECTI) || (MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE)) */

  /* max_amplitude is decided by MOTOR0_BLDC_SCALAR_MAX_AMPLITUDE */
  if (duty_cycle > Motor0_BLDC_SCALAR.max_amplitude)
10000c32:	4b10      	ldr	r3, [pc, #64]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c34:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
10000c38:	68bb      	ldr	r3, [r7, #8]
10000c3a:	429a      	cmp	r2, r3
10000c3c:	d203      	bcs.n	10000c46 <CCU80_0_IRQHandler+0xbe>
  {
    duty_cycle = Motor0_BLDC_SCALAR.max_amplitude;
10000c3e:	4b0d      	ldr	r3, [pc, #52]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c40:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
10000c44:	60bb      	str	r3, [r7, #8]
  }
  /* min_amplitude is decided by MOTOR0_BLDC_SCALAR_MIN_AMPLITUDE */
  if (duty_cycle < Motor0_BLDC_SCALAR.min_amplitude)
10000c46:	4b0b      	ldr	r3, [pc, #44]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c48:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
10000c4c:	68bb      	ldr	r3, [r7, #8]
10000c4e:	429a      	cmp	r2, r3
10000c50:	d901      	bls.n	10000c56 <CCU80_0_IRQHandler+0xce>
  {
    duty_cycle = 0U;
10000c52:	2300      	movs	r3, #0
10000c54:	60bb      	str	r3, [r7, #8]
  }
  Motor0_BLDC_SCALAR.amplitude = duty_cycle;
10000c56:	68bb      	ldr	r3, [r7, #8]
10000c58:	4a06      	ldr	r2, [pc, #24]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c5a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  /* Update the CCU8 compare values */
  Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate((uint16_t)Motor0_BLDC_SCALAR.amplitude);
10000c5e:	4b05      	ldr	r3, [pc, #20]	; (10000c74 <CCU80_0_IRQHandler+0xec>)
10000c60:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
10000c64:	b29b      	uxth	r3, r3
10000c66:	4618      	mov	r0, r3
10000c68:	f000 fa4e 	bl	10001108 <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer>

}
10000c6c:	bf00      	nop
10000c6e:	3710      	adds	r7, #16
10000c70:	46bd      	mov	sp, r7
10000c72:	bd80      	pop	{r7, pc}
10000c74:	2000018c 	.word	0x2000018c
10000c78:	2000008c 	.word	0x2000008c

10000c7c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>:
{
10000c7c:	b480      	push	{r7}
10000c7e:	b083      	sub	sp, #12
10000c80:	af00      	add	r7, sp, #0
10000c82:	6078      	str	r0, [r7, #4]
10000c84:	6039      	str	r1, [r7, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum -= Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000c86:	4b27      	ldr	r3, [pc, #156]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c88:	6a1a      	ldr	r2, [r3, #32]
10000c8a:	4b26      	ldr	r3, [pc, #152]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c8c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000c90:	4619      	mov	r1, r3
10000c92:	4b24      	ldr	r3, [pc, #144]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c94:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000c98:	1ad3      	subs	r3, r2, r3
10000c9a:	4a22      	ldr	r2, [pc, #136]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000c9c:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex] = capval;
10000c9e:	4b21      	ldr	r3, [pc, #132]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000ca0:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000ca4:	4619      	mov	r1, r3
10000ca6:	4a1f      	ldr	r2, [pc, #124]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000ca8:	687b      	ldr	r3, [r7, #4]
10000caa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum += Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000cae:	4b1d      	ldr	r3, [pc, #116]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cb0:	6a1a      	ldr	r2, [r3, #32]
10000cb2:	4b1c      	ldr	r3, [pc, #112]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cb4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000cb8:	4619      	mov	r1, r3
10000cba:	4b1a      	ldr	r3, [pc, #104]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cbc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000cc0:	4413      	add	r3, r2
10000cc2:	4a18      	ldr	r2, [pc, #96]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cc4:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex++;
10000cc6:	4b17      	ldr	r3, [pc, #92]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cc8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000ccc:	3301      	adds	r3, #1
10000cce:	b2da      	uxtb	r2, r3
10000cd0:	4b14      	ldr	r3, [pc, #80]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cd2:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex > BLDC_SCALAR_SPEED_POS_HALL_SPEEDACCUMLIMITCHECK)
10000cd6:	4b13      	ldr	r3, [pc, #76]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cd8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000cdc:	2b05      	cmp	r3, #5
10000cde:	d906      	bls.n	10000cee <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x72>
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
10000ce0:	4b10      	ldr	r3, [pc, #64]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000ce2:	2200      	movs	r2, #0
10000ce4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 1U;
10000ce8:	4b0e      	ldr	r3, [pc, #56]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cea:	2201      	movs	r2, #1
10000cec:	61da      	str	r2, [r3, #28]
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck == 1U)
10000cee:	4b0d      	ldr	r3, [pc, #52]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cf0:	69db      	ldr	r3, [r3, #28]
10000cf2:	2b01      	cmp	r3, #1
10000cf4:	d10c      	bne.n	10000d10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x94>
    if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum > 0U)
10000cf6:	4b0b      	ldr	r3, [pc, #44]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000cf8:	6a1b      	ldr	r3, [r3, #32]
10000cfa:	2b00      	cmp	r3, #0
10000cfc:	d00b      	beq.n	10000d16 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
      *speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant) / (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum);
10000cfe:	4b09      	ldr	r3, [pc, #36]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d00:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10000d02:	4b08      	ldr	r3, [pc, #32]	; (10000d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d04:	6a1b      	ldr	r3, [r3, #32]
10000d06:	fbb2 f2f3 	udiv	r2, r2, r3
10000d0a:	683b      	ldr	r3, [r7, #0]
10000d0c:	601a      	str	r2, [r3, #0]
}
10000d0e:	e002      	b.n	10000d16 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
    *speed = 0U;
10000d10:	683b      	ldr	r3, [r7, #0]
10000d12:	2200      	movs	r2, #0
10000d14:	601a      	str	r2, [r3, #0]
}
10000d16:	bf00      	nop
10000d18:	370c      	adds	r7, #12
10000d1a:	46bd      	mov	sp, r7
10000d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
10000d20:	4770      	bx	lr
10000d22:	bf00      	nop
10000d24:	200000f8 	.word	0x200000f8

10000d28 <POSIF0_0_IRQHandler>:
{
10000d28:	b580      	push	{r7, lr}
10000d2a:	af00      	add	r7, sp, #0
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus(XMC_POSIF_IRQ_EVENT_WHE) == (uint8_t)1)
10000d2c:	2001      	movs	r0, #1
10000d2e:	f000 fa03 	bl	10001138 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer>
10000d32:	4603      	mov	r3, r0
10000d34:	2b01      	cmp	r3, #1
10000d36:	d102      	bne.n	10000d3e <POSIF0_0_IRQHandler+0x16>
    Motor0_BLDC_SCALAR_WrongHallEvent();
10000d38:	f000 f9e2 	bl	10001100 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer>
}
10000d3c:	e001      	b.n	10000d42 <POSIF0_0_IRQHandler+0x1a>
    Motor0_BLDC_SCALAR_CorrectHallEvent();
10000d3e:	f000 f9f7 	bl	10001130 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer>
}
10000d42:	bf00      	nop
10000d44:	bd80      	pop	{r7, pc}
10000d46:	bf00      	nop

10000d48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>:
{
10000d48:	b480      	push	{r7}
10000d4a:	b083      	sub	sp, #12
10000d4c:	af00      	add	r7, sp, #0
10000d4e:	6078      	str	r0, [r7, #4]
10000d50:	6039      	str	r1, [r7, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum -= Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000d52:	4b27      	ldr	r3, [pc, #156]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d54:	6a1a      	ldr	r2, [r3, #32]
10000d56:	4b26      	ldr	r3, [pc, #152]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d58:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d5c:	4619      	mov	r1, r3
10000d5e:	4b24      	ldr	r3, [pc, #144]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d60:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000d64:	1ad3      	subs	r3, r2, r3
10000d66:	4a22      	ldr	r2, [pc, #136]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d68:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex] = capval;
10000d6a:	4b21      	ldr	r3, [pc, #132]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d6c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d70:	4619      	mov	r1, r3
10000d72:	4a1f      	ldr	r2, [pc, #124]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d74:	687b      	ldr	r3, [r7, #4]
10000d76:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum += Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
10000d7a:	4b1d      	ldr	r3, [pc, #116]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d7c:	6a1a      	ldr	r2, [r3, #32]
10000d7e:	4b1c      	ldr	r3, [pc, #112]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d80:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d84:	4619      	mov	r1, r3
10000d86:	4b1a      	ldr	r3, [pc, #104]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d88:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
10000d8c:	4413      	add	r3, r2
10000d8e:	4a18      	ldr	r2, [pc, #96]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d90:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex++;
10000d92:	4b17      	ldr	r3, [pc, #92]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d94:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000d98:	3301      	adds	r3, #1
10000d9a:	b2da      	uxtb	r2, r3
10000d9c:	4b14      	ldr	r3, [pc, #80]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000d9e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex > BLDC_SCALAR_SPEED_POS_HALL_SPEEDACCUMLIMITCHECK)
10000da2:	4b13      	ldr	r3, [pc, #76]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000da4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
10000da8:	2b05      	cmp	r3, #5
10000daa:	d906      	bls.n	10000dba <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x72>
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
10000dac:	4b10      	ldr	r3, [pc, #64]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dae:	2200      	movs	r2, #0
10000db0:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 1U;
10000db4:	4b0e      	ldr	r3, [pc, #56]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000db6:	2201      	movs	r2, #1
10000db8:	61da      	str	r2, [r3, #28]
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck == 1U)
10000dba:	4b0d      	ldr	r3, [pc, #52]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dbc:	69db      	ldr	r3, [r3, #28]
10000dbe:	2b01      	cmp	r3, #1
10000dc0:	d10c      	bne.n	10000ddc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x94>
    if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum > 0U)
10000dc2:	4b0b      	ldr	r3, [pc, #44]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dc4:	6a1b      	ldr	r3, [r3, #32]
10000dc6:	2b00      	cmp	r3, #0
10000dc8:	d00b      	beq.n	10000de2 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
      *speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant) / (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum);
10000dca:	4b09      	ldr	r3, [pc, #36]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dcc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
10000dce:	4b08      	ldr	r3, [pc, #32]	; (10000df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
10000dd0:	6a1b      	ldr	r3, [r3, #32]
10000dd2:	fbb2 f2f3 	udiv	r2, r2, r3
10000dd6:	683b      	ldr	r3, [r7, #0]
10000dd8:	601a      	str	r2, [r3, #0]
}
10000dda:	e002      	b.n	10000de2 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
    *speed = 0U;
10000ddc:	683b      	ldr	r3, [r7, #0]
10000dde:	2200      	movs	r2, #0
10000de0:	601a      	str	r2, [r3, #0]
}
10000de2:	bf00      	nop
10000de4:	370c      	adds	r7, #12
10000de6:	46bd      	mov	sp, r7
10000de8:	f85d 7b04 	ldr.w	r7, [sp], #4
10000dec:	4770      	bx	lr
10000dee:	bf00      	nop
10000df0:	200000f8 	.word	0x200000f8

10000df4 <POSIF0_1_IRQHandler>:
 * Prepare hall and multi-channel pattern for the next commutation.
 * Calculate the Speed based on captured value in CCU4 capture slice.
 */

RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_PatternShadowTx_ISR(void)
{
10000df4:	b580      	push	{r7, lr}
10000df6:	b084      	sub	sp, #16
10000df8:	af00      	add	r7, sp, #0
  uint8_t pos;            /* array index variable */
  uint16_t mcmval;  /*current multi-channel pattern */
  uint16_t mcmvals; /*shadow multi-channel pattern */
  uint32_t capval;  /* calculated time between last two hall events */
  uint8_t status;   /* return status of the API to read the captured value from capture register */
  uint32_t speed = 0U; /* electrical speed in RPM */
10000dfa:	2300      	movs	r3, #0
10000dfc:	603b      	str	r3, [r7, #0]
  uint8_t direction = (uint8_t)Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
10000dfe:	4b2e      	ldr	r3, [pc, #184]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e00:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000e02:	b2db      	uxtb	r3, r3
10000e04:	f003 0308 	and.w	r3, r3, #8
10000e08:	73fb      	strb	r3, [r7, #15]

  /* store the sampled pattern */
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
10000e0a:	f000 f9a1 	bl	10001150 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer>
10000e0e:	4603      	mov	r3, r0
10000e10:	461a      	mov	r2, r3
10000e12:	4b2a      	ldr	r3, [pc, #168]	; (10000ebc <POSIF0_1_IRQHandler+0xc8>)
10000e14:	745a      	strb	r2, [r3, #17]
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  /* To blank the direct DC link current measurement at the commutation point */
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 1U;
10000e16:	4b2a      	ldr	r3, [pc, #168]	; (10000ec0 <POSIF0_1_IRQHandler+0xcc>)
10000e18:	2201      	movs	r2, #1
10000e1a:	f883 2020 	strb.w	r2, [r3, #32]
#endif  /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
#endif /* end of #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) */

  /*Get the expected hall pattern.*/
  pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
10000e1e:	f000 f9a7 	bl	10001170 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>
10000e22:	4603      	mov	r3, r0
10000e24:	73bb      	strb	r3, [r7, #14]
  /*Set next hall pattern and MCM pattern based on the expected hall pattern.*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t)(Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
10000e26:	7bba      	ldrb	r2, [r7, #14]
10000e28:	7bfb      	ldrb	r3, [r7, #15]
10000e2a:	4413      	add	r3, r2
10000e2c:	4a23      	ldr	r2, [pc, #140]	; (10000ebc <POSIF0_1_IRQHandler+0xc8>)
10000e2e:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
10000e30:	4618      	mov	r0, r3
10000e32:	f000 f951 	bl	100010d8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
      (uint16_t)Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pos) +
10000e36:	4b23      	ldr	r3, [pc, #140]	; (10000ec4 <POSIF0_1_IRQHandler+0xd0>)
10000e38:	7b1b      	ldrb	r3, [r3, #12]
10000e3a:	4618      	mov	r0, r3
10000e3c:	7bba      	ldrb	r2, [r7, #14]
                                          (uint8_t)direction]);
10000e3e:	7bfb      	ldrb	r3, [r7, #15]
      (uint16_t)Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pos) +
10000e40:	4413      	add	r3, r2
10000e42:	491d      	ldr	r1, [pc, #116]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e44:	0102      	lsls	r2, r0, #4
10000e46:	4413      	add	r3, r2
10000e48:	005b      	lsls	r3, r3, #1
10000e4a:	440b      	add	r3, r1
10000e4c:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
10000e4e:	4618      	mov	r0, r3
10000e50:	f000 f9b2 	bl	100011b8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>

  /*Get the shadow multi-channel pattern value and apply the PWM modulation.*/
  mcmval = (uint16_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
10000e54:	f000 f964 	bl	10001120 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
10000e58:	4603      	mov	r3, r0
10000e5a:	81bb      	strh	r3, [r7, #12]
  mcmvals = (uint16_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern();
10000e5c:	f000 f940 	bl	100010e0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>
10000e60:	4603      	mov	r3, r0
10000e62:	817b      	strh	r3, [r7, #10]
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval,mcmvals);
10000e64:	4b17      	ldr	r3, [pc, #92]	; (10000ec4 <POSIF0_1_IRQHandler+0xd0>)
10000e66:	685b      	ldr	r3, [r3, #4]
10000e68:	8979      	ldrh	r1, [r7, #10]
10000e6a:	89ba      	ldrh	r2, [r7, #12]
10000e6c:	4610      	mov	r0, r2
10000e6e:	4798      	blx	r3

    /*Get the captured value from capture timer */
  status = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue(&capval);
10000e70:	1d3b      	adds	r3, r7, #4
10000e72:	4618      	mov	r0, r3
10000e74:	f000 f984 	bl	10001180 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer>
10000e78:	4603      	mov	r3, r0
10000e7a:	727b      	strb	r3, [r7, #9]
#if (MOTOR0_BLDC_SCALAR_ENABLE_STALL_DETECTION == 1U)
  /* Reset the stall detection count as hall event is detected for timeout*/
  Motor0_BLDC_SCALAR.stall_detection_counter = 0U;
#endif
  /* if valid speed capture value */
  if (status == (uint8_t)BLDC_SCALAR_SPEED_POS_HALL_STATUS_SUCCESS)
10000e7c:	7a7b      	ldrb	r3, [r7, #9]
10000e7e:	2b00      	cmp	r3, #0
10000e80:	d116      	bne.n	10000eb0 <POSIF0_1_IRQHandler+0xbc>
  {
    /* speed calculation */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation(capval, &speed);
10000e82:	687b      	ldr	r3, [r7, #4]
10000e84:	463a      	mov	r2, r7
10000e86:	4611      	mov	r1, r2
10000e88:	4618      	mov	r0, r3
10000e8a:	f7ff ff5d 	bl	10000d48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>

    Motor0_BLDC_SCALAR.actual_motor_direction = Motor0_BLDC_SCALAR.motor_set_direction;
10000e8e:	4b0a      	ldr	r3, [pc, #40]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e90:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000e92:	4a09      	ldr	r2, [pc, #36]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e94:	67d3      	str	r3, [r2, #124]	; 0x7c
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
10000e96:	4b08      	ldr	r3, [pc, #32]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000e98:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
10000e9a:	683a      	ldr	r2, [r7, #0]
10000e9c:	fb02 f303 	mul.w	r3, r2, r3
                                     (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
10000ea0:	4a05      	ldr	r2, [pc, #20]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000ea2:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
10000ea6:	fb02 f303 	mul.w	r3, r2, r3
                                     (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
10000eaa:	129b      	asrs	r3, r3, #10
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
10000eac:	4a02      	ldr	r2, [pc, #8]	; (10000eb8 <POSIF0_1_IRQHandler+0xc4>)
10000eae:	66d3      	str	r3, [r2, #108]	; 0x6c
      }
    }
#endif
  }

}
10000eb0:	bf00      	nop
10000eb2:	3710      	adds	r7, #16
10000eb4:	46bd      	mov	sp, r7
10000eb6:	bd80      	pop	{r7, pc}
10000eb8:	2000018c 	.word	0x2000018c
10000ebc:	20000158 	.word	0x20000158
10000ec0:	20000124 	.word	0x20000124
10000ec4:	200000d0 	.word	0x200000d0

10000ec8 <Motor0_BLDC_SCALAR_MSM>:
{
10000ec8:	b580      	push	{r7, lr}
10000eca:	af00      	add	r7, sp, #0
  switch (Motor0_BLDC_SCALAR.msm_state)
10000ecc:	4b1a      	ldr	r3, [pc, #104]	; (10000f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
10000ece:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
10000ed2:	b2db      	uxtb	r3, r3
10000ed4:	2b08      	cmp	r3, #8
10000ed6:	d824      	bhi.n	10000f22 <Motor0_BLDC_SCALAR_MSM+0x5a>
10000ed8:	a201      	add	r2, pc, #4	; (adr r2, 10000ee0 <Motor0_BLDC_SCALAR_MSM+0x18>)
10000eda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
10000ede:	bf00      	nop
10000ee0:	10000f1d 	.word	0x10000f1d
10000ee4:	10000f17 	.word	0x10000f17
10000ee8:	10000f0b 	.word	0x10000f0b
10000eec:	10000f23 	.word	0x10000f23
10000ef0:	10000f23 	.word	0x10000f23
10000ef4:	10000f23 	.word	0x10000f23
10000ef8:	10000f23 	.word	0x10000f23
10000efc:	10000f05 	.word	0x10000f05
10000f00:	10000f11 	.word	0x10000f11
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func();
10000f04:	f000 f8f0 	bl	100010e8 <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer>
      break;
10000f08:	e00c      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func();
10000f0a:	f000 f941 	bl	10001190 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer>
      break;
10000f0e:	e009      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_ERROR_Func();
10000f10:	f000 f94a 	bl	100011a8 <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer>
      break;
10000f14:	e006      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_START_Func();
10000f16:	f000 f93f 	bl	10001198 <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer>
      break;
10000f1a:	e003      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MotorStop();
10000f1c:	f000 f924 	bl	10001168 <__Motor0_BLDC_SCALAR_MotorStop_veneer>
      break;
10000f20:	e000      	b.n	10000f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      break;
10000f22:	bf00      	nop
  if (Motor0_BLDC_SCALAR.error_status != 0U)
10000f24:	4b04      	ldr	r3, [pc, #16]	; (10000f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
10000f26:	6e9b      	ldr	r3, [r3, #104]	; 0x68
10000f28:	2b00      	cmp	r3, #0
10000f2a:	d003      	beq.n	10000f34 <Motor0_BLDC_SCALAR_MSM+0x6c>
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
10000f2c:	4b02      	ldr	r3, [pc, #8]	; (10000f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
10000f2e:	2208      	movs	r2, #8
10000f30:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
10000f34:	bf00      	nop
10000f36:	bd80      	pop	{r7, pc}
10000f38:	2000018c 	.word	0x2000018c

10000f3c <Motor0_BLDC_SCALAR_PatternInitiator>:
{
10000f3c:	b580      	push	{r7, lr}
10000f3e:	b084      	sub	sp, #16
10000f40:	af00      	add	r7, sp, #0
10000f42:	4603      	mov	r3, r0
10000f44:	71fb      	strb	r3, [r7, #7]
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_DIRECTION_INDEX;   /* Intended direction */
10000f46:	4b2b      	ldr	r3, [pc, #172]	; (10000ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
10000f48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
10000f4a:	b2db      	uxtb	r3, r3
10000f4c:	f003 0308 	and.w	r3, r3, #8
10000f50:	73fb      	strb	r3, [r7, #15]
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[curpos + (uint32_t) direction]));
10000f52:	79fa      	ldrb	r2, [r7, #7]
10000f54:	7bfb      	ldrb	r3, [r7, #15]
10000f56:	4413      	add	r3, r2
10000f58:	4a27      	ldr	r2, [pc, #156]	; (10000ff8 <Motor0_BLDC_SCALAR_PatternInitiator+0xbc>)
10000f5a:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
10000f5c:	4618      	mov	r0, r3
10000f5e:	f000 f8e3 	bl	10001128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
10000f62:	f000 f909 	bl	10001178 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer>
      (uint16_t) Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(curpos) + (uint8_t) direction]);
10000f66:	4b25      	ldr	r3, [pc, #148]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000f68:	7b1b      	ldrb	r3, [r3, #12]
10000f6a:	4618      	mov	r0, r3
10000f6c:	79fa      	ldrb	r2, [r7, #7]
10000f6e:	7bfb      	ldrb	r3, [r7, #15]
10000f70:	4413      	add	r3, r2
10000f72:	4920      	ldr	r1, [pc, #128]	; (10000ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
10000f74:	0102      	lsls	r2, r0, #4
10000f76:	4413      	add	r3, r2
10000f78:	005b      	lsls	r3, r3, #1
10000f7a:	440b      	add	r3, r1
10000f7c:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
10000f7e:	4618      	mov	r0, r3
10000f80:	f000 f8ca 	bl	10001118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern();
10000f84:	f000 f8b4 	bl	100010f0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer>
  pattern_index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
10000f88:	f000 f8da 	bl	10001140 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>
10000f8c:	4603      	mov	r3, r0
10000f8e:	73bb      	strb	r3, [r7, #14]
  mcmval = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
10000f90:	f000 f8be 	bl	10001110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
10000f94:	4603      	mov	r3, r0
10000f96:	81bb      	strh	r3, [r7, #12]
  Motor0_BLDC_SCALAR_PWM_BC.immediate_modulation_ptr(mcmval);
10000f98:	4b18      	ldr	r3, [pc, #96]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000f9a:	689b      	ldr	r3, [r3, #8]
10000f9c:	89ba      	ldrh	r2, [r7, #12]
10000f9e:	4610      	mov	r0, r2
10000fa0:	4798      	blx	r3
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pattern_index + (uint32_t) direction]));
10000fa2:	7bba      	ldrb	r2, [r7, #14]
10000fa4:	7bfb      	ldrb	r3, [r7, #15]
10000fa6:	4413      	add	r3, r2
10000fa8:	4a13      	ldr	r2, [pc, #76]	; (10000ff8 <Motor0_BLDC_SCALAR_PatternInitiator+0xbc>)
10000faa:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
10000fac:	4618      	mov	r0, r3
10000fae:	f000 f8bb 	bl	10001128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
      (uint16_t) Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pattern_index) + (uint8_t) direction]);
10000fb2:	4b12      	ldr	r3, [pc, #72]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000fb4:	7b1b      	ldrb	r3, [r3, #12]
10000fb6:	4618      	mov	r0, r3
10000fb8:	7bba      	ldrb	r2, [r7, #14]
10000fba:	7bfb      	ldrb	r3, [r7, #15]
10000fbc:	4413      	add	r3, r2
10000fbe:	490d      	ldr	r1, [pc, #52]	; (10000ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
10000fc0:	0102      	lsls	r2, r0, #4
10000fc2:	4413      	add	r3, r2
10000fc4:	005b      	lsls	r3, r3, #1
10000fc6:	440b      	add	r3, r1
10000fc8:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
10000fca:	4618      	mov	r0, r3
10000fcc:	f000 f8a4 	bl	10001118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>
  mcmval = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
10000fd0:	f000 f89e 	bl	10001110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
10000fd4:	4603      	mov	r3, r0
10000fd6:	81bb      	strh	r3, [r7, #12]
  mcmshadow = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern();
10000fd8:	f000 f8ea 	bl	100011b0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>
10000fdc:	4603      	mov	r3, r0
10000fde:	817b      	strh	r3, [r7, #10]
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval, mcmshadow);
10000fe0:	4b06      	ldr	r3, [pc, #24]	; (10000ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
10000fe2:	685b      	ldr	r3, [r3, #4]
10000fe4:	8979      	ldrh	r1, [r7, #10]
10000fe6:	89ba      	ldrh	r2, [r7, #12]
10000fe8:	4610      	mov	r0, r2
10000fea:	4798      	blx	r3
}
10000fec:	bf00      	nop
10000fee:	3710      	adds	r7, #16
10000ff0:	46bd      	mov	sp, r7
10000ff2:	bd80      	pop	{r7, pc}
10000ff4:	2000018c 	.word	0x2000018c
10000ff8:	20000158 	.word	0x20000158
10000ffc:	200000d0 	.word	0x200000d0

10001000 <Motor0_BLDC_SCALAR_Ramp_Linear>:
 * API IMPLEMENTATION
 **********************************************************************************************************************/
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
/* This generates the linear ramp as per configured slew rate */
RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_Ramp_Linear(void)
{
10001000:	b480      	push	{r7}
10001002:	b083      	sub	sp, #12
10001004:	af00      	add	r7, sp, #0
  static int32_t sum;     /* to find the increment/decrement value */
  int32_t setval_diff;   /* difference between ramp input and output value */
  int32_t ramp_val;      /* value by which set value is incremented or decremented */

  /* ramp up - if target end value is greater than the ramp output set_value */
  if ((Motor0_BLDC_SCALAR_Ramp.input_value) >= Motor0_BLDC_SCALAR_Ramp.set_value)
10001006:	4b32      	ldr	r3, [pc, #200]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001008:	685a      	ldr	r2, [r3, #4]
1000100a:	4b31      	ldr	r3, [pc, #196]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000100c:	681b      	ldr	r3, [r3, #0]
1000100e:	429a      	cmp	r2, r3
10001010:	db29      	blt.n	10001066 <Motor0_BLDC_SCALAR_Ramp_Linear+0x66>
  {
    /* Find increment value using fixed point representation */
    setval_diff = (Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value;
10001012:	4b2f      	ldr	r3, [pc, #188]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001014:	685a      	ldr	r2, [r3, #4]
10001016:	4b2e      	ldr	r3, [pc, #184]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001018:	681b      	ldr	r3, [r3, #0]
1000101a:	1ad3      	subs	r3, r2, r3
1000101c:	607b      	str	r3, [r7, #4]
    sum = (int32_t)(sum + (int32_t)Motor0_BLDC_SCALAR_Ramp.ramp_rate);
1000101e:	4b2c      	ldr	r3, [pc, #176]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001020:	689b      	ldr	r3, [r3, #8]
10001022:	461a      	mov	r2, r3
10001024:	4b2b      	ldr	r3, [pc, #172]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001026:	681b      	ldr	r3, [r3, #0]
10001028:	4413      	add	r3, r2
1000102a:	4a2a      	ldr	r2, [pc, #168]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000102c:	6013      	str	r3, [r2, #0]
    ramp_val = (int32_t)(sum >> BLDC_SCALAR_RAMP_SHIFT_16);
1000102e:	4b29      	ldr	r3, [pc, #164]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001030:	681b      	ldr	r3, [r3, #0]
10001032:	141b      	asrs	r3, r3, #16
10001034:	603b      	str	r3, [r7, #0]
    sum = (int32_t)(sum & BLDC_SCALAR_RAMP_POW_16);
10001036:	4b27      	ldr	r3, [pc, #156]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001038:	681b      	ldr	r3, [r3, #0]
1000103a:	b29b      	uxth	r3, r3
1000103c:	4a25      	ldr	r2, [pc, #148]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000103e:	6013      	str	r3, [r2, #0]

    /* Set value reached the end point */
    if (setval_diff <= ramp_val)
10001040:	687a      	ldr	r2, [r7, #4]
10001042:	683b      	ldr	r3, [r7, #0]
10001044:	429a      	cmp	r2, r3
10001046:	dc07      	bgt.n	10001058 <Motor0_BLDC_SCALAR_Ramp_Linear+0x58>
    {
      Motor0_BLDC_SCALAR_Ramp.set_value = (Motor0_BLDC_SCALAR_Ramp.input_value);
10001048:	4b21      	ldr	r3, [pc, #132]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000104a:	685b      	ldr	r3, [r3, #4]
1000104c:	4a20      	ldr	r2, [pc, #128]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000104e:	6013      	str	r3, [r2, #0]
      sum = 0;
10001050:	4b20      	ldr	r3, [pc, #128]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001052:	2200      	movs	r2, #0
10001054:	601a      	str	r2, [r3, #0]
  }
  else
  {

  }
}
10001056:	e035      	b.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
      Motor0_BLDC_SCALAR_Ramp.set_value += ramp_val;
10001058:	4b1d      	ldr	r3, [pc, #116]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000105a:	681a      	ldr	r2, [r3, #0]
1000105c:	683b      	ldr	r3, [r7, #0]
1000105e:	4413      	add	r3, r2
10001060:	4a1b      	ldr	r2, [pc, #108]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001062:	6013      	str	r3, [r2, #0]
}
10001064:	e02e      	b.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
  else if ((Motor0_BLDC_SCALAR_Ramp.input_value) < Motor0_BLDC_SCALAR_Ramp.set_value)
10001066:	4b1a      	ldr	r3, [pc, #104]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001068:	685a      	ldr	r2, [r3, #4]
1000106a:	4b19      	ldr	r3, [pc, #100]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1000106c:	681b      	ldr	r3, [r3, #0]
1000106e:	429a      	cmp	r2, r3
10001070:	da28      	bge.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
    setval_diff =  Motor0_BLDC_SCALAR_Ramp.set_value - (Motor0_BLDC_SCALAR_Ramp.input_value);
10001072:	4b17      	ldr	r3, [pc, #92]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001074:	681a      	ldr	r2, [r3, #0]
10001076:	4b16      	ldr	r3, [pc, #88]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001078:	685b      	ldr	r3, [r3, #4]
1000107a:	1ad3      	subs	r3, r2, r3
1000107c:	607b      	str	r3, [r7, #4]
    sum = (int32_t)(sum + (int32_t)Motor0_BLDC_SCALAR_Ramp.ramp_rate);
1000107e:	4b14      	ldr	r3, [pc, #80]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
10001080:	689b      	ldr	r3, [r3, #8]
10001082:	461a      	mov	r2, r3
10001084:	4b13      	ldr	r3, [pc, #76]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001086:	681b      	ldr	r3, [r3, #0]
10001088:	4413      	add	r3, r2
1000108a:	4a12      	ldr	r2, [pc, #72]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000108c:	6013      	str	r3, [r2, #0]
    ramp_val = (int32_t)(sum >> BLDC_SCALAR_RAMP_SHIFT_16);
1000108e:	4b11      	ldr	r3, [pc, #68]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001090:	681b      	ldr	r3, [r3, #0]
10001092:	141b      	asrs	r3, r3, #16
10001094:	603b      	str	r3, [r7, #0]
    sum = (int32_t)(sum & BLDC_SCALAR_RAMP_POW_16);
10001096:	4b0f      	ldr	r3, [pc, #60]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
10001098:	681b      	ldr	r3, [r3, #0]
1000109a:	b29b      	uxth	r3, r3
1000109c:	4a0d      	ldr	r2, [pc, #52]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1000109e:	6013      	str	r3, [r2, #0]
    if (setval_diff <= ramp_val)
100010a0:	687a      	ldr	r2, [r7, #4]
100010a2:	683b      	ldr	r3, [r7, #0]
100010a4:	429a      	cmp	r2, r3
100010a6:	dc07      	bgt.n	100010b8 <Motor0_BLDC_SCALAR_Ramp_Linear+0xb8>
      Motor0_BLDC_SCALAR_Ramp.set_value = (Motor0_BLDC_SCALAR_Ramp.input_value);
100010a8:	4b09      	ldr	r3, [pc, #36]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010aa:	685b      	ldr	r3, [r3, #4]
100010ac:	4a08      	ldr	r2, [pc, #32]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010ae:	6013      	str	r3, [r2, #0]
      sum = 0;
100010b0:	4b08      	ldr	r3, [pc, #32]	; (100010d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
100010b2:	2200      	movs	r2, #0
100010b4:	601a      	str	r2, [r3, #0]
}
100010b6:	e005      	b.n	100010c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
      Motor0_BLDC_SCALAR_Ramp.set_value -= ramp_val;
100010b8:	4b05      	ldr	r3, [pc, #20]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010ba:	681a      	ldr	r2, [r3, #0]
100010bc:	683b      	ldr	r3, [r7, #0]
100010be:	1ad3      	subs	r3, r2, r3
100010c0:	4a03      	ldr	r2, [pc, #12]	; (100010d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
100010c2:	6013      	str	r3, [r2, #0]
}
100010c4:	bf00      	nop
100010c6:	370c      	adds	r7, #12
100010c8:	46bd      	mov	sp, r7
100010ca:	f85d 7b04 	ldr.w	r7, [sp], #4
100010ce:	4770      	bx	lr
100010d0:	200000bc 	.word	0x200000bc
100010d4:	200005fc 	.word	0x200005fc

100010d8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>:
100010d8:	f85f f000 	ldr.w	pc, [pc]	; 100010dc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer+0x4>
100010dc:	08021e6d 	.word	0x08021e6d

100010e0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>:
100010e0:	f85f f000 	ldr.w	pc, [pc]	; 100010e4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer+0x4>
100010e4:	08021e4d 	.word	0x08021e4d

100010e8 <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer>:
100010e8:	f85f f000 	ldr.w	pc, [pc]	; 100010ec <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer+0x4>
100010ec:	0802233d 	.word	0x0802233d

100010f0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer>:
100010f0:	f85f f000 	ldr.w	pc, [pc]	; 100010f4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer+0x4>
100010f4:	08022625 	.word	0x08022625

100010f8 <__Motor0_BLDC_SCALAR_DirectionControl_veneer>:
100010f8:	f85f f000 	ldr.w	pc, [pc]	; 100010fc <__Motor0_BLDC_SCALAR_DirectionControl_veneer+0x4>
100010fc:	08021711 	.word	0x08021711

10001100 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer>:
10001100:	f85f f000 	ldr.w	pc, [pc]	; 10001104 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer+0x4>
10001104:	08021a6d 	.word	0x08021a6d

10001108 <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer>:
10001108:	f85f f000 	ldr.w	pc, [pc]	; 1000110c <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer+0x4>
1000110c:	08021361 	.word	0x08021361

10001110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>:
10001110:	f85f f000 	ldr.w	pc, [pc]	; 10001114 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer+0x4>
10001114:	08022639 	.word	0x08022639

10001118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>:
10001118:	f85f f000 	ldr.w	pc, [pc]	; 1000111c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer+0x4>
1000111c:	08022605 	.word	0x08022605

10001120 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>:
10001120:	f85f f000 	ldr.w	pc, [pc]	; 10001124 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer+0x4>
10001124:	08021e2d 	.word	0x08021e2d

10001128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>:
10001128:	f85f f000 	ldr.w	pc, [pc]	; 1000112c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer+0x4>
1000112c:	08022679 	.word	0x08022679

10001130 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer>:
10001130:	f85f f000 	ldr.w	pc, [pc]	; 10001134 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer+0x4>
10001134:	08021bf5 	.word	0x08021bf5

10001138 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer>:
10001138:	f85f f000 	ldr.w	pc, [pc]	; 1000113c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer+0x4>
1000113c:	08021a29 	.word	0x08021a29

10001140 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>:
10001140:	f85f f000 	ldr.w	pc, [pc]	; 10001144 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer+0x4>
10001144:	080226ad 	.word	0x080226ad

10001148 <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer>:
10001148:	f85f f000 	ldr.w	pc, [pc]	; 1000114c <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer+0x4>
1000114c:	080216c5 	.word	0x080216c5

10001150 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer>:
10001150:	f85f f000 	ldr.w	pc, [pc]	; 10001154 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer+0x4>
10001154:	08021ead 	.word	0x08021ead

10001158 <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer>:
10001158:	f85f f000 	ldr.w	pc, [pc]	; 1000115c <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer+0x4>
1000115c:	080215a1 	.word	0x080215a1

10001160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>:
10001160:	f85f f000 	ldr.w	pc, [pc]	; 10001164 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer+0x4>
10001164:	08020993 	.word	0x08020993

10001168 <__Motor0_BLDC_SCALAR_MotorStop_veneer>:
10001168:	f85f f000 	ldr.w	pc, [pc]	; 1000116c <__Motor0_BLDC_SCALAR_MotorStop_veneer+0x4>
1000116c:	08022999 	.word	0x08022999

10001170 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>:
10001170:	f85f f000 	ldr.w	pc, [pc]	; 10001174 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer+0x4>
10001174:	08021e8d 	.word	0x08021e8d

10001178 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer>:
10001178:	f85f f000 	ldr.w	pc, [pc]	; 1000117c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer+0x4>
1000117c:	08022699 	.word	0x08022699

10001180 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer>:
10001180:	f85f f000 	ldr.w	pc, [pc]	; 10001184 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer+0x4>
10001184:	08021d99 	.word	0x08021d99

10001188 <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer>:
10001188:	f85f f000 	ldr.w	pc, [pc]	; 1000118c <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer+0x4>
1000118c:	08021505 	.word	0x08021505

10001190 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer>:
10001190:	f85f f000 	ldr.w	pc, [pc]	; 10001194 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer+0x4>
10001194:	08022435 	.word	0x08022435

10001198 <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer>:
10001198:	f85f f000 	ldr.w	pc, [pc]	; 1000119c <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer+0x4>
1000119c:	0802228d 	.word	0x0802228d

100011a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>:
100011a0:	f85f f000 	ldr.w	pc, [pc]	; 100011a4 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer+0x4>
100011a4:	080209b7 	.word	0x080209b7

100011a8 <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer>:
100011a8:	f85f f000 	ldr.w	pc, [pc]	; 100011ac <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer+0x4>
100011ac:	080224e5 	.word	0x080224e5

100011b0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>:
100011b0:	f85f f000 	ldr.w	pc, [pc]	; 100011b4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer+0x4>
100011b4:	08022659 	.word	0x08022659

100011b8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>:
100011b8:	f85f f000 	ldr.w	pc, [pc]	; 100011bc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer+0x4>
100011bc:	08021e0d 	.word	0x08021e0d
